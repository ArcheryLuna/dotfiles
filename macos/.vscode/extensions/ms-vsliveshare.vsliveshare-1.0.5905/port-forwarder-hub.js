/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../http-client/lib/src/Errors.js":
/*!*******************************************!*\
  !*** ../../http-client/lib/src/Errors.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpCancellationError": () => (/* binding */ HttpCancellationError),
/* harmony export */   "HttpClientAuthenticationError": () => (/* binding */ HttpClientAuthenticationError),
/* harmony export */   "HttpClientError": () => (/* binding */ HttpClientError),
/* harmony export */   "HttpClientResponseError": () => (/* binding */ HttpClientResponseError),
/* harmony export */   "HttpError": () => (/* binding */ HttpError)
/* harmony export */ });
/**
 * Base error for the HttpClient.
 */
class HttpError extends Error {
    constructor() {
        super(...arguments);
        this.errorType = 'HttpError';
    }
}
class HttpClientError extends HttpError {
    constructor(reason) {
        super(reason);
        this.errorType = 'HttpClientError';
        if (reason instanceof HttpClientError) {
            return reason;
        }
        let message;
        if (reason instanceof Error) {
            message = reason.message;
        }
        else if (typeof reason === 'string') {
            message = reason;
        }
        else {
            message = '';
        }
        this.message = message;
        this.name = 'HttpClientError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, HttpClientError);
        }
    }
}
class HttpClientAuthenticationError extends HttpError {
    constructor(response) {
        super(`Request failed with status code ${response.status}.`);
        this.response = response;
        this.errorType = 'HttpClientAuthenticationError';
        this.name = 'HttpClientAuthenticationError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, HttpClientAuthenticationError);
        }
    }
}
class HttpClientResponseError extends HttpError {
    constructor(response) {
        super(`Request failed with status code ${response.status}.`);
        this.response = response;
        this.errorType = 'HttpClientResponseError';
        this.name = 'HttpClientResponseError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, HttpClientResponseError);
        }
    }
}
class HttpCancellationError extends HttpError {
    constructor(reason = undefined) {
        super(reason);
        this.errorType = 'HttpCancellationError';
        this.name = 'CancellationError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, HttpCancellationError);
        }
    }
}
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "../../http-client/lib/src/FetchRequest.js":
/*!*************************************************!*\
  !*** ../../http-client/lib/src/FetchRequest.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FetchRequest": () => (/* binding */ FetchRequest)
/* harmony export */ });
/* harmony import */ var _toAbortSignal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toAbortSignal */ "../../http-client/lib/src/toAbortSignal.js");
/* harmony import */ var _createTimeoutTokenSource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createTimeoutTokenSource */ "../../http-client/lib/src/createTimeoutTokenSource.js");
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors */ "../../http-client/lib/src/Errors.js");
/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetch */ "../../http-client/lib/src/fetch.js");




// TODO: Implement disposal of requests
class FetchRequest {
    constructor(logger, configuration, request, init, cancellationToken) {
        var _a;
        this.logger = logger;
        this.configuration = configuration;
        this.request = request;
        this.init = init;
        this.cancellationToken = cancellationToken;
        this.retry = 0;
        this.input = this.request instanceof URL ? this.request.toString() : this.request;
        // We extract the method for logging purposes.
        let method = 'GET';
        if (typeof this.input !== 'string') {
            method = this.input.method;
        }
        if ((_a = this.init) === null || _a === void 0 ? void 0 : _a.method) {
            method = this.init.method;
        }
        this.method = method;
        // We also extract the url
        this.url = typeof this.input === 'string' ? this.input : this.input.url;
    }
    then(onfulfilled, onrejected) {
        return this.fetch().then(onfulfilled, onrejected);
    }
    async text() {
        const response = await this.fetchWithCancellationCheck();
        return await response.text();
    }
    async json() {
        const response = await this.fetchWithCancellationCheck();
        return await response.json();
    }
    async arrayBuffer() {
        const response = await this.fetchWithCancellationCheck();
        return await response.arrayBuffer();
    }
    async blob() {
        const response = await this.fetchWithCancellationCheck();
        return await response.blob();
    }
    async formData() {
        const response = await this.fetchWithCancellationCheck();
        return await response.formData();
    }
    async value() {
        return (await this.json());
    }
    async fetch() {
        var _a;
        this.logger.verbose(`${this.method} - fetch start`);
        if ((_a = this.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancellationRequested) {
            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpCancellationError();
        }
        const transformedRequest = await this.prepareRequest();
        this.ongoingPromise = this.retryRequest(transformedRequest);
        return await this.ongoingPromise;
    }
    async fetchWithCancellationCheck() {
        var _a;
        const response = await this.fetch();
        if ((_a = this.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancellationRequested) {
            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpCancellationError();
        }
        return response;
    }
    async makeRequest(request) {
        let response;
        try {
            response = await (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.fetch)(request);
            this.logger.verbose(`${this.method} - fetch response. (url=${this.url};status=${response.status})`);
        }
        catch (err) {
            if (err.name === 'AbortError') {
                this.logger.verbose(`${this.method} - fetch cancelled. (url=${this.url};cancelled=true)`);
                throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpCancellationError(err.message);
            }
            this.logger.verbose(`${this.method} - fetch failed. (url=${this.url};reason=${err.message};failed=true)`);
            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientError(err);
        }
        if (this.configuration.throwOnErrorStatus &&
            (response.status === 401 || response.status === 403)) {
            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientAuthenticationError(response);
        }
        if (this.configuration.throwOnErrorStatus && !response.ok) {
            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientResponseError(response);
        }
        return response;
    }
    async retryRequest(originalRequest) {
        try {
            return await this.makeRequest(originalRequest);
        }
        catch (err) {
            if (!this.shouldRetry(err)) {
                throw err;
            }
            const transformedRequest = await this.prepareRetryRequest(originalRequest, err.response);
            await this.delayRetry(err);
            this.retry++;
            return await this.retryRequest(transformedRequest);
        }
    }
    shouldRetry(error) {
        if (this.retry >= this.configuration.retryCount) {
            return false;
        }
        if (error instanceof _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientResponseError &&
            error.response &&
            this.configuration.retryStatusCodes.includes(error.response.status)) {
            return true;
        }
        return false;
    }
    delayRetry(error) {
        // We'll use the retry count based delay as minimum
        let delay = this.retry * 1000;
        if (error instanceof _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientResponseError) {
            const response = error.response;
            // Retry-After header specifies how long to wait after a 503, 429, or 301.
            // The value can either be a number of seconds or a Date.
            //
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
            //
            const retryAfter = response.headers.get('Retry-After');
            if (retryAfter !== null) {
                let after = Number(retryAfter);
                if (!isNaN(after)) {
                    after *= 1000;
                }
                else {
                    after = Math.max(Date.parse(retryAfter) - Date.now(), 0);
                }
                if (!isNaN(after)) {
                    delay = Math.max(delay, after);
                }
            }
        }
        return new Promise((resolve) => {
            // tslint:disable-next-line: no-string-based-set-timeout
            setTimeout(resolve, delay);
        });
    }
    async prepareRequest() {
        var _a;
        let request = new _fetch__WEBPACK_IMPORTED_MODULE_3__.Request(this.input, Object.assign({ credentials: 'same-origin' }, this.init));
        if (this.configuration.beforeRequest) {
            request = await this.configuration.beforeRequest(request);
        }
        // We create new timeout cancellation token per retry
        const cancellationToken = (_a = this.cancellationToken) !== null && _a !== void 0 ? _a : (0,_createTimeoutTokenSource__WEBPACK_IMPORTED_MODULE_1__.createTimeoutTokenSource)(this.configuration.timeout).token;
        return new _fetch__WEBPACK_IMPORTED_MODULE_3__.Request(request, { signal: (0,_toAbortSignal__WEBPACK_IMPORTED_MODULE_0__.toAbortSignal)(cancellationToken) });
    }
    async prepareRetryRequest(originalRequest, requestError) {
        var _a;
        let transformedRequest = originalRequest;
        if (this.configuration.beforeRetry) {
            const beforeRetryHookResult = await this.configuration.beforeRetry(originalRequest, requestError, this.retry);
            if (Array.isArray(beforeRetryHookResult)) {
                this.retry = beforeRetryHookResult[1];
                transformedRequest = beforeRetryHookResult[0];
            }
            else {
                transformedRequest = beforeRetryHookResult;
            }
        }
        // We create new timeout cancellation token per retry
        const cancellationToken = (_a = this.cancellationToken) !== null && _a !== void 0 ? _a : (0,_createTimeoutTokenSource__WEBPACK_IMPORTED_MODULE_1__.createTimeoutTokenSource)(this.configuration.timeout).token;
        return new _fetch__WEBPACK_IMPORTED_MODULE_3__.Request(transformedRequest, { signal: (0,_toAbortSignal__WEBPACK_IMPORTED_MODULE_0__.toAbortSignal)(cancellationToken) });
    }
}
//# sourceMappingURL=FetchRequest.js.map

/***/ }),

/***/ "../../http-client/lib/src/IHttpClient.js":
/*!************************************************!*\
  !*** ../../http-client/lib/src/IHttpClient.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=IHttpClient.js.map

/***/ }),

/***/ "../../http-client/lib/src/createTimeoutTokenSource.js":
/*!*************************************************************!*\
  !*** ../../http-client/lib/src/createTimeoutTokenSource.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTimeoutTokenSource": () => (/* binding */ createTimeoutTokenSource)
/* harmony export */ });
/* harmony import */ var vscode_jsonrpc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
/* harmony import */ var vscode_jsonrpc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode_jsonrpc__WEBPACK_IMPORTED_MODULE_0__);

function createTimeoutTokenSource(timeout) {
    const tokenSource = new vscode_jsonrpc__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
    const timeoutHandle = setTimeout(() => {
        tokenSource.cancel();
    }, timeout);
    return {
        cancel: tokenSource.cancel.bind(tokenSource),
        dispose() {
            clearTimeout(timeoutHandle);
            tokenSource.dispose();
        },
        token: tokenSource.token,
    };
}
//# sourceMappingURL=createTimeoutTokenSource.js.map

/***/ }),

/***/ "../../http-client/lib/src/fetch.js":
/*!******************************************!*\
  !*** ../../http-client/lib/src/fetch.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbortController": () => (/* binding */ AbortController),
/* harmony export */   "Request": () => (/* binding */ Request),
/* harmony export */   "fetch": () => (/* binding */ fetch)
/* harmony export */ });
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-fetch */ "../../node_modules/node-fetch/lib/index.mjs");
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abort-controller */ "../../node_modules/abort-controller/dist/abort-controller.js");
/* harmony import */ var abort_controller__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(abort_controller__WEBPACK_IMPORTED_MODULE_1__);


const __mock_value = {
    fetch: undefined,
    Request: undefined,
    AbortController: undefined,
};
const { fetch: browserFetch, Request: BrowserRequest, AbortController: BrowserAbortController } = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : __mock_value;
var fetch = browserFetch !== null && browserFetch !== void 0 ? browserFetch : node_fetch__WEBPACK_IMPORTED_MODULE_0__["default"];
var Request = BrowserRequest !== null && BrowserRequest !== void 0 ? BrowserRequest : node_fetch__WEBPACK_IMPORTED_MODULE_0__.Request;
var AbortController = BrowserAbortController !== null && BrowserAbortController !== void 0 ? BrowserAbortController : abort_controller__WEBPACK_IMPORTED_MODULE_1__.AbortController;
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ "../../http-client/lib/src/http-client.js":
/*!************************************************!*\
  !*** ../../http-client/lib/src/http-client.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpClient": () => (/* binding */ HttpClient)
/* harmony export */ });
/* harmony import */ var _FetchRequest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FetchRequest */ "../../http-client/lib/src/FetchRequest.js");

const globals = {
    requestNumber: 1,
};
const defaultConfiguration = {
    timeout: 30 * 1000,
    throwOnErrorStatus: true,
    beforeRequest: undefined,
    beforeRetry: undefined,
    retryCount: 2,
    retryStatusCodes: [429, 500, 503],
};
class HttpClient {
    constructor(logger, configuration = {}) {
        this.logger = logger;
        this.configuration = Object.assign(Object.assign({}, defaultConfiguration), configuration);
    }
    fetch(input, init, cancellationToken) {
        return new _FetchRequest__WEBPACK_IMPORTED_MODULE_0__.FetchRequest(this.logger.withName(`FetchRequest:${globals.requestNumber++}`), this.configuration, input, init, cancellationToken);
    }
    method(method, input, init, cancellationToken) {
        return this.fetch(input, Object.assign(Object.assign({}, init), { method }), cancellationToken);
    }
    get(input, init, cancellationToken) {
        return this.method('GET', input, init, cancellationToken);
    }
    post(input, init, cancellationToken) {
        return this.method('POST', input, init, cancellationToken);
    }
    put(input, init, cancellationToken) {
        return this.method('PUT', input, init, cancellationToken);
    }
    patch(input, init, cancellationToken) {
        return this.method('PATCH', input, init, cancellationToken);
    }
    head(input, init, cancellationToken) {
        return this.method('HEAD', input, init, cancellationToken);
    }
    delete(input, init, cancellationToken) {
        return this.method('DELETE', input, init, cancellationToken);
    }
}
//# sourceMappingURL=http-client.js.map

/***/ }),

/***/ "../../http-client/lib/src/index.js":
/*!******************************************!*\
  !*** ../../http-client/lib/src/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpCancellationError": () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpCancellationError),
/* harmony export */   "HttpClient": () => (/* reexport safe */ _http_client__WEBPACK_IMPORTED_MODULE_0__.HttpClient),
/* harmony export */   "HttpClientAuthenticationError": () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientAuthenticationError),
/* harmony export */   "HttpClientError": () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientError),
/* harmony export */   "HttpClientResponseError": () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpClientResponseError),
/* harmony export */   "HttpError": () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpError)
/* harmony export */ });
/* harmony import */ var _http_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./http-client */ "../../http-client/lib/src/http-client.js");
/* harmony import */ var _IHttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IHttpClient */ "../../http-client/lib/src/IHttpClient.js");
/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors */ "../../http-client/lib/src/Errors.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../http-client/lib/src/toAbortSignal.js":
/*!**************************************************!*\
  !*** ../../http-client/lib/src/toAbortSignal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toAbortSignal": () => (/* binding */ toAbortSignal)
/* harmony export */ });
/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fetch */ "../../http-client/lib/src/fetch.js");

function toAbortSignal(cancellationToken) {
    const controller = new _fetch__WEBPACK_IMPORTED_MODULE_0__.AbortController();
    if (cancellationToken.isCancellationRequested) {
        controller.abort();
    }
    const disposable = cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.onCancellationRequested(() => {
        disposable.dispose();
        controller.abort();
    });
    return controller.signal;
}
//# sourceMappingURL=toAbortSignal.js.map

/***/ }),

/***/ "../../logging/core/dist/src/GlobalPatternTraceFilter.js":
/*!***************************************************************!*\
  !*** ../../logging/core/dist/src/GlobalPatternTraceFilter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobPatternTraceFilter = void 0;
const minimatch = __webpack_require__(/*! minimatch */ "../../logging/core/node_modules/minimatch/minimatch.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../logging/core/dist/src/interfaces/index.js");
class GlobPatternTraceFilter {
    constructor(globToVerbosity) {
        this.globToVerbosity = globToVerbosity;
        this.traceSourceVerbosityCache = new Map();
    }
    getTraceVerbosity(source) {
        let traceVerbosity = this.traceSourceVerbosityCache.get(source);
        // If we don't have a cached verbosity for this source, find the verbosity and cache it
        if (typeof traceVerbosity === 'undefined') {
            traceVerbosity = 0;
            if (this.globToVerbosity) {
                for (let traceGlob in this.globToVerbosity) {
                    if (minimatch(source, traceGlob)) {
                        traceVerbosity =
                            interfaces_1.LogLevel[this.globToVerbosity[traceGlob]];
                    }
                }
            }
            this.traceSourceVerbosityCache.set(source, traceVerbosity);
        }
        return traceVerbosity;
    }
    shouldTrace(source, logLevel, id) {
        return this.getTraceVerbosity(source) <= logLevel;
    }
}
exports.GlobPatternTraceFilter = GlobPatternTraceFilter;
if (typeof Error.prepareStackTrace === 'function') {
    // Save the stack frames as a property on all errors before preparing the stack trace string.
    const originalPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function prepareVslsStack(e, s) {
        e.vslsStack = s;
        return originalPrepareStackTrace(e, s);
    };
}
;
//# sourceMappingURL=GlobalPatternTraceFilter.js.map

/***/ }),

/***/ "../../logging/core/dist/src/Logger.js":
/*!*********************************************!*\
  !*** ../../logging/core/dist/src/Logger.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = exports.LoggerBase = void 0;
const LogLevel_1 = __webpack_require__(/*! ./interfaces/LogLevel */ "../../logging/core/dist/src/interfaces/LogLevel.js");
/**
 * Base implementation of the ILogger interface.
 */
class LoggerBase {
    constructor(name) {
        this.name = name;
    }
    error(message, ...args) {
        this.log(LogLevel_1.LogLevel.Error, message, ...args);
        return this;
    }
    warning(message, ...args) {
        this.log(LogLevel_1.LogLevel.Warning, message, ...args);
        return this;
    }
    info(message, ...args) {
        this.log(LogLevel_1.LogLevel.Info, message, ...args);
        return this;
    }
    verbose(message, ...args) {
        this.log(LogLevel_1.LogLevel.Debug, message, ...args);
        return this;
    }
    createChild(name) {
        return this.withName(this.name + ':' + name);
    }
}
exports.LoggerBase = LoggerBase;
/**
 * A logger implementation that use a callback to log the values.
 */
class Logger extends LoggerBase {
    constructor(name, logCallback) {
        super(name);
        this.logCallback = logCallback;
    }
    log(logLevel, message, ...args) {
        this.logCallback(logLevel, message, ...args);
        return this;
    }
    withName(name) {
        return new Logger(name, this.logCallback);
    }
}
exports.Logger = Logger;
;
//# sourceMappingURL=Logger.js.map

/***/ }),

/***/ "../../logging/core/dist/src/LoggerSettings.js":
/*!*****************************************************!*\
  !*** ../../logging/core/dist/src/LoggerSettings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerSettings = void 0;
const LogValueType_1 = __webpack_require__(/*! ./interfaces/LogValueType */ "../../logging/core/dist/src/interfaces/LogValueType.js");
class LoggerSettings {
}
exports.LoggerSettings = LoggerSettings;
/**
 * If disable obfuscation is enabled/disabled.
 */
LoggerSettings.disableObfuscation = false;
LoggerSettings.obfuscateProperties = {
    email: LogValueType_1.LogValueType.Email,
    name: LogValueType_1.LogValueType.Text,
    token: LogValueType_1.LogValueType.Text,
    sessionToken: LogValueType_1.LogValueType.Text,
};
//# sourceMappingURL=LoggerSettings.js.map

/***/ }),

/***/ "../../logging/core/dist/src/Privacy.js":
/*!**********************************************!*\
  !*** ../../logging/core/dist/src/Privacy.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Privacy = void 0;
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
const js_sha256_1 = __webpack_require__(/*! js-sha256 */ "../../node_modules/js-sha256/src/sha256.js");
class Privacy {
    static setKey(privacyKeyBase64) {
        Privacy.privacyKey = privacyKeyBase64;
    }
    static getShortHash(value, length = 8, unkeyed = false) {
        return this.getHash(value, unkeyed).substr(0, length);
    }
    static getHash(value, unkeyed = false) {
        if (!value) {
            return '<null>';
        }
        let hasher;
        if (unkeyed) {
            hasher = js_sha256_1.sha256.create();
        }
        else {
            if (!Privacy.privacyKey) {
                return '<redacted>';
            }
            hasher = js_sha256_1.sha256.hmac.create(Privacy.privacyKey);
        }
        return hasher
            .update(value)
            .hex();
    }
    /** Get sha256 hash of UTF8 encoded value. Undefined or null value is treated as empty string. */
    static getSha256Hash(value, maxLength) {
        const result = js_sha256_1.sha256.create().update(new TextEncoder().encode(value || '')).toString();
        return typeof maxLength === 'number' && maxLength > 0 && result.length > maxLength ? result.substr(0, maxLength) : result;
    }
}
exports.Privacy = Privacy;
;
//# sourceMappingURL=Privacy.js.map

/***/ }),

/***/ "../../logging/core/dist/src/TraceFilters.js":
/*!***************************************************!*\
  !*** ../../logging/core/dist/src/TraceFilters.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceFilters = void 0;
class TraceFilters {
    constructor(filters = []) {
        this.filters = filters;
    }
    shouldTrace(source, logLevel, id) {
        return this.filters.every(t => t.shouldTrace(source, logLevel, id));
    }
}
exports.TraceFilters = TraceFilters;
//# sourceMappingURL=TraceFilters.js.map

/***/ }),

/***/ "../../logging/core/dist/src/TraceFormat.js":
/*!**************************************************!*\
  !*** ../../logging/core/dist/src/TraceFormat.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceFormat = void 0;
const dateformat = __webpack_require__(/*! dateformat */ "../../node_modules/dateformat/lib/dateformat.js");
const path = __webpack_require__(/*! path */ "path");
const Privacy_1 = __webpack_require__(/*! ./Privacy */ "../../logging/core/dist/src/Privacy.js");
const LoggerSettings_1 = __webpack_require__(/*! ./LoggerSettings */ "../../logging/core/dist/src/LoggerSettings.js");
const LogLevel_1 = __webpack_require__(/*! ./interfaces/LogLevel */ "../../logging/core/dist/src/interfaces/LogLevel.js");
const LogValueType_1 = __webpack_require__(/*! ./interfaces/LogValueType */ "../../logging/core/dist/src/interfaces/LogValueType.js");
const utils_1 = __webpack_require__(/*! ./utils */ "../../logging/core/dist/src/utils/index.js");
const renderObjectToString = (object) => {
    if (typeof object === undefined) {
        return '<undefined>';
    }
    if (typeof object === null) {
        return '<null>';
    }
    if (typeof object === 'string') {
        return `"${object}"`;
    }
    if (typeof object === 'number') {
        return `#${object}`;
    }
    if (typeof object === 'boolean') {
        return `${object}`;
    }
    if (object instanceof Symbol) {
        return object.toString();
    }
    if (object instanceof Error) {
        return (0, utils_1.errorToString)(object);
    }
    try {
        return TraceFormat.stringify(object);
    }
    catch (_a) {
        try {
            return object.toString();
        }
        catch (e) {
            return '<unknown type>';
        }
    }
};
class TraceFormat {
    static formatDate(time, mask) {
        return dateformat(time, mask || 'yyyy-mm-dd HH:MM:ss.l ', /*utc*/ true);
    }
    static formatEvent(time, source, logLevel, id, message, ...args) {
        let eventTypeChar;
        switch (logLevel) {
            case LogLevel_1.LogLevel.Critical:
                eventTypeChar = 'C';
                break;
            case LogLevel_1.LogLevel.Error:
                eventTypeChar = 'E';
                break;
            case LogLevel_1.LogLevel.Warning:
                eventTypeChar = 'W';
                break;
            case LogLevel_1.LogLevel.Info:
                eventTypeChar = 'I';
                break;
            case LogLevel_1.LogLevel.Debug:
                eventTypeChar = 'V';
                break;
            default:
                eventTypeChar = '?';
                break;
        }
        const dateString = time === null ? '' : TraceFormat.formatDate(time);
        if (message.length > TraceFormat.maxMessageLength) {
            message = message.substr(0, TraceFormat.maxMessageLength) + '...';
        }
        let line;
        if (id !== 0) {
            line = `[${dateString}${source} ${eventTypeChar}] (${id}) ${message}`;
        }
        else {
            line = `[${dateString}${source} ${eventTypeChar}] ${message}`;
        }
        const renderedObjects = args
            .map(renderObjectToString)
            .map((str, i) => {
            return `> object #${i}: ${str}`;
        });
        line += renderedObjects.join('\n');
        return line;
    }
    static parseEventId(formattedMessage) {
        let m = formattedMessage.match(/\] \(([0-9]+)\)/);
        return m ? parseInt(m[1], 10) : 0;
    }
    static formatPath(value) {
        if (!value) {
            return '<null>';
        }
        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {
            return value;
        }
        // Obfuscate the directory and file names, but preserve the extension
        // and whether it's an absolute or relative path.
        const directoryHash = Privacy_1.Privacy.getShortHash(path.dirname(value));
        const extension = path.extname(value);
        const fileHash = Privacy_1.Privacy.getShortHash(path.basename(value, extension));
        const slashIndex = value.replace('\\', '/').indexOf('/');
        if (slashIndex === 2 && value[1] === ':') {
            // Windows style absolute path
            return `<?:${value[2]}${directoryHash}${value[2]}${fileHash}${extension}>`;
        }
        else if (slashIndex === 0) {
            // Unix style absolute path
            return `<${value[0]}${directoryHash}${value[0]}${fileHash}${extension}>`;
        }
        else if (slashIndex > 0) {
            // Relative path
            return `<${directoryHash}${value[slashIndex]}${fileHash}${extension}>`;
        }
        else {
            // Simple file name
            return `<${fileHash}${extension}>`;
        }
    }
    static formatEmail(value) {
        if (!value) {
            return '<null>';
        }
        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {
            return value;
        }
        const emailHash = Privacy_1.Privacy.getShortHash(value);
        return `<${emailHash.substr(0, 4)}@${emailHash.substr(4)}>`;
    }
    static formatText(value) {
        if (!value) {
            return '<null>';
        }
        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {
            return value;
        }
        const valueHash = Privacy_1.Privacy.getShortHash(value);
        return `<${value.length}:${valueHash}>`;
    }
    static stringify(value) {
        if (LoggerSettings_1.LoggerSettings.disableObfuscation) {
            return JSON.stringify(value, null, 2);
        }
        return JSON.stringify(value, (key, value) => {
            if (value instanceof Error) {
                return (0, utils_1.errorToString)(value);
            }
            const logValueType = LoggerSettings_1.LoggerSettings.obfuscateProperties[key];
            if (logValueType) {
                switch (logValueType) {
                    case LogValueType_1.LogValueType.Text:
                        return TraceFormat.formatText(value);
                    case LogValueType_1.LogValueType.Email:
                        return TraceFormat.formatEmail(value);
                    case LogValueType_1.LogValueType.Path:
                        return TraceFormat.formatPath(value);
                }
            }
            return value;
        }, 2);
    }
}
exports.TraceFormat = TraceFormat;
TraceFormat.maxMessageLength = 5120;
//# sourceMappingURL=TraceFormat.js.map

/***/ }),

/***/ "../../logging/core/dist/src/TraceListener.js":
/*!****************************************************!*\
  !*** ../../logging/core/dist/src/TraceListener.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceListener = void 0;
const TraceFormat_1 = __webpack_require__(/*! ./TraceFormat */ "../../logging/core/dist/src/TraceFormat.js");
/**
 * Base class for a listener for events from a TraceSource.
 */
class TraceListener {
    constructor() {
        this.filter = null;
    }
    traceEvent(source, logLevel, id, message, ...args) {
        if (!this.filter || this.filter.shouldTrace(source, logLevel, id)) {
            this.writeEvent(source, logLevel, id, message, ...args);
        }
    }
    writeLine(source, line, includeTimestamp) {
        if (includeTimestamp) {
            line = `[${TraceFormat_1.TraceFormat.formatDate(new Date())} ${source}] ${line}`;
        }
        this.writeTo(line);
    }
}
exports.TraceListener = TraceListener;
//# sourceMappingURL=TraceListener.js.map

/***/ }),

/***/ "../../logging/core/dist/src/TraceSource.js":
/*!**************************************************!*\
  !*** ../../logging/core/dist/src/TraceSource.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceSource = void 0;
const events_1 = __webpack_require__(/*! events */ "events");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "../../logging/core/dist/src/interfaces/index.js");
/**
 * Source for tracing events that associates a name with every event.
 */
class TraceSource extends events_1.EventEmitter {
    constructor(name) {
        super();
        this.name = name;
    }
    /**
     * Creates a new TraceSource with listeners copied from the existing TraceSource.
     */
    withName(name) {
        const newTraceSource = new TraceSource(name);
        this.eventNames().forEach((eventName) => {
            this.listeners(eventName).forEach((listener) => {
                newTraceSource.on(eventName, listener);
            });
        });
        return newTraceSource;
    }
    /**
     * Same as `withName` but the child trace inherits the parent name
     * as the prefix of the it's name, e.g. `parent-name:name`.
     * Useful to define additional context when same component frequently
     * used in many places.
     * Another user-case is to define a package-wide main trace and use
     * the method to create loggers that are child of the main one.
     */
    createChild(name) {
        return this.withName(`${this.name}:${name}`);
    }
    addTraceListener(listener) {
        this.on(TraceSource.eventEventName, listener.traceEvent.bind(listener));
        this.on(TraceSource.lineEventName, listener.writeLine.bind(listener));
        if (listener.flushEvents) {
            this.on(TraceSource.flushEventName, listener.flushEvents.bind(listener));
        }
    }
    flushEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.listeners(TraceSource.flushEventName).map(f => Promise.resolve(f())));
        });
    }
    writeLine(line) {
        this.emit(TraceSource.lineEventName, this.name, line);
    }
    log(logLevel, message, ...args) {
        this.traceEvent(logLevel, 0, message, ...args);
        return this;
    }
    traceEvent(logLevel, id, message, ...args) {
        this.emit(TraceSource.eventEventName, this.name, logLevel, id, message, ...args);
    }
    errorEvent(id, message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Error, id, message, ...args);
    }
    warningEvent(id, message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Warning, id, message, ...args);
    }
    infoEvent(id, message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Info, id, message, ...args);
    }
    error(message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Error, 0, message, ...args);
        return this;
    }
    warning(message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Warning, 0, message, ...args);
        return this;
    }
    info(message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Info, 0, message, ...args);
        return this;
    }
    verbose(message, ...args) {
        this.traceEvent(interfaces_1.LogLevel.Debug, 0, message, ...args);
        return this;
    }
}
exports.TraceSource = TraceSource;
TraceSource.lineEventName = 'line';
TraceSource.eventEventName = 'event';
TraceSource.flushEventName = 'flush';
//# sourceMappingURL=TraceSource.js.map

/***/ }),

/***/ "../../logging/core/dist/src/VerbosityTraceFilter.js":
/*!***********************************************************!*\
  !*** ../../logging/core/dist/src/VerbosityTraceFilter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerbosityTraceFilter = void 0;
class VerbosityTraceFilter {
    constructor(verbosity) {
        this.verbosity = verbosity;
    }
    shouldTrace(source, logLevel, id) {
        return this.verbosity === undefined || this.verbosity <= logLevel;
    }
}
exports.VerbosityTraceFilter = VerbosityTraceFilter;
//# sourceMappingURL=VerbosityTraceFilter.js.map

/***/ }),

/***/ "../../logging/core/dist/src/index.js":
/*!********************************************!*\
  !*** ../../logging/core/dist/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Privacy = exports.LoggerBase = exports.Logger = exports.TraceFilters = exports.TraceSource = exports.TraceFormat = exports.TraceListener = exports.VerbosityTraceFilter = exports.GlobPatternTraceFilter = exports.LoggerSettings = void 0;
/**
 * Interfaces.
 */
__exportStar(__webpack_require__(/*! ./interfaces */ "../../logging/core/dist/src/interfaces/index.js"), exports);
/**
 * Listeners.
 */
__exportStar(__webpack_require__(/*! ./listeners */ "../../logging/core/dist/src/listeners/index.js"), exports);
/**
 * Loggers.
 */
__exportStar(__webpack_require__(/*! ./loggers */ "../../logging/core/dist/src/loggers/index.js"), exports);
/**
 * Utils.
 */
__exportStar(__webpack_require__(/*! ./utils */ "../../logging/core/dist/src/utils/index.js"), exports);
/**
 * Mocks.
 */
__exportStar(__webpack_require__(/*! ./mocks */ "../../logging/core/dist/src/mocks/index.js"), exports);
/**
 * Misc.
 */
var LoggerSettings_1 = __webpack_require__(/*! ./LoggerSettings */ "../../logging/core/dist/src/LoggerSettings.js");
Object.defineProperty(exports, "LoggerSettings", ({ enumerable: true, get: function () { return LoggerSettings_1.LoggerSettings; } }));
var GlobalPatternTraceFilter_1 = __webpack_require__(/*! ./GlobalPatternTraceFilter */ "../../logging/core/dist/src/GlobalPatternTraceFilter.js");
Object.defineProperty(exports, "GlobPatternTraceFilter", ({ enumerable: true, get: function () { return GlobalPatternTraceFilter_1.GlobPatternTraceFilter; } }));
var VerbosityTraceFilter_1 = __webpack_require__(/*! ./VerbosityTraceFilter */ "../../logging/core/dist/src/VerbosityTraceFilter.js");
Object.defineProperty(exports, "VerbosityTraceFilter", ({ enumerable: true, get: function () { return VerbosityTraceFilter_1.VerbosityTraceFilter; } }));
var TraceListener_1 = __webpack_require__(/*! ./TraceListener */ "../../logging/core/dist/src/TraceListener.js");
Object.defineProperty(exports, "TraceListener", ({ enumerable: true, get: function () { return TraceListener_1.TraceListener; } }));
var TraceFormat_1 = __webpack_require__(/*! ./TraceFormat */ "../../logging/core/dist/src/TraceFormat.js");
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return TraceFormat_1.TraceFormat; } }));
var TraceSource_1 = __webpack_require__(/*! ./TraceSource */ "../../logging/core/dist/src/TraceSource.js");
Object.defineProperty(exports, "TraceSource", ({ enumerable: true, get: function () { return TraceSource_1.TraceSource; } }));
var TraceFilters_1 = __webpack_require__(/*! ./TraceFilters */ "../../logging/core/dist/src/TraceFilters.js");
Object.defineProperty(exports, "TraceFilters", ({ enumerable: true, get: function () { return TraceFilters_1.TraceFilters; } }));
var Logger_1 = __webpack_require__(/*! ./Logger */ "../../logging/core/dist/src/Logger.js");
Object.defineProperty(exports, "Logger", ({ enumerable: true, get: function () { return Logger_1.Logger; } }));
Object.defineProperty(exports, "LoggerBase", ({ enumerable: true, get: function () { return Logger_1.LoggerBase; } }));
var Privacy_1 = __webpack_require__(/*! ./Privacy */ "../../logging/core/dist/src/Privacy.js");
Object.defineProperty(exports, "Privacy", ({ enumerable: true, get: function () { return Privacy_1.Privacy; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/dist/src/interfaces/LogLevel.js":
/*!**********************************************************!*\
  !*** ../../logging/core/dist/src/interfaces/LogLevel.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = void 0;
/**
 * The severity level of a log message.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 1] = "Trace";
    LogLevel[LogLevel["Debug"] = 2] = "Debug";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warning"] = 4] = "Warning";
    LogLevel[LogLevel["Error"] = 5] = "Error";
    LogLevel[LogLevel["Critical"] = 6] = "Critical";
    LogLevel[LogLevel["Off"] = 7] = "Off";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
;
//# sourceMappingURL=LogLevel.js.map

/***/ }),

/***/ "../../logging/core/dist/src/interfaces/LogValueType.js":
/*!**************************************************************!*\
  !*** ../../logging/core/dist/src/interfaces/LogValueType.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogValueType = void 0;
/**
 * The log value types we support.
 */
var LogValueType;
(function (LogValueType) {
    LogValueType[LogValueType["None"] = 0] = "None";
    LogValueType[LogValueType["Text"] = 1] = "Text";
    LogValueType[LogValueType["Path"] = 2] = "Path";
    LogValueType[LogValueType["Email"] = 3] = "Email";
})(LogValueType = exports.LogValueType || (exports.LogValueType = {}));
;
//# sourceMappingURL=LogValueType.js.map

/***/ }),

/***/ "../../logging/core/dist/src/interfaces/index.js":
/*!*******************************************************!*\
  !*** ../../logging/core/dist/src/interfaces/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogValueType = exports.LogLevel = void 0;
var LogLevel_1 = __webpack_require__(/*! ./LogLevel */ "../../logging/core/dist/src/interfaces/LogLevel.js");
Object.defineProperty(exports, "LogLevel", ({ enumerable: true, get: function () { return LogLevel_1.LogLevel; } }));
var LogValueType_1 = __webpack_require__(/*! ./LogValueType */ "../../logging/core/dist/src/interfaces/LogValueType.js");
Object.defineProperty(exports, "LogValueType", ({ enumerable: true, get: function () { return LogValueType_1.LogValueType; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/dist/src/listeners/BrowserConsoleTraceLogger.js":
/*!**************************************************************************!*\
  !*** ../../logging/core/dist/src/listeners/BrowserConsoleTraceLogger.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserConsoleTraceListener = void 0;
const LogLevel_1 = __webpack_require__(/*! ../interfaces/LogLevel */ "../../logging/core/dist/src/interfaces/LogLevel.js");
const loggers_1 = __webpack_require__(/*! ../loggers */ "../../logging/core/dist/src/loggers/index.js");
const ConsoleTraceListener_1 = __webpack_require__(/*! ./ConsoleTraceListener */ "../../logging/core/dist/src/listeners/ConsoleTraceListener.js");
/**
 * A trace listener using the `console`.
 */
class BrowserConsoleTraceListener extends ConsoleTraceListener_1.ConsoleTraceListener {
    constructor(consoleReference = new loggers_1.DebugConsoleLogger()) {
        super(consoleReference);
    }
    writeEvent(source, logLevel, id, message, ...args) {
        switch (logLevel) {
            case LogLevel_1.LogLevel.Critical:
            case LogLevel_1.LogLevel.Error: {
                return this.consoleReference.error(source, message, ...args);
            }
            case LogLevel_1.LogLevel.Warning: {
                return this.consoleReference.warn(source, message, ...args);
            }
            case LogLevel_1.LogLevel.Debug: {
                return (this.consoleReference.debug)
                    ? this.consoleReference.debug(source, message, ...args)
                    : this.consoleReference.info(source, message, ...args);
            }
            default: {
                return this.consoleReference.info(source, message, ...args);
            }
        }
    }
    ;
}
exports.BrowserConsoleTraceListener = BrowserConsoleTraceListener;
;
//# sourceMappingURL=BrowserConsoleTraceLogger.js.map

/***/ }),

/***/ "../../logging/core/dist/src/listeners/ConsoleTraceListener.js":
/*!*********************************************************************!*\
  !*** ../../logging/core/dist/src/listeners/ConsoleTraceListener.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleTraceListener = void 0;
const LogLevel_1 = __webpack_require__(/*! ../interfaces/LogLevel */ "../../logging/core/dist/src/interfaces/LogLevel.js");
const TraceFormat_1 = __webpack_require__(/*! ../TraceFormat */ "../../logging/core/dist/src/TraceFormat.js");
const TraceListener_1 = __webpack_require__(/*! ../TraceListener */ "../../logging/core/dist/src/TraceListener.js");
/**
 * A trace listener using the `console`.
 */
class ConsoleTraceListener extends TraceListener_1.TraceListener {
    constructor(consoleReference = console) {
        super();
        this.consoleReference = consoleReference;
    }
    writeTo(line) {
        this.consoleReference.log(line);
    }
    writeEvent(source, logLevel, id, message, ...args) {
        const line = TraceFormat_1.TraceFormat.formatEvent(null, source, logLevel, id, message, ...args);
        switch (logLevel) {
            case LogLevel_1.LogLevel.Critical:
            case LogLevel_1.LogLevel.Error: {
                return this.consoleReference.error(line);
            }
            case LogLevel_1.LogLevel.Warning: {
                return this.consoleReference.warn(line);
            }
            case LogLevel_1.LogLevel.Debug: {
                return (this.consoleReference.debug)
                    ? this.consoleReference.debug(line)
                    : this.consoleReference.log(line);
            }
            default: {
                return this.consoleReference.log(line);
            }
        }
    }
    ;
}
exports.ConsoleTraceListener = ConsoleTraceListener;
;
//# sourceMappingURL=ConsoleTraceListener.js.map

/***/ }),

/***/ "../../logging/core/dist/src/listeners/MemoryTraceListener.js":
/*!********************************************************************!*\
  !*** ../../logging/core/dist/src/listeners/MemoryTraceListener.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryTraceListener = void 0;
const TraceFormat_1 = __webpack_require__(/*! ../TraceFormat */ "../../logging/core/dist/src/TraceFormat.js");
const TraceListener_1 = __webpack_require__(/*! ../TraceListener */ "../../logging/core/dist/src/TraceListener.js");
/**
 * A memory trace listener.
 */
class MemoryTraceListener extends TraceListener_1.TraceListener {
    constructor(maxLogSize) {
        super();
        this.allLogs = [];
        this.logsByLevel = new Map();
        this.maxLogSize = maxLogSize || 128;
    }
    getLogs(logLevel) {
        if (logLevel) {
            const logs = this.logsByLevel.get(logLevel);
            return logs ? logs.map(i => i) : [];
        }
        return this.allLogs.map(i => i);
    }
    writeTo(line) {
        this.addLine(line);
    }
    addLine(line, logLevel) {
        this.allLogs.push(line);
        if (this.allLogs.length > this.maxLogSize) {
            this.allLogs.splice(0, 1);
        }
        if (logLevel) {
            const logEntries = this.logsByLevel.get(logLevel);
            if (!logEntries) {
                this.logsByLevel.set(logLevel, [line]);
            }
            else {
                logEntries.push(line);
                if (logEntries.length > this.maxLogSize) {
                    logEntries.splice(0, 1);
                }
            }
        }
    }
    writeEvent(source, logLevel, id, message, ...args) {
        const line = TraceFormat_1.TraceFormat.formatEvent(new Date(), source, logLevel, id, message, ...args);
        this.addLine(line, logLevel);
    }
    ;
}
exports.MemoryTraceListener = MemoryTraceListener;
;
//# sourceMappingURL=MemoryTraceListener.js.map

/***/ }),

/***/ "../../logging/core/dist/src/listeners/OutputTraceListener.js":
/*!********************************************************************!*\
  !*** ../../logging/core/dist/src/listeners/OutputTraceListener.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputTraceListener = void 0;
const TraceFormat_1 = __webpack_require__(/*! ../TraceFormat */ "../../logging/core/dist/src/TraceFormat.js");
const TraceListener_1 = __webpack_require__(/*! ../TraceListener */ "../../logging/core/dist/src/TraceListener.js");
class OutputTraceListener extends TraceListener_1.TraceListener {
    constructor(outputChannelName, includeTimestamp) {
        super();
        this.includeTimestamp = includeTimestamp;
        this.channel = null;
        this.channelName = outputChannelName;
    }
    writeTo(line) {
        if (this.channel != null) {
            this.channel.appendLine(line);
        }
    }
    writeEvent(source, logLevel, id, message, ...args) {
        const line = TraceFormat_1.TraceFormat.formatEvent(this.includeTimestamp ? new Date() : null, source, logLevel, id, message, ...args);
        this.writeTo(line);
    }
    addOutputChannel(focus) {
        if (this.channel != null) {
            return;
        }
        // Defer import of 'vscode' package.
        const vscodeModule = __webpack_require__(/*! vscode */ "vscode");
        this.channel = vscodeModule.window.createOutputChannel(this.channelName);
        if (focus) {
            // Keep OutputChannel in focus
            this.channel.show(true);
        }
    }
    removeOutputChannel() {
        if (this.channel == null) {
            return;
        }
        this.channel.clear();
        this.channel.dispose();
        this.channel = null;
    }
}
exports.OutputTraceListener = OutputTraceListener;
;
//# sourceMappingURL=OutputTraceListener.js.map

/***/ }),

/***/ "../../logging/core/dist/src/listeners/index.js":
/*!******************************************************!*\
  !*** ../../logging/core/dist/src/listeners/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryTraceListener = exports.OutputTraceListener = exports.ConsoleTraceListener = exports.BrowserConsoleTraceListener = void 0;
var BrowserConsoleTraceLogger_1 = __webpack_require__(/*! ./BrowserConsoleTraceLogger */ "../../logging/core/dist/src/listeners/BrowserConsoleTraceLogger.js");
Object.defineProperty(exports, "BrowserConsoleTraceListener", ({ enumerable: true, get: function () { return BrowserConsoleTraceLogger_1.BrowserConsoleTraceListener; } }));
var ConsoleTraceListener_1 = __webpack_require__(/*! ./ConsoleTraceListener */ "../../logging/core/dist/src/listeners/ConsoleTraceListener.js");
Object.defineProperty(exports, "ConsoleTraceListener", ({ enumerable: true, get: function () { return ConsoleTraceListener_1.ConsoleTraceListener; } }));
var OutputTraceListener_1 = __webpack_require__(/*! ./OutputTraceListener */ "../../logging/core/dist/src/listeners/OutputTraceListener.js");
Object.defineProperty(exports, "OutputTraceListener", ({ enumerable: true, get: function () { return OutputTraceListener_1.OutputTraceListener; } }));
var MemoryTraceListener_1 = __webpack_require__(/*! ./MemoryTraceListener */ "../../logging/core/dist/src/listeners/MemoryTraceListener.js");
Object.defineProperty(exports, "MemoryTraceListener", ({ enumerable: true, get: function () { return MemoryTraceListener_1.MemoryTraceListener; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/dist/src/loggers/DebugConsoleLogger.js":
/*!*****************************************************************!*\
  !*** ../../logging/core/dist/src/loggers/DebugConsoleLogger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConsoleLogger = void 0;
const debug_1 = __webpack_require__(/*! debug */ "../../logging/core/node_modules/debug/src/index.js");
/**
 * Console logger on top of debug package.
 */
class DebugConsoleLogger {
    constructor(console = globalThis.console) {
        this.console = console;
        this.tracesCache = {};
        /**
         * Method to create an `debug` trace isntance with the specified trace level.
         * Caches the create traces for reuse to reduce GC churn.
         */
        this.createTrace = (source, type, consoleFunction) => {
            const traceKey = `${source}:${type}`;
            const cachedTrace = this.tracesCache[traceKey];
            if (cachedTrace) {
                return cachedTrace;
            }
            const trace = (0, debug_1.default)(traceKey);
            trace.log = consoleFunction;
            this.tracesCache[traceKey] = trace;
            return trace;
        };
        this.log = (source, message, ...args) => {
            return this.info(source, message, ...args);
        };
        this.info = (source, message, ...args) => {
            this.createTrace(source, 'info', this.console.info)(message, ...args);
        };
        this.debug = (source, message, ...args) => {
            const method = (this.console.debug)
                ? this.console.debug
                : this.console.log;
            this.createTrace(source, 'trace', method)(message, ...args);
        };
        this.warn = (source, message, ...args) => {
            this.createTrace(source, 'warn', this.console.warn)(source, message, ...args);
        };
        this.error = (source, message, ...args) => {
            this.createTrace(source, 'error', this.console.error)(source, message, ...args);
        };
    }
}
exports.DebugConsoleLogger = DebugConsoleLogger;
DebugConsoleLogger.enable = (path) => {
    debug_1.default.enable(path);
};
//# sourceMappingURL=DebugConsoleLogger.js.map

/***/ }),

/***/ "../../logging/core/dist/src/loggers/index.js":
/*!****************************************************!*\
  !*** ../../logging/core/dist/src/loggers/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugConsoleLogger = void 0;
var DebugConsoleLogger_1 = __webpack_require__(/*! ./DebugConsoleLogger */ "../../logging/core/dist/src/loggers/DebugConsoleLogger.js");
Object.defineProperty(exports, "DebugConsoleLogger", ({ enumerable: true, get: function () { return DebugConsoleLogger_1.DebugConsoleLogger; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/dist/src/mocks/TraceLoggerMock.js":
/*!************************************************************!*\
  !*** ../../logging/core/dist/src/mocks/TraceLoggerMock.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleLoggerMock = void 0;
const DEFAULT_OPTIONS = {
    info: () => { },
    log: () => { },
    debug: () => { },
    warn: () => { },
    error: () => { },
};
class ConsoleLoggerMock {
    constructor(options = {}) {
        this.log = (...args) => {
            throw new Error('The `log` method is not implemented');
        };
        this.info = (...args) => {
            throw new Error('The `info` method is not implemented');
        };
        this.debug = (...args) => {
            throw new Error('The `debug` method is not implemented');
        };
        this.warn = (...args) => {
            throw new Error('The `warn` method is not implemented');
        };
        this.error = (...args) => {
            throw new Error('The `error` method is not implemented');
        };
        this.optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.log = this.optionsWithDefaults.log;
        this.info = this.optionsWithDefaults.info;
        this.warn = this.optionsWithDefaults.warn;
        this.debug = this.optionsWithDefaults.debug;
        this.error = this.optionsWithDefaults.error;
    }
}
exports.ConsoleLoggerMock = ConsoleLoggerMock;
;
//# sourceMappingURL=TraceLoggerMock.js.map

/***/ }),

/***/ "../../logging/core/dist/src/mocks/index.js":
/*!**************************************************!*\
  !*** ../../logging/core/dist/src/mocks/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleLoggerMock = void 0;
var TraceLoggerMock_1 = __webpack_require__(/*! ./TraceLoggerMock */ "../../logging/core/dist/src/mocks/TraceLoggerMock.js");
Object.defineProperty(exports, "ConsoleLoggerMock", ({ enumerable: true, get: function () { return TraceLoggerMock_1.ConsoleLoggerMock; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/dist/src/utils/errorToString.js":
/*!**********************************************************!*\
  !*** ../../logging/core/dist/src/utils/errorToString.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorToString = void 0;
const source_map_support_1 = __webpack_require__(/*! source-map-support */ "../../logging/core/node_modules/source-map-support/source-map-support.js");
/**
 * Converts an error object to a string, including stack trace with source map transformations.
 */
function errorToString(e) {
    if (!e) {
        return null;
    }
    let s = e.message || 'Unknown error';
    const code = e.code;
    if (code) {
        s += ' code:' + code;
    }
    // Try to use source map information to map the stack frames back to original sources.
    let stack = null;
    if (e.vslsStack) {
        try {
            stack = e.vslsStack.map((frame) => '  at ' + (0, source_map_support_1.wrapCallSite)(frame)).join('\n');
        }
        catch (e) { }
    }
    if (!stack) {
        stack = e.stack || null;
    }
    if (stack) {
        s += '\n' + stack;
    }
    return s;
}
exports.errorToString = errorToString;
;
//# sourceMappingURL=errorToString.js.map

/***/ }),

/***/ "../../logging/core/dist/src/utils/index.js":
/*!**************************************************!*\
  !*** ../../logging/core/dist/src/utils/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorToString = void 0;
var errorToString_1 = __webpack_require__(/*! ./errorToString */ "../../logging/core/dist/src/utils/errorToString.js");
Object.defineProperty(exports, "errorToString", ({ enumerable: true, get: function () { return errorToString_1.errorToString; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/core/node_modules/balanced-match/index.js":
/*!***************************************************************!*\
  !*** ../../logging/core/node_modules/balanced-match/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "../../logging/core/node_modules/brace-expansion/index.js":
/*!****************************************************************!*\
  !*** ../../logging/core/node_modules/brace-expansion/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(/*! concat-map */ "../../logging/core/node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "../../logging/core/node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "../../logging/core/node_modules/buffer-from/index.js":
/*!************************************************************!*\
  !*** ../../logging/core/node_modules/buffer-from/index.js ***!
  \************************************************************/
/***/ ((module) => {

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ "../../logging/core/node_modules/concat-map/index.js":
/*!***********************************************************!*\
  !*** ../../logging/core/node_modules/concat-map/index.js ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../../logging/core/node_modules/debug/src/browser.js":
/*!************************************************************!*\
  !*** ../../logging/core/node_modules/debug/src/browser.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../logging/core/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../logging/core/node_modules/debug/src/common.js":
/*!***********************************************************!*\
  !*** ../../logging/core/node_modules/debug/src/common.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../logging/core/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../logging/core/node_modules/debug/src/index.js":
/*!**********************************************************!*\
  !*** ../../logging/core/node_modules/debug/src/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../logging/core/node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../logging/core/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../logging/core/node_modules/debug/src/node.js":
/*!*********************************************************!*\
  !*** ../../logging/core/node_modules/debug/src/node.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../logging/core/node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../logging/core/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../logging/core/node_modules/has-flag/index.js":
/*!*********************************************************!*\
  !*** ../../logging/core/node_modules/has-flag/index.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "../../logging/core/node_modules/minimatch/minimatch.js":
/*!**************************************************************!*\
  !*** ../../logging/core/node_modules/minimatch/minimatch.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(/*! path */ "path")
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(/*! brace-expansion */ "../../logging/core/node_modules/brace-expansion/index.js")

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "../../logging/core/node_modules/ms/index.js":
/*!***************************************************!*\
  !*** ../../logging/core/node_modules/ms/index.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/array-set.js":
/*!***************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/array-set.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js":
/*!****************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64.js":
/*!************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/binary-search.js":
/*!*******************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/binary-search.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js":
/*!******************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js":
/*!****************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js":
/*!*************************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/binary-search.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/array-set.js").ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js");
var quickSort = (__webpack_require__(/*! ./quick-sort */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js").quickSort);

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js":
/*!**************************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/array-set.js").ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js").MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-node.js":
/*!*****************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-node.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js":
/*!**********************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/util.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/node_modules/source-map/source-map.js":
/*!************************************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/node_modules/source-map/source-map.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "../../logging/core/node_modules/source-map-support/source-map-support.js":
/*!********************************************************************************!*\
  !*** ../../logging/core/node_modules/source-map-support/source-map-support.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var SourceMapConsumer = (__webpack_require__(/*! source-map */ "../../logging/core/node_modules/source-map-support/node_modules/source-map/source-map.js").SourceMapConsumer);
var path = __webpack_require__(/*! path */ "path");

var fs;
try {
  fs = __webpack_require__(/*! fs */ "fs");
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = __webpack_require__(/*! buffer-from */ "../../logging/core/node_modules/buffer-from/index.js");

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(process.version) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  if (process.stderr._handle && process.stderr._handle.setBlocking) {
    process.stderr._handle.setBlocking(true);
  }

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = __webpack_require__(/*! module */ "module");
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}


/***/ }),

/***/ "../../logging/core/node_modules/supports-color/index.js":
/*!***************************************************************!*\
  !*** ../../logging/core/node_modules/supports-color/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "../../logging/core/node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if ('GITHUB_ACTIONS' in env) {
		return 1;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "../../logging/desktop/dist/src/index.js":
/*!***********************************************!*\
  !*** ../../logging/desktop/dist/src/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryLogFilter = exports.LogLocations = exports.LogFileTraceListener = void 0;
// tracing
var logFileTraceListener_1 = __webpack_require__(/*! ./logFileTraceListener */ "../../logging/desktop/dist/src/logFileTraceListener.js");
Object.defineProperty(exports, "LogFileTraceListener", ({ enumerable: true, get: function () { return logFileTraceListener_1.LogFileTraceListener; } }));
// log locations
var logLocations_1 = __webpack_require__(/*! ./logLocations */ "../../logging/desktop/dist/src/logLocations.js");
Object.defineProperty(exports, "LogLocations", ({ enumerable: true, get: function () { return logLocations_1.LogLocations; } }));
// telemetry
var LogFilter_1 = __webpack_require__(/*! ./telemetry/LogFilter */ "../../logging/desktop/dist/src/telemetry/LogFilter.js");
Object.defineProperty(exports, "TelemetryLogFilter", ({ enumerable: true, get: function () { return LogFilter_1.LogFilter; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../logging/desktop/dist/src/logFileTraceListener.js":
/*!**************************************************************!*\
  !*** ../../logging/desktop/dist/src/logFileTraceListener.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogFileTraceListener = void 0;
const path = __importStar(__webpack_require__(/*! path-browserify */ "../../node_modules/path-browserify/index.js"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const util = __importStar(__webpack_require__(/*! util */ "util"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const vso_telemetry_1 = __webpack_require__(/*! @vs/vso-telemetry */ "../../telemetry/core/dist/src/index.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const telemetryStrings_1 = __webpack_require__(/*! ./telemetry/telemetryStrings */ "../../logging/desktop/dist/src/telemetry/telemetryStrings.js");
const logLocations_1 = __webpack_require__(/*! ./logLocations */ "../../logging/desktop/dist/src/logLocations.js");
const mkdirAsync = util.promisify(fs.mkdir);
const openAsync = util.promisify(fs.open);
const writeAsync = util.promisify(fs.write);
class LogFileTraceListener extends vso_logging_1.TraceListener {
    constructor(processName, logDirectory = LogFileTraceListener.defaultLogDirectory, fileDescriptor) {
        super();
        this.processName = processName;
        this.logDirectory = logDirectory;
        this.fileDescriptor = fileDescriptor;
        this.writePromise = Promise.resolve();
        this.canWriteLogs = true;
        this.openLogFileAsync = (index = 0) => __awaiter(this, void 0, void 0, function* () {
            // if 5th attempt - report to telemetry and forbit writing to local logs.
            if (index === 5) {
                this.canWriteLogs = false;
                vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.NAME_LOGS_FILE_FAILED, vso_telemetry_1.FaultType.Error, 'Name Log File Failed - Reached maximum number of attempts.');
                return;
            }
            const datePrefix = new Date()
                .toISOString()
                .replace(/T/, '_')
                .replace(/:|-/g, '')
                .replace(/\..+/, '');
            // Ensure a unique file name, in case another log session started around the same time.
            const indexFileName = path.join(this.logDirectory, `${datePrefix}_${Date.now()}${index}_${this.processName}.log`);
            try {
                const fileDescriptor = yield openAsync(indexFileName, 'ax'); // Append, fail if exists
                this.fileDescriptor = fileDescriptor;
                this.fileName = indexFileName;
            }
            catch (err) {
                if (err.code === 'EEXIST') {
                    // try the nex index
                    yield this.openLogFileAsync(index + 1);
                }
                else {
                    this.canWriteLogs = false;
                    vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.OPEN_LOGS_FAILED, vso_telemetry_1.FaultType.Error, `Name Log File Failed. ${err.message}`, err);
                }
            }
            return indexFileName;
        });
        this.flushEvents = () => {
            return this.writePromise;
        };
    }
    static get defaultLogDirectory() {
        return logLocations_1.LogLocations.clientLogFilePath;
    }
    get logFileName() {
        return this.fileName;
    }
    /**
     * Opens the log file. Await this method before using the trace listener.
     */
    openAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield mkdirAsync(this.logDirectory);
            }
            catch (e) { }
            return yield this.openLogFileAsync();
        });
    }
    writeTo(line) {
        if (!this.fileDescriptor) {
            throw new Error('No file descriptor defined, please open file first.');
        }
        fs.writeFileSync(this.fileDescriptor, line + os.EOL);
    }
    writeEvent(source, logLevel, id, message, ...args) {
        if (this.canWriteLogs === false) {
            return;
        }
        const line = vso_logging_1.TraceFormat.formatEvent(new Date(), source, logLevel, id, message, ...args);
        this.writePromise = this.writePromise.then(() => {
            writeAsync(this.fileDescriptor, line + os.EOL).catch((e) => {
                this.canWriteLogs = false;
                // do not reject if error, but log the event to telemetry
                vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.WRITE_LOGS_FAILED, vso_telemetry_1.FaultType.Error, e.message, e);
            });
        });
    }
}
exports.LogFileTraceListener = LogFileTraceListener;
//# sourceMappingURL=logFileTraceListener.js.map

/***/ }),

/***/ "../../logging/desktop/dist/src/logLocations.js":
/*!******************************************************!*\
  !*** ../../logging/desktop/dist/src/logLocations.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLocations = void 0;
class LogLocations {
}
exports.LogLocations = LogLocations;
//# sourceMappingURL=logLocations.js.map

/***/ }),

/***/ "../../logging/desktop/dist/src/telemetry/LogFilter.js":
/*!*************************************************************!*\
  !*** ../../logging/desktop/dist/src/telemetry/LogFilter.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogFilter = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const logFileTraceListener_1 = __webpack_require__(/*! ../logFileTraceListener */ "../../logging/desktop/dist/src/logFileTraceListener.js");
// This filter logs all sent telemetry events to a file.
class LogFilter {
    constructor() {
        this.trace = new vso_logging_1.TraceSource('Telemetry');
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const logFileTraceListener = new logFileTraceListener_1.LogFileTraceListener('VSCodeTelemetry');
            yield logFileTraceListener.openAsync();
            this.trace.addTraceListener(logFileTraceListener);
        });
    }
    shouldSend(eventName, properties, measures) {
        const telemetryEvent = {
            eventName,
            properties,
            measures,
        };
        this.trace.info(JSON.stringify(telemetryEvent, null, 2));
        return true;
    }
}
exports.LogFilter = LogFilter;
//# sourceMappingURL=LogFilter.js.map

/***/ }),

/***/ "../../logging/desktop/dist/src/telemetry/telemetryStrings.js":
/*!********************************************************************!*\
  !*** ../../logging/desktop/dist/src/telemetry/telemetryStrings.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryEventNames = void 0;
class TelemetryEventNames {
}
exports.TelemetryEventNames = TelemetryEventNames;
TelemetryEventNames.FAULT_PREFIX = 'Fault/';
TelemetryEventNames.NAME_LOGS_FILE_FAILED = TelemetryEventNames.FAULT_PREFIX + 'name-logfile-failed';
TelemetryEventNames.OPEN_LOGS_FAILED = TelemetryEventNames.FAULT_PREFIX + 'open-logs-failed';
TelemetryEventNames.WRITE_LOGS_FAILED = TelemetryEventNames.FAULT_PREFIX + 'write-logs-failed';
//# sourceMappingURL=telemetryStrings.js.map

/***/ }),

/***/ "../../node/server/dist/src/MutliChannelRpcSocketServer.js":
/*!*****************************************************************!*\
  !*** ../../node/server/dist/src/MutliChannelRpcSocketServer.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MutliChannelRpcSocketServer = void 0;
const vso_rpc_ssh_1 = __webpack_require__(/*! @vs/vso-rpc-ssh */ "../../rpc/ssh/dist/src/index.js");
const dev_tunnels_ssh_1 = __webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js");
class MutliChannelRpcSocketServer {
    constructor(trace, serverFactory) {
        this.rpcServer = new vso_rpc_ssh_1.MultiChannelRpcServer(trace.withName('RpcServer'));
        this.server = serverFactory(this.rpcServer);
    }
    accept(socket) {
        return __awaiter(this, void 0, void 0, function* () {
            const transportStream = new dev_tunnels_ssh_1.NodeStream(socket);
            const [messageConnectInfo] = yield this.rpcServer.acceptStream(transportStream);
            return messageConnectInfo;
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.server && typeof this.server.dispose === 'function') {
                yield Promise.resolve(this.server.dispose());
            }
        });
    }
}
exports.MutliChannelRpcSocketServer = MutliChannelRpcSocketServer;
//# sourceMappingURL=MutliChannelRpcSocketServer.js.map

/***/ }),

/***/ "../../node/server/dist/src/TelemetryOptions.js":
/*!******************************************************!*\
  !*** ../../node/server/dist/src/TelemetryOptions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=TelemetryOptions.js.map

/***/ }),

/***/ "../../node/server/dist/src/index.js":
/*!*******************************************!*\
  !*** ../../node/server/dist/src/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./MutliChannelRpcSocketServer */ "../../node/server/dist/src/MutliChannelRpcSocketServer.js"), exports);
__exportStar(__webpack_require__(/*! ./serverUtils */ "../../node/server/dist/src/serverUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./TelemetryOptions */ "../../node/server/dist/src/TelemetryOptions.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node/server/dist/src/serverUtils.js":
/*!*************************************************!*\
  !*** ../../node/server/dist/src/serverUtils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startSocketServer = void 0;
const net = __webpack_require__(/*! net */ "net");
const os = __webpack_require__(/*! os */ "os");
const fs = __webpack_require__(/*! fs */ "fs");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vso_node_utils_1 = __webpack_require__(/*! @vs/vso-node-utils */ "../../node/utils/dist/src/index.js");
function startSocketServer(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.port && !options.pipe) {
            throw Error('You need to specify a port or a pipe name');
        }
        const { traceSource, getLogs, socketServerFactory, serverHost = {} } = options;
        const keepAliveTime = options.keepAliveTime || 10000;
        const hostedServer = {
            keepAliveCount: 0,
            rpcConnectionCount: 0,
            options,
            stop: (reason) => stopRpcServer(reason),
        };
        const keepAlive = (time) => {
            const delay = time || keepAliveTime;
            ++hostedServer.keepAliveCount;
            traceSource.verbose(`keepAlive start -> time:${delay}`);
            (0, vscs_utils_1.wait)(delay).then(() => {
                --hostedServer.keepAliveCount;
                traceSource.verbose(`keepAlive end -> count:${hostedServer.keepAliveCount + hostedServer.rpcConnectionCount}`);
                if ((hostedServer.keepAliveCount + hostedServer.rpcConnectionCount) === 0) {
                    if (options.autoExit) {
                        traceSource.info(`shutting down due to inactivity...`);
                        stopRpcServer(99);
                    }
                    else if (typeof serverHost.keepAliveTriggered === 'function') {
                        serverHost.keepAliveTriggered(hostedServer);
                    }
                }
            });
        };
        // initialize
        const socketServer = socketServerFactory(keepAlive, traceSource);
        const clients = [];
        let server;
        // our stop rpc server callback
        const stopRpcServer = (reasonOrExitCode) => __awaiter(this, void 0, void 0, function* () {
            // close the socket server
            if (server) {
                const closed = new vscs_utils_1.Signal();
                traceSource.writeLine(`closing socket server...`);
                clients.forEach(socket => socket.destroy());
                server.close((err) => {
                    closed.resolve();
                    traceSource.writeLine(`server closed err:${err !== null && err !== void 0 ? err : 'n/a'}`);
                });
                yield closed.promise;
            }
            traceSource.writeLine(`stopping rpc server...`);
            try {
                yield socketServer.dispose();
            }
            catch (err) {
                traceSource.error(`failed to dispose server`, err);
            }
            traceSource.info(`rpc server stopped`);
            if (typeof serverHost.serverStopped === 'function') {
                serverHost.serverStopped(reasonOrExitCode, hostedServer);
            }
        });
        let listenCallback;
        if (options.port) {
            listenCallback = (retry) => {
                const port = options.port + retry;
                server.listen(port, 'localhost');
            };
        }
        else {
            listenCallback = (retry) => {
                const pipe = retry === 0 ? options.pipe : `${options.pipe}-${retry}`;
                const pipePath = options.isRawPipe ? pipe : (0, vso_node_utils_1.getPipePath)(pipe);
                if (os.platform() !== "win32" && fs.existsSync(pipePath)) {
                    traceSource.warning(`pipe:${pipePath} already exist, attempting to delete it`);
                    try {
                        fs.unlinkSync(pipePath);
                    }
                    catch (err) {
                        traceSource.error(`failed to delete existing pipe:`, err);
                    }
                }
                server.listen(pipePath);
            };
        }
        // create a server to listen for rpc connections
        server = net.createServer(function (socket) {
            clients.push(socket);
            socket.on('close', function () {
                clients.splice(clients.indexOf(socket), 1);
            });
            socketServer.accept(socket).then((rpcConnection) => {
                rpcConnection.listen();
                // request to get the latest logs
                rpcConnection.onRequest('logService.getLogs', (requestId, logLevel) => {
                    return typeof getLogs === 'function' ? getLogs(logLevel) : [];
                });
                const disposables = [];
                ++hostedServer.rpcConnectionCount;
                traceSource.info(`rpc created count:${hostedServer.rpcConnectionCount}`);
                const removeRpc = (event) => {
                    // stop both closee/disposed notifications in case both event are trigered
                    disposables.forEach(d => d.dispose());
                    --hostedServer.rpcConnectionCount;
                    traceSource.info(`rpc event:${event} count:${hostedServer.rpcConnectionCount}`);
                    keepAlive();
                };
                // subscribe to closed/disposed events
                disposables.push(rpcConnection.onDispose(e => removeRpc('disposed')));
                disposables.push(rpcConnection.onClose(e => removeRpc('closed')));
            }).catch(err => {
                traceSource.info(`failed to accept socket`, err);
            });
        });
        const maxRetries = options.maxRetries || 20;
        let retry = 0;
        server.on('error', (e) => {
            traceSource.error(`socket server err:${e}`);
            if (e.code === 'EADDRINUSE') {
                ++retry;
                if (retry >= maxRetries) {
                    if (typeof serverHost.serverStopped === 'function') {
                        serverHost.serverStopped(e, hostedServer);
                    }
                }
                else {
                    traceSource.info(`listening retry:${retry}`);
                    listenCallback(retry);
                }
            }
        });
        server.on('listening', () => {
            const serverAddress = server.address();
            traceSource.info(`rpc server listening on address:${JSON.stringify(serverAddress)}`);
            if (options.isAdmin) {
                if (typeof serverAddress) {
                    traceSource.info(`change pipe permission...`);
                    try {
                        fs.chmodSync(String(serverAddress), '777');
                    }
                    catch (e) {
                        traceSource.info(`failed to change pipe permission.`, e);
                    }
                }
            }
        });
        listenCallback(0);
        keepAlive();
        return hostedServer;
    });
}
exports.startSocketServer = startSocketServer;
//# sourceMappingURL=serverUtils.js.map

/***/ }),

/***/ "../../node/utils/dist/src/NodeFileAccess.js":
/*!***************************************************!*\
  !*** ../../node/utils/dist/src/NodeFileAccess.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileAccess = void 0;
const fs = __webpack_require__(/*! fs */ "fs");
const util = __webpack_require__(/*! util */ "util");
const fse = __webpack_require__(/*! fs-extra */ "../../node_modules/fs-extra/lib/index.js");
const mkdirAsync = util.promisify(fs.mkdir);
const openAsync = util.promisify(fs.open);
const closeAsync = util.promisify(fs.close);
const writeAsync = util.promisify(fs.write);
const chmodAsync = util.promisify(fs.chmod);
const existsAsync = util.promisify(fs.exists);
const accessAsync = util.promisify(fs.access);
const readdirAsync = util.promisify(fs.readdir);
const unlinkAsync = util.promisify(fs.unlink);
class NodeFileAccess {
    constructor() {
        this.existsAsync = existsAsync;
        this.chmodAsync = chmodAsync;
        this.accessAsync = accessAsync;
    }
    mkdirAsync(path) {
        return mkdirAsync(path);
    }
    mkdirSync(path) {
        fs.mkdirSync(path);
    }
    openFileAsync(filePath, openMode) {
        return openAsync(filePath, openMode);
    }
    openSync(filePath, flags) {
        return fs.openSync(filePath, flags);
    }
    openAsync(filePath, openMode) {
        return openAsync(filePath, openMode);
    }
    closeSync(fileDescriptor) {
        fs.closeSync(fileDescriptor);
    }
    closeAsync(fileDescriptor) {
        return closeAsync(fileDescriptor);
    }
    writeAsync(fileDescriptor, contents) {
        return writeAsync(fileDescriptor, contents);
    }
    writeFile(filePath, data, callback) {
        if (typeof callback !== 'undefined') {
            fs.writeFile(filePath, data, callback);
        }
        else {
            return fse.writeFile(filePath, data);
        }
    }
    writeFileAsync(filePath, data) {
        return fse.writeFile(filePath, data);
    }
    appendFileSync(fileDescriptor, data, options) {
        fs.appendFileSync(fileDescriptor, data, options);
    }
    chmod(path, mode, callback) {
        fs.chmod(path, mode, callback);
    }
    stat(path, callback) {
        fs.stat(path, callback);
    }
    statSync(path) {
        return fs.statSync(path);
    }
    lstatSync(path) {
        return fs.lstatSync(path);
    }
    lstat(path, callback) {
        fs.lstat(path, callback);
    }
    existsSync(filePath) {
        return fs.existsSync(filePath);
    }
    readdirSync(path) {
        return fs.readdirSync(path);
    }
    readdirAsync(path) {
        return readdirAsync(path);
    }
    readFileSync(filePath, options) {
        if (typeof options !== 'undefined') {
            return fs.readFileSync(filePath, options);
        }
        else {
            return fs.readFileSync(filePath);
        }
    }
    readFile(filePath, options, callback) {
        if (typeof callback !== 'undefined' && typeof options !== 'undefined') {
            fs.readFile(filePath, options, callback);
        }
        else {
            return fse.readFile(filePath);
        }
    }
    unlink(path, callback) {
        fs.unlink(path, callback);
    }
    unlinkSync(path) {
        fs.unlinkSync(path);
    }
    unlinkAsync(path) {
        return unlinkAsync(path);
    }
    // FSE
    copySync(sourcePath, targetPath) {
        fse.copySync(sourcePath, targetPath);
    }
    readdir(path, callback) {
        if (typeof callback !== 'undefined') {
            fse.readdir(path, callback);
        }
        else {
            return fse.readdir(path);
        }
    }
    remove(dir) {
        return fse.remove(dir);
    }
    renameSync(sourcePath, targetPath) {
        fse.renameSync(sourcePath, targetPath);
    }
    ensureDir(path) {
        return fse.ensureDir(path);
    }
    ensureDirAsync(path) {
        return fse.ensureDir(path);
    }
    writeFileSync(path, data) {
        fse.writeFileSync(path, data);
    }
    pathExistsSync(path) {
        return fse.pathExistsSync(path);
    }
    access(path) {
        return fse.access(path);
    }
    copyFileSync(src, dest) {
        return fse.copyFileSync(src, dest);
    }
    copyFile(src, dest) {
        return fse.copyFile(src, dest);
    }
    readJson(file) {
        return fse.readJson(file);
    }
    writeJson(file, data, options) {
        return fse.writeJson(file, data, options);
    }
    createReadStream(path) {
        return fse.createReadStream(path);
    }
    createWriteStream(path) {
        return fse.createWriteStream(path);
    }
    pathExists(path) {
        return fse.pathExists(path);
    }
}
exports.fileAccess = new NodeFileAccess();
//# sourceMappingURL=NodeFileAccess.js.map

/***/ }),

/***/ "../../node/utils/dist/src/fileUtils.js":
/*!**********************************************!*\
  !*** ../../node/utils/dist/src/fileUtils.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLastFiles = void 0;
const NodeFileAccess_1 = __webpack_require__(/*! ./NodeFileAccess */ "../../node/utils/dist/src/NodeFileAccess.js");
const path = __webpack_require__(/*! path */ "path");
/**
 * Return the last files on a directory ordered by the timestamp
 * @param dirPath The directory path to look for.
 * @param maxFiles Optional max number of files to return.
 * @returns Array of files sorted by their timestamp.
 */
function getLastFiles(dirPath, maxFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = (yield NodeFileAccess_1.fileAccess
            .readdirAsync(dirPath))
            .map(function (name) {
            const time = NodeFileAccess_1.fileAccess.statSync(path.join(dirPath, name)).mtime.getTime();
            return { name, time };
        })
            .sort(function (a, b) {
            return b.time - a.time;
        })
            .map(function (file) {
            return path.join(dirPath, file.name);
        });
        if (maxFiles && files.length > maxFiles) {
            return files.slice(0, maxFiles);
        }
        return files;
    });
}
exports.getLastFiles = getLastFiles;
//# sourceMappingURL=fileUtils.js.map

/***/ }),

/***/ "../../node/utils/dist/src/getPipePath.js":
/*!************************************************!*\
  !*** ../../node/utils/dist/src/getPipePath.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPipePath = void 0;
const os = __webpack_require__(/*! os */ "os");
function getPipePath(pipeName) {
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\${pipeName}`;
    }
    else {
        // .NET Core on Mac/Linux uses this pattern for pipe paths. Reference:
        // https://github.com/dotnet/corefx/blob/master/src/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs
        return `${os.tmpdir()}/CoreFxPipe_${pipeName}`;
    }
}
exports.getPipePath = getPipePath;
//# sourceMappingURL=getPipePath.js.map

/***/ }),

/***/ "../../node/utils/dist/src/getPlatformProperty.js":
/*!********************************************************!*\
  !*** ../../node/utils/dist/src/getPlatformProperty.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPlatformProperty = void 0;
const os = __webpack_require__(/*! os */ "os");
const osPlatform_1 = __webpack_require__(/*! ./osPlatform */ "../../node/utils/dist/src/osPlatform.js");
function getPlatformProperty() {
    switch (os.platform()) {
        case osPlatform_1.OSPlatform.WINDOWS:
            return 'windows';
        case osPlatform_1.OSPlatform.MACOS:
            return 'osx';
        case osPlatform_1.OSPlatform.LINUX:
        default:
            return 'linux';
    }
}
exports.getPlatformProperty = getPlatformProperty;
//# sourceMappingURL=getPlatformProperty.js.map

/***/ }),

/***/ "../../node/utils/dist/src/index.js":
/*!******************************************!*\
  !*** ../../node/utils/dist/src/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OSPlatform = exports.startSocketSessionOnPipe = exports.startSocketSessionOnPort = exports.startSocketSession = exports.getPlatformProperty = exports.fileAccess = exports.sudoExecAgent = exports.execAgent = exports.lockAgent = exports.getPipePath = void 0;
var getPipePath_1 = __webpack_require__(/*! ./getPipePath */ "../../node/utils/dist/src/getPipePath.js");
Object.defineProperty(exports, "getPipePath", ({ enumerable: true, get: function () { return getPipePath_1.getPipePath; } }));
var lockFileUtils_1 = __webpack_require__(/*! ./lockFileUtils */ "../../node/utils/dist/src/lockFileUtils.js");
Object.defineProperty(exports, "lockAgent", ({ enumerable: true, get: function () { return lockFileUtils_1.lockAgent; } }));
var processUtils_1 = __webpack_require__(/*! ./processUtils */ "../../node/utils/dist/src/processUtils.js");
Object.defineProperty(exports, "execAgent", ({ enumerable: true, get: function () { return processUtils_1.execAgent; } }));
Object.defineProperty(exports, "sudoExecAgent", ({ enumerable: true, get: function () { return processUtils_1.sudoExecAgent; } }));
__exportStar(__webpack_require__(/*! ./fileUtils */ "../../node/utils/dist/src/fileUtils.js"), exports);
var NodeFileAccess_1 = __webpack_require__(/*! ./NodeFileAccess */ "../../node/utils/dist/src/NodeFileAccess.js");
Object.defineProperty(exports, "fileAccess", ({ enumerable: true, get: function () { return NodeFileAccess_1.fileAccess; } }));
var getPlatformProperty_1 = __webpack_require__(/*! ./getPlatformProperty */ "../../node/utils/dist/src/getPlatformProperty.js");
Object.defineProperty(exports, "getPlatformProperty", ({ enumerable: true, get: function () { return getPlatformProperty_1.getPlatformProperty; } }));
var socketUtils_1 = __webpack_require__(/*! ./socketUtils */ "../../node/utils/dist/src/socketUtils.js");
Object.defineProperty(exports, "startSocketSession", ({ enumerable: true, get: function () { return socketUtils_1.startSocketSession; } }));
Object.defineProperty(exports, "startSocketSessionOnPort", ({ enumerable: true, get: function () { return socketUtils_1.startSocketSessionOnPort; } }));
Object.defineProperty(exports, "startSocketSessionOnPipe", ({ enumerable: true, get: function () { return socketUtils_1.startSocketSessionOnPipe; } }));
var osPlatform_1 = __webpack_require__(/*! ./osPlatform */ "../../node/utils/dist/src/osPlatform.js");
Object.defineProperty(exports, "OSPlatform", ({ enumerable: true, get: function () { return osPlatform_1.OSPlatform; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node/utils/dist/src/lockFileUtils.js":
/*!**************************************************!*\
  !*** ../../node/utils/dist/src/lockFileUtils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lockAgent = void 0;
const lockFile = __webpack_require__(/*! lockfile */ "../../node_modules/lockfile/lockfile.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
function lockAgent(path, lockSuccessCallback, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const lockOptions = {
            stale: 60 * 1000,
            retries: 60,
            retryWait: 1000,
        };
        const pathLock = path + '.lock';
        // Check if the file is already locked
        const isLocked = yield new Promise((resolve) => {
            lockFile.check(pathLock, lockOptions, (err, locked) => resolve(!!locked));
        });
        if (isLocked) {
            logger.verbose('Agent is being started by another vscode instance. Waiting for completion...');
        }
        logger.verbose(`Agent lock on:${vso_logging_1.TraceFormat.formatPath(pathLock)}`);
        // Acquire a new lock
        yield new Promise((resolve, reject) => lockFile.lock(pathLock, lockOptions, (err) => {
            if (err) {
                logger.error('Failed to lock the agent');
                reject(err);
            }
            else {
                resolve(true);
            }
        }));
        try {
            if (!isLocked) {
                yield lockSuccessCallback();
                logger.verbose(`Finished agent startup...`);
            }
        }
        finally {
            // No need to wait for unlocking to finish
            lockFile.unlock(pathLock, () => {
                logger.verbose(`Agent unlocked`);
            });
        }
    });
}
exports.lockAgent = lockAgent;
//# sourceMappingURL=lockFileUtils.js.map

/***/ }),

/***/ "../../node/utils/dist/src/osPlatform.js":
/*!***********************************************!*\
  !*** ../../node/utils/dist/src/osPlatform.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OSPlatform = void 0;
/** Defines values that may be returned by Node's `os.platform()` API. */
var OSPlatform;
(function (OSPlatform) {
    OSPlatform["MACOS"] = "darwin";
    OSPlatform["WINDOWS"] = "win32";
    OSPlatform["LINUX"] = "linux";
})(OSPlatform = exports.OSPlatform || (exports.OSPlatform = {}));
//# sourceMappingURL=osPlatform.js.map

/***/ }),

/***/ "../../node/utils/dist/src/processUtils.js":
/*!*************************************************!*\
  !*** ../../node/utils/dist/src/processUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.execAgent = exports.sudoExecAgent = void 0;
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");
const child_process = __webpack_require__(/*! child_process */ "child_process");
const sudo = __webpack_require__(/*! sudo-prompt */ "../../node_modules/sudo-prompt/index.js");
const osPlatform_1 = __webpack_require__(/*! ./osPlatform */ "../../node/utils/dist/src/osPlatform.js");
function sudoExecAgent(agentPath, args, envVars, sudoWindowName) {
    return new Promise((resolve, reject) => {
        const sudoCallback = (error, _stdout, stderr) => {
            if (error) {
                reject(`sudo exec failed - message: ${error.message} - stack: ${error.stack}`);
            }
            else if (stderr) {
                reject(`sudo exec failed - stderr: ${stderr}`);
            }
            resolve(undefined);
        };
        execAgentInternal(agentPath, args, envVars, sudoWindowName, sudoCallback);
    });
}
exports.sudoExecAgent = sudoExecAgent;
function execAgent(agentPath, args, envVars) {
    return execAgentInternal(agentPath, args, envVars);
}
exports.execAgent = execAgent;
function execAgentInternal(agentPath, args, envVars, sudoWindowName, sudoCallback) {
    // Clone process.env before setting additional environment variables
    // that should be applied only to the child agent process
    const childProcessEnv = Object.assign({}, process.env);
    if (envVars) {
        Object.keys(envVars).forEach(key => childProcessEnv[key] = envVars[key]);
    }
    if (envVars && envVars['ELECTRON_RUN_AS_NODE'] === '1') {
        // As of VS Code 1.62.1 we need to pass this additional flag to run as
        // node. See https://github.com/github/codespaces/issues/4715#issuecomment-965063951
        // for more info.
        args.push('--ms-enable-electron-run-as-node');
    }
    if (os.platform() === osPlatform_1.OSPlatform.WINDOWS) {
        // Try to use `cmd.exe`, if found in the expected place.
        // Node's child_process.exec() uses %ComSpec% by default, but when set to other shells that can cause problems.
        const cmdExePath = path.join(process.env.SystemRoot || 'C:\\WINDOWS', 'system32', 'cmd.exe');
        let shell;
        try {
            fs.statSync(cmdExePath);
            shell = cmdExePath;
        }
        catch (_a) {
            shell = process.env.ComSpec || 'cmd.exe';
        }
        const command = `start /B "" "${agentPath}" ${args.join(' ')}`;
        if (sudoWindowName) {
            sudo.exec(command, { name: sudoWindowName, env: envVars }, sudoCallback);
            return;
        }
        return child_process.exec(command, { env: childProcessEnv, shell, windowsHide: true });
    }
    else {
        const sh = `/bin/sh -c '"${agentPath}" ${args.join(' ')}' &`;
        if (sudoWindowName) {
            sudo.exec(`ELECTRON_RUN_AS_NODE=1 /bin/sh -c '"${agentPath}" ${args.join(' ')}' &`, { name: sudoWindowName, env: envVars }, sudoCallback);
            return;
        }
        return child_process.exec(sh, { env: childProcessEnv, windowsHide: true });
    }
}
//# sourceMappingURL=processUtils.js.map

/***/ }),

/***/ "../../node/utils/dist/src/socketUtils.js":
/*!************************************************!*\
  !*** ../../node/utils/dist/src/socketUtils.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startSocketSessionOnPipe = exports.startSocketSessionOnPort = exports.startSocketSession = void 0;
const net = __webpack_require__(/*! net */ "net");
const getPipePath_1 = __webpack_require__(/*! ./getPipePath */ "../../node/utils/dist/src/getPipePath.js");
function startSocketSession(socketFactory) {
    return __awaiter(this, void 0, void 0, function* () {
        let socket;
        const tcpConnect = new Promise((resolve, reject) => {
            let connected = false;
            socket = socketFactory(() => {
                resolve();
                connected = true;
            });
            socket.on('close', () => {
                if (!connected) {
                    reject(new Error('connection closed'));
                }
            });
            socket.on('error', error => {
                if (!connected) {
                    reject(error);
                }
            });
        });
        yield tcpConnect;
        return socket;
    });
}
exports.startSocketSession = startSocketSession;
function startSocketSessionOnPort(port) {
    return startSocketSession((listener) => net.createConnection(port, '127.0.0.1', listener));
}
exports.startSocketSessionOnPort = startSocketSessionOnPort;
function startSocketSessionOnPipe(pipe, isRawPipe) {
    return startSocketSession((listener) => net.createConnection(isRawPipe ? pipe : (0, getPipePath_1.getPipePath)(pipe), listener));
}
exports.startSocketSessionOnPipe = startSocketSessionOnPipe;
//# sourceMappingURL=socketUtils.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.curves = void 0;
/**
 * List of EC curves supported by the SSH ECDSA algorithm.
 */
exports.curves = [
    {
        shortName: 'P-256',
        name: 'nistp256',
        oid: '1.2.840.10045.3.1.7',
        keySize: 256,
    },
    {
        shortName: 'P-384',
        name: 'nistp384',
        oid: '1.3.132.0.34',
        keySize: 384,
    },
    {
        shortName: 'P-521',
        name: 'nistp521',
        oid: '1.3.132.0.35',
        keySize: 521,
    },
];
//# sourceMappingURL=ecdsaCurves.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EncryptionAlgorithm = void 0;
class EncryptionAlgorithm {
    constructor(name) {
        this.name = name;
    }
}
exports.EncryptionAlgorithm = EncryptionAlgorithm;
//# sourceMappingURL=encryptionAlgorithm.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HmacAlgorithm = void 0;
class HmacAlgorithm {
    constructor(name, algorithmName, keyLength, digestLength) {
        this.name = name;
        this.algorithmName = algorithmName;
        this.keyLength = keyLength;
        this.digestLength = digestLength;
    }
}
exports.HmacAlgorithm = HmacAlgorithm;
//# sourceMappingURL=hmacAlgorithm.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyExchangeAlgorithm = void 0;
class KeyExchangeAlgorithm {
    constructor(name, keySizeInBits, hashAlgorithmName, hashDigestLength) {
        this.name = name;
        this.keySizeInBits = keySizeInBits;
        this.hashAlgorithmName = hashAlgorithmName;
        this.hashDigestLength = hashDigestLength;
    }
}
exports.KeyExchangeAlgorithm = KeyExchangeAlgorithm;
//# sourceMappingURL=keyExchangeAlgorithm.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sec1KeyFormatter = exports.Pkcs1KeyFormatter = exports.parsePem = exports.formatPem = void 0;
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const derData_1 = __webpack_require__(/*! ../../io/derData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js");
const ecdsaCurves_1 = __webpack_require__(/*! ../ecdsaCurves */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js");
function formatPem(keyBytes, name) {
    const key = `-----BEGIN ${name}-----\n` +
        keyBytes
            .toString('base64')
            .match(/.{1,64}/g)
            .join('\n') +
        '\n' +
        `-----END ${name}-----\n`;
    return key;
}
exports.formatPem = formatPem;
function parsePem(key) {
    const keyBase64 = key.replace(/-+[^-\n]+KEY-+/g, '').replace(/\s/g, '');
    const keyBytes = Buffer.from(keyBase64, 'base64');
    return keyBytes;
}
exports.parsePem = parsePem;
/**
 * Provides *minimal* PKCS#1 import/export support for Node.js keys.
 *
 * This code is redundant with some of the PKCS#1 import/export code in the separate
 * `ssh-keys` library; that is intentional, and necessary to support a consistent
 * interface for importing/exporting key parameters in the core `ssh` library.
 */
class Pkcs1KeyFormatter {
    static formatRsaPublic(rsa) {
        const writer = new derData_1.DerWriter(Buffer.alloc(1024));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        return writer.toBuffer();
    }
    static formatRsaPrivate(rsa) {
        if (!(rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi)) {
            throw new Error('Missing private key parameters.');
        }
        const writer = new derData_1.DerWriter(Buffer.alloc(2048));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(0));
        writer.writeInteger(rsa.modulus);
        writer.writeInteger(rsa.exponent);
        writer.writeInteger(rsa.d);
        writer.writeInteger(rsa.p);
        writer.writeInteger(rsa.q);
        writer.writeInteger(rsa.dp);
        writer.writeInteger(rsa.dq);
        writer.writeInteger(rsa.qi);
        return writer.toBuffer();
    }
    static parseRsaPublic(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        return { modulus, exponent };
    }
    static parseRsaPrivate(keyBytes) {
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger();
        const modulus = reader.readInteger();
        const exponent = reader.readInteger();
        const d = reader.readInteger();
        const p = reader.readInteger();
        const q = reader.readInteger();
        const dp = reader.readInteger();
        const dq = reader.readInteger();
        const qi = reader.readInteger();
        return { modulus, exponent, d, p, q, dp, dq, qi };
    }
}
exports.Pkcs1KeyFormatter = Pkcs1KeyFormatter;
/**
 * Provides *minimal* SEC1 import/export support for Node.js keys.
 *
 * This code is redundant with some of the SEC1 import/export code in the separate
 * `ssh-keys` library; that is intentional, and necessary to support a consistent
 * interface for importing/exporting key parameters in the core `ssh` library.
 */
class Sec1KeyFormatter {
    static formatECPublic(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        const oidsWriter = new derData_1.DerWriter(Buffer.alloc(100));
        oidsWriter.writeObjectIdentifier(Sec1KeyFormatter.ecPublicKeyOid);
        oidsWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeSequence(oidsWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4; // Indicates uncompressed curve format
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        writer.writeBitString(publicKeyData);
        return writer.toBuffer();
    }
    static formatECPrivate(ec) {
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const writer = new derData_1.DerWriter(Buffer.alloc(512));
        writer.writeInteger(bigInt_1.BigInt.fromInt32(1)); // version
        writer.writeOctetString(ec.d.toBytes({ unsigned: true, length: keySizeInBytes }));
        const curveWriter = new derData_1.DerWriter(Buffer.alloc(100));
        curveWriter.writeObjectIdentifier(ec.curve.oid);
        writer.writeTagged(0, curveWriter);
        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        const publicKeyData = Buffer.alloc(1 + x.length + y.length);
        publicKeyData[0] = 4; // Indicates uncompressed curve format
        x.copy(publicKeyData, 1);
        y.copy(publicKeyData, 1 + x.length);
        const keyWriter = new derData_1.DerWriter(Buffer.alloc(512));
        keyWriter.writeBitString(publicKeyData);
        writer.writeTagged(1, keyWriter);
        return writer.toBuffer();
    }
    static parseECPublic(keyBytes) {
        var _a;
        const reader = new derData_1.DerReader(keyBytes);
        const oidsReader = reader.readSequence();
        const keyTypeOid = oidsReader.readObjectIdentifier();
        if (keyTypeOid !== Sec1KeyFormatter.ecPublicKeyOid) {
            throw new Error(`Unexpected key type OID: ${keyTypeOid}`);
        }
        const curveOid = oidsReader.readObjectIdentifier();
        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;
        const xy = reader.readBitString();
        if (xy.length % 2 !== 1) {
            throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
            curve: { name: curveName, oid: curveOid },
            x,
            y,
        };
        return ec;
    }
    static parseECPrivate(keyBytes) {
        var _a;
        const reader = new derData_1.DerReader(keyBytes);
        const version = reader.readInteger().toInt32();
        if (version !== 1) {
            throw new Error(`Unsupported SEC1 format version: ${version}`);
        }
        const d = bigInt_1.BigInt.fromBytes(reader.readOctetString(), { unsigned: true });
        const curveReader = reader.tryReadTagged(0);
        if (!curveReader) {
            throw new Error('SEC1 curve info not found.');
        }
        const curveOid = curveReader.readObjectIdentifier();
        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;
        const publicKeyReader = reader.tryReadTagged(1);
        if (!publicKeyReader) {
            throw new Error('SEC1 public key data not found.');
        }
        const xy = publicKeyReader.readBitString();
        if (xy.length % 2 !== 1) {
            throw new Error(`Unexpected key data length: ${xy.length}`);
        }
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const ec = {
            curve: { name: curveName, oid: curveOid },
            x,
            y,
            d,
        };
        return ec;
    }
}
exports.Sec1KeyFormatter = Sec1KeyFormatter;
Sec1KeyFormatter.ecPublicKeyOid = '1.2.840.10045.2.1';
//# sourceMappingURL=keyFormatters.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeECDsa = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const publicKeyAlgorithm_1 = __webpack_require__(/*! ../publicKeyAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js");
const ecdsaCurves_1 = __webpack_require__(/*! ../ecdsaCurves */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js");
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const derData_1 = __webpack_require__(/*! ../../io/derData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js");
const sshData_1 = __webpack_require__(/*! ../../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const keyFormatters_1 = __webpack_require__(/*! ./keyFormatters */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js");
const nodeVersionParts = process.versions.node.split('.').map((v) => parseInt(v, 10));
const nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || (nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12);
const nodeKeyObjectSupport = nodeVersionParts[0] > 11 || (nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6);
class NodeECDsaKeyPair {
    /**
     * Constructs a new ECDSA key pair object.
     *
     * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
     * initialized before use via `importParameters()`.
     */
    constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
            this.algorithmName = algorithmName;
        }
    }
    get hasPublicKey() {
        return !!this.publicKey;
    }
    get hasPrivateKey() {
        return !!this.privateKey;
    }
    get keyAlgorithmName() {
        return this.algorithmName;
    }
    get algorithmName() {
        return this.algorithm;
    }
    set algorithmName(value) {
        const curveName = value.split('-')[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
            throw new Error('Invalid or unsupported ECDSA algorithm: ' + value);
        }
        this.algorithm = value;
    }
    generate() {
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
            return this.generateNodeKeyPairObjects();
        }
        else if (nodeGenerateKeyPairSupport) {
            return this.generateNodeKeyPairBuffers();
        }
        else {
            return this.generateExternalKeyPair();
        }
    }
    async generateNodeKeyPairObjects() {
        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {
            const keyGenParams = {
                namedCurve: this.curve.shortName,
            };
            try {
                crypto.generateKeyPair('ec', keyGenParams, (err, publicKey, privateKey) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve([publicKey, privateKey]);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    async generateNodeKeyPairBuffers() {
        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {
            const keyGenParams = {
                namedCurve: this.curve.shortName,
                publicKeyEncoding: { type: 'spki', format: 'pem' },
                privateKeyEncoding: {
                    type: 'sec1',
                    format: 'pem',
                    cipher: undefined,
                    passphrase: undefined,
                },
            };
            try {
                crypto.generateKeyPair('ec', keyGenParams, (err, publicKey, privateKey) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve([publicKey, privateKey]);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    async generateExternalKeyPair() {
        throw new Error('This version of node does not support generating key pairs. Use node >= 10.12.');
    }
    async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
            throw new TypeError('Buffer is required.');
        }
        // Read public key in SSH format.
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString('ascii');
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString('ascii');
        this.algorithmName = `ecdsa-sha2-${curveName}`;
        const xy = reader.readBinary();
        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });
        const derKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic({
            curve: { name: this.curve.name, oid: this.curve.oid },
            x,
            y,
        });
        if (nodeKeyObjectSupport) {
            this.publicKey = crypto.createPublicKey({
                key: derKeyBytes,
                type: 'spki',
                format: 'der',
            });
        }
        else {
            this.publicKey = (0, keyFormatters_1.formatPem)(derKeyBytes, 'PUBLIC KEY');
        }
    }
    async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
            return null;
        }
        let derKeyBytes;
        if (typeof this.publicKey === 'string') {
            derKeyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        }
        else {
            derKeyBytes = this.publicKey.export({
                type: 'spki',
                format: 'der',
            });
        }
        const ec = keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
        // Write public key in SSH format.
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(512));
        keyWriter.writeString(algorithmName, 'ascii');
        keyWriter.writeString(this.curve.name, 'ascii');
        const keySizeInBytes = Math.ceil(this.curve.keySize / 8);
        const xBytes = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });
        const yBytes = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });
        keyWriter.writeUInt32(1 + xBytes.length + yBytes.length);
        keyWriter.writeByte(4); // Indicates uncompressed curve format
        keyWriter.write(xBytes);
        keyWriter.write(yBytes);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
    }
    async importParameters(parameters) {
        if (!parameters.curve)
            throw new TypeError('A curve is required.');
        let curve;
        if (parameters.curve.oid) {
            curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
            if (!curve) {
                throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
            }
        }
        else if (parameters.curve.name) {
            curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
            if (!curve) {
                throw new Error(`Unsupported curve: ${parameters.curve.name}`);
            }
        }
        else {
            throw new TypeError('A curve OID or name is required.');
        }
        this.algorithmName = 'ecdsa-sha2-' + curve.name;
        const publicKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic(parameters);
        if (nodeKeyObjectSupport) {
            this.publicKey = crypto.createPublicKey({
                key: publicKeyBytes,
                type: 'spki',
                format: 'der',
            });
        }
        else {
            this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, 'EC PUBLIC KEY');
        }
        if (parameters.d) {
            const privateKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPrivate(parameters);
            if (nodeKeyObjectSupport) {
                this.privateKey = crypto.createPrivateKey({
                    key: privateKeyBytes,
                    type: 'sec1',
                    format: 'der',
                });
            }
            else {
                this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, 'EC PRIVATE KEY');
            }
        }
        else {
            this.privateKey = undefined;
        }
    }
    async exportParameters() {
        var _a, _b;
        if (!this.publicKey) {
            throw new Error('Key is not present.');
        }
        let derKeyBytes;
        if (typeof this.publicKey === 'string') {
            derKeyBytes = (0, keyFormatters_1.parsePem)((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);
        }
        else {
            derKeyBytes = ((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey).export({
                type: this.privateKey ? 'sec1' : 'spki',
                format: 'der',
            });
        }
        return this.privateKey
            ? keyFormatters_1.Sec1KeyFormatter.parseECPrivate(derKeyBytes)
            : keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);
    }
    dispose() { }
}
class NodeECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
    constructor(name, hashAlgorithmName) {
        super(name, name, // The key algorithm name is the same (unlike RSA).
        hashAlgorithmName);
    }
    createKeyPair() {
        return new NodeECDsaKeyPair(this.name);
    }
    async generateKeyPair() {
        const ecdsaKey = new NodeECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
    }
    createSigner(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
            throw new TypeError('ECDSA key pair object expected.');
        }
        return new NodeECDsaSignerVerifier(keyPair, NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
    }
    createVerifier(keyPair) {
        if (!(keyPair instanceof NodeECDsaKeyPair)) {
            throw new TypeError('ECDSA key pair object expected.');
        }
        return new NodeECDsaSignerVerifier(keyPair, NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));
    }
    static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace('SHA2-', 'SHA');
    }
    /* @internal */
    static getSignatureLength(keySizeInBits) {
        // The signature is double the key size, but formatted as 2 bigints.
        // To each bigint add 4 for the length and 1 for a leading zero.
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
    }
}
exports.NodeECDsa = NodeECDsa;
NodeECDsa.ecdsaSha2Nistp256 = 'ecdsa-sha2-nistp256';
NodeECDsa.ecdsaSha2Nistp384 = 'ecdsa-sha2-nistp384';
NodeECDsa.ecdsaSha2Nistp521 = 'ecdsa-sha2-nistp521';
NodeECDsa.curves = ecdsaCurves_1.curves;
NodeECDsa.KeyPair = NodeECDsaKeyPair;
class NodeECDsaSignerVerifier {
    constructor(keyPair, hashAlgorithmName) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
    }
    get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
            return 0;
        }
        else {
            return NodeECDsa.getSignatureLength(curve.keySize);
        }
    }
    async sign(data) {
        if (!this.keyPair.privateKey) {
            throw new Error('Private key not set.');
        }
        const signer = crypto.createSign(this.hashAlgorithmName);
        signer.update(data);
        let signature = signer.sign(this.keyPair.privateKey);
        // Reformat the signature integer bytes as required by SSH.
        const signatureReader = new derData_1.DerReader(signature);
        const x = signatureReader.readInteger();
        const y = signatureReader.readInteger();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
    }
    async verify(data, signature) {
        if (!this.keyPair.publicKey) {
            throw new Error('Public key not set.');
        }
        // Reformat the signature integer bytes as required by node.
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const signatureWriter = new derData_1.DerWriter(buffer_1.Buffer.alloc(signature.length));
        signatureWriter.writeInteger(x);
        signatureWriter.writeInteger(y);
        signature = signatureWriter.toBuffer();
        const verifier = crypto.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
    }
    dispose() { }
}
//# sourceMappingURL=nodeECDsa.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeEncryption = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const encryptionAlgorithm_1 = __webpack_require__(/*! ../encryptionAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js");
class NodeEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
    constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        if (algorithmName !== 'AES') {
            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
        this.blockSizeInBits = NodeEncryption.getBlockSize(algorithmName);
    }
    get keyLength() {
        return this.keySizeInBits / 8;
    }
    get blockLength() {
        return this.blockSizeInBits / 8;
    }
    async createCipher(isEncryption, key, iv) {
        let cipher;
        if (this.cipherMode === 'CTR' || this.cipherMode === 'CBC') {
            cipher = new NodeAesCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv, this.cipherMode);
        }
        else if (this.cipherMode === 'GCM') {
            cipher = new NodeAesGcmCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv);
        }
        else {
            throw new Error(`Unsupported cipher mode: ${this.cipherMode}`);
        }
        return cipher;
    }
    static getBlockSize(algorithmName) {
        if (algorithmName === 'AES') {
            return 128;
        }
        else {
            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
    }
}
exports.NodeEncryption = NodeEncryption;
class NodeAesCipher {
    constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv, cipherMode) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        const nodeAlgorithm = `AES-${this.keySizeInBits}-${cipherMode}`;
        this.cipher = this.isEncryption
            ? crypto.createCipheriv(nodeAlgorithm, key, iv)
            : crypto.createDecipheriv(nodeAlgorithm, key, iv);
        this.cipher.setAutoPadding(false);
    }
    get blockLength() {
        return this.blockSizeInBits / 8;
    }
    transform(data) {
        const result = this.cipher.update(data);
        if (result.length !== data.length) {
            const message = 'Result from encrypt/decrypt has invalid length ' +
                `${result.length}, expected ${data.length}.`;
            throw new Error(message);
        }
        return Promise.resolve(result);
    }
    dispose() { }
}
class NodeAesGcmCipher {
    constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv) {
        this.isEncryption = isEncryption;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        this.algorithmName = `aes-${this.keySizeInBits}-gcm`;
        this.key = buffer_1.Buffer.alloc(key.length);
        key.copy(this.key);
        // Ininitialize the nonce to the first 12 bytes of the IV. It will be incremented by each op.
        this.nonce = buffer_1.Buffer.alloc(12);
        iv.copy(this.nonce, 0, 0, 12);
        this.associatedData = buffer_1.Buffer.alloc(4);
    }
    get blockLength() {
        return this.blockSizeInBits / 8;
    }
    get digestLength() {
        return 16;
    }
    get authenticatedEncryption() {
        return true;
    }
    transform(data) {
        if (data.length % this.blockLength !== 0) {
            const message = 'Encrypt/decrypt input has invalid length ' +
                `${data.length}, not a multiple of block size ${this.blockLength}.`;
            throw new Error(message);
        }
        const cipher = this.isEncryption
            ? crypto.createCipheriv(this.algorithmName, this.key, this.nonce)
            : crypto.createDecipheriv(this.algorithmName, this.key, this.nonce);
        // Associated data is the 32-bit packet length.
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        cipher.setAAD(this.associatedData);
        if (!this.isEncryption) {
            if (!this.tag) {
                throw new Error('AES-GCM tag was not set before decrypting.');
            }
            cipher.setAuthTag(this.tag);
        }
        const result = cipher.update(data);
        if (result.length !== data.length) {
            const message = 'Result from encrypt/decrypt has invalid length ' +
                `${result.length}, expected ${data.length}.`;
            throw new Error(message);
        }
        cipher.final();
        if (this.isEncryption) {
            this.tag = cipher.getAuthTag();
        }
        else {
            this.tag = null;
        }
        // Increment the counter (last 8 bytes of the nonce) as a big-endian integer.
        // First increment the last byte, and if it reaches 0 then increment the
        // next-to-last byte, and so on.
        let k = 12;
        while (--k >= 4) {
            this.nonce[k]++;
            if (this.nonce[k] !== 0) {
                break;
            }
        }
        return Promise.resolve(result);
    }
    async sign(data) {
        if (!this.tag) {
            throw new Error('AES-GCM tag was not obtained by encrypting.');
        }
        return this.tag;
    }
    async verify(data, signature) {
        if (signature.length !== this.digestLength) {
            throw new Error('Incorrect AES-GCM tag length.');
        }
        this.tag = signature;
        return true;
    }
    dispose() { }
}
//# sourceMappingURL=nodeEncryption.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHmac = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const hmacAlgorithm_1 = __webpack_require__(/*! ../hmacAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js");
class NodeHmac extends hmacAlgorithm_1.HmacAlgorithm {
    constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, NodeHmac.getHashKeyLength(algorithmName), NodeHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
    }
    async createSigner(key) {
        const hmac = new NodeSignerVerifier(NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
    }
    async createVerifier(key) {
        const hmac = new NodeSignerVerifier(NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);
        return hmac;
    }
    static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === 'SHA2-512')
            return 512 / 8;
        if (hashAlgorithmName === 'SHA2-384')
            return 384 / 8;
        if (hashAlgorithmName === 'SHA2-256')
            return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
    }
    static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
    }
    static getNodeHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === 'SHA2-512')
            return 'sha512';
        if (hashAlgorithmName === 'SHA2-384')
            return 'sha384';
        if (hashAlgorithmName === 'SHA2-256')
            return 'sha256';
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
    }
}
exports.NodeHmac = NodeHmac;
class NodeSignerVerifier {
    constructor(algorithmName, digestLength, encryptThenMac, key) {
        this.algorithmName = algorithmName;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
        // crypto.createSecretKey is only available on node >= 11.6.
        this.key = crypto.createSecretKey ? crypto.createSecretKey(key) : buffer_1.Buffer.from(key);
    }
    async sign(data) {
        const signer = crypto.createHmac(this.algorithmName, this.key);
        signer.update(data);
        const hmac = signer.digest();
        return hmac;
    }
    async verify(data, signature) {
        const verifier = crypto.createHmac(this.algorithmName, this.key);
        verifier.update(data);
        const hmac = verifier.digest();
        const result = hmac.equals(signature);
        return result;
    }
    dispose() { }
}
//# sourceMappingURL=nodeHmac.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeECDiffieHellman = exports.NodeDiffieHellman = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const keyExchangeAlgorithm_1 = __webpack_require__(/*! ../keyExchangeAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js");
const nodeHmac_1 = __webpack_require__(/*! ./nodeHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js");
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
class NodeDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
    constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
    }
    createKeyExchange() {
        return new NodeDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
    }
}
exports.NodeDiffieHellman = NodeDiffieHellman;
class NodeDiffieHellmanKex {
    constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
            case 1024:
                this.dh = crypto.getDiffieHellman('modp2');
                break;
            case 2048:
                this.dh = crypto.getDiffieHellman('modp14');
                break;
            case 4096:
                this.dh = crypto.getDiffieHellman('modp16');
                break;
            default:
                throw new Error('Invalid DH bit length.');
        }
    }
    startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
    }
    decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
    }
    async sign(data) {
        const hash = crypto.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
    }
    dispose() { }
}
class NodeECDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
    constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));
    }
    createKeyExchange() {
        return new NodeECDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
    }
}
exports.NodeECDiffieHellman = NodeECDiffieHellman;
class NodeECDiffieHellmanKex {
    constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
            case 256:
                this.ecdh = crypto.createECDH('prime256v1');
                break;
            case 384:
                this.ecdh = crypto.createECDH('secp384r1');
                break;
            case 521:
                this.ecdh = crypto.createECDH('secp521r1');
                break;
            default:
                throw new Error('Invalid ECDH bit length.');
        }
    }
    startKeyExchange() {
        const exchangeValue = this.ecdh.generateKeys();
        return Promise.resolve(exchangeValue);
    }
    decryptKeyExchange(exchangeValue) {
        const sharedSecretBytes = this.ecdh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
    }
    async sign(data) {
        const hash = crypto.createHash(this.hashAlgorithmName);
        hash.update(data);
        return buffer_1.Buffer.from(hash.digest());
    }
    dispose() { }
}
//# sourceMappingURL=nodeKeyExchange.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeRandom = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
class NodeRandom {
    getBytes(buffer) {
        const randomBytes = crypto.randomBytes(buffer.length);
        randomBytes.copy(buffer);
    }
}
exports.NodeRandom = NodeRandom;
//# sourceMappingURL=nodeRandom.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeRsa = void 0;
const crypto = __webpack_require__(/*! crypto */ "crypto");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const publicKeyAlgorithm_1 = __webpack_require__(/*! ../publicKeyAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js");
const sshData_1 = __webpack_require__(/*! ../../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const nodeHmac_1 = __webpack_require__(/*! ./nodeHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js");
const keyFormatters_1 = __webpack_require__(/*! ./keyFormatters */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/keyFormatters.js");
const nodeVersionParts = process.versions.node.split('.').map((v) => parseInt(v, 10));
const nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || (nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12);
const nodeKeyObjectSupport = nodeVersionParts[0] > 11 || (nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6);
// Note this is exposed as an inner-class property below: `NodeRsa.KeyPair`.
// TypeScript requires that the class definition comes first.
class NodeRsaKeyPair {
    /* @internal */
    constructor() {
        this.comment = null;
    }
    get hasPublicKey() {
        return !!this.publicKey;
    }
    get hasPrivateKey() {
        return !!this.privateKey;
    }
    get keyAlgorithmName() {
        return NodeRsa.keyAlgorithmName;
    }
    generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : NodeRsaKeyPair.defaultKeySize;
        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {
            return this.generateNodeKeyPairObjects(keySizeInBits);
        }
        else if (nodeGenerateKeyPairSupport) {
            return this.generateNodeKeyPairBuffers(keySizeInBits);
        }
        else {
            return this.generateExternalKeyPair(keySizeInBits);
        }
    }
    async generateNodeKeyPairObjects(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {
            const keyGenParams = {
                modulusLength: keySizeInBits,
            };
            try {
                crypto.generateKeyPair('rsa', keyGenParams, (err, publicKey, privateKey) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve([publicKey, privateKey]);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    async generateNodeKeyPairBuffers(keySizeInBits) {
        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {
            const keyGenParams = {
                modulusLength: keySizeInBits,
                publicKeyEncoding: { type: 'pkcs1', format: 'pem' },
                privateKeyEncoding: {
                    type: 'pkcs1',
                    format: 'pem',
                    cipher: undefined,
                    passphrase: undefined,
                },
            };
            try {
                crypto.generateKeyPair('rsa', keyGenParams, (err, publicKey, privateKey) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve([publicKey, privateKey]);
                    }
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    async generateExternalKeyPair(keySizeInBits) {
        // When running in a version of node that doesn't have a built-in API
        // for RSA key-gen, use an external library. Note this implementation
        // is SLOW because it's pure JS. It may take 1-5 seconds to generate
        // a 2048 bit key.
        const externRsa = await Promise.resolve().then(() => __webpack_require__(/*! node-rsa */ "../../node_modules/node-rsa/src/NodeRSA.js"));
        const keyPair = new externRsa({ b: keySizeInBits });
        this.publicKey = keyPair.exportKey('pkcs1-public-pem');
        this.privateKey = keyPair.exportKey('pkcs1-private-pem');
        // Ensure the PEM format ends in a newline, just for consistency.
        if (!this.publicKey.endsWith('\n'))
            this.publicKey += '\n';
        if (!this.privateKey.endsWith('\n'))
            this.privateKey += '\n';
    }
    async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
            throw new TypeError('Buffer is required.');
        }
        // Read public key in SSH format.
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString('ascii');
        if (algorithmName !== this.keyAlgorithmName &&
            algorithmName !== NodeRsa.rsaWithSha256 &&
            algorithmName !== NodeRsa.rsaWithSha512) {
            throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        // Write public key in PKCS#1 format.
        keyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic({ modulus, exponent });
        if (nodeKeyObjectSupport) {
            this.publicKey = crypto.createPublicKey({
                key: keyBytes,
                type: 'pkcs1',
                format: 'der',
            });
        }
        else {
            this.publicKey = (0, keyFormatters_1.formatPem)(keyBytes, 'RSA PUBLIC KEY');
        }
    }
    async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
            return null;
        }
        if (!algorithmName) {
            algorithmName = this.keyAlgorithmName;
        }
        let keyBytes;
        if (typeof this.publicKey === 'string') {
            keyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);
        }
        else {
            keyBytes = this.publicKey.export({
                type: 'pkcs1',
                format: 'der',
            });
        }
        const parameters = keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
        // Write public key in SSH format.
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, 'ascii');
        keyWriter.writeBigInt(parameters.exponent);
        keyWriter.writeBigInt(parameters.modulus);
        keyBytes = keyWriter.toBuffer();
        return keyBytes;
    }
    async importParameters(parameters) {
        if (nodeKeyObjectSupport) {
            this.publicKey = crypto.createPublicKey({
                key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters),
                format: 'der',
                type: 'pkcs1',
            });
            if (parameters.d) {
                this.privateKey = crypto.createPrivateKey({
                    key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters),
                    format: 'der',
                    type: 'pkcs1',
                });
            }
            else {
                this.privateKey = undefined;
            }
        }
        else {
            const publicKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters);
            this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, 'RSA PUBLIC KEY');
            if (parameters.d) {
                const privateKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters);
                this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, 'RSA PRIVATE KEY');
            }
        }
    }
    async exportParameters() {
        var _a, _b;
        if (!this.publicKey)
            throw new Error('Public key not set.');
        let keyBytes;
        if (nodeKeyObjectSupport) {
            keyBytes = ((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey).export({
                format: 'der',
                type: 'pkcs1',
            });
        }
        else {
            keyBytes = (0, keyFormatters_1.parsePem)((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey);
        }
        return this.privateKey
            ? keyFormatters_1.Pkcs1KeyFormatter.parseRsaPrivate(keyBytes)
            : keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);
    }
    dispose() {
        this.publicKey = undefined;
        this.privateKey = undefined;
    }
}
NodeRsaKeyPair.defaultKeySize = 2048;
class NodeRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
    constructor(name, hashAlgorithmName) {
        super(name, NodeRsa.keyAlgorithmName, hashAlgorithmName);
    }
    createKeyPair() {
        return new NodeRsaKeyPair();
    }
    async generateKeyPair(keySizeInBits) {
        const rsaKey = new NodeRsaKeyPair();
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
    }
    createSigner(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
            throw new TypeError('RSA key pair object expected.');
        }
        return new NodeRsaSignerVerifier(keyPair, NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
    }
    createVerifier(keyPair) {
        if (!(keyPair instanceof NodeRsaKeyPair)) {
            throw new TypeError('RSA key pair object expected.');
        }
        return new NodeRsaSignerVerifier(keyPair, NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));
    }
    static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace('SHA2-', 'SHA');
    }
}
exports.NodeRsa = NodeRsa;
NodeRsa.keyAlgorithmName = 'ssh-rsa';
NodeRsa.rsaWithSha256 = 'rsa-sha2-256';
NodeRsa.rsaWithSha512 = 'rsa-sha2-512';
NodeRsa.KeyPair = NodeRsaKeyPair;
class NodeRsaSignerVerifier {
    constructor(keyPair, hashAlgorithmName, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
    }
    async sign(data) {
        if (!this.keyPair.privateKey) {
            throw new Error('Private key not set.');
        }
        const signer = crypto.createSign(this.hashAlgorithmName);
        signer.update(data);
        const signature = signer.sign(this.keyPair.privateKey);
        return signature;
    }
    async verify(data, signature) {
        if (!this.keyPair.publicKey) {
            throw new Error('Public key not set.');
        }
        const verifier = crypto.createVerify(this.hashAlgorithmName);
        verifier.update(data);
        const result = verifier.verify(this.keyPair.publicKey, signature);
        return result;
    }
    dispose() { }
}
//# sourceMappingURL=nodeRsa.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublicKeyAlgorithm = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
class PublicKeyAlgorithm {
    constructor(name, keyAlgorithmName, hashAlgorithmName) {
        this.name = name;
        this.keyAlgorithmName = keyAlgorithmName;
        this.hashAlgorithmName = hashAlgorithmName;
    }
    readSignatureData(signatureData) {
        const reader = new sshData_1.SshDataReader(signatureData);
        const algorithmName = reader.readString('ascii');
        if (algorithmName !== this.name) {
            throw new Error('Mismatched public key algorithm: ' +
                `got '${algorithmName}', expected '${this.name}'.`);
        }
        const signature = reader.readBinary();
        return signature;
    }
    createSignatureData(signature) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.name.length + signature.length + 20));
        writer.writeString(this.name, 'ascii');
        writer.writeBinary(signature);
        return writer.toBuffer();
    }
}
exports.PublicKeyAlgorithm = PublicKeyAlgorithm;
//# sourceMappingURL=publicKeyAlgorithm.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.algorithmNames = exports.SshAlgorithms = exports.Encryption = exports.ECDsa = exports.Rsa = exports.HmacAlgorithm = exports.EncryptionAlgorithm = exports.PublicKeyAlgorithm = exports.KeyExchangeAlgorithm = void 0;
const keyExchangeAlgorithm_1 = __webpack_require__(/*! ./keyExchangeAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js");
Object.defineProperty(exports, "KeyExchangeAlgorithm", ({ enumerable: true, get: function () { return keyExchangeAlgorithm_1.KeyExchangeAlgorithm; } }));
const publicKeyAlgorithm_1 = __webpack_require__(/*! ./publicKeyAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js");
Object.defineProperty(exports, "PublicKeyAlgorithm", ({ enumerable: true, get: function () { return publicKeyAlgorithm_1.PublicKeyAlgorithm; } }));
const encryptionAlgorithm_1 = __webpack_require__(/*! ./encryptionAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js");
Object.defineProperty(exports, "EncryptionAlgorithm", ({ enumerable: true, get: function () { return encryptionAlgorithm_1.EncryptionAlgorithm; } }));
const hmacAlgorithm_1 = __webpack_require__(/*! ./hmacAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js");
Object.defineProperty(exports, "HmacAlgorithm", ({ enumerable: true, get: function () { return hmacAlgorithm_1.HmacAlgorithm; } }));
// Swap imports to node crypto implementations when web crypto is not available.
// The 'self' variable is defined in browser environments (including web workers)
// but not in Node.js (or Node.js web workers).
// https://developer.mozilla.org/en-US/docs/Web/API/Window/self
const useWebCrypto = typeof self === 'object' && !!(typeof crypto === 'object' && crypto.subtle);
const webKeyExchange_1 = __webpack_require__(/*! ./web/webKeyExchange */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js");
const webRsa_1 = __webpack_require__(/*! ./web/webRsa */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js");
const webECDsa_1 = __webpack_require__(/*! ./web/webECDsa */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js");
const webEncryption_1 = __webpack_require__(/*! ./web/webEncryption */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js");
const webHmac_1 = __webpack_require__(/*! ./web/webHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js");
const webRandom_1 = __webpack_require__(/*! ./web/webRandom */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js");
/* eslint-disable @typescript-eslint/naming-convention, id-match */
const DiffieHellman = useWebCrypto
    ? webKeyExchange_1.WebDiffieHellman
    : (__webpack_require__(/*! ./node/nodeKeyExchange */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js").NodeDiffieHellman);
const ECDiffieHellman = useWebCrypto
    ? webKeyExchange_1.WebECDiffieHellman
    : (__webpack_require__(/*! ./node/nodeKeyExchange */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeKeyExchange.js").NodeECDiffieHellman);
const Rsa = useWebCrypto ? webRsa_1.WebRsa : (__webpack_require__(/*! ./node/nodeRsa */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRsa.js").NodeRsa);
exports.Rsa = Rsa;
const ECDsa = useWebCrypto ? webECDsa_1.WebECDsa : (__webpack_require__(/*! ./node/nodeECDsa */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeECDsa.js").NodeECDsa);
exports.ECDsa = ECDsa;
const Encryption = useWebCrypto
    ? webEncryption_1.WebEncryption
    : (__webpack_require__(/*! ./node/nodeEncryption */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeEncryption.js").NodeEncryption);
exports.Encryption = Encryption;
const Hmac = useWebCrypto ? webHmac_1.WebHmac : (__webpack_require__(/*! ./node/nodeHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeHmac.js").NodeHmac);
// eslint-disable-next-line no-redeclare
const Random = useWebCrypto ? webRandom_1.WebRandom : (__webpack_require__(/*! ./node/nodeRandom */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/node/nodeRandom.js").NodeRandom);
class SshAlgorithms {
}
exports.SshAlgorithms = SshAlgorithms;
SshAlgorithms.keyExchange = {
    none: null,
    dhGroup14Sha256: new DiffieHellman('diffie-hellman-group14-sha256', 2048, 'SHA2-256'),
    dhGroup16Sha512: new DiffieHellman('diffie-hellman-group16-sha512', 4096, 'SHA2-512'),
    ecdhNistp256Sha256: new ECDiffieHellman('ecdh-sha2-nistp256', 256, 'SHA2-256'),
    ecdhNistp384Sha384: new ECDiffieHellman('ecdh-sha2-nistp384', 384, 'SHA2-384'),
    ecdhNistp521Sha512: new ECDiffieHellman('ecdh-sha2-nistp521', 521, 'SHA2-512'),
};
SshAlgorithms.publicKey = {
    none: null,
    rsaWithSha256: new Rsa('rsa-sha2-256', 'SHA2-256'),
    rsaWithSha512: new Rsa('rsa-sha2-512', 'SHA2-512'),
    ecdsaSha2Nistp256: new ECDsa('ecdsa-sha2-nistp256', 'SHA2-256'),
    ecdsaSha2Nistp384: new ECDsa('ecdsa-sha2-nistp384', 'SHA2-384'),
    ecdsaSha2Nistp521: new ECDsa('ecdsa-sha2-nistp521', 'SHA2-512'),
};
SshAlgorithms.encryption = {
    none: null,
    ////aes256Cbc: new Encryption('aes256-cbc', 'AES', 'CBC', 256) },
    aes256Ctr: new Encryption('aes256-ctr', 'AES', 'CTR', 256),
    aes256Gcm: new Encryption('aes256-gcm@openssh.com', 'AES', 'GCM', 256),
};
SshAlgorithms.hmac = {
    none: null,
    hmacSha256: new Hmac('hmac-sha2-256', 'SHA2-256'),
    hmacSha512: new Hmac('hmac-sha2-512', 'SHA2-512'),
    hmacSha256Etm: new Hmac('hmac-sha2-256-etm@openssh.com', 'SHA2-256', true),
    hmacSha512Etm: new Hmac('hmac-sha2-512-etm@openssh.com', 'SHA2-512', true),
};
SshAlgorithms.compression = {
    none: null,
};
SshAlgorithms.random = new Random();
function algorithmNames(list) {
    return list.map((a) => (a ? a.name : 'none'));
}
exports.algorithmNames = algorithmNames;
//# sourceMappingURL=sshAlgorithms.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonWebKeyFormatter = void 0;
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const ecdsaCurves_1 = __webpack_require__(/*! ../ecdsaCurves */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js");
/**
 * Provides *minimal* JWK import/export support for web keys.
 *
 * This code is redundant with some of the JWK import/export code in the separate
 * `ssh-keys` library; that is intentional, and necessary to support a consistent
 * interface for importing/exporting key parameters in the core `ssh` library.
 */
class JsonWebKeyFormatter {
    static formatRsa(rsa, includePrivate) {
        const formatBigInt = JsonWebKeyFormatter.formatBigInt;
        let jwk;
        if (includePrivate !== false && rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi) {
            jwk = {
                kty: 'RSA',
                n: formatBigInt(rsa.modulus),
                e: formatBigInt(rsa.exponent),
                d: formatBigInt(rsa.d),
                p: formatBigInt(rsa.p),
                q: formatBigInt(rsa.q),
                dp: formatBigInt(rsa.dp),
                dq: formatBigInt(rsa.dq),
                qi: formatBigInt(rsa.qi),
            };
        }
        else if (!includePrivate) {
            jwk = {
                kty: 'RSA',
                n: formatBigInt(rsa.modulus),
                e: formatBigInt(rsa.exponent),
            };
        }
        else {
            throw new Error('Missing private key parameters.');
        }
        return jwk;
    }
    static parseRsa(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== 'RSA' || !(jwk.n && jwk.e))
            throw new Error('Invalid RSA JWK.');
        const parseBigInt = JsonWebKeyFormatter.parseBigInt;
        let rsa;
        if (includePrivate !== false && jwk.d && jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi) {
            rsa = {
                modulus: parseBigInt(jwk.n),
                exponent: parseBigInt(jwk.e),
                d: parseBigInt(jwk.d),
                p: parseBigInt(jwk.p),
                q: parseBigInt(jwk.q),
                dp: parseBigInt(jwk.dp),
                dq: parseBigInt(jwk.dq),
                qi: parseBigInt(jwk.qi),
            };
        }
        else {
            rsa = {
                modulus: parseBigInt(jwk.n),
                exponent: parseBigInt(jwk.e),
            };
        }
        return rsa;
    }
    static formatEC(ec, includePrivate) {
        const formatBigInt = JsonWebKeyFormatter.formatBigInt;
        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid || c.name === ec.curve.name || c.shortName === ec.curve.name);
        const keySizeInBytes = Math.ceil(curve.keySize / 8);
        const jwk = {
            kty: 'EC',
            crv: ec.curve.name,
            x: formatBigInt(ec.x, keySizeInBytes),
            y: formatBigInt(ec.y, keySizeInBytes),
        };
        if (includePrivate !== false && ec.d) {
            jwk.d = formatBigInt(ec.d, keySizeInBytes);
        }
        else if (includePrivate) {
            throw new Error('Missing private key parameters.');
        }
        return jwk;
    }
    static parseEC(jwk, includePrivate) {
        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== 'EC' || !(jwk.crv && jwk.x && jwk.y))
            throw new Error('Invalid EC JWK.');
        const parseBigInt = JsonWebKeyFormatter.parseBigInt;
        const ec = {
            curve: { name: jwk.crv },
            x: parseBigInt(jwk.x),
            y: parseBigInt(jwk.y),
        };
        if (includePrivate !== false && jwk.d) {
            ec.d = parseBigInt(jwk.d);
        }
        return ec;
    }
    static formatBigInt(value, length) {
        return JsonWebKeyFormatter.base64UrlEncode(value.toBytes({ unsigned: true, length }));
    }
    static parseBigInt(value) {
        return bigInt_1.BigInt.fromBytes(Buffer.from(value, 'base64'), { unsigned: true });
    }
    static base64UrlEncode(data) {
        // JWK format uses base64-url-encoding, which is base64 but with 2 substituted characters.
        // (Note Buffer's base64 DECODING implicitly supports this format.)
        return data
            .toString('base64')
            .replace(/=+$/g, '')
            .replace(/\+/g, '-')
            .replace(/\//g, '_');
    }
}
exports.JsonWebKeyFormatter = JsonWebKeyFormatter;
//# sourceMappingURL=jsonWebKeyFormatter.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webECDsa.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebECDsa = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const publicKeyAlgorithm_1 = __webpack_require__(/*! ../publicKeyAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js");
const sshData_1 = __webpack_require__(/*! ../../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const ecdsaCurves_1 = __webpack_require__(/*! ../ecdsaCurves */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/ecdsaCurves.js");
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const jsonWebKeyFormatter_1 = __webpack_require__(/*! ./jsonWebKeyFormatter */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js");
class WebECDsaKeyPair {
    /**
     * Constructs a new ECDSA key pair object.
     *
     * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be
     * initialized before use via `importParameters()`.
     */
    constructor(algorithmName) {
        this.comment = null;
        if (algorithmName) {
            this.algorithmName = algorithmName;
        }
    }
    get hasPublicKey() {
        return !!this.publicKey;
    }
    get hasPrivateKey() {
        return !!this.privateKey;
    }
    get keyAlgorithmName() {
        return this.algorithmName;
    }
    get algorithmName() {
        return this.algorithm;
    }
    set algorithmName(value) {
        const curveName = value.split('-')[2];
        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);
        if (!this.curve) {
            throw new Error('Invalid or unsupported ECDSA algorithm: ' + value);
        }
        this.algorithm = value;
    }
    async generate() {
        try {
            const keyGenParams = {
                name: 'ECDSA',
                namedCurve: this.curve.shortName,
            };
            const keyPair = (await crypto.subtle.generateKey(keyGenParams, true, ['sign', 'verify']));
            this.publicKey = keyPair.publicKey;
            this.privateKey = keyPair.privateKey;
        }
        catch (e) {
            throw new Error('Failed to generate RSA key pair: ' + e);
        }
    }
    async setPublicKeyBytes(keyBytes, algorithmName) {
        if (!keyBytes) {
            throw new TypeError('Buffer is required.');
        }
        // Read public key in SSH format.
        const reader = new sshData_1.SshDataReader(keyBytes);
        const readAlgorithmName = reader.readString('ascii');
        this.algorithmName = algorithmName || readAlgorithmName;
        const curveName = reader.readString('ascii');
        if (curveName !== this.curve.name) {
            throw new Error('EC curve name does not match.');
        }
        // X and Y parameters are equal length, after a one-byte header.
        const key = reader.readBinary();
        const n = Math.ceil(this.curve.keySize / 8);
        const x = bigInt_1.BigInt.fromBytes(key.slice(1, 1 + n), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(key.slice(1 + n, key.length), { unsigned: true });
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
            curve: { name: this.curve.shortName, oid: this.curve.oid },
            x,
            y,
        });
        try {
            const importParams = {
                name: 'ECDSA',
                namedCurve: this.curve.shortName,
            };
            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);
        }
        catch (e) {
            throw new Error('Failed to import EC public key: ' + e);
        }
    }
    async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
            return null;
        }
        // Export public key in JWK format.
        let jwk;
        try {
            jwk = await crypto.subtle.exportKey('jwk', this.publicKey);
        }
        catch (e) {
            throw new Error('Failed to export ECDSA public key: ' + e);
        }
        const x = buffer_1.Buffer.from(jwk.x, 'base64');
        const y = buffer_1.Buffer.from(jwk.y, 'base64');
        const n = Math.ceil(this.curve.keySize / 8);
        if (x.length !== n || y.length !== n) {
            throw new Error('Unexpected key length.');
        }
        // Write public key in SSH format.
        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;
        const keyBuffer = buffer_1.Buffer.alloc(algorithmName.length + x.length + y.length + 10);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, 'ascii');
        keyWriter.writeString(this.curve.name, 'ascii');
        keyWriter.writeUInt32(1 + x.length + y.length);
        keyWriter.writeByte(4); // Indicates uncompressed curve format
        keyWriter.write(x);
        keyWriter.write(y);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
    }
    async importParameters(parameters) {
        if (!parameters.curve)
            throw new TypeError('A curve is required.');
        let curve;
        if (parameters.curve.oid) {
            curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);
            if (!curve) {
                throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);
            }
        }
        else if (parameters.curve.name) {
            curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);
            if (!curve) {
                throw new Error(`Unsupported curve: ${parameters.curve.name}`);
            }
        }
        else {
            throw new TypeError('A curve OID or name is required.');
        }
        this.algorithmName = 'ecdsa-sha2-' + curve.name;
        const importParams = {
            name: 'ECDSA',
            namedCurve: this.curve.shortName,
        };
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC(parameters);
        jwk.crv = this.curve.shortName;
        try {
            if (jwk.d) {
                this.privateKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, [
                    'sign',
                ]);
                jwk.d = undefined;
            }
            else {
                this.privateKey = undefined;
            }
            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);
        }
        catch (e) {
            throw new Error('Failed to import ECDSA key pair: ' + e);
        }
    }
    async exportParameters() {
        var _a;
        const exportKey = (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey;
        if (!exportKey) {
            throw new Error('Key not present.');
        }
        let jwk;
        try {
            jwk = await crypto.subtle.exportKey('jwk', exportKey);
        }
        catch (e) {
            throw new Error('Failed to export ECDSA key pair: ' + e);
        }
        const parameters = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        parameters.curve = { name: this.curve.name, oid: this.curve.oid };
        return parameters;
    }
    dispose() { }
}
class WebECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
    constructor(name, hashAlgorithmName) {
        super(name, name, hashAlgorithmName);
    }
    createKeyPair() {
        return new WebECDsaKeyPair(this.name);
    }
    async generateKeyPair() {
        const ecdsaKey = new WebECDsaKeyPair(this.name);
        await ecdsaKey.generate();
        return ecdsaKey;
    }
    createSigner(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
            throw new TypeError('ECDSA key pair object expected.');
        }
        const hashAlgorithm = WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
    }
    createVerifier(keyPair) {
        if (!(keyPair instanceof WebECDsaKeyPair)) {
            throw new TypeError('ECDSA key pair object expected.');
        }
        const hashAlgorithm = WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);
    }
    static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace('SHA2-', 'SHA-');
    }
    /* @internal */
    static getSignatureLength(keySizeInBits) {
        // The signature is double the key size, but formatted as 2 bigints.
        // To each bigint add 4 for the length and 1 for a leading zero.
        const keySizeInBytes = Math.ceil(keySizeInBits / 8);
        return (4 + 1 + keySizeInBytes) * 2;
    }
}
exports.WebECDsa = WebECDsa;
WebECDsa.ecdsaSha2Nistp256 = 'ecdsa-sha2-nistp256';
WebECDsa.ecdsaSha2Nistp384 = 'ecdsa-sha2-nistp384';
WebECDsa.ecdsaSha2Nistp521 = 'ecdsa-sha2-nistp521';
WebECDsa.curves = ecdsaCurves_1.curves;
WebECDsa.KeyPair = WebECDsaKeyPair;
class WebECDsaSignerVerifier {
    constructor(keyPair, hashAlgorithm) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
    }
    get digestLength() {
        const curve = this.keyPair.curve;
        if (!curve) {
            return 0;
        }
        else {
            return WebECDsa.getSignatureLength(curve.keySize);
        }
    }
    async sign(data) {
        if (!this.keyPair.privateKey) {
            throw new Error('Private key not set.');
        }
        let signature = buffer_1.Buffer.from(await crypto.subtle.sign({ name: 'ECDSA', hash: { name: this.hashAlgorithm } }, this.keyPair.privateKey, data));
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        if (signature.length !== 2 * keySizeInBytes) {
            throw new Error(`Unexpected signature length: ${signature.length}`);
        }
        // Reformat the signature integer bytes as required by SSH.
        const x = bigInt_1.BigInt.fromBytes(signature.slice(0, keySizeInBytes), { unsigned: true });
        const y = bigInt_1.BigInt.fromBytes(signature.slice(keySizeInBytes, signature.length), {
            unsigned: true,
        });
        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));
        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));
        signature = signatureWriter.toBuffer();
        return signature;
    }
    async verify(data, signature) {
        if (!this.keyPair.publicKey) {
            throw new Error('Public key not set.');
        }
        // Reformat the signature integer bytes as required by the web crypto API.
        const signatureReader = new sshData_1.SshDataReader(signature);
        const x = signatureReader.readBigInt();
        const y = signatureReader.readBigInt();
        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);
        signature = buffer_1.Buffer.alloc(2 * keySizeInBytes);
        x.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, 0);
        y.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, keySizeInBytes);
        const result = await crypto.subtle.verify({ name: 'ECDSA', hash: { name: this.hashAlgorithm } }, this.keyPair.publicKey, signature, data);
        return result;
    }
    dispose() { }
}
//# sourceMappingURL=webECDsa.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webEncryption.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebEncryption = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const encryptionAlgorithm_1 = __webpack_require__(/*! ../encryptionAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/encryptionAlgorithm.js");
class WebEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {
    constructor(name, algorithmName, cipherMode, keySizeInBits) {
        super(name);
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = WebEncryption.getBlockSize(algorithmName);
    }
    get keyLength() {
        return this.keySizeInBits / 8;
    }
    get blockLength() {
        return this.blockSizeInBits / 8;
    }
    async createCipher(isEncryption, key, iv) {
        const cipher = new WebCipher(isEncryption, this.algorithmName, this.cipherMode, this.keySizeInBits, this.blockSizeInBits);
        await cipher.init(key, iv);
        return cipher;
    }
    static getBlockSize(algorithmName) {
        if (algorithmName === 'AES') {
            return 128;
        }
        else {
            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);
        }
    }
}
exports.WebEncryption = WebEncryption;
class WebCipher {
    get blockLength() {
        return this.blockSizeInBits / 8;
    }
    constructor(isEncryption, algorithmName, cipherMode, keySizeInBits, blockSizeInBits) {
        this.isEncryption = isEncryption;
        this.algorithmName = algorithmName;
        this.cipherMode = cipherMode;
        this.keySizeInBits = keySizeInBits;
        this.blockSizeInBits = blockSizeInBits;
        this.tag = null;
        if (this.algorithmName === 'AES' && this.cipherMode === 'CTR') {
            this.transform = this.aesCtr.bind(this, isEncryption);
        }
        else if (this.algorithmName === 'AES' && this.cipherMode === 'CBC') {
            this.transform = this.aesCbc.bind(this, isEncryption);
        }
        else if (this.algorithmName === 'AES' && this.cipherMode === 'GCM') {
            this.transform = this.aesGcm.bind(this, isEncryption);
            this.associatedData = buffer_1.Buffer.alloc(4);
            this.decryptBuffer = buffer_1.Buffer.alloc(this.blockLength * 4);
        }
        else {
            throw new Error(`Unsupported encryption algorithm: ${this.algorithmName}-${this.cipherMode}`);
        }
    }
    async init(key, iv) {
        try {
            const name = `${this.algorithmName}-${this.cipherMode}`;
            this.key = await crypto.subtle.importKey('raw', key, { name, length: this.keySizeInBits }, false, this.isEncryption ? ['encrypt'] : ['decrypt']);
        }
        catch (e) {
            throw new Error('Failed to initialize AES: ' + e);
        }
        if (this.cipherMode === 'GCM') {
            this.iv = buffer_1.Buffer.from(iv.slice(0, 12));
        }
        else {
            this.iv = buffer_1.Buffer.from(iv);
        }
    }
    async aesCtr(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
            const message = 'Encrypt/decrypt input has invalid length ' +
                `${data.length}, not a multiple of block size ${this.blockLength}.`;
            throw new Error(message);
        }
        let result;
        if (isEncryption) {
            result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: 'AES-CTR', counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        }
        else {
            result = buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: 'AES-CTR', counter: this.iv, length: this.blockSizeInBits }, this.key, data));
        }
        if (result.length !== data.length) {
            const message = 'Result from encrypt/decrypt has invalid length ' +
                `${result.length}, expected ${data.length}.`;
            throw new Error(message);
        }
        // A single call to encrypt() or decrypt() internally increments the counter.
        // This code ensures those increments get preserved across multiple calls.
        const incrementCount = data.length / this.blockLength;
        for (let i = 0; i < incrementCount; i++) {
            // Increment the counter that is combined with the IV as a big-endian integer.
            // First increment the last byte, and if it reaches 0 then increment the
            // next-to-last byte, and so on.
            for (let k = this.iv.length - 1; k >= 0; k--) {
                this.iv[k] = this.iv[k] + 1;
                if (this.iv[k])
                    break;
            }
        }
        return result;
    }
    async aesCbc(isEncryption, data) {
        // TODO: Fix padding. Web crypto's AES-CBC uses padding by default,
        // which isn't compatible with SSH.
        if (isEncryption) {
            let result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this.iv }, this.key, data));
            result = result.slice(0, data.length);
            return result;
        }
        else {
            return buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv }, this.key, data));
        }
    }
    async aesGcm(isEncryption, data) {
        if (data.length % this.blockLength !== 0) {
            const message = 'Encrypt/decrypt input has invalid length ' +
                `${data.length}, not a multiple of block size ${this.blockLength}.`;
            throw new Error(message);
        }
        // Associated data is the 32-bit packet length.
        const packetLength = data.length;
        this.associatedData[0] = packetLength >>> 24;
        this.associatedData[1] = packetLength >>> 16;
        this.associatedData[2] = packetLength >>> 8;
        this.associatedData[3] = packetLength;
        let result;
        if (isEncryption) {
            result = buffer_1.Buffer.from(await crypto.subtle.encrypt({
                name: 'AES-GCM',
                iv: this.iv,
                additionalData: this.associatedData,
                tagLength: this.digestLength * 8, // tagLength is in bits, not bytes
            }, this.key, data));
            this.tag = result.slice(result.length - this.digestLength);
            result = result.slice(0, result.length - this.digestLength);
        }
        else {
            if (!this.tag) {
                throw new Error('AES-GCM tag was not set before decrypting.');
            }
            // The AES-GCM decrypt API expects the ciphertext and tag to be in a contiguous buffer.
            // Re-use a temporary buffer for that purpose, expanding it as needed.
            const inputLength = data.length + this.digestLength;
            if (this.decryptBuffer.length < inputLength) {
                let newLength = this.decryptBuffer.length * 2;
                while (newLength < inputLength)
                    newLength *= 2;
                this.decryptBuffer = buffer_1.Buffer.alloc(newLength);
            }
            const input = this.decryptBuffer.slice(0, inputLength);
            data.copy(input, 0);
            this.tag.copy(input, data.length);
            result = buffer_1.Buffer.from(await crypto.subtle.decrypt({
                name: 'AES-GCM',
                iv: this.iv,
                additionalData: this.associatedData,
                tagLength: this.digestLength * 8, // tagLength is in bits, not bytes
            }, this.key, input));
        }
        if (result.length !== data.length) {
            const message = 'Result from encrypt/decrypt has invalid length ' +
                `${result.length}, expected ${data.length}.`;
            throw new Error(message);
        }
        // Increment the counter (last 8 bytes of the iv/nonce) as a big-endian integer.
        // First increment the last byte, and if it reaches 0 then increment the
        // next-to-last byte, and so on.
        let k = 12;
        while (--k >= 4) {
            this.iv[k]++;
            if (this.iv[k] !== 0) {
                break;
            }
        }
        return result;
    }
    get digestLength() {
        return 16;
    }
    get authenticatedEncryption() {
        return this.cipherMode === 'GCM';
    }
    async sign(data) {
        if (!this.tag) {
            throw new Error('AES-GCM tag was not obtained by encrypting.');
        }
        return this.tag;
    }
    async verify(data, signature) {
        if (signature.length !== this.digestLength) {
            throw new Error('Incorrect AES-GCM tag length.');
        }
        this.tag = signature;
        return true;
    }
    dispose() { }
}
//# sourceMappingURL=webEncryption.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebHmac = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const hmacAlgorithm_1 = __webpack_require__(/*! ../hmacAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/hmacAlgorithm.js");
class WebHmac extends hmacAlgorithm_1.HmacAlgorithm {
    constructor(name, algorithmName, encryptThenMac = false) {
        super(name, algorithmName, WebHmac.getHashKeyLength(algorithmName), WebHmac.getHashDigestLength(algorithmName));
        this.encryptThenMac = encryptThenMac;
    }
    async createSigner(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, true, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
    }
    async createVerifier(key) {
        const hmac = new WebSignerVerifier(this.algorithmName, false, this.digestLength, this.encryptThenMac);
        await hmac.init(key);
        return hmac;
    }
    static getHashKeyLength(hashAlgorithmName) {
        if (hashAlgorithmName === 'SHA2-512')
            return 512 / 8;
        if (hashAlgorithmName === 'SHA2-384')
            return 384 / 8;
        if (hashAlgorithmName === 'SHA2-256')
            return 256 / 8;
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
    }
    static getHashDigestLength(hashAlgorithmName) {
        return this.getHashKeyLength(hashAlgorithmName);
    }
    static getWebHashAlgorithmName(hashAlgorithmName) {
        if (hashAlgorithmName === 'SHA2-512')
            return 'SHA-512';
        if (hashAlgorithmName === 'SHA2-384')
            return 'SHA-384';
        if (hashAlgorithmName === 'SHA2-256')
            return 'SHA-256';
        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);
    }
}
exports.WebHmac = WebHmac;
class WebSignerVerifier {
    constructor(algorithmName, isSigning, digestLength, encryptThenMac) {
        this.algorithmName = algorithmName;
        this.isSigning = isSigning;
        this.digestLength = digestLength;
        this.encryptThenMac = encryptThenMac;
    }
    async init(key) {
        try {
            const name = this.algorithmName.replace('SHA2-', 'SHA-');
            this.key = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: { name } }, false, this.isSigning ? ['sign'] : ['verify']);
        }
        catch (e) {
            throw new Error('Failed to initialize HMAC: ' + e);
        }
    }
    async sign(data) {
        return buffer_1.Buffer.from(await crypto.subtle.sign({ name: 'HMAC', hash: { name: this.algorithmName } }, this.key, data));
    }
    async verify(data, signature) {
        return await crypto.subtle.verify({ name: 'HMAC', hash: { name: this.algorithmName } }, this.key, signature, data);
    }
    dispose() { }
}
//# sourceMappingURL=webHmac.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webKeyExchange.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebECDiffieHellman = exports.WebDiffieHellman = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const diffie_hellman_1 = __webpack_require__(/*! diffie-hellman */ "../../node_modules/diffie-hellman/index.js");
const keyExchangeAlgorithm_1 = __webpack_require__(/*! ../keyExchangeAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/keyExchangeAlgorithm.js");
const webHmac_1 = __webpack_require__(/*! ./webHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js");
const bigInt_1 = __webpack_require__(/*! ../../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const jsonWebKeyFormatter_1 = __webpack_require__(/*! ./jsonWebKeyFormatter */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js");
class WebDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
    constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
    }
    createKeyExchange() {
        return new WebDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
    }
}
exports.WebDiffieHellman = WebDiffieHellman;
class WebDiffieHellmanKex {
    constructor(bitLength, hashAlgorithmName, digestLength) {
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        switch (bitLength) {
            case 1024:
                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp2');
                break;
            case 2048:
                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp14');
                break;
            case 4096:
                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp16');
                break;
            default:
                throw new Error('Invalid DH bit length.');
        }
    }
    startKeyExchange() {
        const exchangeValueKeys = this.dh.generateKeys();
        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();
        return Promise.resolve(exchangeValue);
    }
    decryptKeyExchange(exchangeValue) {
        const key = this.dh.computeSecret(exchangeValue);
        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();
        return Promise.resolve(sharedSecret);
    }
    async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
    }
    dispose() { }
}
class WebECDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {
    constructor(name, keySizeInBits, hashAlgorithmName) {
        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));
    }
    createKeyExchange() {
        return new WebECDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);
    }
}
exports.WebECDiffieHellman = WebECDiffieHellman;
class WebECDiffieHellmanKex {
    constructor(bitLength, hashAlgorithmName, digestLength) {
        this.bitLength = bitLength;
        this.hashAlgorithmName = hashAlgorithmName;
        this.digestLength = digestLength;
        this.algorithm = {
            name: 'ECDH',
            namedCurve: 'P-' + bitLength,
        };
    }
    async startKeyExchange() {
        if (!this.keyPair) {
            this.keyPair = await crypto.subtle.generateKey(this.algorithm, true, // exportable
            ['deriveBits']);
        }
        const jwk = await crypto.subtle.exportKey('jwk', this.keyPair.publicKey);
        const ec = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);
        const length = Math.ceil(this.bitLength / 8);
        const publicKeyBytes = buffer_1.Buffer.alloc(1 + length * 2);
        publicKeyBytes[0] = 4;
        ec.x.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1);
        ec.y.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1 + length);
        return buffer_1.Buffer.from(publicKeyBytes);
    }
    async decryptKeyExchange(exchangeValue) {
        if (!this.keyPair) {
            throw new Error('Key exchange not started.');
        }
        const xy = exchangeValue;
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({
            curve: { name: this.algorithm.namedCurve },
            x: bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true }),
            y: bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true }),
        });
        const otherPublicKey = await crypto.subtle.importKey('jwk', jwk, this.algorithm, false, []);
        const sharedSecretBytes = buffer_1.Buffer.from(await crypto.subtle.deriveBits(Object.assign(Object.assign({}, this.algorithm), { public: otherPublicKey }), this.keyPair.privateKey, Math.ceil(this.bitLength / 8) * 8));
        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();
        return sharedSecret;
    }
    async sign(data) {
        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);
        return buffer_1.Buffer.from(hashBuffer);
    }
    dispose() { }
}
//# sourceMappingURL=webKeyExchange.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRandom.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebRandom = void 0;
class WebRandom {
    getBytes(buffer) {
        crypto.getRandomValues(buffer);
    }
}
exports.WebRandom = WebRandom;
//# sourceMappingURL=webRandom.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webRsa.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebRsa = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const publicKeyAlgorithm_1 = __webpack_require__(/*! ../publicKeyAlgorithm */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/publicKeyAlgorithm.js");
const webHmac_1 = __webpack_require__(/*! ./webHmac */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/webHmac.js");
const sshData_1 = __webpack_require__(/*! ../../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const jsonWebKeyFormatter_1 = __webpack_require__(/*! ./jsonWebKeyFormatter */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/web/jsonWebKeyFormatter.js");
// Note this is exposed as an inner-class property below: `WebRsa.KeyPair`.
// TypeScript requires that the class definition comes first.
class WebRsaKeyPair {
    /* @internal */
    constructor(hashAlgorithm) {
        this.hashAlgorithm = hashAlgorithm;
        this.comment = null;
    }
    get hasPublicKey() {
        return !!this.publicKey;
    }
    get hasPrivateKey() {
        return !!this.privateKey;
    }
    get keyAlgorithmName() {
        return WebRsa.keyAlgorithmName;
    }
    async generate(keySizeInBits) {
        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : WebRsaKeyPair.defaultKeySize;
        try {
            const keyGenParams = {
                name: 'RSASSA-PKCS1-v1_5',
                modulusLength: keySizeInBits,
                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                hash: { name: this.hashAlgorithm },
            };
            const keyPair = (await crypto.subtle.generateKey(keyGenParams, true, ['sign', 'verify']));
            this.publicKey = keyPair.publicKey;
            this.privateKey = keyPair.privateKey;
        }
        catch (e) {
            throw new Error('Failed to generate RSA key pair: ' + e);
        }
    }
    async setPublicKeyBytes(keyBytes) {
        if (!keyBytes) {
            throw new TypeError('Buffer is required.');
        }
        // Read public key in SSH format.
        const reader = new sshData_1.SshDataReader(keyBytes);
        const algorithmName = reader.readString('ascii');
        if (algorithmName !== this.keyAlgorithmName &&
            algorithmName !== WebRsa.rsaWithSha256 &&
            algorithmName !== WebRsa.rsaWithSha512) {
            throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);
        }
        const exponent = reader.readBigInt();
        const modulus = reader.readBigInt();
        // Import public key in JWK format.
        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa({ modulus, exponent }, false);
        jwk.alg = 'RS' + this.hashAlgorithm.replace('SHA-', '');
        jwk.key_ops = ['verify'];
        try {
            const importParams = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: { name: this.hashAlgorithm },
            };
            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);
        }
        catch (e) {
            throw new Error('Failed to import RSA public key: ' + e);
        }
    }
    async getPublicKeyBytes(algorithmName) {
        if (!this.publicKey) {
            return null;
        }
        if (!algorithmName) {
            algorithmName = this.keyAlgorithmName;
        }
        // Export public key in JWK format.
        let jwk;
        try {
            jwk = await crypto.subtle.exportKey('jwk', this.publicKey);
        }
        catch (e) {
            throw new Error('Failed to export RSA public key: ' + e);
        }
        const { modulus, exponent } = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, false);
        // Write public key in SSH format.
        const keyBuffer = buffer_1.Buffer.alloc(512);
        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);
        keyWriter.writeString(algorithmName, 'ascii');
        keyWriter.writeBigInt(exponent);
        keyWriter.writeBigInt(modulus);
        const keyBytes = keyWriter.toBuffer();
        return keyBytes;
    }
    async importParameters(parameters) {
        const privateJwk = parameters.d ? jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, true) : null;
        const publicJwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, false);
        const importParams = {
            name: 'RSASSA-PKCS1-v1_5',
            hash: { name: this.hashAlgorithm },
        };
        try {
            this.publicKey = await crypto.subtle.importKey('jwk', publicJwk, importParams, true, [
                'verify',
            ]);
            if (privateJwk) {
                this.privateKey = await crypto.subtle.importKey('jwk', privateJwk, importParams, true, [
                    'sign',
                ]);
            }
            else {
                this.privateKey = undefined;
            }
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            throw new Error('Failed to import RSA key pair: ' + e.message);
        }
    }
    async exportParameters() {
        var _a;
        if (!this.publicKey)
            throw new Error('Public key not set.');
        let jwk;
        try {
            jwk = await crypto.subtle.exportKey('jwk', (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            throw new Error('Failed to export RSA public key: ' + e.message);
        }
        return jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, !!this.privateKey);
    }
    dispose() { }
}
WebRsaKeyPair.defaultKeySize = 2048;
class WebRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {
    constructor(name, hashAlgorithmName) {
        super(name, WebRsa.keyAlgorithmName, hashAlgorithmName);
    }
    createKeyPair() {
        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaKeyPair(hashAlgorithm);
    }
    async generateKeyPair(keySizeInBits) {
        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        const rsaKey = new WebRsaKeyPair(hashAlgorithm);
        await rsaKey.generate(keySizeInBits);
        return rsaKey;
    }
    createSigner(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
            throw new TypeError('RSA key pair object expected.');
        }
        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
    }
    createVerifier(keyPair) {
        if (!(keyPair instanceof WebRsaKeyPair)) {
            throw new TypeError('RSA key pair object expected.');
        }
        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);
        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));
    }
    static convertHashAlgorithmName(hashAlgorithmName) {
        return hashAlgorithmName.replace('SHA2-', 'SHA-');
    }
}
exports.WebRsa = WebRsa;
WebRsa.keyAlgorithmName = 'ssh-rsa';
WebRsa.rsaWithSha256 = 'rsa-sha2-256';
WebRsa.rsaWithSha512 = 'rsa-sha2-512';
WebRsa.KeyPair = WebRsaKeyPair;
class WebRsaSignerVerifier {
    constructor(keyPair, hashAlgorithm, digestLength) {
        this.keyPair = keyPair;
        this.hashAlgorithm = hashAlgorithm;
        this.digestLength = digestLength;
    }
    async sign(data) {
        if (!this.keyPair.privateKey) {
            throw new Error('Private key not set.');
        }
        await this.convertKeyHashAlgorithm();
        const signature = buffer_1.Buffer.from(await crypto.subtle.sign('RSASSA-PKCS1-v1_5', this.keyPair.privateKey, data));
        return signature;
    }
    async verify(data, signature) {
        if (!this.keyPair.publicKey) {
            throw new Error('Public key not set.');
        }
        await this.convertKeyHashAlgorithm();
        const result = await crypto.subtle.verify('RSASSA-PKCS1-v1_5', this.keyPair.publicKey, signature, data);
        return result;
    }
    async convertKeyHashAlgorithm() {
        if (this.keyPair.hashAlgorithm !== this.hashAlgorithm) {
            const parameters = await this.keyPair.exportParameters();
            this.keyPair = new WebRsaKeyPair(this.hashAlgorithm);
            await this.keyPair.importParameters(parameters);
        }
    }
    dispose() { }
}
//# sourceMappingURL=webRsa.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/errors.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectDisposedError = exports.SshChannelError = exports.SshReconnectError = exports.SshConnectionError = void 0;
class SshConnectionError extends Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
    }
}
exports.SshConnectionError = SshConnectionError;
class SshReconnectError extends Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
    }
}
exports.SshReconnectError = SshReconnectError;
class SshChannelError extends Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
    }
}
exports.SshChannelError = SshChannelError;
class ObjectDisposedError extends Error {
    // eslint-disable-next-line @typescript-eslint/ban-types
    constructor(objectOrMessage) {
        var _a, _b;
        let message;
        if (typeof objectOrMessage === 'string') {
            // Custom message.
            message = objectOrMessage;
        }
        else if (typeof objectOrMessage === 'function') {
            // Constructor function (class name).
            // eslint-disable-next-line @typescript-eslint/ban-types
            message = objectOrMessage.name + ' disposed.';
        }
        else {
            // Disposable object - get its class name.
            message = ((_b = (_a = objectOrMessage === null || objectOrMessage === void 0 ? void 0 : objectOrMessage.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'Object ') + ' disposed.';
        }
        super(message);
    }
}
exports.ObjectDisposedError = ObjectDisposedError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshAuthenticatingEventArgs = exports.SshAuthenticationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
/**
 * Indicates the type of authentication being requested by an SSH client or server when an
 * `SshSession.authenticating` event is raised.
 */
var SshAuthenticationType;
(function (SshAuthenticationType) {
    /**
     * The client is attempting to authenticate without any credentials, or with only a
     * username, or is merely checking what authentication methods are supported by the server.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "none" method. With this method, all of the credential properties in the
     * `SshAuthenticatingEventArgs` are null.
     *
     * If the server app wishes to allow the client to authenticate with only a username, it may
     * return a principal for the user. Othwerwise, the "none" authentication method fails, and
     * the client may make a follow-up attempt to authenticate _with_ credentials.
     */
    SshAuthenticationType[SshAuthenticationType["clientNone"] = 0] = "clientNone";
    /**
     * The client is attempting to authenticate with a client host public key.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "hostbased" method. The authentication handler must verify that the public key
     * actually belongs to the client host name, _and_ that the network address the client
     * connected from matches that host name, before returning a user principal to indicate
     * successful authentication.
     */
    SshAuthenticationType[SshAuthenticationType["clientHostBased"] = 1] = "clientHostBased";
    /**
     * The client is attempting to authenticate with a username and password credential.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "password" method. The authentication handler must verify that the username
     * and password match known credentials on the server, before returning a user principal
     * to indicate successful authentication.
     */
    SshAuthenticationType[SshAuthenticationType["clientPassword"] = 2] = "clientPassword";
    /**
     * The client is querying whether authentication may be possible for a specified username and
     * public key without yet proving they have the private key.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "publickey" method _without_ providing a signature. The authentication handler
     * must verify that the username and public key match known credentials on the server. If
     * they match, an _unauthenticated_ principal should be returned. That indicates to the
     * client that they may proceed to actually authenticate using that username and public key.
     */
    SshAuthenticationType[SshAuthenticationType["clientPublicKeyQuery"] = 3] = "clientPublicKeyQuery";
    /**
     * The client is attempting to authenticate with a username and public key credential.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "publickey" method, including a signature that proves they have the private
     * key. The authentication handler must verify that the username and public key match known
     * credentials on the server, before returning a user principal to indicate successful
     * authentication.
     */
    SshAuthenticationType[SshAuthenticationType["clientPublicKey"] = 4] = "clientPublicKey";
    /**
     * The client is attempting to authenticate with interactive prompts.
     *
     * This event is raised by an `SshServerSession` when the client requests authentication
     * using the "keyboard-interactive" method. The event may be raised multiple times for the
     * same client to facilitate multi-step authentication.
     */
    SshAuthenticationType[SshAuthenticationType["clientInteractive"] = 5] = "clientInteractive";
    /**
     * The server is attempting to authenticate with a public key credential.
     *
     * This event is raised by an `SshClientSession` when the server requests
     * authentication by providing a signature that proves it has the private key. The client
     * authentication handler must verify that the public key matches known public key(s) for
     * that server. Or if not known (often the case for the first time connecting to that server)
     * it may prompt the user to consent, and then save the public key for later reference. To
     * indicate successful authentication, the client authentication handler returns a principal
     * that represents the server.
     */
    SshAuthenticationType[SshAuthenticationType["serverPublicKey"] = 10] = "serverPublicKey";
})(SshAuthenticationType = exports.SshAuthenticationType || (exports.SshAuthenticationType = {}));
/**
 * Arguments for the `SshSession.Authenticating` event that is raised when a client
 * or server is requesting authentication.
 *
 * See `SshAuthenticationType` for a description of the different authentication methods and
 * how they map to properties in this event-args object.
 *
 * After validating the credentials, the event handler must set the `authenticationPromise`
 * property to a task that resolves to a principal object to indicate successful authentication.
 * That principal will then be associated with the session as the `SshSession.principal` property.
 */
class SshAuthenticatingEventArgs {
    constructor(authenticationType, { username, password, publicKey, clientHostname, clientUsername, infoRequest, infoResponse, }, cancellation) {
        this.authenticationType = authenticationType;
        /**
         * Gets or sets a request for more information for interactive authentication.
         *
         * The server may set this property when handling an interactive authenticating event to prompt
         * for information/credentials. The client may read this property when handling an interactive
         * authenticating event to determine what prompts to show and what information is requested.
         */
        this.infoRequest = null;
        /**
         * Gets or sets the client's responses to interactive prompts; valid only for interactive
         * authentication when information was previously requested via `InfoRequest`.
         */
        this.infoResponse = null;
        const validate = ({ usernameRequired, passwordRequired, publicKeyRequired, clientHostnameRequired, clientUsernameRequired, }) => {
            // This is intentionally not checking for empty strings. The authentication handler
            // should determine whether any non-null string values are valid.
            if ((typeof username === 'string') !== !!usernameRequired)
                return false;
            if ((typeof password === 'string') !== !!passwordRequired)
                return false;
            if (!!publicKey !== !!publicKeyRequired)
                return false;
            if ((typeof clientHostname === 'string') !== !!clientHostnameRequired)
                return false;
            if ((typeof clientUsername === 'string') !== !!clientUsernameRequired)
                return false;
            return true;
        };
        let valid;
        switch (authenticationType) {
            case SshAuthenticationType.clientNone:
                valid = validate({ usernameRequired: true });
                break;
            case SshAuthenticationType.clientHostBased:
                valid = validate({
                    usernameRequired: true,
                    publicKeyRequired: true,
                    clientHostnameRequired: true,
                    clientUsernameRequired: true,
                });
                break;
            case SshAuthenticationType.clientPassword:
                valid = validate({ usernameRequired: true, passwordRequired: true });
                break;
            case SshAuthenticationType.clientPublicKeyQuery:
            case SshAuthenticationType.clientPublicKey:
                valid = validate({ usernameRequired: true, publicKeyRequired: true });
                break;
            case SshAuthenticationType.serverPublicKey:
                valid = validate({ publicKeyRequired: true });
                break;
            case SshAuthenticationType.clientInteractive:
                valid = true;
                break;
            default:
                throw new Error(`Invalid authentication type: ${authenticationType}`);
        }
        if (!valid) {
            throw new Error(`Invalid arguments for authentication type: ${authenticationType}`);
        }
        this.username = username !== null && username !== void 0 ? username : null;
        this.password = password !== null && password !== void 0 ? password : null;
        this.publicKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
        this.clientHostname = clientHostname !== null && clientHostname !== void 0 ? clientHostname : null;
        this.clientUsername = clientUsername !== null && clientUsername !== void 0 ? clientUsername : null;
        this.infoRequest = infoRequest !== null && infoRequest !== void 0 ? infoRequest : null;
        this.infoResponse = infoResponse !== null && infoResponse !== void 0 ? infoResponse : null;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
    }
    /**
     * Gets a token that is cancelled if the session ends before the authentication handler
     * completes.
     */
    get cancellation() {
        return this.cancellationValue;
    }
    /* @internal */
    set cancellation(value) {
        this.cancellationValue = value;
    }
    toString() {
        if (this.infoRequest) {
            return `Info request: ${this.infoRequest.name}`;
        }
        else if (this.infoResponse) {
            return `"${this.username}" info response`;
        }
        else if (this.password) {
            return `${this.username ? '"' + this.username + '" ' : ''}[password]`;
        }
        else if (this.publicKey) {
            return `${this.username ? '"' + this.username + '" ' : ''}[${this.publicKey.keyAlgorithmName}]`;
        }
        else {
            return `"${this.username}"`;
        }
    }
}
exports.SshAuthenticatingEventArgs = SshAuthenticatingEventArgs;
//# sourceMappingURL=sshAuthenticatingEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshChannelClosedEventArgs = void 0;
class SshChannelClosedEventArgs {
    constructor(exitStatusOrSignalOrError, errorMessage) {
        if (typeof exitStatusOrSignalOrError === 'number') {
            this.exitStatus = exitStatusOrSignalOrError;
        }
        else if (typeof exitStatusOrSignalOrError === 'string') {
            this.exitSignal = exitStatusOrSignalOrError;
            this.errorMessage = errorMessage;
        }
        else if (exitStatusOrSignalOrError instanceof Error) {
            this.error = exitStatusOrSignalOrError;
        }
    }
}
exports.SshChannelClosedEventArgs = SshChannelClosedEventArgs;
//# sourceMappingURL=sshChannelClosedEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshChannelOpeningEventArgs = void 0;
const connectionMessages_1 = __webpack_require__(/*! ../messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
class SshChannelOpeningEventArgs {
    constructor(request, channel, isRemoteRequest, cancellation) {
        this.request = request;
        this.channel = channel;
        this.isRemoteRequest = isRemoteRequest;
        /**
         * Specifies a reason that the channel could not be opened.
         *
         * The handler of this event can optionally block the channel by setting
         * a failure reason. If the event is not handled or the reason remains
         * `none` then the channel is allowed to open.
         */
        this.failureReason = connectionMessages_1.SshChannelOpenFailureReason.none;
        /**
         * Optional message to go along with a failure reason.
         */
        this.failureDescription = null;
        if (!request)
            throw new TypeError('A channel open message is required.');
        if (!channel)
            throw new TypeError('A channel is required.');
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
    }
    /**
     * Gets a token that is cancelled if the session ends before the request handler
     * completes.
     */
    get cancellation() {
        return this.cancellationValue;
    }
    /* @internal */
    set cancellation(value) {
        this.cancellationValue = value;
    }
    toString() {
        return `${this.channel.toString()}${this.failureReason ? ' ' + connectionMessages_1.SshChannelOpenFailureReason[this.failureReason] : ''}`;
    }
}
exports.SshChannelOpeningEventArgs = SshChannelOpeningEventArgs;
//# sourceMappingURL=sshChannelOpeningEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshExtendedDataEventArgs = exports.SshExtendedDataType = void 0;
var SshExtendedDataType;
(function (SshExtendedDataType) {
    /**
     * The extended data type SSH_EXTENDED_DATA_STDERR has been defined for stderr data.
     */
    SshExtendedDataType[SshExtendedDataType["STDERR"] = 1] = "STDERR";
})(SshExtendedDataType = exports.SshExtendedDataType || (exports.SshExtendedDataType = {}));
class SshExtendedDataEventArgs {
    constructor(dataTypeCode, data) {
        this.dataTypeCode = dataTypeCode;
        this.data = data;
    }
    toString() {
        return `${SshExtendedDataType[this.dataTypeCode]}: ${this.data.toString()}`;
    }
}
exports.SshExtendedDataEventArgs = SshExtendedDataEventArgs;
//# sourceMappingURL=sshExtendedDataEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshReportProgressEventArgs = void 0;
class SshReportProgressEventArgs {
    constructor(progress, sessionNumber) {
        this.progress = progress;
        this.sessionNumber = sessionNumber;
    }
    toString() {
        return `Progress: ${this.progress}` +
            this.sessionNumber ? ` Session number: ${this.sessionNumber}` : '';
    }
}
exports.SshReportProgressEventArgs = SshReportProgressEventArgs;
//# sourceMappingURL=sshReportProgressEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshRequestEventArgs = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
class SshRequestEventArgs {
    constructor(requestType, request, principal, cancellation) {
        this.requestType = requestType;
        this.request = request;
        this.principal = principal;
        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
    }
    /**
     * Gets a token that is cancelled if the session ends before the request handler
     * completes.
     */
    get cancellation() {
        return this.cancellationValue;
    }
    /* @internal */
    set cancellation(value) {
        this.cancellationValue = value;
    }
    toString() {
        return `RequestType: ${this.requestType}` + this.request ? ` Request: ${this.request}` : '';
    }
}
exports.SshRequestEventArgs = SshRequestEventArgs;
//# sourceMappingURL=sshRequestEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshSessionClosedEventArgs = void 0;
const transportMessages_1 = __webpack_require__(/*! ../messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
class SshSessionClosedEventArgs {
    constructor(reason, message, error) {
        this.reason = reason;
        this.message = message;
        this.error = error;
        if (!message)
            throw new TypeError('A disconnect message is required.');
    }
    toString() {
        return `${transportMessages_1.SshDisconnectReason[this.reason]}: ${this.message}`;
    }
}
exports.SshSessionClosedEventArgs = SshSessionClosedEventArgs;
//# sourceMappingURL=sshSessionClosedEventArgs.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandRequestMessage = exports.ChannelRequestType = exports.ChannelRequestMessage = exports.ChannelOpenConfirmationMessage = exports.ChannelOpenMessage = exports.ChannelOpenFailureMessage = exports.ChannelMessage = exports.SshChannelOpenFailureReason = exports.SessionChannelRequestMessage = exports.ServiceAcceptMessage = exports.ServiceRequestMessage = exports.SshReconnectFailureReason = exports.SshDisconnectReason = exports.SessionRequestFailureMessage = exports.SessionRequestSuccessMessage = exports.DebugMessage = exports.SessionRequestMessage = exports.PasswordRequestMessage = exports.PublicKeyOKMessage = exports.PublicKeyRequestMessage = exports.AuthenticationInfoResponseMessage = exports.AuthenticationInfoRequestMessage = exports.AuthenticationFailureMessage = exports.AuthenticationSuccessMessage = exports.AuthenticationRequestMessage = exports.AuthenticationMessage = exports.SshMessage = exports.SshExtendedDataEventArgs = exports.SshExtendedDataType = exports.SshChannelClosedEventArgs = exports.SshSessionClosedEventArgs = exports.SshChannelOpeningEventArgs = exports.SshReportProgressEventArgs = exports.SshRequestEventArgs = exports.SshAuthenticatingEventArgs = exports.SshAuthenticationType = exports.serviceActivation = exports.SshService = exports.SshRpcMessageStream = exports.WebSocketStream = exports.NodeStream = exports.BaseStream = exports.SshStream = exports.SshChannel = exports.SshServerSession = exports.SshClientSession = exports.SshSession = exports.SshVersionInfo = exports.SshProtocolExtensionNames = exports.SshSessionConfiguration = void 0;
exports.Progress = exports.SshTraceEventIds = exports.TraceLevel = exports.SecureStream = exports.MultiChannelStream = exports.SessionContour = exports.ChannelMetrics = exports.SessionMetrics = exports.Queue = exports.Semaphore = exports.PromiseCompletionSource = exports.CancellationError = exports.CancellationTokenSource = exports.CancellationToken = exports.ObjectDisposedError = exports.SshReconnectError = exports.SshConnectionError = exports.SshChannelError = exports.BigInt = exports.DerWriter = exports.DerReader = exports.formatBuffer = exports.SshDataWriter = exports.SshDataReader = exports.ECDsa = exports.Rsa = exports.Encryption = exports.HmacAlgorithm = exports.EncryptionAlgorithm = exports.PublicKeyAlgorithm = exports.KeyExchangeAlgorithm = exports.SshAlgorithms = void 0;
var sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
Object.defineProperty(exports, "SshSessionConfiguration", ({ enumerable: true, get: function () { return sshSessionConfiguration_1.SshSessionConfiguration; } }));
Object.defineProperty(exports, "SshProtocolExtensionNames", ({ enumerable: true, get: function () { return sshSessionConfiguration_1.SshProtocolExtensionNames; } }));
var sshVersionInfo_1 = __webpack_require__(/*! ./sshVersionInfo */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js");
Object.defineProperty(exports, "SshVersionInfo", ({ enumerable: true, get: function () { return sshVersionInfo_1.SshVersionInfo; } }));
var sshSession_1 = __webpack_require__(/*! ./sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
Object.defineProperty(exports, "SshSession", ({ enumerable: true, get: function () { return sshSession_1.SshSession; } }));
var sshClientSession_1 = __webpack_require__(/*! ./sshClientSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js");
Object.defineProperty(exports, "SshClientSession", ({ enumerable: true, get: function () { return sshClientSession_1.SshClientSession; } }));
var sshServerSession_1 = __webpack_require__(/*! ./sshServerSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js");
Object.defineProperty(exports, "SshServerSession", ({ enumerable: true, get: function () { return sshServerSession_1.SshServerSession; } }));
var sshChannel_1 = __webpack_require__(/*! ./sshChannel */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js");
Object.defineProperty(exports, "SshChannel", ({ enumerable: true, get: function () { return sshChannel_1.SshChannel; } }));
var sshStream_1 = __webpack_require__(/*! ./sshStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js");
Object.defineProperty(exports, "SshStream", ({ enumerable: true, get: function () { return sshStream_1.SshStream; } }));
var streams_1 = __webpack_require__(/*! ./streams */ "../../node_modules/@microsoft/dev-tunnels-ssh/streams.js");
Object.defineProperty(exports, "BaseStream", ({ enumerable: true, get: function () { return streams_1.BaseStream; } }));
Object.defineProperty(exports, "NodeStream", ({ enumerable: true, get: function () { return streams_1.NodeStream; } }));
Object.defineProperty(exports, "WebSocketStream", ({ enumerable: true, get: function () { return streams_1.WebSocketStream; } }));
var sshRpcMessageStream_1 = __webpack_require__(/*! ./sshRpcMessageStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js");
Object.defineProperty(exports, "SshRpcMessageStream", ({ enumerable: true, get: function () { return sshRpcMessageStream_1.SshRpcMessageStream; } }));
var sshService_1 = __webpack_require__(/*! ./services/sshService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js");
Object.defineProperty(exports, "SshService", ({ enumerable: true, get: function () { return sshService_1.SshService; } }));
var serviceActivation_1 = __webpack_require__(/*! ./services/serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
Object.defineProperty(exports, "serviceActivation", ({ enumerable: true, get: function () { return serviceActivation_1.serviceActivation; } }));
var sshAuthenticatingEventArgs_1 = __webpack_require__(/*! ./events/sshAuthenticatingEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js");
Object.defineProperty(exports, "SshAuthenticationType", ({ enumerable: true, get: function () { return sshAuthenticatingEventArgs_1.SshAuthenticationType; } }));
Object.defineProperty(exports, "SshAuthenticatingEventArgs", ({ enumerable: true, get: function () { return sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs; } }));
var sshRequestEventArgs_1 = __webpack_require__(/*! ./events/sshRequestEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js");
Object.defineProperty(exports, "SshRequestEventArgs", ({ enumerable: true, get: function () { return sshRequestEventArgs_1.SshRequestEventArgs; } }));
var sshReportProgressEventArgs_1 = __webpack_require__(/*! ./events/sshReportProgressEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js");
Object.defineProperty(exports, "SshReportProgressEventArgs", ({ enumerable: true, get: function () { return sshReportProgressEventArgs_1.SshReportProgressEventArgs; } }));
var sshChannelOpeningEventArgs_1 = __webpack_require__(/*! ./events/sshChannelOpeningEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js");
Object.defineProperty(exports, "SshChannelOpeningEventArgs", ({ enumerable: true, get: function () { return sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs; } }));
var sshSessionClosedEventArgs_1 = __webpack_require__(/*! ./events/sshSessionClosedEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js");
Object.defineProperty(exports, "SshSessionClosedEventArgs", ({ enumerable: true, get: function () { return sshSessionClosedEventArgs_1.SshSessionClosedEventArgs; } }));
var sshChannelClosedEventArgs_1 = __webpack_require__(/*! ./events/sshChannelClosedEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js");
Object.defineProperty(exports, "SshChannelClosedEventArgs", ({ enumerable: true, get: function () { return sshChannelClosedEventArgs_1.SshChannelClosedEventArgs; } }));
var sshExtendedDataEventArgs_1 = __webpack_require__(/*! ./events/sshExtendedDataEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js");
Object.defineProperty(exports, "SshExtendedDataType", ({ enumerable: true, get: function () { return sshExtendedDataEventArgs_1.SshExtendedDataType; } }));
Object.defineProperty(exports, "SshExtendedDataEventArgs", ({ enumerable: true, get: function () { return sshExtendedDataEventArgs_1.SshExtendedDataEventArgs; } }));
var sshMessage_1 = __webpack_require__(/*! ./messages/sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
Object.defineProperty(exports, "SshMessage", ({ enumerable: true, get: function () { return sshMessage_1.SshMessage; } }));
var authenticationMessages_1 = __webpack_require__(/*! ./messages/authenticationMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js");
Object.defineProperty(exports, "AuthenticationMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationMessage; } }));
Object.defineProperty(exports, "AuthenticationRequestMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationRequestMessage; } }));
Object.defineProperty(exports, "AuthenticationSuccessMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationSuccessMessage; } }));
Object.defineProperty(exports, "AuthenticationFailureMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationFailureMessage; } }));
Object.defineProperty(exports, "AuthenticationInfoRequestMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationInfoRequestMessage; } }));
Object.defineProperty(exports, "AuthenticationInfoResponseMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.AuthenticationInfoResponseMessage; } }));
Object.defineProperty(exports, "PublicKeyRequestMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.PublicKeyRequestMessage; } }));
Object.defineProperty(exports, "PublicKeyOKMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.PublicKeyOKMessage; } }));
Object.defineProperty(exports, "PasswordRequestMessage", ({ enumerable: true, get: function () { return authenticationMessages_1.PasswordRequestMessage; } }));
var transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
Object.defineProperty(exports, "SessionRequestMessage", ({ enumerable: true, get: function () { return transportMessages_1.SessionRequestMessage; } }));
Object.defineProperty(exports, "DebugMessage", ({ enumerable: true, get: function () { return transportMessages_1.DebugMessage; } }));
Object.defineProperty(exports, "SessionRequestSuccessMessage", ({ enumerable: true, get: function () { return transportMessages_1.SessionRequestSuccessMessage; } }));
Object.defineProperty(exports, "SessionRequestFailureMessage", ({ enumerable: true, get: function () { return transportMessages_1.SessionRequestFailureMessage; } }));
Object.defineProperty(exports, "SshDisconnectReason", ({ enumerable: true, get: function () { return transportMessages_1.SshDisconnectReason; } }));
Object.defineProperty(exports, "SshReconnectFailureReason", ({ enumerable: true, get: function () { return transportMessages_1.SshReconnectFailureReason; } }));
Object.defineProperty(exports, "ServiceRequestMessage", ({ enumerable: true, get: function () { return transportMessages_1.ServiceRequestMessage; } }));
Object.defineProperty(exports, "ServiceAcceptMessage", ({ enumerable: true, get: function () { return transportMessages_1.ServiceAcceptMessage; } }));
Object.defineProperty(exports, "SessionChannelRequestMessage", ({ enumerable: true, get: function () { return transportMessages_1.SessionChannelRequestMessage; } }));
var connectionMessages_1 = __webpack_require__(/*! ./messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
Object.defineProperty(exports, "SshChannelOpenFailureReason", ({ enumerable: true, get: function () { return connectionMessages_1.SshChannelOpenFailureReason; } }));
Object.defineProperty(exports, "ChannelMessage", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelMessage; } }));
Object.defineProperty(exports, "ChannelOpenFailureMessage", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelOpenFailureMessage; } }));
Object.defineProperty(exports, "ChannelOpenMessage", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelOpenMessage; } }));
Object.defineProperty(exports, "ChannelOpenConfirmationMessage", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelOpenConfirmationMessage; } }));
Object.defineProperty(exports, "ChannelRequestMessage", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelRequestMessage; } }));
Object.defineProperty(exports, "ChannelRequestType", ({ enumerable: true, get: function () { return connectionMessages_1.ChannelRequestType; } }));
Object.defineProperty(exports, "CommandRequestMessage", ({ enumerable: true, get: function () { return connectionMessages_1.CommandRequestMessage; } }));
var sshAlgorithms_1 = __webpack_require__(/*! ./algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
Object.defineProperty(exports, "SshAlgorithms", ({ enumerable: true, get: function () { return sshAlgorithms_1.SshAlgorithms; } }));
Object.defineProperty(exports, "KeyExchangeAlgorithm", ({ enumerable: true, get: function () { return sshAlgorithms_1.KeyExchangeAlgorithm; } }));
Object.defineProperty(exports, "PublicKeyAlgorithm", ({ enumerable: true, get: function () { return sshAlgorithms_1.PublicKeyAlgorithm; } }));
Object.defineProperty(exports, "EncryptionAlgorithm", ({ enumerable: true, get: function () { return sshAlgorithms_1.EncryptionAlgorithm; } }));
Object.defineProperty(exports, "HmacAlgorithm", ({ enumerable: true, get: function () { return sshAlgorithms_1.HmacAlgorithm; } }));
Object.defineProperty(exports, "Encryption", ({ enumerable: true, get: function () { return sshAlgorithms_1.Encryption; } }));
Object.defineProperty(exports, "Rsa", ({ enumerable: true, get: function () { return sshAlgorithms_1.Rsa; } }));
Object.defineProperty(exports, "ECDsa", ({ enumerable: true, get: function () { return sshAlgorithms_1.ECDsa; } }));
var sshData_1 = __webpack_require__(/*! ./io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
Object.defineProperty(exports, "SshDataReader", ({ enumerable: true, get: function () { return sshData_1.SshDataReader; } }));
Object.defineProperty(exports, "SshDataWriter", ({ enumerable: true, get: function () { return sshData_1.SshDataWriter; } }));
Object.defineProperty(exports, "formatBuffer", ({ enumerable: true, get: function () { return sshData_1.formatBuffer; } }));
var derData_1 = __webpack_require__(/*! ./io/derData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js");
Object.defineProperty(exports, "DerReader", ({ enumerable: true, get: function () { return derData_1.DerReader; } }));
Object.defineProperty(exports, "DerWriter", ({ enumerable: true, get: function () { return derData_1.DerWriter; } }));
var bigInt_1 = __webpack_require__(/*! ./io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
Object.defineProperty(exports, "BigInt", ({ enumerable: true, get: function () { return bigInt_1.BigInt; } }));
var errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
Object.defineProperty(exports, "SshChannelError", ({ enumerable: true, get: function () { return errors_1.SshChannelError; } }));
Object.defineProperty(exports, "SshConnectionError", ({ enumerable: true, get: function () { return errors_1.SshConnectionError; } }));
Object.defineProperty(exports, "SshReconnectError", ({ enumerable: true, get: function () { return errors_1.SshReconnectError; } }));
Object.defineProperty(exports, "ObjectDisposedError", ({ enumerable: true, get: function () { return errors_1.ObjectDisposedError; } }));
var cancellation_1 = __webpack_require__(/*! ./util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationError", ({ enumerable: true, get: function () { return cancellation_1.CancellationError; } }));
var promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
Object.defineProperty(exports, "PromiseCompletionSource", ({ enumerable: true, get: function () { return promiseCompletionSource_1.PromiseCompletionSource; } }));
var semaphore_1 = __webpack_require__(/*! ./util/semaphore */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js");
Object.defineProperty(exports, "Semaphore", ({ enumerable: true, get: function () { return semaphore_1.Semaphore; } }));
var queue_1 = __webpack_require__(/*! ./util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
Object.defineProperty(exports, "Queue", ({ enumerable: true, get: function () { return queue_1.Queue; } }));
var sessionMetrics_1 = __webpack_require__(/*! ./metrics/sessionMetrics */ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js");
Object.defineProperty(exports, "SessionMetrics", ({ enumerable: true, get: function () { return sessionMetrics_1.SessionMetrics; } }));
var channelMetrics_1 = __webpack_require__(/*! ./metrics/channelMetrics */ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js");
Object.defineProperty(exports, "ChannelMetrics", ({ enumerable: true, get: function () { return channelMetrics_1.ChannelMetrics; } }));
var sessionContour_1 = __webpack_require__(/*! ./metrics/sessionContour */ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js");
Object.defineProperty(exports, "SessionContour", ({ enumerable: true, get: function () { return sessionContour_1.SessionContour; } }));
var multiChannelStream_1 = __webpack_require__(/*! ./multiChannelStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js");
Object.defineProperty(exports, "MultiChannelStream", ({ enumerable: true, get: function () { return multiChannelStream_1.MultiChannelStream; } }));
var secureStream_1 = __webpack_require__(/*! ./secureStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js");
Object.defineProperty(exports, "SecureStream", ({ enumerable: true, get: function () { return secureStream_1.SecureStream; } }));
var trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
Object.defineProperty(exports, "TraceLevel", ({ enumerable: true, get: function () { return trace_1.TraceLevel; } }));
Object.defineProperty(exports, "SshTraceEventIds", ({ enumerable: true, get: function () { return trace_1.SshTraceEventIds; } }));
var progress_1 = __webpack_require__(/*! ./progress */ "../../node_modules/@microsoft/dev-tunnels-ssh/progress.js");
Object.defineProperty(exports, "Progress", ({ enumerable: true, get: function () { return progress_1.Progress; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigInt = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshData_1 = __webpack_require__(/*! ./sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
/**
 * Represents a large signed integer as a byte byffer.
 */
class BigInt {
    /**
     * Creates a new BigInt instance from a buffer of signed bytes.
     *
     * The first (high) bit of the first (high) byte is the sign bit. Therefore if the
     * highest byte of an unsigned integer is greater than 127, the bytes must include
     * a leading zero byte to prevent interpretation as a negative value.
     */
    constructor(buffer) {
        this.buffer = buffer;
        if (buffer.length === 0) {
            throw new Error('BigInt buffer length must be greater than zero.');
        }
    }
    /**
     * Gets a value that indicates the sign of the big integer:
     * 1 for positive, 0 for zero, -1 for negative.
     */
    get sign() {
        const highByte = this.buffer[0];
        if (highByte === 0) {
            return this.buffer.length > 1 ? 1 : 0;
        }
        else {
            return (highByte & 0x80) === 0 ? 1 : -1;
        }
    }
    static fromInt32(value) {
        if (value === 0) {
            return BigInt.zero;
        }
        let isNegative = false;
        if (value < 0) {
            isNegative = true;
            value = -value;
        }
        const bytes = [];
        for (let bit = 24; bit >= 0; bit -= 8) {
            if (value >= 1 << bit || bytes.length > 0) {
                bytes.push(value >> bit);
                value = value & ~((1 << bit) - 1);
            }
        }
        if (isNegative) {
            if ((bytes[0] & 0x80) === 0) {
                bytes[0] |= 0x80;
            }
            else {
                bytes.splice(0, 0, 0x80);
            }
        }
        return new BigInt(buffer_1.Buffer.from(new Uint8Array(bytes)));
    }
    toInt32() {
        if (this.buffer.length > 4) {
            throw new TypeError('BigInt value cannot be converted to a 32-bit signed integer.');
        }
        let value = this.buffer[0];
        if (this.sign < 0) {
            value &= 0x7f;
        }
        for (let i = 1; i < this.buffer.length; i++) {
            value = (value << 8) + this.buffer[i];
        }
        if (this.sign < 0) {
            value = -value;
        }
        return value;
    }
    /**
     * Creates a new BigInt instance from a byte buffer.
     * @param bytes Source byte buffer.
     * @param options.unsigned True if the bytes should be interpreted as unsigned. If false,
     * the high bit of the high byte is the sign bit. The default is false.
     */
    static fromBytes(bytes, options) {
        if (!buffer_1.Buffer.isBuffer(bytes)) {
            throw new TypeError('Buffer expected.');
        }
        else if (bytes.length === 0) {
            throw new Error('BigInt buffer length must be greater than zero.');
        }
        options = options !== null && options !== void 0 ? options : {};
        const highBit = (bytes[0] & 0x80) !== 0;
        const prependZeroCount = options.unsigned && highBit ? 1 : 0;
        let skipZeroCount = 0;
        // Skip non-significant zeroes at the big end.
        for (let i = 0; i < bytes.length - 1 && bytes[i] === 0; i++) {
            if ((bytes[i + 1] & 0x80) === 0) {
                skipZeroCount++;
            }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length + prependZeroCount - skipZeroCount);
        bytes.copy(newBytes, prependZeroCount, skipZeroCount, bytes.length);
        return new BigInt(newBytes);
    }
    /**
     * Converts a BigInt instance to a byte buffer.
     *
     * @param options.unsigned True if the returned bytes will be interprted as unsigned.
     * If false, a positive integer may have a leading zero to prevent it from being
     * interpreted as negative.
     * @param options.length Desired length of the resulting buffer. The value will be zero-
     * padded to fill the length. Only applies when `options.unsigned` is true.
     */
    toBytes(options) {
        options = options !== null && options !== void 0 ? options : {};
        let bytes = this.buffer;
        if (options.unsigned) {
            if (this.sign < 0) {
                throw new TypeError('Cannot format a negative BigInt as unsigned.');
            }
            else if (bytes[0] === 0 && bytes.length > 1) {
                bytes = bytes.slice(1, bytes.length);
            }
            if (options.length !== undefined) {
                if (bytes.length > options.length) {
                    throw new Error(`BigInt (${bytes.length} bytes) is too large for length ${options.length}.`);
                }
                else if (bytes.length < options.length) {
                    const padded = buffer_1.Buffer.alloc(options.length);
                    bytes.copy(padded, options.length - bytes.length);
                    return padded;
                }
            }
        }
        const newBytes = buffer_1.Buffer.alloc(bytes.length);
        bytes.copy(newBytes, 0, 0, bytes.length);
        return newBytes;
    }
    copyTo(buffer, offset = 0) {
        this.buffer.copy(buffer, offset, 0, this.buffer.length);
    }
    equals(other) {
        return other instanceof BigInt && this.buffer.equals(other.buffer);
    }
    toString(name) {
        return (0, sshData_1.formatBuffer)(this.buffer, name !== null && name !== void 0 ? name : 'BigInt');
    }
}
exports.BigInt = BigInt;
BigInt.zero = new BigInt(buffer_1.Buffer.alloc(1));
//# sourceMappingURL=bigInt.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/io/derData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DerWriter = exports.DerReader = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const bigInt_1 = __webpack_require__(/*! ./bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
/**
 * Reads data in DER (Distinguished Encoding Rules) format.
 *
 * Enables importing and exporting key files, which are commonly DER-encoded.
 */
class DerReader {
    constructor(buffer, dataType = 32 /* DerType.Constructed */ | 16 /* DerType.Sequence */) {
        this.buffer = buffer;
        this.position = 0;
        this.readType(dataType);
        const length = this.readLength();
        if (length > this.buffer.length - this.position) {
            throw new Error('Read out of bounds.');
        }
        this.buffer = this.buffer.slice(0, this.position + length);
    }
    get available() {
        return this.buffer.length - this.position;
    }
    readNull() {
        this.readType(5 /* DerType.Null */);
        if (this.readByte() !== 0) {
            throw new Error('Expected a 0 after Null type.');
        }
    }
    readInteger() {
        this.readType(2 /* DerType.Integer */);
        const length = this.readLength();
        const bytes = this.readBytes(length);
        const result = new bigInt_1.BigInt(bytes);
        return result;
    }
    readOctetString() {
        this.readType(4 /* DerType.OctetString */);
        const length = this.readLength();
        const result = this.readBytes(length);
        return result;
    }
    readBitString() {
        this.readType(3 /* DerType.BitString */);
        const length = this.readLength();
        const padding = this.readByte();
        if (padding !== 0) {
            throw new Error('Padded bit strings are not supported.');
        }
        const result = this.readBytes(length - 1);
        return result;
    }
    readObjectIdentifier(expected) {
        this.readType(6 /* DerType.ObjectIdentifier */);
        const length = this.readLength();
        const end = this.position + length;
        const values = [];
        const first = this.readByte();
        values.push(Math.trunc(first / 40));
        values.push(first % 40);
        let next = 0;
        while (this.position < end) {
            const b = this.readByte();
            if ((b & 0x80) !== 0) {
                next = next * 128 + (b & 0x7f);
            }
            else {
                next = next * 128 + b;
                values.push(next);
                next = 0;
            }
        }
        if (next !== 0) {
            throw new Error('Invalid OID format.');
        }
        const result = values.join('.');
        if (expected && result !== expected) {
            throw new Error(`Expected OID ${expected}, found: ${result}`);
        }
        return result;
    }
    readSequence() {
        const start = this.position;
        this.readType(32 /* DerType.Constructed */ | 16 /* DerType.Sequence */);
        const length = this.readLength();
        this.position += length;
        return new DerReader(this.buffer.slice(start, this.position));
    }
    tryReadTagged(tagId) {
        if (this.position >= this.buffer.length) {
            return null;
        }
        const type = this.buffer[this.position];
        if ((type & 160 /* DerType.Tagged */) === 0 || (type & ~160 /* DerType.Tagged */) !== tagId) {
            return null;
        }
        const start = this.position;
        this.position++;
        const length = this.readLength();
        this.position += length;
        const taggedData = new DerReader(this.buffer.slice(start, this.position), type);
        return taggedData;
    }
    /** Reads the type of the next value in the sequence WITHOUT advancing the reader position. */
    peek() {
        if (this.position >= this.buffer.length) {
            throw new Error('Read out of bounds.');
        }
        return this.buffer[this.position];
    }
    readLength() {
        let length = this.readByte();
        if (length === 0x80) {
            throw new Error('Indefinite-length encoding is not supported.');
        }
        if (length > 127) {
            const size = length & 0x7f;
            if (size > 4) {
                throw new Error(`DER length size is ${size} and cannot be more than 4 bytes.`);
            }
            length = 0;
            for (let i = 0; i < size; i++) {
                const next = this.readByte();
                length = (length << 8) + next;
            }
            if (length < 0) {
                throw new Error('Corrupted data - negative length found');
            }
        }
        return length;
    }
    readByte() {
        if (this.position >= this.buffer.length) {
            throw new Error('Read out of bounds.');
        }
        return this.buffer[this.position++];
    }
    readBytes(length) {
        if (this.position + length > this.buffer.length) {
            throw new Error('Read out of bounds.');
        }
        const result = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return result;
    }
    readType(expectedType) {
        const type = this.readByte();
        if (type !== expectedType) {
            throw new Error(`Expected ${expectedType} data type, found : ${type}`);
        }
    }
}
exports.DerReader = DerReader;
/**
 * Writes data in DER (Distinguished Encoding Rules) format.
 *
 * Enables importing and exporting key files, which are commonly DER-encoded.
 */
class DerWriter {
    constructor(buffer, dataType = 32 /* DerType.Constructed */ | 16 /* DerType.Sequence */) {
        this.buffer = buffer;
        this.dataType = dataType;
        this.position = 0;
        this.buffer = buffer;
    }
    toBuffer() {
        // Move the data over to make space for the type + length prefix.
        const length = this.position;
        const lengthBytes = DerWriter.getLength(length);
        this.ensureCapacity(1 + lengthBytes.length + length);
        const result = this.buffer.slice(0, 1 + lengthBytes.length + length);
        this.buffer.copy(result, 1 + lengthBytes.length);
        // Write the type + length prefix.
        result[0] = this.dataType;
        lengthBytes.copy(result, 1, 0);
        // Restore the writer buffer to its previous state (without the type + length prefix).
        this.buffer = this.buffer.slice(1 + lengthBytes.length, result.length);
        this.position = length;
        return result;
    }
    writeSequence(data) {
        this.writeBytes(data.toBuffer());
    }
    writeTagged(tagId, data) {
        if (tagId > 0xf)
            throw new Error('Invalid DER tag.');
        this.writeByte(160 /* DerType.Tagged */ | tagId);
        const lengthBytes = DerWriter.getLength(data.position);
        this.writeBytes(lengthBytes);
        this.writeBytes(data.buffer.slice(0, data.position));
    }
    writeNull() {
        this.writeByte(5 /* DerType.Null */);
        this.writeByte(0);
    }
    writeInteger(value) {
        this.writeByte(2 /* DerType.Integer */);
        const integerBytes = value.toBytes();
        const lengthBytes = DerWriter.getLength(integerBytes.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(integerBytes);
    }
    writeOctetString(data) {
        this.writeByte(4 /* DerType.OctetString */);
        const lengthBytes = DerWriter.getLength(data.length);
        this.writeBytes(lengthBytes);
        this.writeBytes(data);
    }
    writeBitString(data) {
        this.writeByte(3 /* DerType.BitString */);
        const lengthBytes = DerWriter.getLength(1 + data.length);
        this.writeBytes(lengthBytes);
        this.writeByte(0);
        this.writeBytes(data);
    }
    writeObjectIdentifier(oid) {
        if (!oid)
            throw new TypeError('OID value is null or empty.');
        const values = oid.split('.').map(Number);
        if (values.length < 2 || values[0] > 3 || values[1] >= 40) {
            throw new Error(`Invalid OID: ${oid}`);
        }
        this.writeByte(6 /* DerType.ObjectIdentifier */);
        let length = values.length - 1;
        for (let i = 2; i < values.length; i++) {
            let value = values[i];
            while (value > 128) {
                length++;
                value /= 128;
            }
        }
        const lengthBytes = DerWriter.getLength(length);
        this.writeBytes(lengthBytes);
        this.writeByte(values[0] * 40 + values[1]);
        for (let i = 2; i < values.length; i++) {
            let value = values[i];
            if (value >= 128) {
                const bytes = [];
                bytes.push(value & 0x7f);
                while (value >= 128) {
                    value /= 128;
                    bytes.push(0x80 | (value & 0x7f));
                }
                while (bytes.length > 0) {
                    this.writeByte(bytes.pop());
                }
            }
            else {
                this.writeByte(value);
            }
        }
    }
    static getLength(length) {
        if (length > 127) {
            let size = 1;
            for (let val = length >> 8; val !== 0; val >>= 8) {
                size++;
            }
            const lengthBytes = DerWriter.lengthBuffer.slice(0, size + 1);
            lengthBytes[0] = size | 0x80;
            for (let i = (size - 1) * 8, j = 1; i >= 0; i -= 8, j++) {
                lengthBytes[j] = length >> i;
            }
            return lengthBytes;
        }
        else {
            const lengthBytes = DerWriter.lengthBuffer.slice(0, 1);
            lengthBytes[0] = length;
            return lengthBytes;
        }
    }
    writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position++] = value;
    }
    writeBytes(value) {
        this.ensureCapacity(this.position + value.length);
        value.copy(this.buffer, this.position);
        this.position += value.length;
    }
    ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
            let newLength = Math.max(512, this.buffer.length * 2);
            while (newLength < capacity)
                newLength *= 2;
            const newBuffer = buffer_1.Buffer.alloc(newLength);
            this.buffer.copy(newBuffer, 0, 0, this.position);
            this.buffer = newBuffer;
        }
    }
}
exports.DerWriter = DerWriter;
DerWriter.lengthBuffer = buffer_1.Buffer.alloc(10);
//# sourceMappingURL=derData.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatBuffer = exports.SshDataWriter = exports.SshDataReader = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshAlgorithms_1 = __webpack_require__(/*! ../algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
const bigInt_1 = __webpack_require__(/*! ./bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
class SshDataReader {
    constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
    }
    get available() {
        return this.buffer.length - this.position;
    }
    read(length) {
        if (this.available < length) {
            throw new Error('Attempted to read past end of buffer.');
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
    }
    readByte() {
        if (this.available === 0) {
            throw new Error('Attempted to read past end of buffer.');
        }
        const value = this.buffer[this.position];
        this.position++;
        return value;
    }
    readBinary() {
        const length = this.readUInt32();
        if (this.available < length) {
            throw new Error('Attempted to read past end of buffer.');
        }
        const data = this.buffer.slice(this.position, this.position + length);
        this.position += length;
        return data;
    }
    readString(encoding) {
        const bytes = this.readBinary();
        return bytes.toString();
    }
    readList(encoding) {
        const stringList = this.readString(encoding);
        return stringList.length === 0 ? [] : stringList.split(',');
    }
    readBoolean() {
        return this.readByte() !== 0;
    }
    readUInt32() {
        if (this.available < 4) {
            throw new Error('Attempted to read past end of buffer.');
        }
        // Big-endian encoding
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        this.position += 4;
        const value = ((value0 << 24) | (value1 << 16) | (value2 << 8) | value3) >>> 0;
        return value;
    }
    readUInt64() {
        if (this.available < 8) {
            throw new Error('Attempted to read past end of buffer.');
        }
        // Big-endian encoding
        const value0 = this.buffer[this.position + 0];
        const value1 = this.buffer[this.position + 1];
        const value2 = this.buffer[this.position + 2];
        const value3 = this.buffer[this.position + 3];
        const value4 = this.buffer[this.position + 4];
        const value5 = this.buffer[this.position + 5];
        const value6 = this.buffer[this.position + 6];
        const value7 = this.buffer[this.position + 7];
        this.position += 8;
        const high = ((value0 << 24) | (value1 << 16) | (value2 << 8) | value3) >>> 0;
        const low = ((value4 << 24) | (value5 << 16) | (value6 << 8) | value7) >>> 0;
        return high * 0x100000000 + low;
    }
    readBigInt() {
        const data = this.readBinary();
        if (data.length === 0) {
            return bigInt_1.BigInt.zero;
        }
        return bigInt_1.BigInt.fromBytes(data);
    }
}
exports.SshDataReader = SshDataReader;
SshDataReader.mpintZero = buffer_1.Buffer.alloc(1);
class SshDataWriter {
    constructor(buffer) {
        this.buffer = buffer;
        this.position = 0;
    }
    write(data) {
        this.ensureCapacity(this.position + data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
    }
    writeByte(value) {
        this.ensureCapacity(this.position + 1);
        this.buffer[this.position] = value;
        this.position++;
    }
    writeBinary(data) {
        this.ensureCapacity(this.position + 4 + data.length);
        this.writeUInt32(data.length);
        data.copy(this.buffer, this.position);
        this.position += data.length;
    }
    writeString(value, encoding) {
        this.writeBinary(buffer_1.Buffer.from(value));
    }
    writeList(value, encoding) {
        this.writeString(value ? value.join(',') : '', encoding);
    }
    writeBoolean(value) {
        this.writeByte(value ? 1 : 0);
    }
    writeUInt32(value) {
        this.ensureCapacity(this.position + 4);
        // Big-endian encoding
        this.buffer[this.position + 0] = value >>> 24;
        this.buffer[this.position + 1] = value >>> 16;
        this.buffer[this.position + 2] = value >>> 8;
        this.buffer[this.position + 3] = value >>> 0;
        this.position += 4;
    }
    /* @internal */
    static writeUInt32(buffer, offset, value) {
        buffer[offset + 0] = value >>> 24;
        buffer[offset + 1] = value >>> 16;
        buffer[offset + 2] = value >>> 8;
        buffer[offset + 3] = value >>> 0;
    }
    writeUInt64(value) {
        this.ensureCapacity(this.position + 8);
        const low = value & 0xffffffff;
        const high = (value - low) / 0x100000000;
        // Big-endian encoding
        this.buffer[this.position + 0] = high >>> 24;
        this.buffer[this.position + 1] = high >>> 16;
        this.buffer[this.position + 2] = high >>> 8;
        this.buffer[this.position + 3] = high >>> 0;
        this.buffer[this.position + 4] = low >>> 24;
        this.buffer[this.position + 5] = low >>> 16;
        this.buffer[this.position + 6] = low >>> 8;
        this.buffer[this.position + 7] = low >>> 0;
        this.position += 8;
    }
    writeBigInt(value) {
        const data = value.toBytes();
        if (data.length === 1 && data[0] === 0) {
            this.writeUInt32(0);
        }
        else {
            this.writeBinary(data);
        }
    }
    writeRandom(length) {
        this.ensureCapacity(this.position + length);
        const randomBuffer = this.buffer.slice(this.position, this.position + length);
        sshAlgorithms_1.SshAlgorithms.random.getBytes(randomBuffer);
        this.position += length;
    }
    skip(length) {
        this.ensureCapacity(this.position + length);
        this.position += length;
    }
    ensureCapacity(capacity) {
        if (this.buffer.length < capacity) {
            let newLength = Math.max(512, this.buffer.length * 2);
            while (newLength < capacity)
                newLength *= 2;
            const newBuffer = buffer_1.Buffer.alloc(newLength);
            this.buffer.copy(newBuffer, 0, 0, this.position);
            this.buffer = newBuffer;
        }
    }
    toBuffer() {
        return this.buffer.slice(0, this.position);
    }
}
exports.SshDataWriter = SshDataWriter;
function makeCrcTable() {
    let c;
    const table = [];
    for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        table[n] = c;
    }
    return table;
}
let crcTable;
function crc32(data) {
    if (!crcTable) {
        crcTable = makeCrcTable();
    }
    let crc = 0 ^ -1;
    for (let i = 0; i < data.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xff];
    }
    const result = (crc ^ -1) >>> 0;
    return (result + 0x100000000)
        .toString(16)
        .substr(-8)
        .toUpperCase();
}
/**
 * Formats a byte buffer using the same format as OpenSSH,
 * useful for debugging and comparison in logs.
 */
function formatBuffer(data, name, formatData) {
    let s = `${name === undefined ? 'Buffer' : name}[${data.length}] (${crc32(data)})\n`;
    if (formatData === false) {
        return s;
    }
    const max = Math.min(2048, data.length);
    for (let lineOffset = 0; lineOffset < max; lineOffset += 16) {
        if (lineOffset < 1000)
            s += '0';
        if (lineOffset < 100)
            s += '0';
        if (lineOffset < 10)
            s += '0';
        s += lineOffset + ':';
        for (let i = lineOffset; i < lineOffset + 16; i++) {
            if (i < max) {
                s += ' ' + data.slice(i, i + 1).toString('hex');
            }
            else {
                s += '   ';
            }
        }
        s += '  ';
        for (let i = lineOffset; i < lineOffset + 16; i++) {
            if (i < max) {
                const c = data[i];
                s += c > 32 && c <= 127 ? data.slice(i, i + 1).toString() : '.';
            }
            else {
                s += ' ';
            }
        }
        s += '\n';
    }
    if (max < data.length) {
        s += '...\n';
    }
    return s;
}
exports.formatBuffer = formatBuffer;
//# sourceMappingURL=sshData.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshProtocol = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const queue_1 = __webpack_require__(/*! ../util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
const semaphore_1 = __webpack_require__(/*! ../util/semaphore */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js");
const sshMessage_1 = __webpack_require__(/*! ../messages/sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const transportMessages_1 = __webpack_require__(/*! ../messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const kexMessages_1 = __webpack_require__(/*! ../messages/kexMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js");
const connectionMessages_1 = __webpack_require__(/*! ../messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const trace_1 = __webpack_require__(/*! ../trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
class SequencedMessage {
    constructor(sequence, message) {
        this.sequence = sequence;
        this.message = message;
    }
}
/**
 * Implements the base SSH protocol (sending and receiving messages) over a Stream.
 */
class SshProtocol {
    constructor(stream, config, metrics, trace) {
        this.config = config;
        this.metrics = metrics;
        this.trace = trace;
        this.sessionSemaphore = new semaphore_1.Semaphore(1);
        this.inboundPacketSequence = 0;
        this.outboundPacketSequence = 0;
        this.inboundFlow = 0;
        this.outboundFlow = 0;
        // Sent messages are kept for a short time, until the other side acknowledges
        // that they have been received. This enables re-sending lost messages on reconnect.
        this.recentSentMessages = new queue_1.Queue();
        // Initialize buffers that are re-used for each sent/received message.
        // The buffers will be automatically expanded as necessary.
        this.sendWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.receiveWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        /* @internal */
        this.traceChannelData = false;
        this.extensions = null;
        this.kexService = null;
        this.algorithms = null;
        this.messageContext = null;
        this.outgoingMessagesHaveLatencyInfo = false;
        this.incomingMessagesHaveLatencyInfo = false;
        this.outgoingMessagesHaveReconnectInfo = false;
        this.incomingMessagesHaveReconnectInfo = false;
        this.stream = stream;
        this.traceChannelData = config.traceChannelData;
    }
    get lastIncomingSequence() {
        return this.inboundPacketSequence - 1;
    }
    getSentMessages(startingSequenceNumber) {
        if (startingSequenceNumber === this.outboundPacketSequence + 1) {
            // The recipient is already up-to-date.
            return [];
        }
        if (this.recentSentMessages.size > 0 &&
            startingSequenceNumber < this.recentSentMessages.peek().sequence) {
            // The cached recent messages do not go back as far as the requested sequence number.
            // This should never happen because messages are not dropped from this list until
            // the other side acknowledges they have been received, so they should not be
            // requested again after reconnecting.
            return null;
        }
        // Return all messages starting with the requested sequence number.
        // Exclude key exchange messages because they cannot be retransmitted; a reconnected
        // session will do key exchange separately. Also exclude any disconnect messages that
        // may have been attempted when the connection was lost.
        const messagesToRetransmit = new Array();
        for (const sequencedMessage of this.recentSentMessages) {
            if (sequencedMessage.sequence >= startingSequenceNumber) {
                const message = sequencedMessage.message;
                if (!(message instanceof kexMessages_1.KeyExchangeMessage || message instanceof transportMessages_1.DisconnectMessage)) {
                    messagesToRetransmit.push(message);
                }
            }
        }
        return messagesToRetransmit;
    }
    async writeProtocolVersion(version, cancellation) {
        const stream = this.stream;
        if (!stream)
            throw new Error('SSH session disconnected.');
        const data = buffer_1.Buffer.from(version + '\r\n');
        await stream.write(data, cancellation);
        this.metrics.addMessageSent(data.length);
        return Promise.resolve();
    }
    async readProtocolVersion(cancellation) {
        const stream = this.stream;
        if (!stream)
            throw new Error('SSH session disconnected.');
        // http://tools.ietf.org/html/rfc4253#section-4.2
        const buffer = buffer_1.Buffer.alloc(255);
        let lineCount = 0;
        for (let i = 0; i < buffer.length; i++) {
            const byteBuffer = await stream.read(1, cancellation);
            if (!byteBuffer) {
                break;
            }
            buffer[i] = byteBuffer[0];
            const carriageReturn = 0x0d;
            const lineFeed = 0x0a;
            if (i > 0 && buffer[i - 1] === carriageReturn && buffer[i] === lineFeed) {
                const line = buffer.toString('utf8', 0, i - 1);
                if (line.startsWith('SSH-')) {
                    this.metrics.addMessageReceived(i + 1);
                    return line;
                }
                else if (lineCount > 20) {
                    // Give up if a version string was not found after 20 lines.
                    break;
                }
                else {
                    // Ignore initial lines before the version line.
                    lineCount++;
                    i = -1;
                }
            }
        }
        throw new errors_1.SshConnectionError('Failed to read the protocol version', transportMessages_1.SshDisconnectReason.protocolError);
    }
    async handleNewKeys(cancellation) {
        try {
            await this.sessionSemaphore.wait(cancellation);
            this.inboundFlow = 0;
            this.outboundFlow = 0;
            this.algorithms = this.kexService.finishKeyExchange();
        }
        finally {
            this.sessionSemaphore.release();
        }
    }
    /**
     * Attempts to read from the stream until the buffer is full.
     * @returns True if the read succeeded, false if the stream was disposed.
     */
    async read(buffer, cancellation) {
        const stream = this.stream;
        if (!stream)
            return false;
        let bytesRead = 0;
        do {
            let data;
            try {
                data = await stream.read(buffer.length - bytesRead, cancellation);
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                if (stream.isDisposed)
                    return false;
                stream.dispose();
                this.stream = null;
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamReadError, `Error reading from stream: ${e.message}`, e);
                throw new errors_1.SshConnectionError('Error reading from stream: ' + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
            }
            if (!data)
                return false;
            data.copy(buffer, bytesRead);
            bytesRead += data.length;
        } while (bytesRead < buffer.length);
        return true;
    }
    /**
     * Attempts to write data to the stream.
     * @returns True if the write succeeded, false if the stream was disposed.
     */
    async write(data, cancellation) {
        const stream = this.stream;
        if (!stream)
            return false;
        try {
            await stream.write(data, cancellation);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            if (stream.isDisposed)
                return false;
            stream.dispose();
            this.stream = null;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamWriteError, `Error writing to stream: ${e.message}`, e);
            throw new errors_1.SshConnectionError('Error writing to stream: ' + e.message, transportMessages_1.SshDisconnectReason.connectionLost);
        }
        return true;
    }
    async considerReExchange(initial, cancellation) {
        const kexService = this.kexService;
        if (!kexService)
            return;
        let kexMessage = null;
        let kexGuessMessage = null;
        if (!kexService.exchanging &&
            (initial || this.inboundFlow + this.outboundFlow > this.config.keyRotationThreshold)) {
            [kexMessage, kexGuessMessage] = await kexService.startKeyExchange(initial);
        }
        if (kexMessage) {
            await this.sendMessage(kexMessage, cancellation);
            if (kexGuessMessage) {
                await this.sendMessage(kexGuessMessage, cancellation);
            }
        }
    }
    async computeHmac(signer, payload, seq) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await signer.sign(writer.toBuffer());
        return result;
    }
    async verifyHmac(verifier, payload, seq, mac) {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));
        writer.writeUInt32(seq);
        writer.write(payload);
        const result = await verifier.verify(writer.toBuffer(), mac);
        return result;
    }
    async readAndVerifyHmac(verifier, data, macBuffer, cancellation) {
        if (!(await this.read(macBuffer, cancellation))) {
            return false;
        }
        const verified = await this.verifyHmac(verifier, data, this.inboundPacketSequence, macBuffer);
        if (!verified) {
            throw new errors_1.SshConnectionError('Invalid MAC', transportMessages_1.SshDisconnectReason.macError);
        }
        return true;
    }
    /**
     * Attemps to write one message to the stream.
     * @returns `true` if writing succeeded, `false` if the stream was disposed.
     * @throws SshConnectionException if writing to the stream failed for any other reason.
     */
    async sendMessage(message, cancellation) {
        var _a;
        const algorithms = this.algorithms;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.compressor;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.cipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageSigner;
        let result;
        await this.sessionSemaphore.wait(cancellation);
        try {
            const blockSize = encryption ? Math.max(8, encryption.blockLength) : 8;
            // Start by writing the uncompressed payload to the buffer at the correct offset.
            const payloadOffset = SshProtocol.packetLengthSize + SshProtocol.paddingLengthSize;
            this.sendWriter.position = payloadOffset;
            message.write(this.sendWriter);
            if (this.outgoingMessagesHaveReconnectInfo) {
                // Write the sequence number of the last inbound packet processed.
                this.sendWriter.writeUInt64(this.lastIncomingSequence);
                if (this.outgoingMessagesHaveLatencyInfo) {
                    // Write the time (in microseconds, not ms) since last packet was received.
                    const timeSinceLastReceivedMessage = Math.min(4294967295, // max uint32
                    Math.round((this.metrics.time - this.lastIncomingTimestamp) * 1000));
                    this.sendWriter.writeUInt32(timeSinceLastReceivedMessage);
                }
            }
            let payload = this.sendWriter.toBuffer().slice(payloadOffset);
            if (compression != null) {
                payload = compression.compress(payload);
            }
            // The packet length is not encrypted when in EtM or AEAD mode.
            const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
            // http://tools.ietf.org/html/rfc4253
            // 6.  Binary Packet Protocol
            // the total length of (packet_length || padding_length || payload || padding)
            // is a multiple of the cipher block size or 8,
            // padding length must between 4 and 255 bytes.
            let paddingLength = blockSize -
                (((isLengthEncrypted ? SshProtocol.packetLengthSize : 0) +
                    SshProtocol.paddingLengthSize +
                    payload.length) %
                    blockSize);
            if (paddingLength < 4) {
                paddingLength += blockSize;
            }
            const packetLength = SshProtocol.paddingLengthSize + payload.length + paddingLength;
            this.sendWriter.position = 0;
            this.sendWriter.writeUInt32(packetLength);
            this.sendWriter.writeByte(paddingLength);
            // The uncompressed payload was already written at the correct offset.
            // When compression is enabled, rewrite the compressed payload.
            if (compression != null) {
                this.sendWriter.write(payload);
            }
            else {
                this.sendWriter.position += payload.length;
            }
            this.sendWriter.writeRandom(paddingLength);
            payload = this.sendWriter.toBuffer();
            let mac = null;
            if ((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) && encryption) {
                // In EtM mode, compute the MAC after encrypting. And don't encrypt the length.
                const packetWithoutLength = payload.slice(SshProtocol.packetLengthSize, payload.length);
                const encryptedPacket = await encryption.transform(packetWithoutLength);
                encryptedPacket.copy(packetWithoutLength);
                mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
            }
            else if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
                // With a GCM cipher, the packet length is not included in the plaintext.
                const packetWithoutLength = payload.slice(SshProtocol.packetLengthSize, payload.length);
                const encryptedPacket = await encryption.transform(packetWithoutLength);
                encryptedPacket.copy(packetWithoutLength);
                // The GCM tag was already generated during the transform call above;
                // this just retrieves it.
                mac = await hmac.sign(packetWithoutLength);
            }
            else {
                if (hmac) {
                    mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);
                }
                if (encryption) {
                    payload = await encryption.transform(payload);
                }
            }
            if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
                this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingMessage, `Sending #${this.outboundPacketSequence} ${message}`);
            }
            else if (this.traceChannelData) {
                this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sendingChannelData, `Sending #${this.outboundPacketSequence} ${message}`);
            }
            if (this.incomingMessagesHaveReconnectInfo) {
                // Save sent messages in case they need to be re-sent after reconnect.
                // They'll be discarded soon, after the other side acknowledges them.
                const sequencedMessage = new SequencedMessage(this.outboundPacketSequence, message);
                sequencedMessage.sentTime = this.metrics.time;
                this.recentSentMessages.enqueue(sequencedMessage);
            }
            this.outboundPacketSequence++;
            this.outboundFlow += packetLength;
            if (mac) {
                const packet = buffer_1.Buffer.concat([payload, mac], payload.length + mac.length);
                result = await this.write(packet, cancellation);
            }
            else {
                result = await this.write(payload, cancellation);
            }
            this.metrics.addMessageSent(SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));
        }
        finally {
            this.sessionSemaphore.release();
        }
        await this.considerReExchange(false, cancellation);
        return result;
    }
    /**
     * Attemps to read one message from the stream.
     * @returns The message, or `null` if the stream was disposed.
     * @throws SshConnectionError if reading from the stream failed for any other reason.
     */
    async receiveMessage(cancellation) {
        var _a;
        const algorithms = this.algorithms;
        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decipher;
        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageVerifier;
        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decompressor;
        // The packet length is not encrypted when in EtM or AEAD mode.
        // So read only the length bytes first, separate from the remaining payload.
        const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));
        const firstBlockSize = !isLengthEncrypted
            ? SshProtocol.packetLengthSize
            : encryption
                ? Math.max(8, encryption.blockLength)
                : 8;
        this.receiveWriter.position = firstBlockSize;
        let firstBlock = this.receiveWriter.toBuffer();
        if (!(await this.read(firstBlock, cancellation))) {
            return null;
        }
        this.lastIncomingTimestamp = this.metrics.time;
        // Decrypt the first block to get the packet length.
        if (encryption && isLengthEncrypted) {
            firstBlock = await encryption.transform(firstBlock);
            this.receiveWriter.position = 0;
            this.receiveWriter.write(firstBlock);
        }
        const receiveReader = new sshData_1.SshDataReader(firstBlock);
        const packetLength = receiveReader.readUInt32();
        if (packetLength > SshProtocol.maxPacketLength) {
            throw new errors_1.SshConnectionError('Invalid packet length.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        const packetBufferSize = SshProtocol.packetLengthSize + packetLength;
        if (packetBufferSize > firstBlockSize) {
            this.receiveWriter.skip(packetBufferSize - firstBlockSize);
        }
        if (hmac) {
            // Ensure the receive buffer is large enough to also hold the mac without expanding.
            this.receiveWriter.skip(hmac.digestLength);
        }
        const receiveBuffer = this.receiveWriter.toBuffer();
        const packetBuffer = receiveBuffer.slice(0, packetBufferSize);
        const macBuffer = receiveBuffer.slice(packetBufferSize);
        let followingBlocks = packetBuffer.slice(firstBlockSize, packetBufferSize);
        if (followingBlocks.length > 0) {
            if (!(await this.read(followingBlocks, cancellation))) {
                return null;
            }
            if (hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) {
                // In EtM mode, read and verify the MAC before decrypting.
                ///const packetWithoutLength = packet.slice(SshProtocol.packetLengthSize);
                if (!(await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation))) {
                    return null;
                }
            }
            if (encryption) {
                if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
                    // With a GCM cipher, the MAC is required for decryption.
                    if (!(await this.read(macBuffer, cancellation))) {
                        return null;
                    }
                    // This doesn't actually verify anything yet (hence the return value is not checked);
                    // it sets the tag to be used for verification in the following transform call.
                    await hmac.verify(followingBlocks, macBuffer);
                }
                try {
                    followingBlocks = await encryption.transform(followingBlocks);
                }
                catch (e) {
                    if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {
                        // GCM decryption failed to verify data + tag.
                        throw new errors_1.SshConnectionError('Invalid MAC', transportMessages_1.SshDisconnectReason.macError);
                    }
                    else {
                        throw e;
                    }
                }
                this.receiveWriter.position = firstBlockSize;
                this.receiveWriter.write(followingBlocks);
            }
        }
        if (hmac && !hmac.encryptThenMac && !hmac.authenticatedEncryption) {
            if (!(await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation))) {
                return null;
            }
        }
        const paddingLength = packetBuffer[SshProtocol.packetLengthSize];
        let payload = packetBuffer.slice(SshProtocol.packetLengthSize + SshProtocol.paddingLengthSize, SshProtocol.packetLengthSize + (packetLength - paddingLength));
        if (compression) {
            payload = compression.decompress(payload);
        }
        if (this.incomingMessagesHaveReconnectInfo) {
            // Read the extension info from the end of the payload.
            let lastSequenceSeenByRemote;
            let remoteTimeSinceLastReceived;
            if (this.incomingMessagesHaveLatencyInfo) {
                const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 12, payload.length));
                lastSequenceSeenByRemote = reader.readUInt64();
                remoteTimeSinceLastReceived = reader.readUInt32() / 1000; // microseconds to ms
                payload = payload.slice(0, payload.length - 12);
            }
            else {
                const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 8, payload.length));
                lastSequenceSeenByRemote = reader.readUInt64();
                remoteTimeSinceLastReceived = 0;
                payload = payload.slice(0, payload.length - 8);
            }
            // Discard any recently sent messages that were acknowledged.
            while (this.recentSentMessages.size > 0) {
                const oldestSequenceMessage = this.recentSentMessages.peek();
                if (oldestSequenceMessage.sequence > lastSequenceSeenByRemote) {
                    break;
                }
                if (this.stream &&
                    this.incomingMessagesHaveLatencyInfo &&
                    oldestSequenceMessage.sequence === lastSequenceSeenByRemote) {
                    // Compute the time since the message with the last-seen sequence was sent.
                    // Subtract the time between when the remote side received the message with the
                    // last-seen sequence and sent the current message.
                    const timeSinceSent = this.lastIncomingTimestamp - oldestSequenceMessage.sentTime;
                    const roundTripLatency = timeSinceSent - remoteTimeSinceLastReceived;
                    this.metrics.updateLatency(roundTripLatency, this.trace);
                }
                this.recentSentMessages.dequeue();
            }
        }
        const messageType = payload[0];
        let message = sshMessage_1.SshMessage.create(this.config, messageType, this.messageContext, payload);
        if (!message) {
            const unimplementedMessage = new transportMessages_1.UnimplementedMessage();
            unimplementedMessage.sequenceNumber = this.inboundPacketSequence;
            unimplementedMessage.unimplementedMessageType = messageType;
            message = unimplementedMessage;
        }
        if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingMessage, `Receiving #${this.inboundPacketSequence} ${message}`);
        }
        else if (this.traceChannelData) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.receivingChannelData, `Receiving #${this.inboundPacketSequence} ${message}`);
        }
        await this.sessionSemaphore.wait(cancellation);
        this.inboundPacketSequence++;
        this.inboundFlow += packetLength;
        this.sessionSemaphore.release();
        this.metrics.addMessageReceived(SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));
        await this.considerReExchange(false, cancellation);
        return message;
    }
    dispose() {
        try {
            if (this.stream)
                this.stream.close().catch((e) => {
                    this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
                });
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing stream: ${e.message}`, e);
        }
        this.stream = null;
        this.metrics.updateLatency(0);
        if (this.algorithms)
            this.algorithms.dispose();
    }
}
exports.SshProtocol = SshProtocol;
SshProtocol.maxPacketLength = 1024 * 1024; // 1 MB
SshProtocol.packetLengthSize = 4;
SshProtocol.paddingLengthSize = 1;
//# sourceMappingURL=sshProtocol.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationSuccessMessage = exports.AuthenticationFailureMessage = exports.PasswordRequestMessage = exports.PublicKeyOKMessage = exports.AuthenticationInfoResponseMessage = exports.AuthenticationInfoRequestMessage = exports.PublicKeyRequestMessage = exports.AuthenticationRequestMessage = exports.AuthenticationMessage = void 0;
const sshMessage_1 = __webpack_require__(/*! ./sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
class AuthenticationMessage extends sshMessage_1.SshMessage {
}
exports.AuthenticationMessage = AuthenticationMessage;
class AuthenticationRequestMessage extends AuthenticationMessage {
    get messageType() {
        return 50;
    }
    onRead(reader) {
        this.username = reader.readString('utf8');
        this.serviceName = reader.readString('ascii');
        this.methodName = reader.readString('ascii');
    }
    onWrite(writer) {
        writer.writeString(this.username || '', 'utf8');
        writer.writeString(this.serviceName || '', 'ascii');
        writer.writeString(this.validateField(this.methodName, 'method name'), 'ascii');
    }
    toString() {
        return super.toString() + ` (Method: ${this.methodName}, Username: ${this.username})`;
    }
}
exports.AuthenticationRequestMessage = AuthenticationRequestMessage;
class PublicKeyRequestMessage extends AuthenticationRequestMessage {
    constructor() {
        super();
        this.methodName = "publickey" /* AuthenticationMethod.publicKey */;
    }
    get hasSignature() {
        return this.signature && this.signature.length > 0 ? true : false;
    }
    onRead(reader) {
        super.onRead(reader);
        const hasSignature = reader.readBoolean();
        this.keyAlgorithmName = reader.readString('ascii');
        this.publicKey = reader.readBinary();
        if (hasSignature) {
            this.signature = reader.readBinary();
            this.payloadWithoutSignature = this.rawBytes.slice(0, this.rawBytes.length - this.signature.length - 4);
        }
        else {
            this.signature = undefined;
        }
    }
    onWrite(writer) {
        var _a, _b;
        super.onWrite(writer);
        if (!this.keyAlgorithmName)
            throw new Error('Key algorithm name not set.');
        if (this.methodName === "hostbased" /* AuthenticationMethod.hostBased */) {
            writer.writeString(this.keyAlgorithmName, 'ascii');
            writer.writeBinary(this.publicKey || Buffer.alloc(0));
            writer.writeString((_a = this.clientHostname) !== null && _a !== void 0 ? _a : '', 'ascii');
            writer.writeString((_b = this.clientUsername) !== null && _b !== void 0 ? _b : '', 'ascii');
            if (!this.hasSignature) {
                throw new Error('A signature is required for a host-based authentcation request.');
            }
            writer.writeBinary(this.signature);
        }
        else {
            writer.writeBoolean(this.hasSignature);
            writer.writeString(this.keyAlgorithmName, 'ascii');
            writer.writeBinary(this.publicKey || Buffer.alloc(0));
            if (this.hasSignature) {
                writer.writeBinary(this.signature);
            }
        }
    }
}
exports.PublicKeyRequestMessage = PublicKeyRequestMessage;
class AuthenticationInfoRequestMessage extends AuthenticationMessage {
    get messageType() {
        return 60;
    }
    onRead(reader) {
        this.name = reader.readString('utf8');
        this.instruction = reader.readString('utf8');
        this.language = reader.readString('ascii');
        this.prompts = [];
        const promptsCount = reader.readUInt32();
        const promptStrings = [];
        for (let i = 0; i < promptsCount; i++) {
            promptStrings.push(reader.readString('utf8'));
        }
        for (let i = 0; i < promptsCount; i++) {
            this.prompts.push({
                prompt: promptStrings[i],
                echo: reader.readBoolean(),
            });
        }
    }
    onWrite(writer) {
        var _a, _b;
        writer.writeString(this.name || '', 'utf8');
        writer.writeString(this.instruction || '', 'utf8');
        writer.writeString(this.language || '', 'ascii');
        const promptsCount = (_b = (_a = this.prompts) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(promptsCount);
        for (let i = 0; i < promptsCount; i++) {
            writer.writeString(this.prompts[i].prompt || '', 'utf8');
        }
        for (let i = 0; i < promptsCount; i++) {
            writer.writeBoolean(this.prompts[i].echo);
        }
    }
}
exports.AuthenticationInfoRequestMessage = AuthenticationInfoRequestMessage;
class AuthenticationInfoResponseMessage extends AuthenticationMessage {
    get messageType() {
        return 61;
    }
    onRead(reader) {
        this.responses = [];
        const responseCount = reader.readUInt32();
        for (let i = 0; i < responseCount; i++) {
            this.responses.push(reader.readString('utf8'));
        }
    }
    onWrite(writer) {
        var _a, _b;
        const responseCount = (_b = (_a = this.responses) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        writer.writeUInt32(responseCount);
        for (let i = 0; i < responseCount; i++) {
            writer.writeString(this.responses[i] || '', 'utf8');
        }
    }
}
exports.AuthenticationInfoResponseMessage = AuthenticationInfoResponseMessage;
class PublicKeyOKMessage extends AuthenticationMessage {
    get messageType() {
        return 60;
    }
    onRead(reader) {
        this.keyAlgorithmName = reader.readString('ascii');
        this.publicKey = reader.readBinary();
    }
    onWrite(writer) {
        if (!this.keyAlgorithmName)
            throw new Error('Key algorithm name not set.');
        if (!this.publicKey)
            throw new Error('Public key not set.');
        writer.writeString(this.keyAlgorithmName, 'ascii');
        writer.writeBinary(this.publicKey);
    }
}
exports.PublicKeyOKMessage = PublicKeyOKMessage;
class PasswordRequestMessage extends AuthenticationRequestMessage {
    constructor() {
        super();
        this.methodName = "password" /* AuthenticationMethod.password */;
    }
    onRead(reader) {
        super.onRead(reader);
        reader.readBoolean();
        this.password = reader.readString('utf8');
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeBoolean(false);
        writer.writeString(this.password || '', 'utf8');
    }
}
exports.PasswordRequestMessage = PasswordRequestMessage;
class AuthenticationFailureMessage extends AuthenticationMessage {
    constructor() {
        super(...arguments);
        this.partialSuccess = false;
    }
    get messageType() {
        return 51;
    }
    onRead(reader) {
        this.methodNames = reader.readList('ascii');
        this.partialSuccess = reader.readBoolean();
    }
    onWrite(writer) {
        writer.writeList(this.methodNames || [], 'ascii');
        writer.writeBoolean(this.partialSuccess);
    }
}
exports.AuthenticationFailureMessage = AuthenticationFailureMessage;
class AuthenticationSuccessMessage extends AuthenticationMessage {
    get messageType() {
        return 52;
    }
    onRead(reader) { }
    onWrite(writer) { }
}
exports.AuthenticationSuccessMessage = AuthenticationSuccessMessage;
sshMessage_1.SshMessage.index.set(50, AuthenticationRequestMessage);
sshMessage_1.SshMessage.index.set(51, AuthenticationFailureMessage);
sshMessage_1.SshMessage.index.set(52, AuthenticationSuccessMessage);
sshMessage_1.SshMessage.index.set([60, "publickey" /* AuthenticationMethod.publicKey */], PublicKeyRequestMessage);
sshMessage_1.SshMessage.index.set([60, "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */], AuthenticationInfoRequestMessage);
sshMessage_1.SshMessage.index.set([61, "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */], AuthenticationInfoResponseMessage);
//# sourceMappingURL=authenticationMessages.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelFailureMessage = exports.ChannelSuccessMessage = exports.ChannelSignalMessage = exports.CommandRequestMessage = exports.ChannelRequestMessage = exports.ChannelRequestType = exports.ChannelCloseMessage = exports.ChannelEofMessage = exports.ChannelExtendedDataMessage = exports.ChannelDataMessage = exports.ChannelWindowAdjustMessage = exports.ChannelOpenFailureMessage = exports.SshChannelOpenFailureReason = exports.ChannelOpenConfirmationMessage = exports.ChannelOpenMessage = exports.ChannelMessage = exports.ConnectionMessage = void 0;
const sshMessage_1 = __webpack_require__(/*! ./sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
class ConnectionMessage extends sshMessage_1.SshMessage {
}
exports.ConnectionMessage = ConnectionMessage;
class ChannelMessage extends ConnectionMessage {
    get recipientChannel() {
        return this.recipientChannelValue;
    }
    set recipientChannel(value) {
        if (value !== this.recipientChannelValue) {
            this.recipientChannelValue = value;
            if (this.rawBytes) {
                // The recipientChannel can be updated without re-serializing the message.
                // This supports piping channel messages with re-mapped channel IDs.
                // The recipientChannel field follows the 1-byte message type.
                sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1, value !== null && value !== void 0 ? value : 0);
            }
        }
    }
    onRead(reader) {
        this.recipientChannel = reader.readUInt32();
    }
    onWrite(writer) {
        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));
    }
    toString() {
        return `${super.toString()} (recipientChannel=${this.recipientChannel})`;
    }
}
exports.ChannelMessage = ChannelMessage;
class ChannelOpenMessage extends ConnectionMessage {
    get messageType() {
        return 90;
    }
    get senderChannel() {
        return this.senderChannelValue;
    }
    set senderChannel(value) {
        if (value !== this.senderChannelValue) {
            this.senderChannelValue = value;
            if (this.rawBytes && this.channelType) {
                // The senderChannel can be updated without re-serializing the message.
                // This supports piping channel messages with re-mapped channel IDs.
                // The senderChannel field follows the 1-byte message type and
                // length-prefixed channelType string.
                sshData_1.SshDataWriter.writeUInt32(this.rawBytes, 1 + 4 + this.channelType.length, value !== null && value !== void 0 ? value : 0);
            }
        }
    }
    onRead(reader) {
        this.channelType = reader.readString('ascii');
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
    }
    onWrite(writer) {
        writer.writeString(this.validateField(this.channelType, 'channel type'), 'ascii');
        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));
        writer.writeUInt32(this.maxWindowSize || ChannelOpenMessage.defaultMaxWindowSize);
        writer.writeUInt32(this.maxPacketSize || ChannelOpenMessage.defaultMaxPacketSize);
    }
    toString() {
        return `${super.toString()}(channelType=${this.channelType}, senderChannel=${this.senderChannel})`;
    }
}
exports.ChannelOpenMessage = ChannelOpenMessage;
/* @internal */
ChannelOpenMessage.defaultMaxPacketSize = 32 * 1024;
/* @internal */
ChannelOpenMessage.defaultMaxWindowSize = 1024 * 1024;
class ChannelOpenConfirmationMessage extends ChannelMessage {
    get messageType() {
        return 91;
    }
    onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        this.maxWindowSize = reader.readUInt32();
        this.maxPacketSize = reader.readUInt32();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));
        writer.writeUInt32(this.validateField(this.maxWindowSize, 'max window size'));
        writer.writeUInt32(this.validateField(this.maxPacketSize, 'max packet size'));
    }
    toString() {
        return `${super.toString()}(senderChannel=${this.senderChannel})`;
    }
}
exports.ChannelOpenConfirmationMessage = ChannelOpenConfirmationMessage;
var SshChannelOpenFailureReason;
(function (SshChannelOpenFailureReason) {
    SshChannelOpenFailureReason[SshChannelOpenFailureReason["none"] = 0] = "none";
    SshChannelOpenFailureReason[SshChannelOpenFailureReason["administrativelyProhibited"] = 1] = "administrativelyProhibited";
    SshChannelOpenFailureReason[SshChannelOpenFailureReason["connectFailed"] = 2] = "connectFailed";
    SshChannelOpenFailureReason[SshChannelOpenFailureReason["unknownChannelType"] = 3] = "unknownChannelType";
    SshChannelOpenFailureReason[SshChannelOpenFailureReason["resourceShortage"] = 4] = "resourceShortage";
})(SshChannelOpenFailureReason = exports.SshChannelOpenFailureReason || (exports.SshChannelOpenFailureReason = {}));
class ChannelOpenFailureMessage extends ChannelMessage {
    get messageType() {
        return 92;
    }
    onRead(reader) {
        super.onRead(reader);
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString('utf8');
        this.language = reader.readString('ascii');
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));
        writer.writeString(this.description || '', 'utf8');
        writer.writeString(this.language || 'en', 'ascii');
    }
    toString() {
        return `${super.toString()} (${SshChannelOpenFailureReason[this.reasonCode || 0]}: ${this.description})`;
    }
}
exports.ChannelOpenFailureMessage = ChannelOpenFailureMessage;
class ChannelWindowAdjustMessage extends ChannelMessage {
    get messageType() {
        return 93;
    }
    onRead(reader) {
        super.onRead(reader);
        this.bytesToAdd = reader.readUInt32();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.bytesToAdd, 'bytes to add'));
    }
    toString() {
        return `${super.toString()} (bytesToAdd=${this.bytesToAdd})`;
    }
}
exports.ChannelWindowAdjustMessage = ChannelWindowAdjustMessage;
class ChannelDataMessage extends ChannelMessage {
    get messageType() {
        return 94;
    }
    onRead(reader) {
        super.onRead(reader);
        this.data = reader.readBinary();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.data, 'data'));
    }
    toString() {
        return this.data ? (0, sshData_1.formatBuffer)(this.data, '') : '[0]';
    }
}
exports.ChannelDataMessage = ChannelDataMessage;
class ChannelExtendedDataMessage extends ChannelMessage {
    get messageType() {
        return 95;
    }
    onRead(reader) {
        super.onRead(reader);
        this.dataTypeCode = reader.readUInt32();
        this.data = reader.readBinary();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.dataTypeCode, 'data type code'));
        writer.writeBinary(this.validateField(this.data, 'data'));
    }
    toString() {
        return `${super.toString()} (dataTypeCode=${this.dataTypeCode}, data=${this.data ? (0, sshData_1.formatBuffer)(this.data, '') : '[0]'})`;
    }
}
exports.ChannelExtendedDataMessage = ChannelExtendedDataMessage;
class ChannelEofMessage extends ChannelMessage {
    get messageType() {
        return 96;
    }
}
exports.ChannelEofMessage = ChannelEofMessage;
class ChannelCloseMessage extends ChannelMessage {
    get messageType() {
        return 97;
    }
}
exports.ChannelCloseMessage = ChannelCloseMessage;
var ChannelRequestType;
(function (ChannelRequestType) {
    ChannelRequestType["command"] = "exec";
    ChannelRequestType["shell"] = "shell";
    ChannelRequestType["terminal"] = "pty-req";
    ChannelRequestType["signal"] = "signal";
    ChannelRequestType["exitSignal"] = "exit-signal";
    ChannelRequestType["exitStatus"] = "exit-status";
})(ChannelRequestType = exports.ChannelRequestType || (exports.ChannelRequestType = {}));
class ChannelRequestMessage extends ChannelMessage {
    constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
    }
    get messageType() {
        return 98;
    }
    onRead(reader) {
        super.onRead(reader);
        this.requestType = reader.readString('ascii');
        this.wantReply = reader.readBoolean();
    }
    onWrite(writer) {
        if (typeof this.recipientChannel === 'undefined') {
            // The recipient channel field may be uninitialized when sending a channel request
            // that is bundled with the channel-open request.
            this.recipientChannel = 0;
        }
        super.onWrite(writer);
        writer.writeString(this.validateField(this.requestType, 'request type'), 'ascii');
        writer.writeBoolean(this.wantReply);
    }
}
exports.ChannelRequestMessage = ChannelRequestMessage;
class CommandRequestMessage extends ChannelRequestMessage {
    constructor() {
        super();
        this.requestType = ChannelRequestType.command;
    }
    onRead(reader) {
        super.onRead(reader);
        this.command = reader.readString('utf8');
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeString(this.validateField(this.command, 'command'), 'utf8');
    }
    toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
    }
}
exports.CommandRequestMessage = CommandRequestMessage;
class ChannelSignalMessage extends ChannelRequestMessage {
    constructor() {
        super();
    }
    get signal() {
        return this.signalValue;
    }
    set signal(value) {
        this.requestType = ChannelRequestType.signal;
        this.signalValue = value;
    }
    get exitSignal() {
        return this.signalValue;
    }
    set exitSignal(value) {
        this.requestType = ChannelRequestType.exitSignal;
        this.signalValue = value;
    }
    get errorMessage() {
        return this.errorMessageValue;
    }
    set errorMessage(value) {
        if (this.requestType !== ChannelRequestType.exitSignal) {
            throw new Error(`Error message property is only valid for ${ChannelRequestType.exitSignal} messages.`);
        }
        this.errorMessageValue = value;
    }
    get exitStatus() {
        return this.statusValue;
    }
    set exitStatus(value) {
        this.requestType = ChannelRequestType.exitStatus;
        this.statusValue = value;
    }
    onRead(reader) {
        super.onRead(reader);
        switch (this.requestType) {
            case ChannelRequestType.exitStatus:
                this.exitStatus = reader.readUInt32();
                break;
            case ChannelRequestType.signal:
                this.signal = reader.readString('ascii');
                break;
            case ChannelRequestType.exitSignal:
                this.exitSignal = reader.readString('ascii');
                reader.readBoolean(); // Core dumped
                this.errorMessage = reader.readString('utf8');
                reader.readString('ascii'); // Language tag
                break;
            default:
                break;
        }
    }
    onWrite(writer) {
        if (!this.requestType) {
            throw new Error('Signal message request type not set.');
        }
        this.wantReply = false;
        super.onWrite(writer);
        switch (this.requestType) {
            case ChannelRequestType.exitStatus:
                writer.writeUInt32(this.validateField(this.exitStatus, 'exit status'));
                break;
            case ChannelRequestType.signal:
                writer.writeString(this.validateField(this.signal, 'signal'), 'ascii');
                break;
            case ChannelRequestType.exitSignal:
                writer.writeString(this.validateField(this.exitSignal, 'exit signal'), 'ascii');
                writer.writeBoolean(false); // Core dumped
                writer.writeString(this.errorMessage || '', 'utf8');
                writer.writeString('', 'ascii'); // Language tag
                break;
            default:
                throw new Error(`Unknown signal message request type: ${this.requestType}`);
        }
    }
}
exports.ChannelSignalMessage = ChannelSignalMessage;
class ChannelSuccessMessage extends ChannelMessage {
    get messageType() {
        return 99;
    }
}
exports.ChannelSuccessMessage = ChannelSuccessMessage;
class ChannelFailureMessage extends ChannelMessage {
    get messageType() {
        return 100;
    }
}
exports.ChannelFailureMessage = ChannelFailureMessage;
sshMessage_1.SshMessage.index.set(90, ChannelOpenMessage);
sshMessage_1.SshMessage.index.set(91, ChannelOpenConfirmationMessage);
sshMessage_1.SshMessage.index.set(92, ChannelOpenFailureMessage);
sshMessage_1.SshMessage.index.set(93, ChannelWindowAdjustMessage);
sshMessage_1.SshMessage.index.set(94, ChannelDataMessage);
sshMessage_1.SshMessage.index.set(95, ChannelExtendedDataMessage);
sshMessage_1.SshMessage.index.set(96, ChannelEofMessage);
sshMessage_1.SshMessage.index.set(97, ChannelCloseMessage);
sshMessage_1.SshMessage.index.set(98, ChannelRequestMessage);
sshMessage_1.SshMessage.index.set(99, ChannelSuccessMessage);
sshMessage_1.SshMessage.index.set(100, ChannelFailureMessage);
//# sourceMappingURL=connectionMessages.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewKeysMessage = exports.KeyExchangeDhReplyMessage = exports.KeyExchangeDhInitMessage = exports.KeyExchangeInitMessage = exports.KeyExchangeMessage = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshMessage_1 = __webpack_require__(/*! ./sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
const sshAlgorithms_1 = __webpack_require__(/*! ../algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
class KeyExchangeMessage extends sshMessage_1.SshMessage {
}
exports.KeyExchangeMessage = KeyExchangeMessage;
const keyExchangeInitCookieLength = 16;
class KeyExchangeInitMessage extends KeyExchangeMessage {
    get messageType() {
        return 20;
    }
    onRead(reader) {
        this.cookie = reader.read(keyExchangeInitCookieLength);
        this.keyExchangeAlgorithms = reader.readList('ascii');
        this.serverHostKeyAlgorithms = reader.readList('ascii');
        this.encryptionAlgorithmsClientToServer = reader.readList('ascii');
        this.encryptionAlgorithmsServerToClient = reader.readList('ascii');
        this.macAlgorithmsClientToServer = reader.readList('ascii');
        this.macAlgorithmsServerToClient = reader.readList('ascii');
        this.compressionAlgorithmsClientToServer = reader.readList('ascii');
        this.compressionAlgorithmsServerToClient = reader.readList('ascii');
        this.languagesClientToServer = reader.readList('ascii');
        this.languagesServerToClient = reader.readList('ascii');
        this.firstKexPacketFollows = reader.readBoolean();
        this.reserved = reader.readUInt32();
    }
    onWrite(writer) {
        var _a;
        if (!this.cookie) {
            this.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
            sshAlgorithms_1.SshAlgorithms.random.getBytes(this.cookie);
        }
        writer.write(this.cookie);
        writer.writeList(this.keyExchangeAlgorithms || [], 'ascii');
        writer.writeList(this.serverHostKeyAlgorithms || [], 'ascii');
        writer.writeList(this.encryptionAlgorithmsClientToServer || [], 'ascii');
        writer.writeList(this.encryptionAlgorithmsServerToClient || [], 'ascii');
        writer.writeList(this.macAlgorithmsClientToServer || [], 'ascii');
        writer.writeList(this.macAlgorithmsServerToClient || [], 'ascii');
        writer.writeList(this.compressionAlgorithmsClientToServer || [], 'ascii');
        writer.writeList(this.compressionAlgorithmsServerToClient || [], 'ascii');
        writer.writeList(this.languagesClientToServer || [], 'ascii');
        writer.writeList(this.languagesServerToClient || [], 'ascii');
        writer.writeBoolean((_a = this.firstKexPacketFollows) !== null && _a !== void 0 ? _a : false);
        writer.writeUInt32(this.reserved || 0);
    }
    static CreateNone() {
        const noneArray = ['none'];
        const emptyArray = [''];
        const message = new KeyExchangeInitMessage();
        message.cookie = buffer_1.Buffer.alloc(keyExchangeInitCookieLength);
        message.keyExchangeAlgorithms = noneArray;
        message.serverHostKeyAlgorithms = noneArray;
        message.encryptionAlgorithmsClientToServer = noneArray;
        message.encryptionAlgorithmsServerToClient = noneArray;
        message.macAlgorithmsClientToServer = noneArray;
        message.macAlgorithmsServerToClient = noneArray;
        message.compressionAlgorithmsClientToServer = noneArray;
        message.compressionAlgorithmsServerToClient = noneArray;
        message.languagesClientToServer = emptyArray;
        message.languagesServerToClient = emptyArray;
        // Save the serialized bytes so that the message doesn't have to be re-serialized every time
        // it is sent.
        message.rawBytes = message.toBuffer();
        return message;
    }
    get allowsNone() {
        const includesNone = (algorithms) => (algorithms === null || algorithms === void 0 ? void 0 : algorithms.includes('none')) === true;
        return (includesNone(this.keyExchangeAlgorithms) &&
            includesNone(this.serverHostKeyAlgorithms) &&
            includesNone(this.encryptionAlgorithmsClientToServer) &&
            includesNone(this.encryptionAlgorithmsServerToClient) &&
            includesNone(this.macAlgorithmsClientToServer) &&
            includesNone(this.macAlgorithmsServerToClient) &&
            includesNone(this.compressionAlgorithmsClientToServer) &&
            includesNone(this.compressionAlgorithmsServerToClient) &&
            this.firstKexPacketFollows !== true);
    }
}
exports.KeyExchangeInitMessage = KeyExchangeInitMessage;
KeyExchangeInitMessage.none = KeyExchangeInitMessage.CreateNone();
class KeyExchangeDhInitMessage extends KeyExchangeMessage {
    get messageType() {
        return 30;
    }
    onRead(reader) {
        this.e = reader.readBinary();
    }
    onWrite(writer) {
        writer.writeBinary(this.validateField(this.e, 'E'));
    }
}
exports.KeyExchangeDhInitMessage = KeyExchangeDhInitMessage;
class KeyExchangeDhReplyMessage extends KeyExchangeMessage {
    get messageType() {
        return 31;
    }
    onRead(reader) {
        this.hostKey = reader.readBinary();
        this.f = reader.readBinary();
        this.signature = reader.readBinary();
    }
    onWrite(writer) {
        writer.writeBinary(this.validateField(this.hostKey, 'host key'));
        writer.writeBinary(this.validateField(this.f, 'F'));
        writer.writeBinary(this.validateField(this.signature, 'signature'));
    }
}
exports.KeyExchangeDhReplyMessage = KeyExchangeDhReplyMessage;
class NewKeysMessage extends KeyExchangeMessage {
    get messageType() {
        return 21;
    }
    onRead(reader) { }
    onWrite(writer) { }
}
exports.NewKeysMessage = NewKeysMessage;
sshMessage_1.SshMessage.index.set(20, KeyExchangeInitMessage);
sshMessage_1.SshMessage.index.set(30, KeyExchangeDhInitMessage);
sshMessage_1.SshMessage.index.set(31, KeyExchangeDhReplyMessage);
sshMessage_1.SshMessage.index.set(21, NewKeysMessage);
//# sourceMappingURL=kexMessages.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshMessage = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
class SshMessage {
    get messageType() {
        return 0;
    }
    toBuffer() {
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
        this.write(writer);
        return writer.toBuffer();
    }
    read(reader) {
        this.rawBytes = reader.buffer;
        const number = reader.readByte();
        if (number !== this.messageType) {
            throw new Error(`Message type ${number} is not valid.`);
        }
        this.onRead(reader);
    }
    write(writer) {
        if (this.rawBytes) {
            // Piped messages are rewritten without re-serialization. This preserves any
            // unparsed extended message data. It assumes no properties of the message
            // have been modified without also updating the serialized bytes.
            writer.write(this.rawBytes);
        }
        else {
            writer.writeByte(this.messageType);
            this.onWrite(writer);
        }
    }
    /**
     * Rewrites the message to its buffer to ensure the buffer has the correct values.
     * This should be called after modifying properties of a message that was (potentially)
     * received, before re-sending it.
     */
    rewrite() {
        if (this.rawBytes) {
            const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));
            writer.writeByte(this.messageType);
            this.onWrite(writer);
            this.rawBytes = writer.toBuffer();
        }
    }
    onRead(reader) {
        throw new Error('Not supported.');
    }
    onWrite(writer) {
        throw new Error('Not supported.');
    }
    validateField(value, name) {
        if (typeof value === 'undefined') {
            throw new Error(`${this.constructor.name} ${name} is required.`);
        }
        return value;
    }
    toString() {
        return this.constructor.name;
    }
    static create(config, messageType, messageContext, data) {
        let messageClass = config.messages.get(messageType);
        if (!messageClass && messageContext) {
            const contextMessageTypes = config.contextualMessages.get(messageContext);
            if (contextMessageTypes) {
                messageClass = contextMessageTypes.get(messageType);
            }
        }
        if (messageClass) {
            const message = new messageClass();
            message.read(new sshData_1.SshDataReader(data));
            return message;
        }
        else {
            return null;
        }
    }
    convertTo(otherMessage, copy = false) {
        const reader = new sshData_1.SshDataReader(copy ? buffer_1.Buffer.from(this.rawBytes) : this.rawBytes);
        otherMessage.read(reader);
        return otherMessage;
    }
}
exports.SshMessage = SshMessage;
/* @internal */
SshMessage.index = new Map();
//# sourceMappingURL=sshMessage.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionReconnectFailureMessage = exports.SshReconnectFailureReason = exports.SessionReconnectResponseMessage = exports.SessionReconnectRequestMessage = exports.SessionChannelRequestMessage = exports.ExtensionInfoMessage = exports.SessionRequestFailureMessage = exports.SessionRequestSuccessMessage = exports.SessionRequestMessage = exports.ServiceAcceptMessage = exports.ServiceRequestMessage = exports.DebugMessage = exports.UnimplementedMessage = exports.IgnoreMessage = exports.DisconnectMessage = exports.SshDisconnectReason = void 0;
const sshMessage_1 = __webpack_require__(/*! ./sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
const connectionMessages_1 = __webpack_require__(/*! ./connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
var SshDisconnectReason;
(function (SshDisconnectReason) {
    SshDisconnectReason[SshDisconnectReason["none"] = 0] = "none";
    SshDisconnectReason[SshDisconnectReason["hostNotAllowedToConnect"] = 1] = "hostNotAllowedToConnect";
    SshDisconnectReason[SshDisconnectReason["protocolError"] = 2] = "protocolError";
    SshDisconnectReason[SshDisconnectReason["keyExchangeFailed"] = 3] = "keyExchangeFailed";
    SshDisconnectReason[SshDisconnectReason["reserved"] = 4] = "reserved";
    SshDisconnectReason[SshDisconnectReason["macError"] = 5] = "macError";
    SshDisconnectReason[SshDisconnectReason["compressionError"] = 6] = "compressionError";
    SshDisconnectReason[SshDisconnectReason["serviceNotAvailable"] = 7] = "serviceNotAvailable";
    SshDisconnectReason[SshDisconnectReason["protocolVersionNotSupported"] = 8] = "protocolVersionNotSupported";
    SshDisconnectReason[SshDisconnectReason["hostKeyNotVerifiable"] = 9] = "hostKeyNotVerifiable";
    SshDisconnectReason[SshDisconnectReason["connectionLost"] = 10] = "connectionLost";
    SshDisconnectReason[SshDisconnectReason["byApplication"] = 11] = "byApplication";
    SshDisconnectReason[SshDisconnectReason["tooManyConnections"] = 12] = "tooManyConnections";
    SshDisconnectReason[SshDisconnectReason["authCancelledByUser"] = 13] = "authCancelledByUser";
    SshDisconnectReason[SshDisconnectReason["noMoreAuthMethodsAvailable"] = 14] = "noMoreAuthMethodsAvailable";
    SshDisconnectReason[SshDisconnectReason["illegalUserName"] = 15] = "illegalUserName";
})(SshDisconnectReason = exports.SshDisconnectReason || (exports.SshDisconnectReason = {}));
class DisconnectMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 1;
    }
    onRead(reader) {
        this.reasonCode = reader.readUInt32();
        this.description = reader.readString('utf8');
        if (reader.available >= 4) {
            this.language = reader.readString('ascii');
        }
        else {
            this.language = null;
        }
    }
    onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));
        writer.writeString(this.description || '', 'utf8');
        if (this.language) {
            writer.writeString(this.language, 'ascii');
        }
    }
    toString() {
        return `${super.toString()} (${SshDisconnectReason[this.reasonCode || 0]}: ${this.description})`;
    }
}
exports.DisconnectMessage = DisconnectMessage;
class IgnoreMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 2;
    }
    onRead(reader) { }
    onWrite(writer) { }
}
exports.IgnoreMessage = IgnoreMessage;
class UnimplementedMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 3;
    }
    onRead(reader) {
        this.sequenceNumber = reader.readUInt32();
    }
    onWrite(writer) {
        writer.writeUInt32(this.validateField(this.sequenceNumber, 'sequence number'));
    }
    toString() {
        return this.unimplementedMessageType
            ? `${super.toString()} (messageType=${this.unimplementedMessageType})`
            : `${super.toString()} (sequenceNumber=${this.sequenceNumber})`;
    }
}
exports.UnimplementedMessage = UnimplementedMessage;
class DebugMessage extends sshMessage_1.SshMessage {
    constructor(message) {
        super();
        this.alwaysDisplay = false;
        this.message = message;
    }
    get messageType() {
        return 4;
    }
    onRead(reader) {
        this.alwaysDisplay = reader.readBoolean();
        this.message = reader.readString('utf8');
        this.language = reader.readString('ascii');
    }
    onWrite(writer) {
        var _a, _b;
        writer.writeBoolean(this.alwaysDisplay);
        writer.writeString((_a = this.message) !== null && _a !== void 0 ? _a : '', 'utf8');
        writer.writeString((_b = this.language) !== null && _b !== void 0 ? _b : '', 'ascii');
    }
    toString() {
        return `${super.toString()}: ${this.message}`;
    }
}
exports.DebugMessage = DebugMessage;
class ServiceRequestMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 5;
    }
    onRead(reader) {
        this.serviceName = reader.readString('ascii');
    }
    onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, 'service name'), 'ascii');
    }
}
exports.ServiceRequestMessage = ServiceRequestMessage;
class ServiceAcceptMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 6;
    }
    onRead(reader) {
        this.serviceName = reader.readString('ascii');
    }
    onWrite(writer) {
        writer.writeString(this.validateField(this.serviceName, 'service name'), 'ascii');
    }
}
exports.ServiceAcceptMessage = ServiceAcceptMessage;
class SessionRequestMessage extends sshMessage_1.SshMessage {
    constructor(requestType, wantReply) {
        super();
        this.requestType = requestType;
        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;
    }
    get messageType() {
        return 80;
    }
    onRead(reader) {
        this.requestType = reader.readString('ascii');
        this.wantReply = reader.readBoolean();
    }
    onWrite(writer) {
        writer.writeString(this.validateField(this.requestType, 'request type'), 'ascii');
        writer.writeBoolean(this.wantReply);
    }
    toString() {
        return `${super.toString()} (requestType=${this.requestType})`;
    }
}
exports.SessionRequestMessage = SessionRequestMessage;
class SessionRequestSuccessMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 81;
    }
    onRead(reader) { }
    onWrite(writer) { }
}
exports.SessionRequestSuccessMessage = SessionRequestSuccessMessage;
class SessionRequestFailureMessage extends sshMessage_1.SshMessage {
    get messageType() {
        return 82;
    }
    onRead(reader) { }
    onWrite(writer) { }
}
exports.SessionRequestFailureMessage = SessionRequestFailureMessage;
class ExtensionInfoMessage extends sshMessage_1.SshMessage {
    constructor() {
        // https://tools.ietf.org/html/draft-ietf-curdle-ssh-ext-info-15
        super(...arguments);
        this.extensionInfo = {};
    }
    get messageType() {
        return 7;
    }
    onRead(reader) {
        const count = reader.readUInt32();
        this.extensionInfo = {};
        for (let i = 0; i < count; i++) {
            const key = reader.readString('ascii');
            const value = reader.readString('utf8');
            this.extensionInfo[key] = value;
        }
    }
    onWrite(writer) {
        const keys = Object.keys(this.extensionInfo);
        writer.writeUInt32(keys.length);
        for (const key of keys) {
            writer.writeString(key, 'ascii');
            writer.writeString(this.extensionInfo[key] || '', 'utf8');
        }
    }
    toString() {
        let extensionInfoDetails = '';
        for (const [key, value] of Object.entries(this.extensionInfo)) {
            if (extensionInfoDetails) {
                extensionInfoDetails += '; ';
            }
            extensionInfoDetails += key;
            if (value) {
                extensionInfoDetails += '=' + value;
            }
        }
        return `${super.toString()} (${extensionInfoDetails})`;
    }
}
exports.ExtensionInfoMessage = ExtensionInfoMessage;
ExtensionInfoMessage.serverIndicator = 'ext-info-c';
ExtensionInfoMessage.clientIndicator = 'ext-info-c';
class SessionChannelRequestMessage extends SessionRequestMessage {
    onRead(reader) {
        super.onRead(reader);
        this.senderChannel = reader.readUInt32();
        const request = new connectionMessages_1.ChannelRequestMessage();
        request.read(reader);
        this.request = request;
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));
        this.validateField(this.request, 'request message').write(writer);
    }
}
exports.SessionChannelRequestMessage = SessionChannelRequestMessage;
class SessionReconnectRequestMessage extends SessionRequestMessage {
    onRead(reader) {
        super.onRead(reader);
        this.clientReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.clientReconnectToken, 'clientReconnectToken'));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, 'lastReceivedSequenceNumber'));
    }
}
exports.SessionReconnectRequestMessage = SessionReconnectRequestMessage;
class SessionReconnectResponseMessage extends SessionRequestSuccessMessage {
    onRead(reader) {
        super.onRead(reader);
        this.serverReconnectToken = reader.readBinary();
        this.lastReceivedSequenceNumber = reader.readUInt64();
    }
    onWrite(writer) {
        super.onWrite(writer);
        writer.writeBinary(this.validateField(this.serverReconnectToken, 'serverReconnectToken'));
        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, 'lastReceivedSequenceNumber'));
    }
}
exports.SessionReconnectResponseMessage = SessionReconnectResponseMessage;
var SshReconnectFailureReason;
(function (SshReconnectFailureReason) {
    /** No reason was specified. */
    SshReconnectFailureReason[SshReconnectFailureReason["none"] = 0] = "none";
    /**
     * Reconnection failed due to an unknown server-side error.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["unknownServerFailure"] = 1] = "unknownServerFailure";
    /**
     * The session ID requested by the client for reconnection was not found among
     * the server's reconnectable sessions.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["sessionNotFound"] = 2] = "sessionNotFound";
    /**
     * The reconnect token supplied by the client was invalid when checked by the server.
     * The validation ensures that the client knows a secret key negotiated in the
     * previously connected session.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["invalidClientReconnectToken"] = 3] = "invalidClientReconnectToken";
    /**
     * The server was unable to re-send dropped messages that were requested by the client.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["serverDroppedMessages"] = 4] = "serverDroppedMessages";
    /**
     * Reconnection failed due to an unknown client-side error.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["unknownClientFailure"] = 101] = "unknownClientFailure";
    /**
     * The host key supplied by the reconnected server did not match the host key from the
     * original session; the client refused to reconnect to a different host.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["differentServerHostKey"] = 102] = "differentServerHostKey";
    /**
     * The reconnect token supplied by the server was invalid when checked by the client.
     * The validation ensures that the server knows a secret key negotiated in the
     * previously connected session.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["invalidServerReconnectToken"] = 103] = "invalidServerReconnectToken";
    /**
     * The client was unable to re-send dropped messages that were requested by the server.
     */
    SshReconnectFailureReason[SshReconnectFailureReason["clientDroppedMessages"] = 104] = "clientDroppedMessages";
})(SshReconnectFailureReason = exports.SshReconnectFailureReason || (exports.SshReconnectFailureReason = {}));
class SessionReconnectFailureMessage extends SessionRequestFailureMessage {
    onRead(reader) {
        if (reader.available > 0) {
            this.reasonCode = reader.readUInt32();
            this.description = reader.readString('utf8');
            this.language = reader.readString('ascii');
        }
    }
    onWrite(writer) {
        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));
        writer.writeString(this.description || '', 'utf8');
        writer.writeString(this.language || 'en', 'ascii');
    }
    toString() {
        return `${super.toString()} (${SshReconnectFailureReason[this.reasonCode || 0]}: ${this.description})`;
    }
}
exports.SessionReconnectFailureMessage = SessionReconnectFailureMessage;
sshMessage_1.SshMessage.index.set(1, DisconnectMessage);
sshMessage_1.SshMessage.index.set(2, IgnoreMessage);
sshMessage_1.SshMessage.index.set(3, UnimplementedMessage);
sshMessage_1.SshMessage.index.set(5, ServiceRequestMessage);
sshMessage_1.SshMessage.index.set(6, ServiceAcceptMessage);
sshMessage_1.SshMessage.index.set(7, ExtensionInfoMessage);
sshMessage_1.SshMessage.index.set(80, SessionRequestMessage);
sshMessage_1.SshMessage.index.set(81, SessionRequestSuccessMessage);
sshMessage_1.SshMessage.index.set(82, SessionRequestFailureMessage);
//# sourceMappingURL=transportMessages.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelMetrics = void 0;
/**
 * Collects cumulative measurements about a channel.
 */
class ChannelMetrics {
    /* @internal */
    constructor() {
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
    }
    /**
     * Gets the total cumulative number of bytes sent for the duration of the channel,
     * not including message framing, padding, and MAC bytes.
     */
    get bytesSent() {
        return this.bytesSentSum;
    }
    /**
     * Gets the total cumulative number of bytes received for the duration of the channel,
     * not including message framing, padding, and MAC bytes.
     */
    get bytesReceived() {
        return this.bytesReceivedSum;
    }
    /* @internal */
    addBytesSent(count) {
        this.bytesSentSum += count;
    }
    /* @internal */
    addBytesReceived(count) {
        this.bytesReceivedSum += count;
    }
    toString() {
        return `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; `;
    }
}
exports.ChannelMetrics = ChannelMetrics;
//# sourceMappingURL=channelMetrics.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionContour.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionContour = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const queue_1 = __webpack_require__(/*! ../util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
const semaphore_1 = __webpack_require__(/*! ../util/semaphore */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js");
/**
 * Collects session metrics over time, producing an outline of the timing, speed,
 * and quantity of bytes sent/received during the session.
 *
 * Metrics are recorded across a number of equal time intervals. As the session time
 * increases, intervals are expanded to keep the number of intervals under the configured
 * maximum. Each expansion doubles the length of all intervals, while combining the metrics
 * within each pair of combined intervals. Therefore, a longer session has longer intervals
 * and less-granular metrics. In this way, the memory usage (and serialized size) of the
 * session contour remains roughly constant regardless of the length of the session.
 *
 * Metrics exposed via the collection properties on this class may be momentarily
 * inconsistent (but will not throw exceptions) if continued session operation causes
 * intervals to be expanded while the data is being read concurrently. To avoid any
 * inconsistency, hold a lock on the <see cref="SessionContour" /> instance while reading
 * data. (Or wait until the session ends.)
 *
 * A session contour can be exported in a compact form suitable for logging or telemetry.
 * Use the code in `SessionContour.kql` to chart a session contour in Azure Data Explorer.
 */
class SessionContour {
    /**
     * Creates a new instance of the `SessionContour` class.
     *
     * @param maxIntervals Maximum number of metric intervals to record,
     * defaults to 256. Must be a power of two.
     */
    constructor(maxIntervals = 256) {
        /** Current size of the metrics interval, in milliseconds. */
        this.intervalMs = SessionContour.initialInterval;
        /** Number of intervals for which metrics have been recorded. */
        this.count = 0;
        this.updateQueue = new queue_1.Queue();
        this.updateSemaphore = new semaphore_1.Semaphore(0);
        this.disposed = false;
        if (maxIntervals < 2 || (maxIntervals & (maxIntervals - 1)) !== 0) {
            throw new Error('Contour intervals must be a power of two.');
        }
        this.maxIntervals = maxIntervals;
        this.intervalBytesSent = new Array(maxIntervals);
        this.intervalBytesReceived = new Array(maxIntervals);
        this.intervalLatencyMin = new Array(maxIntervals);
        this.intervalLatencyMax = new Array(maxIntervals);
        this.intervalLatencySum = new Array(maxIntervals);
        this.intervalLatencyCount = new Array(maxIntervals);
        this.intervalLatencyAvg = new Array(maxIntervals);
        this.intervalBytesSent.fill(0);
        this.intervalBytesReceived.fill(0);
        this.intervalLatencyMin.fill(0);
        this.intervalLatencyMax.fill(0);
        this.intervalLatencySum.fill(0);
        this.intervalLatencyCount.fill(0);
        this.intervalLatencyAvg.fill(0);
    }
    /**
     * Gets the current number of contour intervals with recorded metrics. This is always
     * less than `maxIntervals`.
     */
    get intervalCount() {
        return this.count;
    }
    /**
     * Gets the current time span of each contour interval, in milliseconds. This interval time
     * span is doubled as necesary such that the entire duration of the session is always covered
     * by fewer intervals than the maximum.
     */
    get interval() {
        return this.intervalMs;
    }
    /**
     * Gets the total number of bytes sent for each interval during the session,
     * including all channels and non-channel protocol messages, and including message
     * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
     */
    get bytesSent() {
        return this.intervalBytesSent.slice(0, this.count);
    }
    /**
     * Gets the total number of bytes received for each interval during the session,
     * including all channels and non-channel protocol messages, and including message
     * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.
     */
    get bytesReceived() {
        return this.intervalBytesReceived.slice(0, this.count);
    }
    /**
     * Gets the minimum recorded round-trip connection latency between client and server for
     * each interval during the session. The number of values is equal to `intervalCount`.
     */
    get latencyMinMs() {
        return this.intervalLatencyMin.slice(0, this.count);
    }
    /**
     * Gets the maximum recorded round-trip connection latency between client and server for
     * each interval during the session. The number of values is equal to `intervalCount`.
     */
    get latencyMaxMs() {
        return this.intervalLatencyMax.slice(0, this.count);
    }
    /**
     * Gets the average recorded round-trip connection latency between client and server for
     * each interval during the session. The number of values is equal to `intervalCount`.
     */
    get latencyAverageMs() {
        return this.intervalLatencyAvg.slice(0, this.count);
    }
    onMessageSent(e) {
        this.updateQueue.enqueue({
            time: e.time,
            bytesSent: e.size,
        });
        this.updateSemaphore.tryRelease();
    }
    onMessageReceived(e) {
        this.updateQueue.enqueue({
            time: e.time,
            bytesReceived: e.size,
        });
        this.updateSemaphore.tryRelease();
    }
    onLatencyUpdated(e) {
        this.updateQueue.enqueue(e);
        this.updateSemaphore.tryRelease();
    }
    onSessionClosed() {
        this.updateSemaphore.tryRelease();
    }
    /**
     * Starts collecting session metrics, and processes the metrics in a backgroud loop until
     * cancelled or until the session is closed or the `SessionContour` instance is disposed.
     */
    async collectMetrics(sessionMetrics, cancellation) {
        if (!sessionMetrics)
            throw new TypeError('A session metrics object is required.');
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        const eventRegistrations = [];
        eventRegistrations.push(sessionMetrics.onMessageSent(this.onMessageSent.bind(this)));
        eventRegistrations.push(sessionMetrics.onMessageReceived(this.onMessageReceived.bind(this)));
        eventRegistrations.push(sessionMetrics.onLatencyUpdated(this.onLatencyUpdated.bind(this)));
        eventRegistrations.push(sessionMetrics.onSessionClosed(this.onSessionClosed.bind(this)));
        try {
            while (!(cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {
                try {
                    await this.updateSemaphore.wait(cancellation);
                }
                catch (e) {
                    // The semaphore was disposed.
                    break;
                }
                const update = this.updateQueue.dequeue();
                if (!update) {
                    // The semaphore was released without enqueueing an update item.
                    break;
                }
                const intervalIndex = this.updateInterval(update.time);
                if (update.bytesSent) {
                    this.intervalBytesSent[intervalIndex] += update.bytesSent;
                }
                if (update.bytesReceived) {
                    this.intervalBytesReceived[intervalIndex] += update.bytesReceived;
                }
                const latency = update.latency;
                if (latency) {
                    if (!this.intervalLatencyMin[intervalIndex] ||
                        latency < this.intervalLatencyMin[intervalIndex]) {
                        this.intervalLatencyMin[intervalIndex] = latency;
                    }
                    if (!this.intervalLatencyMax[intervalIndex] ||
                        latency > this.intervalLatencyMax[intervalIndex]) {
                        this.intervalLatencyMax[intervalIndex] = latency;
                    }
                    this.intervalLatencySum[intervalIndex] += latency;
                    this.intervalLatencyCount[intervalIndex]++;
                    this.intervalLatencyAvg[intervalIndex] =
                        this.intervalLatencySum[intervalIndex] / this.intervalLatencyCount[intervalIndex];
                }
            }
            if (this.disposed) {
                this.updateSemaphore.dispose();
            }
        }
        finally {
            for (const eventRegistration of eventRegistrations) {
                eventRegistration.dispose();
            }
        }
    }
    updateInterval(time) {
        let intervalIndex = Math.floor(time / this.intervalMs);
        if (intervalIndex >= this.intervalCount) {
            // Expand as needed to accomodate the current time interval.
            while (intervalIndex >= this.maxIntervals) {
                this.expandIntervals();
                intervalIndex = Math.floor(time / this.intervalMs);
            }
            this.count = intervalIndex + 1;
        }
        return intervalIndex;
    }
    expandIntervals() {
        const combineLatency = (a, b, f) => a === 0 ? b : b === 0 ? a : f(a, b);
        const halfMaxIntervals = this.maxIntervals / 2;
        for (let i = 0; i < halfMaxIntervals; i++) {
            const iA = 2 * i;
            const iB = 2 * i + 1;
            this.intervalBytesSent[i] = this.intervalBytesSent[iA] + this.intervalBytesSent[iB];
            this.intervalBytesReceived[i] =
                this.intervalBytesReceived[iA] + this.intervalBytesReceived[iB];
            this.intervalLatencyMin[i] = combineLatency(this.intervalLatencyMin[iA], this.intervalLatencyMin[iB], Math.min);
            this.intervalLatencyMax[i] = combineLatency(this.intervalLatencyMax[iA], this.intervalLatencyMax[iB], Math.max);
            this.intervalLatencySum[i] = this.intervalLatencySum[iA] + this.intervalLatencySum[iB];
            const countSum = this.intervalLatencyCount[iA] + this.intervalLatencyCount[iB];
            this.intervalLatencyCount[i] = countSum;
            this.intervalLatencyAvg[i] =
                countSum === 0 ? 0 : this.intervalLatencySum[i] / this.intervalLatencyCount[i];
        }
        this.intervalBytesSent.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalBytesReceived.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMin.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyMax.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencySum.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyCount.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalLatencyAvg.fill(0, halfMaxIntervals, this.maxIntervals);
        this.intervalMs *= 2;
    }
    dispose() {
        this.disposed = true;
        // The semaphore will be disposed after all remaining updates have been processed.
        this.updateSemaphore.tryRelease();
    }
    /**
     * Serializes the session contour into a compact form suitable for recording in
     * logs or telemetry.
     *
     * This compact serialization format uses one byte per metric per interval, so there is
     * some loss of precision, but generally not so much that it affects a visualization. A
     * scale factor for each metric is automatically determined and included in the serialized
     * header. The size of the serialized encoded data will be a little under 7 bytes per
     * interval. With the default interval maximum (256), that comes out to less than 1.75 KB.
     *
     * Use the code in `SessionContour.kql` to decode and chart this output in
     * Azure Data Explorer.
     */
    export() {
        // Time and value scales are in log2 form, determined based on the maximum
        // value in each series. This allows for a reasonable range of precision for each
        // value (with byte values ranging from 0-255). For example a max latency in the
        // 500ms range will get a scale factor of 1 (because ceil(log2(500/255)) = 1), so
        // each serialized value (0-255) is half the actual value (0-510).
        const getScale = (values) => Math.max(0, Math.ceil(Math.log2(Math.max(...values) / 255)));
        const applyReverseScale = (value, scale) => Math.round(value / Math.pow(2, scale));
        const bytes = Buffer.alloc(3 + (2 + this.intervalCount) * 5);
        const version = 1;
        const timeScale = Math.log2(this.interval / SessionContour.initialInterval);
        bytes[0] = version;
        bytes[1] = 5; // Number of metrics per interval
        bytes[2] = timeScale;
        bytes[3] = getScale(this.latencyMinMs);
        bytes[4] = getScale(this.latencyMaxMs);
        bytes[5] = getScale(this.latencyAverageMs);
        bytes[6] = getScale(this.bytesSent);
        bytes[7] = getScale(this.bytesReceived);
        bytes[8] = SessionMetric.latencyMin;
        bytes[9] = SessionMetric.latencyMax;
        bytes[10] = SessionMetric.latencyAverage;
        bytes[11] = SessionMetric.bytesSent;
        bytes[12] = SessionMetric.bytesReceived;
        for (let i = 0; i < this.intervalCount; i++) {
            const offset = 13 + 5 * i;
            bytes[offset + 0] = applyReverseScale(this.intervalLatencyMin[i], bytes[3]);
            bytes[offset + 1] = applyReverseScale(this.intervalLatencyMax[i], bytes[4]);
            bytes[offset + 2] = applyReverseScale(this.intervalLatencyAvg[i], bytes[5]);
            bytes[offset + 3] = applyReverseScale(this.intervalBytesSent[i], bytes[6]);
            bytes[offset + 4] = applyReverseScale(this.intervalBytesReceived[i], bytes[7]);
        }
        return bytes.toString('base64');
    }
    /**
     * Deserializes a session contour that was previously exported.
     *
     * Due to loss in precision, some values in the deserialized contour will not exactly match
     * the original, but they will be close.
     */
    static import(contourBase64) {
        const bytes = Buffer.from(contourBase64, 'base64');
        if (bytes.length < 3) {
            throw new Error('Invalid session contour string.');
        }
        const version = bytes[0];
        const metricsPerInterval = bytes[1];
        const timeScale = bytes[2];
        if (version !== 1) {
            throw new Error(`Unsupported session contour version: ${version}`);
        }
        const intervalCount = (bytes.length - 3) / metricsPerInterval - 2;
        if (intervalCount < 1 || bytes.length !== 3 + metricsPerInterval * (intervalCount + 2)) {
            throw new Error('Incomplete session contour string.');
        }
        const maxIntervals = Math.pow(2, Math.ceil(Math.log2(intervalCount)));
        const sessionContour = new SessionContour(maxIntervals);
        sessionContour.intervalMs = Math.pow(2, timeScale) * SessionContour.initialInterval;
        sessionContour.count = intervalCount;
        const scales = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
            scales[m] = Math.pow(2, bytes[3 + m]);
        }
        const ids = new Array(metricsPerInterval);
        for (let m = 0; m < metricsPerInterval; m++) {
            ids[m] = bytes[3 + metricsPerInterval + m];
        }
        for (let i = 0; i < intervalCount; i++) {
            const offset = 3 + (2 + i) * metricsPerInterval;
            for (let m = 0; m < metricsPerInterval; m++) {
                switch (ids[m]) {
                    case SessionMetric.latencyMin:
                        sessionContour.intervalLatencyMin[i] = bytes[offset + m] * scales[m];
                        break;
                    case SessionMetric.latencyMax:
                        sessionContour.intervalLatencyMax[i] = bytes[offset + m] * scales[m];
                        break;
                    case SessionMetric.latencyAverage:
                        sessionContour.intervalLatencyAvg[i] = sessionContour.intervalLatencySum[i] =
                            bytes[offset + m] * scales[m];
                        sessionContour.intervalLatencyCount[i] = bytes[offset + m] === 0 ? 0 : 1;
                        break;
                    case SessionMetric.bytesSent:
                        sessionContour.intervalBytesSent[i] = bytes[offset + m] * scales[m];
                        break;
                    case SessionMetric.bytesReceived:
                        sessionContour.intervalBytesReceived[i] = bytes[offset + m] * scales[m];
                        break;
                    default:
                        // Ignore any unknown metrics
                        break;
                }
            }
        }
        return sessionContour;
    }
}
exports.SessionContour = SessionContour;
SessionContour.initialInterval = 1000; // 1 second (in milliseconds)
var SessionMetric;
(function (SessionMetric) {
    SessionMetric[SessionMetric["none"] = 0] = "none";
    SessionMetric[SessionMetric["latencyMin"] = 1] = "latencyMin";
    SessionMetric[SessionMetric["latencyMax"] = 2] = "latencyMax";
    SessionMetric[SessionMetric["latencyAverage"] = 3] = "latencyAverage";
    SessionMetric[SessionMetric["bytesSent"] = 11] = "bytesSent";
    SessionMetric[SessionMetric["bytesReceived"] = 12] = "bytesReceived";
})(SessionMetric || (SessionMetric = {}));
//# sourceMappingURL=sessionContour.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionMetrics = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const trace_1 = __webpack_require__(/*! ../trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
/**
 * Collects current and cumulative measurements about a session.
 */
class SessionMetrics {
    /* @internal */
    constructor() {
        this.startTime = 0;
        this.messagesSentCount = 0;
        this.messagesReceivedCount = 0;
        this.bytesSentSum = 0;
        this.bytesReceivedSum = 0;
        this.reconnectionsCount = 0;
        this.currentLatency = 0;
        this.minLatency = 0;
        this.maxLatency = 0;
        this.latencySum = 0;
        this.latencyCount = 0;
        this.messageSentEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageSent = this.messageSentEmitter.event;
        this.messageReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onMessageReceived = this.messageReceivedEmitter.event;
        this.latencyUpdatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onLatencyUpdated = this.latencyUpdatedEmitter.event;
        this.sessionClosedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onSessionClosed = this.sessionClosedEmitter.event;
        if (typeof performance === 'object' && typeof performance.now === 'function') {
            Object.defineProperty(this, 'time', { get: this.browserTime });
        }
        else if (typeof process === 'object' && typeof process.hrtime === 'function') {
            Object.defineProperty(this, 'time', { get: this.nodejsTime });
        }
        this.startTime = this.time;
    }
    /**
     * Gets the current stopwatch value in milliseconds (possibly including fractional milliseconds),
     * used for measuring latency.
     */
    /* @internal */
    get time() {
        // The SessionMetrics constructor may replace this with either of the below
        // high-precision implementations, depending on availability of platform APIs.
        return Date.now() - this.startTime;
    }
    browserTime() {
        // Use the browser high-resolution time API.
        // Note the precision may be reduced for pricacy depending on browser and page policy.
        return performance.now() - this.startTime;
    }
    nodejsTime() {
        // Use Node.js high-resolution time API.
        const [s, ns] = process.hrtime();
        return s * 1000 + ns / 1000000 - this.startTime;
    }
    /**
     * Gets the total cumulative number of messages sent for the duration of the session,
     * including all channels and non-channel protocol messages.
     */
    get messagesSent() {
        return this.messagesSentCount;
    }
    /**
     * Gets the total cumulative number of messages received for the duration of the session,
     * including all channels and non-channel protocol messages.
     */
    get messagesReceived() {
        return this.messagesReceivedCount;
    }
    /**
     * Gets the total cumulative number of bytes sent for the duration of the session,
     * including all channels and non-channel protocol messages, and including message
     * framing, padding, and MAC bytes.
     */
    get bytesSent() {
        return this.bytesSentSum;
    }
    /**
     * Gets the total cumulative number of bytes received for the duration of the session,
     * including all channels and non-channel protocol messages, and including message
     * framing, padding, and MAC bytes.
     */
    get bytesReceived() {
        return this.bytesReceivedSum;
    }
    /**
     * Gets the number of times the session has reconnected.
     * </summary>
     * <remarks>
     * Reconnection requires both sides to support the
     * <see cref="SshProtocolExtensionNames.SessionReconnect" /> protocol extension.
     */
    get reconnections() {
        return this.reconnectionsCount;
    }
    /**
     * Gets the average measured round-trip connection latency between client and server
     * over the duration of the session, in milliseconds.
     * </summary>
     * <remarks>
     * Latency measurement requires both sides to support the
     * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
     * If not supported, this Sum will be 0.
     */
    get latencyAverageMs() {
        return this.latencyCount === 0 ? 0 : this.latencySum / this.latencyCount;
    }
    /**
     * Gets the minimum measured round-trip connection latency between client and server
     * over the duration of the session, in milliseconds.
     * </summary>
     * <remarks>
     * Latency measurement requires both sides to support the
     * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
     * If not supported, this Sum will be 0.
     */
    get latencyMinMs() {
        return this.minLatency;
    }
    /**
     * Gets the maximum measured round-trip connection latency between client and server
     * over the duration of the session, in milliseconds.
     * </summary>
     * <remarks>
     * Latency measurement requires both sides to support the
     * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
     * If not supported, this Sum will be 0.
     */
    get latencyMaxMs() {
        return this.maxLatency;
    }
    /**
     * Gets the most recent measurement of round-trip connection latency between client and
     * server, in milliseconds.
     * </summary>
     * <remarks>
     * Latency measurement requires both sides to support the
     * <see cref="SshProtocolExtensionNames.SessionLatency" /> protocol extension.
     * If not supported or the session is not currently connected, this Sum will be 0.
     */
    get latencyCurrentMs() {
        return this.currentLatency;
    }
    /* @internal */
    addMessageSent(size) {
        this.messagesSentCount++;
        this.bytesSentSum += size;
        this.messageSentEmitter.fire({ time: this.time, size });
    }
    /* @internal */
    addMessageReceived(size) {
        this.messagesReceivedCount++;
        this.bytesReceivedSum += size;
        this.messageReceivedEmitter.fire({ time: this.time, size });
    }
    /* @internal */
    addReconnection() {
        this.reconnectionsCount++;
    }
    /* @internal */
    updateLatency(latencyMs, trace) {
        if (latencyMs < 0) {
            if (trace) {
                trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.metricsError, `Measured latency was negative: ${latencyMs} us`);
            }
            return;
        }
        this.currentLatency = latencyMs;
        if (latencyMs === 0) {
            // Disconnected.
            return;
        }
        if (this.minLatency === 0 || latencyMs < this.minLatency) {
            this.minLatency = latencyMs;
        }
        if (this.maxLatency === 0 || latencyMs > this.maxLatency) {
            this.maxLatency = latencyMs;
        }
        // Enable computing the average.
        this.latencySum += latencyMs;
        this.latencyCount++;
        this.latencyUpdatedEmitter.fire({ time: this.time, latency: latencyMs });
    }
    /* @internal */
    close() {
        this.currentLatency = 0;
        this.sessionClosedEmitter.fire();
    }
    toString() {
        let s = `Messages S/R: ${this.messagesSent} / ${this.messagesReceived}; ` +
            `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; ` +
            `Reconnections: ${this.reconnections}; `;
        // Show extra precision for a low-latency connection.
        const precision = this.minLatency >= 10 ? 1 : this.minLatency >= 1 ? 10 : 100;
        if (this.maxLatency > 0) {
            const min = Math.round(this.minLatency * precision) / precision;
            const avg = Math.round((this.latencySum / this.latencyCount) * precision) / precision;
            const max = Math.round(this.maxLatency * precision) / precision;
            s += `Latency Min-Avg-Max: ${min} - ${avg} - ${max} ms; `;
        }
        if (this.currentLatency > 0) {
            const current = Math.round(this.currentLatency * precision) / precision;
            s += `Current Latency: ${current} ms; `;
        }
        return s;
    }
}
exports.SessionMetrics = SessionMetrics;
//# sourceMappingURL=sessionMetrics.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/multiChannelStream.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiChannelStream = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const sshChannel_1 = __webpack_require__(/*! ./sshChannel */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js");
const sshStream_1 = __webpack_require__(/*! ./sshStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js");
const sshSession_1 = __webpack_require__(/*! ./sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
const sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const connectionMessages_1 = __webpack_require__(/*! ./messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const sshReportProgressEventArgs_1 = __webpack_require__(/*! ./events/sshReportProgressEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js");
/**
 * Multiplexes multiple virtual streams (channels) over a single transport stream, using the
 * SSH protocol while providing a simplified interface without any encryption or authentication.
 *
 * This class is a complement to `SecureStream`, which provides only the encryption and
 * authentication functions of SSH.
 *
 * To communicate over multiple channels, two sides first establish a transport stream
 * over a pipe, socket, or anything else. Then one side accepts a channel while the
 * other side opens a channel. Either side can both open and accept channels over the
 * same transport stream, as long as the other side does the complementary action.
 */
class MultiChannelStream {
    /**
     * Creates a new multi-channel stream over an underlying transport stream.
     * @param transportStream Stream that is used to multiplex all the channels.
     */
    constructor(transportStream) {
        this.transportStream = transportStream;
        this.disposed = false;
        this.disposables = [];
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        /**
         * Event that is raised to report connection progress.
         *
         * See `Progress` for a description of the different progress events that can be reported.
         */
        this.onReportProgress = this.reportProgressEmitter.event;
        /**
         * Gets or sets the maximum window size for channels within the multi-channel stream.
         * @see `SshChannel.maxWindowSize`
         */
        this.channelMaxWindowSize = sshChannel_1.SshChannel.defaultMaxWindowSize;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        if (!transportStream)
            throw new TypeError('transportStream is required.');
        const noSecurityConfig = new sshSessionConfiguration_1.SshSessionConfiguration(false);
        this.session = new sshSession_1.SshSession(noSecurityConfig);
        this.session.onReportProgress((args) => this.raiseReportProgress(args.progress, args.sessionNumber), this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
        this.session.onChannelOpening(this.onSessionChannelOpening, this, this.disposables);
    }
    get trace() {
        return this.session.trace;
    }
    set trace(trace) {
        this.session.trace = trace;
    }
    raiseReportProgress(progress, sessionNumber) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, sessionNumber);
        this.reportProgressEmitter.fire(args);
    }
    get isClosed() {
        return this.disposed || this.session.isClosed;
    }
    /**
     * Initiates the SSH session over the transport stream by exchanging initial messages with the
     * remote peer. Waits for the protocol version exchange and key exchange. Additional message
     * processing is kicked off as a background promise chain.
     * @param cancellation optional cancellation token.
     */
    async connect(cancellation) {
        await this.session.connect(this.transportStream, cancellation);
    }
    /**
     * Asynchronously waits for the other side to open a channel.
     * @param channelType optional channel type
     * @param cancellation optional cancellation token.
     */
    async acceptChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const channel = await this.session.acceptChannel(channelType, cancellation);
        return channel;
    }
    /**
     * Asynchronously waits for the other side to open a channel.
     * @param channelType optional channel type
     * @param cancellation optional cancellation token.
     */
    async acceptStream(channelType, cancellation) {
        return this.createStream(await this.acceptChannel(channelType, cancellation));
    }
    /**
     * Opens a channel and asynchronously waits for the other side to accept it.
     * @param channelType optional channel type
     * @param cancellation optional cancellation token.
     */
    async openChannel(channelType, cancellation) {
        await this.session.connect(this.transportStream, cancellation);
        const openMessage = new connectionMessages_1.ChannelOpenMessage();
        openMessage.channelType = channelType !== null && channelType !== void 0 ? channelType : sshChannel_1.SshChannel.sessionChannelType;
        openMessage.maxWindowSize = this.channelMaxWindowSize;
        const channel = await this.session.openChannel(openMessage, null, cancellation);
        return channel;
    }
    /**
     * Opens a channel and asynchronously waits for the other side to accept it.
     * @param channelType optional channel type
     * @param cancellation optional cancellation token.
     */
    async openStream(channelType, cancellation) {
        return this.createStream(await this.openChannel(channelType, cancellation));
    }
    /**
     * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
     */
    createStream(channel) {
        return new sshStream_1.SshStream(channel);
    }
    /**
     * Connects, waits until the session closes or `cancellation` is cancelled, and then disposes the
     * session and the transport stream.
     * @param cancellation optional cancellation token.
     */
    async connectAndRunUntilClosed(cancellation) {
        const disposables = [];
        const sessionClosedPromise = new Promise((resolve, reject) => {
            cancellation === null || cancellation === void 0 ? void 0 : cancellation.onCancellationRequested(reject, null, disposables);
            this.session.onClosed(resolve, null, disposables);
        });
        try {
            await this.connect(cancellation);
            await sessionClosedPromise;
        }
        finally {
            disposables.forEach((d) => d.dispose());
            await this.close();
        }
    }
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.session.dispose();
            this.unsubscribe();
            try {
                if (this.transportStream)
                    this.transportStream.close().catch((e) => {
                        this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
                    });
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
            }
        }
    }
    async close() {
        if (!this.disposed) {
            this.disposed = true;
            await this.session.close(transportMessages_1.SshDisconnectReason.none, 'SshSession disposed');
            this.session.dispose();
            this.unsubscribe();
            await this.transportStream.close();
        }
    }
    onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
    }
    onSessionChannelOpening(e) {
        if (e.isRemoteRequest) {
            e.channel.maxWindowSize = this.channelMaxWindowSize;
        }
        this.channelOpeningEmitter.fire(e);
    }
    unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
    }
}
exports.MultiChannelStream = MultiChannelStream;
//# sourceMappingURL=multiChannelStream.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PipeExtensions = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const connectionMessages_1 = __webpack_require__(/*! ./messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
/**
 * Extension methods for piping sessions and channels.
 *
 * Note this class is not exported from the package. Instead, the piping APIs are exposed via
 * public methods on the `SshSession` and `SshChannel` classes. See those respective methods
 * for API documentation.
 */
class PipeExtensions {
    static async pipeSession(session, toSession) {
        if (!session)
            throw new TypeError('Session is required.');
        if (!toSession)
            throw new TypeError('Target session is required');
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        session.onRequest((e) => {
            e.responsePromise = PipeExtensions.forwardSessionRequest(e, toSession, e.cancellation);
        });
        toSession.onRequest((e) => {
            e.responsePromise = PipeExtensions.forwardSessionRequest(e, session, e.cancellation);
        });
        session.onChannelOpening((e) => {
            if (e.isRemoteRequest) {
                e.openingPromise = PipeExtensions.forwardChannel(e, toSession, e.cancellation);
            }
        });
        toSession.onChannelOpening((e) => {
            if (e.isRemoteRequest) {
                e.openingPromise = PipeExtensions.forwardChannel(e, session, e.cancellation);
            }
        });
        session.onClosed((e) => {
            endCompletion.resolve(PipeExtensions.forwardSessionClose(toSession, e));
        });
        toSession.onClosed((e) => {
            endCompletion.resolve(PipeExtensions.forwardSessionClose(session, e));
        });
        const endPromise = await endCompletion.promise;
        await endPromise;
    }
    static async pipeChannel(channel, toChannel) {
        if (!channel)
            throw new TypeError('Channel is required.');
        if (!toChannel)
            throw new TypeError('Target channel is required');
        const endCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        let closed = false;
        channel.onRequest((e) => {
            e.responsePromise = PipeExtensions.forwardChannelRequest(e, toChannel, e.cancellation);
        });
        toChannel.onRequest((e) => {
            e.responsePromise = PipeExtensions.forwardChannelRequest(e, channel, e.cancellation);
        });
        channel.onDataReceived((data) => {
            void PipeExtensions.forwardData(channel, toChannel, data).catch();
        });
        toChannel.onDataReceived((data) => {
            void PipeExtensions.forwardData(toChannel, channel, data).catch();
        });
        channel.onEof(() => {
            void PipeExtensions.forwardData(channel, toChannel, buffer_1.Buffer.alloc(0)).catch();
        });
        toChannel.onEof(() => {
            void PipeExtensions.forwardData(toChannel, channel, buffer_1.Buffer.alloc(0)).catch();
        });
        channel.onExtendedDataReceived((data) => {
            void PipeExtensions.forwardExtendedData(channel, toChannel, data.dataTypeCode, data.data).catch();
        });
        toChannel.onExtendedDataReceived((data) => {
            void PipeExtensions.forwardExtendedData(toChannel, channel, data.dataTypeCode, data.data).catch();
        });
        channel.onClosed((e) => {
            if (!closed) {
                closed = true;
                endCompletion.resolve(PipeExtensions.forwardChannelClose(channel, toChannel, e));
            }
        });
        toChannel.onClosed((e) => {
            if (!closed) {
                closed = true;
                endCompletion.resolve(PipeExtensions.forwardChannelClose(toChannel, channel, e));
            }
        });
        const endTask = await endCompletion.promise;
        await endTask;
    }
    static async forwardSessionRequest(e, toSession, cancellation) {
        // `SshSession.requestResponse()` always set `wantReply` to `true` internally and waits for a
        // response, but since the message buffer is cached the updated `wantReply` value is not sent.
        // Anyway, it's better to forward a no-reply message as another no-reply message, using
        // `SshSession.request()` instead.
        if (!e.request.wantReply) {
            return toSession
                .request(e.request, cancellation)
                .then(() => new transportMessages_1.SessionRequestSuccessMessage());
        }
        return toSession.requestResponse(e.request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
    }
    static async forwardChannel(e, toSession, cancellation) {
        var _a;
        try {
            const toChannel = await toSession.openChannel(e.request, null, cancellation);
            void PipeExtensions.pipeChannel(e.channel, toChannel).catch();
            return new connectionMessages_1.ChannelOpenConfirmationMessage();
        }
        catch (err) {
            if (!(err instanceof Error))
                throw err;
            const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
            if (err instanceof errors_1.SshChannelError) {
                failureMessage.reasonCode = (_a = err.reason) !== null && _a !== void 0 ? _a : connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
            }
            else {
                failureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.connectFailed;
            }
            failureMessage.description = err.message;
            return failureMessage;
        }
    }
    static async forwardChannelRequest(e, toChannel, cancellation) {
        e.request.recipientChannel = toChannel.remoteChannelId;
        const result = await toChannel.request(e.request, cancellation);
        return result ? new connectionMessages_1.ChannelSuccessMessage() : new connectionMessages_1.ChannelFailureMessage();
    }
    static async forwardSessionClose(session, e) {
        var _a;
        return session.close(e.reason, e.message, (_a = e.error) !== null && _a !== void 0 ? _a : undefined);
    }
    static async forwardData(channel, toChannel, data) {
        // Make a copy of the buffer before sending because SshChannel.send() is an async operation
        // (it may need to wait for the window to open), while the buffer will be re-used for the
        // next message as sson as this task yields.
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise = toChannel.send(buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise;
    }
    static async forwardExtendedData(channel, toChannel, dataTypeCode, data) {
        // Make a copy of the buffer before sending because SshChannel.send() is an async operation
        // (it may need to wait for the window to open), while the buffer will be re-used for the
        // next message as sson as this task yields.
        const buffer = buffer_1.Buffer.alloc(data.length);
        data.copy(buffer);
        const promise = toChannel.sendExtendedData(dataTypeCode, buffer, vscode_jsonrpc_1.CancellationToken.None);
        channel.adjustWindow(buffer.length);
        return promise;
    }
    static async forwardChannelClose(fromChannel, toChannel, e) {
        const message = `Piping channel closure.\n` +
            `Source: ${fromChannel.session} ${fromChannel}\n` +
            `Destination: ${toChannel.session} ${toChannel}\n`;
        toChannel.session.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.channelClosed, message);
        if (e.error) {
            toChannel.close(e.error);
            return Promise.resolve();
        }
        else if (e.exitSignal) {
            return toChannel.close(e.exitSignal, e.errorMessage);
        }
        else if (typeof e.exitStatus === 'number') {
            return toChannel.close(e.exitStatus);
        }
        else {
            return toChannel.close();
        }
    }
}
exports.PipeExtensions = PipeExtensions;
//# sourceMappingURL=pipeExtensions.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/progress.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/progress.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Progress = void 0;
/**
 * Connection progress
 */
var Progress;
(function (Progress) {
    // Client connection to relay
    Progress["OpeningClientConnectionToRelay"] = "OpeningClientConnectionToRelay";
    Progress["OpenedClientConnectionToRelay"] = "OpenedClientConnectionToRelay";
    // Host connection to relay
    Progress["OpeningHostConnectionToRelay"] = "OpeningHostConnectionToRelay";
    Progress["OpenedHostConnectionToRelay"] = "OpenedHostConnectionToRelay";
    // SSH Session Connection
    Progress["OpeningSshSessionConnection"] = "OpeningSshSessionConnection";
    Progress["OpenedSshSessionConnection"] = "OpenedSshSessionConnection";
    Progress["StartingProtocolVersionExchange"] = "StartingProtocolVersionExchange";
    Progress["CompletedProtocolVersionExchange"] = "CompletedProtocolVersionExchange";
    Progress["StartingKeyExchange"] = "StartingKeyExchange";
    Progress["CompletedKeyExchange"] = "CompletedKeyExchange";
    Progress["StartingSessionAuthentication"] = "StartingSessionAuthentication";
    Progress["CompletedSessionAuthentication"] = "CompletedSessionAuthentication";
})(Progress = exports.Progress || (exports.Progress = {}));
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/secureStream.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecureStream = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const streams_1 = __webpack_require__(/*! ./streams */ "../../node_modules/@microsoft/dev-tunnels-ssh/streams.js");
const sshStream_1 = __webpack_require__(/*! ./sshStream */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js");
const sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const sshClientSession_1 = __webpack_require__(/*! ./sshClientSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js");
const sshServerSession_1 = __webpack_require__(/*! ./sshServerSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const stream_1 = __webpack_require__(/*! stream */ "stream");
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
/**
 * Establishes an end-to-end encrypted two-way authenticated data stream over an underlying
 * transport stream, using the SSH protocol but providing simplified interface that is limited to
 * a single duplex stream (channel).
 *
 * This class is a complement to `MultiChannelStream`, which provides only the channel-multiplexing
 * functions of SSH.
 *
 * To establish a secure connection, the two sides first establish an insecure transport stream
 * over a pipe, socket, or anything else. Then they encrypt and authenticate the connection
 * before beginning to send and receive data.
 */
class SecureStream extends stream_1.Duplex {
    /**
     * Creates a new encrypted and authenticated stream over an underlying transport stream.
     * @param transportStream Stream that is used to multiplex all the channels.
     * @param credentials Client or server credentials for authenticating the secure connection.
     * @param reconnectableSessions Optional parameter that enables the stream to be reconnected
     * with a new transport stream after a temporary disconnection. For a stream client it is
     * a boolean value; for a stream server it must be an array.
     */
    constructor(transportStream, credentials, reconnectableSessions) {
        super({
            write(chunk, encoding, cb) {
                this.connectCompletion.promise.then((stream) => {
                    if (!stream) {
                        cb(new errors_1.ObjectDisposedError('SecureStream'));
                    }
                    else {
                        // eslint-disable-next-line no-underscore-dangle
                        stream._write(chunk, encoding, cb);
                    }
                }, cb);
            },
            writev(chunks, cb) {
                this.connectCompletion.promise.then((stream) => {
                    if (!stream) {
                        cb(new errors_1.ObjectDisposedError('SecureStream'));
                    }
                    else {
                        // eslint-disable-next-line no-underscore-dangle
                        stream._writev(chunks, cb);
                    }
                }, cb);
            },
            final(cb) {
                this.connectCompletion.promise.then((stream) => {
                    if (!stream) {
                        cb(new errors_1.ObjectDisposedError('SecureStream'));
                    }
                    else {
                        // eslint-disable-next-line no-underscore-dangle
                        stream._final(cb);
                    }
                }, cb);
            },
            read(size) {
                this.connectCompletion.promise.then((stream) => {
                    if (!stream) {
                        this.push(null); // EOF
                    }
                    else {
                        // eslint-disable-next-line no-underscore-dangle
                        stream._read(size);
                    }
                }, (e) => {
                    // The error will be thrown from the connect() method.
                });
            },
        });
        this.transportStream = transportStream;
        this.clientCredentials = null;
        this.serverCredentials = null;
        this.connectCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.disposed = false;
        this.disposables = [];
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        if (!transportStream)
            throw new TypeError('A transport stream is required.');
        if (!credentials)
            throw new TypeError('Client or server credentials are required.');
        const sessionConfig = new sshSessionConfiguration_1.SshSessionConfiguration(true);
        if (reconnectableSessions) {
            sessionConfig.protocolExtensions.push(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        }
        if ('username' in credentials) {
            if (typeof reconnectableSessions !== 'undefined' &&
                typeof reconnectableSessions !== 'boolean') {
                throw new TypeError('SecureStream client reconnectable sessions must be a boolean.');
            }
            this.clientCredentials = credentials;
            this.session = new sshClientSession_1.SshClientSession(sessionConfig);
        }
        else if (credentials.publicKeys) {
            if (typeof reconnectableSessions !== 'undefined' &&
                !Array.isArray(reconnectableSessions)) {
                throw new TypeError('SecureStream server reconnectable sessions must be an array.');
            }
            this.serverCredentials = credentials;
            this.session = new sshServerSession_1.SshServerSession(sessionConfig, reconnectableSessions);
        }
        else {
            throw new TypeError('Client or server credentials are required.');
        }
        this.session.onDisconnected(this.onSessionDisconnected, this, this.disposables);
        this.session.onClosed(this.onSessionClosed, this, this.disposables);
    }
    get trace() {
        return this.session.trace;
    }
    set trace(trace) {
        this.session.trace = trace;
    }
    get isClosed() {
        return this.disposed || this.session.isClosed;
    }
    onAuthenticating(listener, thisArgs, disposables) {
        return this.session.onAuthenticating(listener, thisArgs, disposables);
    }
    /**
     * Initiates the SSH session over the transport stream by exchanging initial messages with the
     * remote peer. Waits for the protocol version exchange and key exchange. Additional message
     * processing is kicked off as a background promise chain.
     * @param cancellation optional cancellation token.
     */
    async connect(cancellation) {
        let sessionConnected = false;
        try {
            if (this.serverCredentials) {
                const serverSession = this.session;
                serverSession.credentials = this.serverCredentials;
            }
            let stream = this.transportStream;
            if (stream instanceof stream_1.Duplex) {
                stream = new streams_1.NodeStream(stream);
            }
            await this.session.connect(stream, cancellation);
            sessionConnected = true;
            let channel = null;
            if (this.clientCredentials) {
                const clientSession = this.session;
                if (!(await clientSession.authenticateServer(cancellation))) {
                    throw new errors_1.SshConnectionError('Server authentication failed.', transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
                }
                if (!(await clientSession.authenticateClient(this.clientCredentials, cancellation))) {
                    throw new errors_1.SshConnectionError('Client authentication failed.', transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable);
                }
                channel = await this.session.openChannel(cancellation);
            }
            else {
                channel = await this.session.acceptChannel(cancellation);
            }
            this.stream = this.createStream(channel);
            // Do not forward the 'readable' event because adding a listener causes a read.
            this.stream.on('data', (data) => this.emit('data', data));
            this.stream.on('end', () => this.emit('end'));
            this.stream.on('close', () => this.emit('close'));
            this.stream.on('error', () => this.emit('error'));
            channel.onClosed(() => this.dispose());
            this.connectCompletion.resolve(this.stream);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            if (e instanceof errors_1.ObjectDisposedError && this.session.isClosed) {
                // The session was closed while waiting for the channel.
                // This can happen in reconnect scenarios.
                this.connectCompletion.resolve(null);
            }
            else {
                let disconnectReason = e instanceof errors_1.SshConnectionError ? e.reason : undefined;
                disconnectReason !== null && disconnectReason !== void 0 ? disconnectReason : (disconnectReason = transportMessages_1.SshDisconnectReason.protocolError);
                await this.session.close(disconnectReason, e.message, e);
                this.connectCompletion.reject(e);
                throw e;
            }
        }
    }
    /**
     * Re-initiates the SSH session over a NEW transport stream by exchanging initial messages
     * with the remote server. Waits for the secure reconnect handshake to complete. Additional
     * message processing is kicked off as a background task chain.
     *
     * Applies only to a secure stream client. (The secure stream server handles reconnections
     * automatically during the session handshake.)
     */
    async reconnect(transportStream, cancellation) {
        if (!(this.session instanceof sshClientSession_1.SshClientSession)) {
            throw new Error('Cannot reconnect SecureStream server.');
        }
        if (!transportStream)
            throw new TypeError('A transport stream is required.');
        this.transportStream = transportStream;
        let stream = this.transportStream;
        if (stream instanceof stream_1.Duplex) {
            stream = new streams_1.NodeStream(stream);
        }
        await this.session.reconnect(stream, cancellation);
    }
    /**
     * Creates a stream instance for a channel. May be overridden to create a `SshStream` subclass.
     */
    createStream(channel) {
        return new sshStream_1.SshStream(channel);
    }
    dispose() {
        if (!this.disposed) {
            const sessionWasConnected = this.session.isConnected || this.session.isClosed;
            this.disposed = true;
            this.session.dispose();
            this.unsubscribe();
            try {
                // If the session did not connect yet, it doesn't know about the stream and
                // won't dispose it. So dispose it here.
                if (!sessionWasConnected && this.transportStream) {
                    if (this.transportStream instanceof stream_1.Duplex) {
                        this.transportStream.end();
                        this.transportStream.destroy();
                    }
                    else {
                        this.transportStream.close().catch((e) => {
                            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
                        });
                    }
                }
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.streamCloseError, `Error closing transport stream: ${e.message}`, e);
            }
        }
    }
    async close() {
        if (!this.disposed) {
            this.disposed = true;
            await this.session.close(transportMessages_1.SshDisconnectReason.none, this.session.constructor.name + ' disposed.');
            this.session.dispose();
            this.unsubscribe();
            if (this.transportStream instanceof stream_1.Duplex) {
                await new Promise((resolve) => {
                    this.transportStream.end(resolve);
                });
            }
            else {
                await this.transportStream.close();
            }
        }
    }
    onSessionDisconnected() {
        this.disconnectedEmitter.fire();
    }
    onSessionClosed(e) {
        this.unsubscribe();
        this.closedEmitter.fire(e);
    }
    unsubscribe() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
    }
}
exports.SecureStream = SecureStream;
//# sourceMappingURL=secureStream.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AuthenticationService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationService = void 0;
const sshService_1 = __webpack_require__(/*! ./sshService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js");
const authenticationMessages_1 = __webpack_require__(/*! ../messages/authenticationMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const transportMessages_1 = __webpack_require__(/*! ../messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const sshAuthenticatingEventArgs_1 = __webpack_require__(/*! ../events/sshAuthenticatingEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js");
const connectionService_1 = __webpack_require__(/*! ./connectionService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js");
const serviceActivation_1 = __webpack_require__(/*! ./serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
const queue_1 = __webpack_require__(/*! ../util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
const trace_1 = __webpack_require__(/*! ../trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
/**
 * Handles SSH protocol messages related to client authentication.
 */
let AuthenticationService = AuthenticationService_1 = class AuthenticationService extends sshService_1.SshService {
    constructor(session) {
        var _a;
        super(session);
        this.currentRequestMessage = null;
        this.authenticationFailureCount = 0;
        this.disposeCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();
        const algorithmName = (_a = session.algorithms) === null || _a === void 0 ? void 0 : _a.publicKeyAlgorithmName;
        if (!algorithmName) {
            throw new Error('Algorithms not initialized.');
        }
        this.publicKeyAlgorithmName = algorithmName;
    }
    handleMessage(message, cancellation) {
        if (message instanceof authenticationMessages_1.AuthenticationSuccessMessage) {
            return this.handleSuccessMessage(message);
        }
        else if (message instanceof authenticationMessages_1.AuthenticationFailureMessage) {
            return this.handleFailureMessage(message);
        }
        else if (message instanceof authenticationMessages_1.AuthenticationRequestMessage) {
            return this.handleAuthenticationRequestMessage(message, cancellation);
        }
        else if (message instanceof authenticationMessages_1.AuthenticationInfoRequestMessage) {
            return this.handleInfoRequestMessage(message, cancellation);
        }
        else if (message instanceof authenticationMessages_1.AuthenticationInfoResponseMessage) {
            return this.handleInfoResponseMessage(message, cancellation);
        }
        else if (message instanceof authenticationMessages_1.PublicKeyOKMessage) {
            // Not handled.
        }
        else {
            // Ignore unrecognized authentication messages.
        }
    }
    async handleAuthenticationRequestMessage(message, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `Authentication request: ${message.methodName}`);
        let methodName = message.methodName;
        if (!this.session.config.authenticationMethods.includes(methodName)) {
            methodName = null;
        }
        if (methodName === "publickey" /* AuthenticationMethod.publicKey */ ||
            methodName === "hostbased" /* AuthenticationMethod.hostBased */) {
            const publicKeymessage = message.convertTo(new authenticationMessages_1.PublicKeyRequestMessage());
            this.setCurrentRequest(publicKeymessage);
            return this.handlePublicKeyRequestMessage(publicKeymessage, cancellation);
        }
        else if (methodName === "password" /* AuthenticationMethod.password */) {
            const passwordMessage = message.convertTo(new authenticationMessages_1.PasswordRequestMessage());
            this.setCurrentRequest(passwordMessage);
            return this.handlePasswordRequestMessage(passwordMessage, cancellation);
        }
        else if (methodName === "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */) {
            this.setCurrentRequest(message);
            return this.beginInteractiveAuthentication(message, cancellation);
        }
        else if (methodName === "none" /* AuthenticationMethod.none */) {
            this.setCurrentRequest(message);
            return this.handleAuthenticating(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientNone, {
                username: message.username,
            }), cancellation);
        }
        else {
            this.setCurrentRequest(null);
            const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
            failureMessage.methodNames = [
                "publickey" /* AuthenticationMethod.publicKey */,
                "password" /* AuthenticationMethod.password */,
                "hostbased" /* AuthenticationMethod.hostBased */,
            ];
            await this.session.sendMessage(failureMessage, cancellation);
        }
    }
    setCurrentRequest(message) {
        var _a;
        this.currentRequestMessage = message;
        const protocol = this.session.protocol;
        if (protocol) {
            protocol.messageContext = (_a = message === null || message === void 0 ? void 0 : message.methodName) !== null && _a !== void 0 ? _a : null;
        }
    }
    async handlePublicKeyRequestMessage(message, cancellation) {
        var _a, _b, _c;
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(message.keyAlgorithmName);
        if (!publicKeyAlg) {
            const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
            failureMessage.methodNames = [
                "publickey" /* AuthenticationMethod.publicKey */,
                "password" /* AuthenticationMethod.password */,
            ];
            await this.session.sendMessage(failureMessage, cancellation);
            return;
        }
        const publicKey = publicKeyAlg.createKeyPair();
        await publicKey.setPublicKeyBytes(message.publicKey);
        let args;
        if (message.methodName === "hostbased" /* AuthenticationMethod.hostBased */) {
            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientHostBased, {
                username: (_a = message.username) !== null && _a !== void 0 ? _a : '',
                publicKey: publicKey,
                clientHostname: message.clientHostname,
                clientUsername: message.clientUsername,
            });
        }
        else if (!message.hasSignature) {
            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery, {
                username: (_b = message.username) !== null && _b !== void 0 ? _b : '',
                publicKey: publicKey,
            });
        }
        else {
            // Verify that the signature matches the public key.
            const signature = publicKeyAlg.readSignatureData(message.signature);
            const sessionId = this.session.sessionId;
            if (sessionId == null) {
                throw new Error('Session ID not initialized.');
            }
            const writer = new sshData_1.SshDataWriter(Buffer.alloc(sessionId.length + message.payloadWithoutSignature.length + 20));
            writer.writeBinary(sessionId);
            writer.write(message.payloadWithoutSignature);
            const signedData = writer.toBuffer();
            const verifier = publicKeyAlg.createVerifier(publicKey);
            const verified = await verifier.verify(signedData, signature);
            if (!verified) {
                await this.handleAuthenticationFailure('Public key authentication failed: invalid signature.', cancellation);
            }
            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKey, {
                username: (_c = message.username) !== null && _c !== void 0 ? _c : '',
                publicKey: publicKey,
            });
        }
        // Raise an Authenticating event that allows handlers to do additional verification
        // of the client's username and public key.
        await this.handleAuthenticating(args, cancellation);
    }
    async handlePasswordRequestMessage(message, cancellation) {
        var _a, _b;
        // Raise an Authenticating event that allows handlers to do verification
        // of the client's username and password.
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPassword, {
            username: (_a = message.username) !== null && _a !== void 0 ? _a : '',
            password: (_b = message.password) !== null && _b !== void 0 ? _b : '',
        });
        await this.handleAuthenticating(args, cancellation);
    }
    async beginInteractiveAuthentication(message, cancellation) {
        // Raise an Authenticating event that allows the server to interactively prompt for
        // information from the client.
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
            username: message.username,
        });
        await this.handleAuthenticating(args, cancellation);
    }
    async handleInfoRequestMessage(message, cancellation) {
        // Raise an Authenticating event that allows the client to respond to interactive prompts
        // and provide requested information to the server.
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
            infoRequest: message,
        });
        await this.handleAuthenticating(args, cancellation);
    }
    async handleInfoResponseMessage(message, cancellation) {
        var _a;
        // Raise an Authenticating event that allows the server to process the client's responses
        // to interactive prompts, and request further info if necessary.
        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive, {
            username: (_a = this.currentRequestMessage) === null || _a === void 0 ? void 0 : _a.username,
            infoResponse: message,
        });
        await this.handleAuthenticating(args, cancellation);
    }
    async handleAuthenticating(args, cancellation) {
        var _a;
        if (!this.currentRequestMessage) {
            throw new errors_1.SshConnectionError('No current authentication request.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        args.cancellation = this.disposeCancellationSource.token;
        let authenticatedPrincipal = null;
        try {
            authenticatedPrincipal = await this.session.raiseAuthenticatingEvent(args);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating client: ${e.message}`, e);
            authenticatedPrincipal = null;
        }
        if (authenticatedPrincipal) {
            if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery) {
                const publicKeyRequest = this.currentRequestMessage;
                const okMessage = new authenticationMessages_1.PublicKeyOKMessage();
                okMessage.keyAlgorithmName = publicKeyRequest.keyAlgorithmName;
                okMessage.publicKey = publicKeyRequest.publicKey;
                this.setCurrentRequest(null);
                await this.session.sendMessage(okMessage, cancellation);
            }
            else {
                this.session.principal = authenticatedPrincipal;
                const serviceName = this.currentRequestMessage.serviceName;
                if (serviceName) {
                    this.session.activateService(serviceName);
                }
                this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication succeeded.`);
                this.setCurrentRequest(null);
                await this.session.sendMessage(new authenticationMessages_1.AuthenticationSuccessMessage(), cancellation);
                (_a = this.session) === null || _a === void 0 ? void 0 : _a.handleClientAuthenticated();
            }
        }
        else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive &&
            !this.session.isClientSession &&
            args.infoRequest) {
            // Server authenticating event-handler supplied an info request.
            await this.sendMessage(args.infoRequest, cancellation);
        }
        else if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientInteractive &&
            this.session.isClientSession &&
            args.infoResponse) {
            // Client authenticating event-handler supplied an info response.
            await this.sendMessage(args.infoResponse, cancellation);
        }
        else {
            this.setCurrentRequest(null);
            await this.handleAuthenticationFailure(`${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication failed.`);
        }
    }
    async handleAuthenticationFailure(message, cancellation) {
        this.authenticationFailureCount++;
        this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, message);
        const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();
        failureMessage.methodNames = this.session.config.authenticationMethods;
        await this.session.sendMessage(failureMessage, cancellation);
        // Allow trying again with another authentication method. But prevent unlimited tries.
        if (this.authenticationFailureCount >= this.session.config.maxClientAuthenticationAttempts) {
            await this.session.close(transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable, 'Authentication failed.');
        }
    }
    async authenticateClient(credentials, cancellation) {
        var _a, _b, _c, _d;
        this.clientAuthenticationMethods = new queue_1.Queue();
        const configuredMethods = this.session.config.authenticationMethods;
        if (configuredMethods.includes("publickey" /* AuthenticationMethod.publicKey */)) {
            for (const publicKey of (_a = credentials.publicKeys) !== null && _a !== void 0 ? _a : []) {
                if (!publicKey)
                    continue;
                const username = (_b = credentials.username) !== null && _b !== void 0 ? _b : '';
                let privateKey = publicKey;
                const privateKeyProvider = credentials.privateKeyProvider;
                this.clientAuthenticationMethods.enqueue({
                    method: "publickey" /* AuthenticationMethod.publicKey */,
                    handler: async (cancellation2) => {
                        if (!privateKey.hasPrivateKey) {
                            if (privateKeyProvider == null) {
                                throw new Error('A private key provider is required.');
                            }
                            privateKey = await privateKeyProvider(publicKey, cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                        }
                        if (privateKey) {
                            await this.requestPublicKeyAuthentication(username, privateKey, cancellation2);
                        }
                        else {
                            await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                        }
                    },
                });
            }
        }
        if (configuredMethods.includes("password" /* AuthenticationMethod.password */)) {
            const passwordCredentialProvider = credentials.passwordProvider;
            if (passwordCredentialProvider) {
                this.clientAuthenticationMethods.enqueue({
                    method: "password" /* AuthenticationMethod.password */,
                    handler: async (cancellation2) => {
                        var _a;
                        const passwordCredentialPromise = passwordCredentialProvider(cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);
                        const passwordCredential = passwordCredentialPromise
                            ? await passwordCredentialPromise
                            : null;
                        if (passwordCredential) {
                            await this.requestPasswordAuthentication((_a = passwordCredential[0]) !== null && _a !== void 0 ? _a : '', passwordCredential[1], cancellation2);
                        }
                        else {
                            await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);
                        }
                    },
                });
            }
            else if (credentials.password) {
                const username = (_c = credentials.username) !== null && _c !== void 0 ? _c : '';
                const password = credentials.password;
                this.clientAuthenticationMethods.enqueue({
                    method: "password" /* AuthenticationMethod.password */,
                    handler: async (cancellation2) => {
                        await this.requestPasswordAuthentication(username, password, cancellation2);
                    },
                });
            }
        }
        // Only add None or Interactive methods if no client credentials were supplied.
        if (this.clientAuthenticationMethods.size === 0) {
            const username = (_d = credentials.username) !== null && _d !== void 0 ? _d : '';
            if (configuredMethods.includes("none" /* AuthenticationMethod.none */)) {
                this.clientAuthenticationMethods.enqueue({
                    method: "none" /* AuthenticationMethod.none */,
                    handler: async (cancellation2) => {
                        await this.requestUsernameAuthentication(username, cancellation2);
                    },
                });
            }
            if (configuredMethods.includes("keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */)) {
                this.clientAuthenticationMethods.enqueue({
                    method: "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */,
                    handler: async (cancellation2) => {
                        await this.requestInteractiveAuthentication(username, cancellation2);
                    },
                });
            }
            if (this.clientAuthenticationMethods.size === 0) {
                throw new Error('Could not prepare request for authentication method(s): ' +
                    configuredMethods.join(', ') +
                    '. Supply client credentials or enable none or interactive authentication methods.');
            }
        }
        // Auth request messages all include a request the for the server to activate the connection
        // service . Go ahead and activate it on the client side too; if authentication fails then
        // a following channel open request will fail anyway.
        this.session.activateService(connectionService_1.ConnectionService);
        const firstAuthMethod = this.clientAuthenticationMethods.dequeue();
        await firstAuthMethod.handler(cancellation);
    }
    async requestUsernameAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "none" /* AuthenticationMethod.none */;
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
    }
    async requestPublicKeyAuthentication(username, key, cancellation) {
        const algorithm = this.session.config.publicKeyAlgorithms.find((a) => (a === null || a === void 0 ? void 0 : a.keyAlgorithmName) === key.keyAlgorithmName);
        if (!algorithm) {
            throw new Error(`Public key algorithm '${key.keyAlgorithmName}' is not in session config.`);
        }
        const authMessage = new authenticationMessages_1.PublicKeyRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.keyAlgorithmName = algorithm.name;
        authMessage.publicKey = (await key.getPublicKeyBytes(algorithm.name));
        authMessage.signature = await this.createAuthenticationSignature(authMessage, algorithm, key);
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
    }
    async requestPasswordAuthentication(username, password, cancellation) {
        const authMessage = new authenticationMessages_1.PasswordRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.username = username;
        authMessage.password = password;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
    }
    async requestInteractiveAuthentication(username, cancellation) {
        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();
        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;
        authMessage.methodName = "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */;
        authMessage.username = username;
        this.setCurrentRequest(authMessage);
        await this.session.sendMessage(authMessage, cancellation);
    }
    async handleFailureMessage(message) {
        var _a, _b;
        this.setCurrentRequest(null);
        while ((_a = this.clientAuthenticationMethods) === null || _a === void 0 ? void 0 : _a.size) {
            const nextAuthMethod = this.clientAuthenticationMethods.dequeue();
            // Skip client auth methods that the server did not suggest.
            if ((_b = message.methodNames) === null || _b === void 0 ? void 0 : _b.includes(nextAuthMethod.method)) {
                await nextAuthMethod.handler(this.disposeCancellationSource.token);
                return;
            }
        }
        this.session.onAuthenticationComplete(false);
    }
    handleSuccessMessage(message) {
        this.setCurrentRequest(null);
        this.session.onAuthenticationComplete(true);
    }
    async createAuthenticationSignature(requestMessage, algorithm, key) {
        const sessionId = this.session.sessionId;
        if (sessionId == null) {
            throw new Error('Session ID not initialized.');
        }
        const writer = new sshData_1.SshDataWriter(Buffer.alloc(requestMessage.publicKey.length + (requestMessage.username || '').length + 400));
        writer.writeBinary(sessionId);
        writer.writeByte(requestMessage.messageType);
        writer.writeString(requestMessage.username || '', 'utf8');
        writer.writeString(requestMessage.serviceName || '', 'ascii');
        writer.writeString("publickey" /* AuthenticationMethod.publicKey */, 'ascii');
        writer.writeBoolean(true);
        writer.writeString(requestMessage.keyAlgorithmName, 'ascii');
        writer.writeBinary(requestMessage.publicKey);
        const signer = algorithm.createSigner(key);
        const signature = await signer.sign(writer.toBuffer());
        return algorithm.createSignatureData(signature);
    }
    dispose() {
        try {
            this.disposeCancellationSource.cancel();
            this.disposeCancellationSource.dispose();
        }
        catch (_a) { }
        super.dispose();
    }
};
AuthenticationService.serviceName = 'ssh-userauth';
AuthenticationService = AuthenticationService_1 = __decorate([
    (0, serviceActivation_1.serviceActivation)({ serviceRequest: AuthenticationService_1.serviceName })
], AuthenticationService);
exports.AuthenticationService = AuthenticationService;
//# sourceMappingURL=authenticationService.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ConnectionService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionService = void 0;
const sshService_1 = __webpack_require__(/*! ./sshService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js");
const connectionMessages_1 = __webpack_require__(/*! ../messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const promiseCompletionSource_1 = __webpack_require__(/*! ../util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const sshChannel_1 = __webpack_require__(/*! ../sshChannel */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js");
const cancellation_1 = __webpack_require__(/*! ../util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const sshChannelOpeningEventArgs_1 = __webpack_require__(/*! ../events/sshChannelOpeningEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelOpeningEventArgs.js");
const serviceActivation_1 = __webpack_require__(/*! ./serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
const trace_1 = __webpack_require__(/*! ../trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const sshExtendedDataEventArgs_1 = __webpack_require__(/*! ../events/sshExtendedDataEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshExtendedDataEventArgs.js");
let ConnectionService = ConnectionService_1 = class ConnectionService extends sshService_1.SshService {
    constructor(session) {
        super(session);
        this.channelCounter = 0;
        this.channelMap = new Map();
        this.nonAcceptedChannels = new Map();
        this.pendingChannels = new Map();
        this.pendingAcceptChannels = new Map();
    }
    get channels() {
        return Array.from(this.channelMap.values());
    }
    close(e) {
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
            channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of this.channelMap.values()) {
            channel.close(e);
        }
        for (const channelCompletion of channelCompletions) {
            channelCompletion.reject(e);
        }
    }
    dispose() {
        const channels = [...this.channelMap.values()];
        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);
        if (this.pendingAcceptChannels.size > 0) {
            channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));
        }
        for (const channel of channels) {
            channel.dispose();
        }
        for (const channelCompletion of channelCompletions) {
            channelCompletion.reject(new errors_1.ObjectDisposedError('Session closed.'));
        }
        super.dispose();
    }
    async acceptChannel(channelType, cancellation) {
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        let cancellationRegistration;
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellationRegistration = cancellation.onCancellationRequested(() => {
                const list = this.pendingAcceptChannels.get(channelType);
                if (list) {
                    const index = list.findIndex((item) => Object.is(item, completionSource));
                    if (index >= 0) {
                        list.splice(index, 1);
                    }
                }
                completionSource.reject(new cancellation_1.CancellationError());
            });
        }
        let channel = null;
        channel =
            Array.from(this.nonAcceptedChannels.values()).find((c) => c.channelType === channelType) ||
                null;
        if (channel) {
            // Found a channel that was already opened but not accepted.
            this.nonAcceptedChannels.delete(channel.channelId);
        }
        else {
            // Set up the completion source to wait for a channel of the requested type.
            let list = this.pendingAcceptChannels.get(channelType);
            if (!list) {
                list = [];
                this.pendingAcceptChannels.set(channelType, list);
            }
            list.push(completionSource);
        }
        try {
            return channel || (await completionSource.promise);
        }
        finally {
            if (cancellationRegistration)
                cancellationRegistration.dispose();
        }
    }
    async openChannel(openMessage, completionSource, cancellation) {
        const channelId = ++this.channelCounter;
        openMessage.senderChannel = channelId;
        let cancellationRegistration = null;
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellationRegistration = cancellation.onCancellationRequested(() => {
                if (this.pendingChannels.delete(channelId)) {
                    completionSource.reject(new cancellation_1.CancellationError());
                }
            });
        }
        this.pendingChannels.set(channelId, {
            openMessage: openMessage,
            completionSource: completionSource,
            cancellationRegistration: cancellationRegistration,
        });
        await this.session.sendMessage(openMessage);
        return channelId;
    }
    handleMessage(message, cancellation) {
        if (message instanceof connectionMessages_1.ChannelDataMessage) {
            return this.handleDataMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelExtendedDataMessage) {
            return this.handleExtendedDataMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelWindowAdjustMessage) {
            return this.handleAdjustWindowMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelEofMessage) {
            return this.handleEofMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelOpenMessage) {
            return this.handleOpenMessage(message, cancellation);
        }
        else if (message instanceof connectionMessages_1.ChannelCloseMessage) {
            return this.handleCloseMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelOpenConfirmationMessage) {
            return this.handleOpenConfirmationMessage(message, cancellation);
        }
        else if (message instanceof connectionMessages_1.ChannelOpenFailureMessage) {
            return this.handleOpenFailureMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelRequestMessage) {
            return this.handleRequestMessage(message, cancellation);
        }
        else if (message instanceof connectionMessages_1.ChannelSuccessMessage) {
            return this.handleSuccessMessage(message);
        }
        else if (message instanceof connectionMessages_1.ChannelFailureMessage) {
            return this.handleFailureMessage(message);
        }
        else {
            throw new Error(`Message not implemented: ${message}`);
        }
    }
    async handleOpenMessage(message, cancellation) {
        var _a;
        const senderChannel = message.senderChannel;
        if (!this.session.canAcceptRequests) {
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, 'Channel open request blocked because the session is not yet authenticated.');
            const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
            openFailureMessage.recipientChannel = senderChannel;
            openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.administrativelyProhibited;
            openFailureMessage.description = 'Authenticate before opening channels.';
            await this.session.sendMessage(openFailureMessage, cancellation);
            return;
        }
        else if (!message.channelType) {
            const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
            openFailureMessage.recipientChannel = senderChannel;
            openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.unknownChannelType;
            openFailureMessage.description = 'Channel type not specified.';
            await this.session.sendMessage(openFailureMessage, cancellation);
            return;
        }
        // Save a copy of the message because its buffer will be overwitten by the next receive.
        message = message.convertTo(new connectionMessages_1.ChannelOpenMessage(), true);
        // The confirmation message may be reassigned if the opening task returns a custom message.
        let confirmationMessage = new connectionMessages_1.ChannelOpenConfirmationMessage();
        const channelId = ++this.channelCounter;
        const channel = new sshChannel_1.SshChannel(this, message.channelType, channelId, senderChannel, message.maxWindowSize, message.maxPacketSize, message, confirmationMessage);
        let responseMessage;
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(message, channel, true);
        try {
            await this.session.handleChannelOpening(args, cancellation);
            if (args.openingPromise) {
                responseMessage = await args.openingPromise;
            }
            else if (args.failureReason !== connectionMessages_1.SshChannelOpenFailureReason.none) {
                const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();
                failureMessage.reasonCode = args.failureReason;
                failureMessage.description = (_a = args.failureDescription) !== null && _a !== void 0 ? _a : undefined;
                responseMessage = failureMessage;
            }
            else {
                responseMessage = confirmationMessage;
            }
        }
        catch (e) {
            channel.dispose();
            throw e;
        }
        if (responseMessage instanceof connectionMessages_1.ChannelOpenFailureMessage) {
            responseMessage.recipientChannel = senderChannel;
            try {
                await this.session.sendMessage(responseMessage, cancellation);
            }
            finally {
                channel.dispose();
            }
            return;
        }
        // The session might have been closed while opening the channel.
        if (this.session.isClosed) {
            channel.dispose();
            return;
        }
        // Prevent any changes to the channel max window size after sending the value in the
        // open confirmation message.
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        confirmationMessage = responseMessage;
        confirmationMessage.recipientChannel = channel.remoteChannelId;
        confirmationMessage.senderChannel = channel.channelId;
        confirmationMessage.maxWindowSize = channel.maxWindowSize;
        confirmationMessage.maxPacketSize = channel.maxPacketSize;
        confirmationMessage.rewrite();
        channel.openConfirmationMessage = confirmationMessage;
        await this.session.sendMessage(confirmationMessage, cancellation);
        // Check if there are any accept operations waiting on this channel type.
        let accepted = false;
        const list = this.pendingAcceptChannels.get(channel.channelType);
        while (list && list.length > 0) {
            const acceptCompletionSource = list.shift();
            acceptCompletionSource.resolve(channel);
            accepted = true;
            break;
        }
        if (!accepted) {
            this.nonAcceptedChannels.set(channel.channelId, channel);
        }
        this.onChannelOpenCompleted(channel.channelId, channel);
        channel.enableSending();
    }
    handleCloseMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        if (channel) {
            channel.handleClose();
        }
    }
    async handleOpenConfirmationMessage(message, cancellation) {
        var _a;
        let completionSource = null;
        let openMessage;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
            openMessage = pendingChannel.openMessage;
            completionSource = pendingChannel.completionSource;
            if (pendingChannel.cancellationRegistration) {
                pendingChannel.cancellationRegistration.dispose();
            }
            this.pendingChannels.delete(message.recipientChannel);
        }
        else if (this.channelMap.has(message.recipientChannel)) {
            throw new Error('Duplicate channel ID.');
        }
        else {
            throw new Error('Channel confirmation was not requested.');
        }
        // Save a copy of the message because its buffer will be overwitten by the next receive.
        message = message.convertTo(new connectionMessages_1.ChannelOpenConfirmationMessage(), true);
        const channel = new sshChannel_1.SshChannel(this, openMessage.channelType || sshChannel_1.SshChannel.sessionChannelType, message.recipientChannel, message.senderChannel, message.maxWindowSize, message.maxPacketSize, openMessage, message);
        // Set the channel max window size property to match the value sent in the open message,
        // (if specified) and lock it to prevent any further changes.
        if (typeof openMessage.maxWindowSize === 'number') {
            channel.maxWindowSize = openMessage.maxWindowSize;
        }
        channel.isMaxWindowSizeLocked = true;
        this.channelMap.set(channel.channelId, channel);
        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(openMessage, channel, false);
        await this.session.handleChannelOpening(args, cancellation);
        if (completionSource) {
            if (args.failureReason === connectionMessages_1.SshChannelOpenFailureReason.none) {
                completionSource.resolve(channel);
            }
            else {
                completionSource.reject(new errors_1.SshChannelError((_a = args.failureDescription) !== null && _a !== void 0 ? _a : 'Channel open failure.', args.failureReason));
                return;
            }
        }
        else {
            this.onChannelOpenCompleted(channel.channelId, channel);
        }
        channel.enableSending();
    }
    handleOpenFailureMessage(message) {
        let completionSource = null;
        const pendingChannel = this.pendingChannels.get(message.recipientChannel);
        if (pendingChannel) {
            completionSource = pendingChannel.completionSource;
            if (pendingChannel.cancellationRegistration) {
                pendingChannel.cancellationRegistration.dispose();
            }
            this.pendingChannels.delete(message.recipientChannel);
        }
        if (completionSource != null) {
            completionSource.reject(new errors_1.SshChannelError(message.description || 'Channel open rejected.', message.reasonCode));
        }
        else {
            this.onChannelOpenCompleted(message.recipientChannel, null);
        }
    }
    async handleRequestMessage(message, cancellation) {
        const channel = this.tryGetChannelForMessage(message);
        if (!channel)
            return;
        await channel.handleRequest(message, cancellation);
    }
    handleSuccessMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(true);
    }
    handleFailureMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleResponse(false);
    }
    handleDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleDataReceived(message.data);
    }
    handleExtendedDataMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.handleExtendedDataReceived(new sshExtendedDataEventArgs_1.SshExtendedDataEventArgs(message.dataTypeCode, message.data));
    }
    handleAdjustWindowMessage(message) {
        const channel = this.tryGetChannelForMessage(message);
        channel === null || channel === void 0 ? void 0 : channel.adjustRemoteWindow(message.bytesToAdd);
    }
    handleEofMessage(message) {
        const channel = this.findChannelById(message.recipientChannel);
        channel === null || channel === void 0 ? void 0 : channel.handleEof();
    }
    onChannelOpenCompleted(channelId, channel) {
        if (channel) {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelOpened, `${this.session} ChannelOpenCompleted(${channel})`);
        }
        else {
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelOpenFailed, `${this.session} ChannelOpenCompleted(${channelId} failed)`);
        }
    }
    /**
     * Gets the channel object based on the message `recipientChannel` property.
     * Logs a warning if the channel was not found.
     */
    tryGetChannelForMessage(channelMessage) {
        const channel = this.findChannelById(channelMessage.recipientChannel);
        if (!channel) {
            const messageString = channelMessage instanceof connectionMessages_1.ChannelDataMessage
                ? 'channel data message'
                : channelMessage.toString();
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelRequestFailed, `Invalid channel ID ${channelMessage.recipientChannel} in ${messageString}.`);
        }
        return channel;
    }
    findChannelById(id) {
        var _a;
        const channel = (_a = this.channelMap.get(id)) !== null && _a !== void 0 ? _a : null;
        return channel;
    }
    /* @internal */
    removeChannel(channel) {
        this.channelMap.delete(channel.channelId);
        this.pendingChannels.delete(channel.channelId);
    }
};
ConnectionService.serviceName = 'ssh-connection';
ConnectionService = ConnectionService_1 = __decorate([
    (0, serviceActivation_1.serviceActivation)({ serviceRequest: ConnectionService_1.serviceName })
], ConnectionService);
exports.ConnectionService = ConnectionService;
//# sourceMappingURL=connectionService.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var KeyExchangeService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyExchangeService = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshSession_1 = __webpack_require__(/*! ../sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
const sshService_1 = __webpack_require__(/*! ./sshService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js");
const bigInt_1 = __webpack_require__(/*! ../io/bigInt */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/bigInt.js");
const kexMessages_1 = __webpack_require__(/*! ../messages/kexMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js");
const sshAlgorithms_1 = __webpack_require__(/*! ../algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
const sshData_1 = __webpack_require__(/*! ../io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const transportMessages_1 = __webpack_require__(/*! ../messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const sshSessionAlgorithms_1 = __webpack_require__(/*! ../sshSessionAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const connectionService_1 = __webpack_require__(/*! ./connectionService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js");
const serviceActivation_1 = __webpack_require__(/*! ./serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
const trace_1 = __webpack_require__(/*! ../trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
class ExchangeContext {
}
const serverExtensionInfoSignal = 'ext-info-s';
const clientExtensionInfoSignal = 'ext-info-c';
let KeyExchangeService = KeyExchangeService_1 = class KeyExchangeService extends sshService_1.SshService {
    constructor(session) {
        super(session);
        this.isInitialExchange = false;
        this.exchangeContext = null;
    }
    get exchanging() {
        return !!this.exchangeContext;
    }
    async startKeyExchange(isInitialExchange) {
        this.isInitialExchange = isInitialExchange;
        this.exchangeContext = new ExchangeContext();
        const kexInitMessage = this.createKeyExchangeInitMessage();
        let kexGuessMessage = null;
        if (this.session.isClientSession) {
            if (isInitialExchange && this.session.config.enableKeyExchangeGuess) {
                kexGuessMessage = await this.createKeyExchangeGuessMessage();
                kexInitMessage.firstKexPacketFollows = !!kexGuessMessage;
            }
            this.exchangeContext.clientKexInitPayload = kexInitMessage.toBuffer();
        }
        else {
            this.exchangeContext.serverKexInitPayload = kexInitMessage.toBuffer();
        }
        return [kexInitMessage, kexGuessMessage];
    }
    finishKeyExchange() {
        var _a;
        if (!this.exchangeContext) {
            throw new errors_1.SshConnectionError('Key exchange not started.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        const newAlgorithms = this.exchangeContext.newAlgorithms;
        if (!newAlgorithms) {
            throw new errors_1.SshConnectionError('Key exchange not completed.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        newAlgorithms.isExtensionInfoRequested = (_a = this.exchangeContext) === null || _a === void 0 ? void 0 : _a.isExtensionInfoRequested;
        this.exchangeContext = null;
        return newAlgorithms;
    }
    abortKeyExchange() {
        this.exchangeContext = null;
    }
    createKeyExchangeInitMessage() {
        // Reference RFC 8308: Signaling of Extension Negotiation in Key Exchange.
        const extinfo = this.session.isClientSession ?
            clientExtensionInfoSignal : serverExtensionInfoSignal;
        const config = this.session.config;
        const message = new kexMessages_1.KeyExchangeInitMessage();
        message.keyExchangeAlgorithms = (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms).concat(extinfo);
        message.serverHostKeyAlgorithms = this.getPublicKeyAlgorithms();
        message.encryptionAlgorithmsClientToServer = message.encryptionAlgorithmsServerToClient =
            (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms);
        message.macAlgorithmsClientToServer = message.macAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms);
        message.compressionAlgorithmsClientToServer = message.compressionAlgorithmsServerToClient =
            (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms);
        message.languagesClientToServer = [''];
        message.languagesServerToClient = [''];
        message.firstKexPacketFollows = false;
        message.reserved = 0;
        return message;
    }
    /**
     * Gets the list of public key algorithms that the current session can support.
     * For a server session the list is filtered based on the available private keys.
     */
    getPublicKeyAlgorithms() {
        var _a, _b;
        let publicKeyAlgorithms = [...this.session.config.publicKeyAlgorithms];
        if (publicKeyAlgorithms.length > 1 && !this.session.isClientSession) {
            const privateKeyAlgorithms = (_b = (_a = this.session.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) === null || _b === void 0 ? void 0 : _b.map((k) => k.keyAlgorithmName);
            if (privateKeyAlgorithms) {
                publicKeyAlgorithms = publicKeyAlgorithms.filter((a) => a && privateKeyAlgorithms.includes(a.keyAlgorithmName));
            }
        }
        const publicKeyAlgorithmNames = (0, sshAlgorithms_1.algorithmNames)(publicKeyAlgorithms);
        return publicKeyAlgorithmNames;
    }
    async createKeyExchangeGuessMessage() {
        if (!this.exchangeContext) {
            throw new Error('Key exchange was not started.');
        }
        // Select the first key exchange algorithm as the "guess". (They are in preferential order.)
        const kexAlgorithm = this.session.config.keyExchangeAlgorithms[0];
        if (!kexAlgorithm) {
            return null;
        }
        this.exchangeContext.keyExchange = kexAlgorithm.name;
        this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
        this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();
        const guess = new kexMessages_1.KeyExchangeDhInitMessage();
        guess.e = this.exchangeContext.exchangeValue;
        return guess;
    }
    handleMessage(message, cancellation) {
        if (message instanceof kexMessages_1.KeyExchangeInitMessage) {
            return this.handleInitMessage(message, cancellation);
        }
        else if (message instanceof kexMessages_1.KeyExchangeDhInitMessage) {
            return this.handleDhInitMessage(message, cancellation);
        }
        else if (message instanceof kexMessages_1.KeyExchangeDhReplyMessage) {
            return this.handleDhReplyMessage(message, cancellation);
        }
        else {
            throw new Error(`Message not implemented: ${message}`);
        }
    }
    async handleInitMessage(message, cancellation) {
        var _a, _b, _c, _d;
        if (!this.exchangeContext) {
            throw new Error('Key exchange was not started.');
        }
        const config = this.session.config;
        this.exchangeContext.keyExchange = this.chooseAlgorithm('KeyExchange', (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms), message.keyExchangeAlgorithms);
        if (this.exchangeContext.keyExchange === 'none') {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, 'Client and server negotiated no security. Cancelling key-exchange.');
            // The connection service is normally activated after authentication. But when there is
            // no key-exchange there will be no authentication, so connections must be enabled now.
            this.session.activateService(connectionService_1.ConnectionService);
            this.exchangeContext.newAlgorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
            await this.session.handleNewKeysMessage(new kexMessages_1.NewKeysMessage(), cancellation);
            return;
        }
        this.exchangeContext.publicKey = this.chooseAlgorithm('PublicKey', this.getPublicKeyAlgorithms(), message.serverHostKeyAlgorithms);
        this.exchangeContext.clientEncryption = this.chooseAlgorithm('ClientEncryption', (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsClientToServer);
        this.exchangeContext.serverEncryption = this.chooseAlgorithm('ServerEncryption', (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsServerToClient);
        this.exchangeContext.clientHmac = this.chooseAlgorithm('ClientHmac', (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsClientToServer);
        this.exchangeContext.serverHmac = this.chooseAlgorithm('ServerHmac', (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsServerToClient);
        this.exchangeContext.clientCompression = this.chooseAlgorithm('ClientCompression', (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsClientToServer);
        this.exchangeContext.serverCompression = this.chooseAlgorithm('ServerCompression', (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsServerToClient);
        if (this.session.isClientSession) {
            this.exchangeContext.serverKexInitPayload = message.toBuffer();
            // If the exchange value is already initialized then this side sent a guess.
            const alreadySentGuess = !!this.exchangeContext.exchangeValue;
            // Check if the negotiated algorithm is the one preferred by THIS side.
            // This means if there was a "guess" at kex initialization then it was correct.
            const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_a = config.keyExchangeAlgorithms[0]) === null || _a === void 0 ? void 0 : _a.name);
            // If a guess was not sent, or the guess was wrong, send the init message now.
            if (!alreadySentGuess || !negotiatedKexAlgorithmIsPreferred) {
                const kexAlgorithm = config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
                this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();
                this.exchangeContext.exchangeValue =
                    await this.exchangeContext.exchange.startKeyExchange();
                const reply = new kexMessages_1.KeyExchangeDhInitMessage();
                reply.e = this.exchangeContext.exchangeValue;
                await this.session.sendMessage(reply, cancellation);
            }
            else {
                this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, 'Already sent correct guess for key-exchange init.');
            }
            this.exchangeContext.isExtensionInfoRequested =
                this.isInitialExchange &&
                    ((_b = message.keyExchangeAlgorithms) === null || _b === void 0 ? void 0 : _b.includes(serverExtensionInfoSignal));
        }
        else {
            if (message.firstKexPacketFollows) {
                // The remote side indicated it is sending a guess immediately following.
                // Check if the negotiated algorithm is the one preferred by the OTHER side.
                // If so, the following "guess" will be correct. Otherwise it must be ignored.
                const negotiatedKexAlgorithmIsPreferred = this.exchangeContext.keyExchange === ((_c = message.keyExchangeAlgorithms) === null || _c === void 0 ? void 0 : _c[0]);
                const guessResult = negotiatedKexAlgorithmIsPreferred ? 'correct' : 'incorrect';
                this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.algorithmNegotiation, `Client's KeyExchange guess was ${guessResult}.`);
                this.exchangeContext.discardGuessedInit = !negotiatedKexAlgorithmIsPreferred;
            }
            this.exchangeContext.clientKexInitPayload = message.toBuffer();
            this.exchangeContext.isExtensionInfoRequested =
                this.isInitialExchange &&
                    ((_d = message.keyExchangeAlgorithms) === null || _d === void 0 ? void 0 : _d.includes(clientExtensionInfoSignal));
        }
    }
    async handleDhInitMessage(message, cancellation) {
        var _a, _b, _c, _d, _e;
        if (this.session.isClientSession) {
            return;
        }
        const serverSession = this.session;
        if (!this.exchangeContext ||
            !this.exchangeContext.keyExchange ||
            !this.exchangeContext.publicKey) {
            throw new errors_1.SshConnectionError('Key exchange not started.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (this.exchangeContext.discardGuessedInit) {
            // Algorithm negotiation determined that an incorrect guess would be received.
            this.exchangeContext.discardGuessedInit = false;
            return;
        }
        const kexAlg = this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);
        if (!kexAlg) {
            throw new errors_1.SshConnectionError('Key exchange not supported for algorithm: ' + this.exchangeContext.keyExchange, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);
        if (!publicKeyAlg) {
            throw new errors_1.SshConnectionError('Public key algorithm not supported: ' + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        let privateKey = null;
        if ((_a = serverSession.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) {
            const publicKey = serverSession.credentials.publicKeys.find((k) => k.keyAlgorithmName === publicKeyAlg.keyAlgorithmName);
            privateKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;
            if ((privateKey === null || privateKey === void 0 ? void 0 : privateKey.hasPrivateKey) === false) {
                if (!serverSession.credentials.privateKeyProvider) {
                    throw new Error('A private key provider is required.');
                }
                privateKey = await serverSession.credentials.privateKeyProvider(publicKey, cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None);
            }
        }
        if (privateKey == null) {
            throw new errors_1.SshConnectionError('Private key not found for algorithm: ' + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const clientEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const keyExchange = kexAlg.createKeyExchange();
        const clientExchangeValue = message.e || buffer_1.Buffer.alloc(0);
        const serverExchangeValue = await keyExchange.startKeyExchange();
        const sharedSecret = await keyExchange.decryptKeyExchange(clientExchangeValue);
        const hostKeyAndCerts = await privateKey.getPublicKeyBytes(publicKeyAlg.name);
        if (!hostKeyAndCerts) {
            throw new errors_1.SshConnectionError('Public key not set.', transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        if (!this.session.sessionId) {
            this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey,] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_b = (await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(true, serverCipherKey, serverCipherIV)))) !== null && _b !== void 0 ? _b : null;
        const decipher = (_c = (await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(false, clientCipherKey, clientCipherIV)))) !== null && _c !== void 0 ? _c : null;
        const signer = (_d = (await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createSigner(serverHmacKey)))) !== null && _d !== void 0 ? _d : null;
        const verifier = (_e = (await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createVerifier(clientHmacKey)))) !== null && _e !== void 0 ? _e : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = this.exchangeContext.publicKey;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption)
            ? cipher
            : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption)
            ? decipher
            : verifier;
        algorithms.compressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        algorithms.decompressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        // Wipe the keys from memory after they are stored in native key objects.
        if (clientCipherIV)
            clientCipherIV.fill(0);
        if (clientCipherKey)
            clientCipherKey.fill(0);
        if (clientHmacKey)
            clientHmacKey.fill(0);
        if (serverCipherIV)
            serverCipherIV.fill(0);
        if (serverCipherKey)
            serverCipherKey.fill(0);
        if (serverHmacKey)
            serverHmacKey.fill(0);
        const exchangeSigner = publicKeyAlg.createSigner(privateKey);
        let signature = await exchangeSigner.sign(exchangeHash);
        signature = publicKeyAlg.createSignatureData(signature);
        const reply = new kexMessages_1.KeyExchangeDhReplyMessage();
        reply.hostKey = hostKeyAndCerts;
        reply.f = serverExchangeValue;
        reply.signature = signature;
        await this.session.sendMessage(reply, cancellation);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
    }
    async handleDhReplyMessage(message, cancellation) {
        var _a, _b, _c, _d;
        if (!this.session.isClientSession) {
            return;
        }
        if (!this.exchangeContext) {
            throw new errors_1.SshConnectionError('Key exchange was not started.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        const config = this.session.config;
        const keyExchange = this.exchangeContext.exchange;
        const publicKeyAlgorithmName = this.exchangeContext.publicKey;
        const publicKeyAlg = config.getPublicKeyAlgorithm(publicKeyAlgorithmName);
        const clientEncryption = config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);
        const serverEncryption = config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);
        const serverHmac = config.getHmacAlgorithm(this.exchangeContext.serverHmac);
        const clientHmac = config.getHmacAlgorithm(this.exchangeContext.clientHmac);
        const clientExchangeValue = this.exchangeContext.exchangeValue;
        const serverExchangeValue = message.f;
        if (!keyExchange || !clientExchangeValue) {
            throw new errors_1.SshConnectionError('Failed to initialize crypto after key exchange.', transportMessages_1.SshDisconnectReason.keyExchangeFailed);
        }
        // Load the server's public key bytes into a key-pair instance.
        this.hostKey = publicKeyAlg.createKeyPair();
        await this.hostKey.setPublicKeyBytes(message.hostKey);
        const sharedSecret = await keyExchange.decryptKeyExchange(serverExchangeValue);
        const hostKeyAndCerts = message.hostKey;
        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);
        const signature = publicKeyAlg.readSignatureData(message.signature);
        const exchangeVerifier = publicKeyAlg.createVerifier(this.hostKey);
        let verified;
        try {
            verified = await exchangeVerifier.verify(exchangeHash, signature);
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverAuthenticationFailed, `Server public key verification error: ${e.message}`, e);
            throw new errors_1.SshConnectionError(`Server public key verification failed: ${e.message}`, transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (verified) {
            this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.sessionAuthenticated, 'Server public key verification succeeded.');
        }
        else {
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, 'Server public key verification failed.');
            throw new errors_1.SshConnectionError('Server public key verification failed.', transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);
        }
        if (this.session.sessionId == null) {
            this.session.sessionId = exchangeHash;
        }
        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey,] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);
        const cipher = (_a = (await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(true, clientCipherKey, clientCipherIV)))) !== null && _a !== void 0 ? _a : null;
        const decipher = (_b = (await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(false, serverCipherKey, serverCipherIV)))) !== null && _b !== void 0 ? _b : null;
        const signer = (_c = (await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createSigner(clientHmacKey)))) !== null && _c !== void 0 ? _c : null;
        const verifier = (_d = (await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createVerifier(serverHmacKey)))) !== null && _d !== void 0 ? _d : null;
        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();
        algorithms.publicKeyAlgorithmName = publicKeyAlgorithmName;
        algorithms.cipher = cipher;
        algorithms.decipher = decipher;
        algorithms.signer = signer;
        algorithms.verifier = verifier;
        algorithms.messageSigner = (cipher === null || cipher === void 0 ? void 0 : cipher.authenticatedEncryption)
            ? cipher
            : signer;
        algorithms.messageVerifier = (decipher === null || decipher === void 0 ? void 0 : decipher.authenticatedEncryption)
            ? decipher
            : verifier;
        algorithms.compressor = config.getCompressionAlgorithm(this.exchangeContext.clientCompression);
        algorithms.decompressor = config.getCompressionAlgorithm(this.exchangeContext.serverCompression);
        this.exchangeContext.newAlgorithms = algorithms;
        // Wipe the keys from memory after they are stored in native key objects.
        if (clientCipherIV)
            clientCipherIV.fill(0);
        if (clientCipherKey)
            clientCipherKey.fill(0);
        if (clientHmacKey)
            clientHmacKey.fill(0);
        if (serverCipherIV)
            serverCipherIV.fill(0);
        if (serverCipherKey)
            serverCipherKey.fill(0);
        if (serverHmacKey)
            serverHmacKey.fill(0);
        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);
    }
    chooseAlgorithm(label, localAlgorithms, remoteAlgorithms) {
        // Ensure consistent results if the client and server list the same algorithms
        // in different order of preference.
        let serverAlgorithms;
        let clientAlgorithms;
        if (this.session.isClientSession) {
            serverAlgorithms = remoteAlgorithms || [];
            clientAlgorithms = localAlgorithms;
        }
        else {
            serverAlgorithms = localAlgorithms;
            clientAlgorithms = remoteAlgorithms || [];
        }
        const negotiationDetail = `${label} negotiation: ` +
            `Server (${serverAlgorithms.join(', ')}) ` +
            `Client (${clientAlgorithms.join(', ')})`;
        for (const client of clientAlgorithms) {
            for (const server of serverAlgorithms) {
                if (server === client) {
                    const result = server;
                    this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.algorithmNegotiation, `${negotiationDetail} => ${result}`);
                    return result;
                }
            }
        }
        throw new Error(`Failed ${negotiationDetail}`);
    }
    async computeExchangeHash(kex, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret) {
        if (!this.session.remoteVersion) {
            throw new Error('Key exchange not completed.');
        }
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(2048));
        if (this.session.isClientSession) {
            writer.writeString(sshSession_1.SshSession.localVersion.toString(), 'ascii');
            writer.writeString(this.session.remoteVersion.toString(), 'ascii');
        }
        else {
            writer.writeString(this.session.remoteVersion.toString(), 'ascii');
            writer.writeString(sshSession_1.SshSession.localVersion.toString(), 'ascii');
        }
        writer.writeBinary(this.exchangeContext.clientKexInitPayload);
        writer.writeBinary(this.exchangeContext.serverKexInitPayload);
        writer.writeBinary(hostKeyAndCerts);
        // These values are formatted as bigints (with leading zeroes if the first bit is high)
        // even though they might not really be bigints, depending on the key-exchange algorithm.
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(clientExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(serverExchangeValue, { unsigned: true }));
        writer.writeBigInt(bigInt_1.BigInt.fromBytes(sharedSecret, { unsigned: true }));
        const hash = await kex.sign(writer.toBuffer());
        return hash;
    }
    async computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac) {
        var _a, _b;
        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 /* mpint header */ +
            sharedSecret.length +
            exchangeHash.length +
            Math.max(1 /* letter */ + ((_b = (_a = this.session.sessionId) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0), keyExchange.digestLength)));
        writer.writeBinary(sharedSecret);
        writer.write(exchangeHash);
        const offset = writer.position;
        const clientCipherIV = clientEncryption &&
            (await this.computeKey(keyExchange, writer, offset, clientEncryption.blockLength, 'A'));
        const serverCipherIV = serverEncryption &&
            (await this.computeKey(keyExchange, writer, offset, serverEncryption.blockLength, 'B'));
        const clientCipherKey = clientEncryption &&
            (await this.computeKey(keyExchange, writer, offset, clientEncryption.keyLength, 'C'));
        const serverCipherKey = serverEncryption &&
            (await this.computeKey(keyExchange, writer, offset, serverEncryption.keyLength, 'D'));
        const clientHmacKey = clientHmac &&
            (await this.computeKey(keyExchange, writer, offset, clientHmac.keyLength, 'E'));
        const serverHmacKey = serverHmac &&
            (await this.computeKey(keyExchange, writer, offset, serverHmac.keyLength, 'F'));
        return [
            clientCipherIV,
            serverCipherIV,
            clientCipherKey,
            serverCipherKey,
            clientHmacKey,
            serverHmacKey,
        ];
    }
    async computeKey(keyExchange, writer, writerOffset, blockSize, letter) {
        const keyBuffer = buffer_1.Buffer.alloc(blockSize);
        let keyBufferIndex = 0;
        let currentHashLength = 0;
        let currentHash = null;
        if (!this.session.sessionId) {
            throw new Error('Session ID not set.');
        }
        while (keyBufferIndex < blockSize) {
            writer.position = writerOffset;
            if (!currentHash) {
                writer.writeByte(letter.charCodeAt(0));
                writer.write(this.session.sessionId);
            }
            else {
                writer.write(currentHash);
            }
            currentHash = await keyExchange.sign(writer.toBuffer());
            currentHashLength = Math.min(currentHash.length, blockSize - keyBufferIndex);
            currentHash.copy(keyBuffer, keyBufferIndex);
            keyBufferIndex += currentHashLength;
        }
        if (currentHash) {
            currentHash.fill(0);
        }
        return keyBuffer;
    }
};
KeyExchangeService.serviceName = 'ssh-keyexchange';
KeyExchangeService = KeyExchangeService_1 = __decorate([
    (0, serviceActivation_1.serviceActivation)({ serviceRequest: KeyExchangeService_1.serviceName })
], KeyExchangeService);
exports.KeyExchangeService = KeyExchangeService;
//# sourceMappingURL=keyExchangeService.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findService = exports.serviceActivation = void 0;
/**
 * Decorator applied to suclasses of `SshService` that declares how the service gets activated.
 */
function serviceActivation(activation) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return (constructor) => {
        if (!constructor.activations) {
            constructor.activations = [];
        }
        constructor.activations.push(activation);
    };
}
exports.serviceActivation = serviceActivation;
/**
 * Locates a service type in configuration, using a predicate to check service activation
 * attributes.
 *
 * @param serviceConfigs Service configuration dictionary from `SshSessionConfiguration.services`.
 * @param predicate Function to test whether a service activation attribute matches some condition.
 * @returns Service type (constructor), or null if no service type satisfies the predicate.
 */
function findService(serviceConfigs, predicate) {
    for (const serviceType of serviceConfigs.keys()) {
        const activations = serviceType.activations;
        let foundActivation = false;
        for (const activation of activations) {
            foundActivation = true;
            if (predicate(activation)) {
                return serviceType;
            }
        }
        if (!foundActivation) {
            throw new Error(`SSH service type '${serviceType.name}' must have one or more ` +
                '\'serviceActivation\' decorators.');
        }
    }
    return null;
}
exports.findService = findService;
//# sourceMappingURL=serviceActivation.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/services/sshService.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshService = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const sshSession_1 = __webpack_require__(/*! ../sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
/**
 * Base class for SSH session services that handle incoming requests.
 *
 * Services can be on either the server side or the client side, because either side may
 * send requests to the other's services.
 *
 * Service subclasses must have one or more `serviceActivation` decorators applied to them to
 * declare the type(s) of requests that cause the service to be activated. Only one instance
 * of each service type gets activated for a session, even if there are multiple activation
 * rules. After activation, a service remains active for the duration of the session,
 * handling any additional requests, until it is disposed when the session is disposed.
 *
 * To enable activation of a service, add the service type to
 * `SshSessionConfiguration.services`. When a service is activated, the session raises a
 * `SshSession.serviceActivated` event.
 */
class SshService {
    constructor(session) {
        this.session = session;
        this.disposed = false;
        this.disposedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisposed = this.disposedEmitter.event;
        if (!(session instanceof sshSession_1.SshSession)) {
            // Other packages provide services that inherit from SshService. When they do, they
            // reference the SshSession type from a specific version of this package. But at runtime,
            // the service may be activated with a session from a different version of this package,
            // if there are multiple instances due to version mismatches. Multiple instances of SSH
            // types causes problems, so it's best to detect the error at initialization time.
            throw new TypeError('Session is not an instance of SshSession. ' +
                '(This may be due to a version mismatch between SSH packages.)');
        }
    }
    get trace() {
        return this.session.trace;
    }
    raiseReportProgress(progress) {
        this.session.raiseReportProgress(progress);
    }
    dispose() {
        if (this.disposed)
            return;
        this.disposed = true;
        this.disposedEmitter.fire();
    }
    /**
     * Services that are activated via session requests must override this method to handle
     * incoming session requests.
     *
     * Implementations must set `SshRequestEventArgs.isAuthorized` or
     * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
     */
    async onSessionRequest(request, cancellation) {
        this.session.raiseSessionRequest(request);
    }
    /**
     * Services that are activated via channel types must override this method to handle
     * incoming requests to open a channel.
     *
     * Implementations may set `SshChannelOpeningEventArgs.failureReason` or
     * `SshChannelOpeningEventArgs.openingPromise` to block opening of the channel.
     * The default behavior allows the channel to open.
     *
     * Requests on the opened channel will not be directed to `onChannelRequest`
     * unless the service also declares activation on specific channel request(s). Otherwise,
     * an implementation of this method may add any event-handlers to the
     * `SshChannelOpeningEventArgs.channel` including a request event handler.
     */
    async onChannelOpening(request, cancellation) {
        if (!request)
            throw new TypeError('Request is required.');
        return this.session.handleChannelOpening(request, cancellation, false);
    }
    /**
     * Services that are activated via channel requests must override this method to handle
     * incoming channel requests.
     *
     * Implementations must set `SshRequestEventArgs.isAuthorized` or
     * `SshRequestEventArgs.responsePromise` to indicate whether the request was allowed.
     */
    async onChannelRequest(channel, request, cancellation) { }
    /**
     * Sends any message.
     */
    async sendMessage(message, cancellation) {
        await this.session.sendMessage(message, cancellation);
    }
}
exports.SshService = SshService;
//# sourceMappingURL=sshService.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshChannel = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const serviceActivation_1 = __webpack_require__(/*! ./services/serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
const connectionMessages_1 = __webpack_require__(/*! ./messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const channelMetrics_1 = __webpack_require__(/*! ./metrics/channelMetrics */ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/channelMetrics.js");
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const sshRequestEventArgs_1 = __webpack_require__(/*! ./events/sshRequestEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js");
const sshChannelClosedEventArgs_1 = __webpack_require__(/*! ./events/sshChannelClosedEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshChannelClosedEventArgs.js");
const cancellation_1 = __webpack_require__(/*! ./util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const semaphore_1 = __webpack_require__(/*! ./util/semaphore */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const pipeExtensions_1 = __webpack_require__(/*! ./pipeExtensions */ "../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js");
const queue_1 = __webpack_require__(/*! ./util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
/**
 * Represents a channel on an SSH session. A session may include multiple channels, which
 * are multiplexed over the connection. Each channel within a session has a unique integer ID.
 */
class SshChannel {
    /* @internal */
    constructor(connectionService, channelType, channelId, remoteChannelId, remoteMaxWindowSize, remoteMaxPacketSize, openMessage, openConfirmationMessage) {
        this.connectionService = connectionService;
        this.channelType = channelType;
        this.channelId = channelId;
        this.remoteChannelId = remoteChannelId;
        this.openMessage = openMessage;
        this.openConfirmationMessage = openConfirmationMessage;
        this.remoteClosed = false;
        this.localClosed = false;
        this.sentEof = false;
        this.disposed = false;
        this.openSendingWindowCompletionSource = null;
        this.requestCompletionSources = new queue_1.Queue();
        this.sendSemaphore = new semaphore_1.Semaphore(0);
        /**
         * Gets an object that reports measurements about the channel.
         */
        this.metrics = new channelMetrics_1.ChannelMetrics();
        this.dataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        this.extendedDataReceivedEmitter = new vscode_jsonrpc_1.Emitter();
        /**
         * Event raised when a data message is received on the channel.
         *
         * Users of a channel MUST add a `onDataReceived` event handler immediately after a
         * channel is opened/accepted, or else all session communication will be blocked.
         * (The `SshStream` class does this automatically.)
         *
         * The event handler must call `adjustWindow` when the data has been consumed,
         * to notify the remote side that it may send more data.
         */
        this.onDataReceived = this.dataReceivedEmitter.event;
        this.onExtendedDataReceived = this.extendedDataReceivedEmitter.event;
        this.eofEmitter = new vscode_jsonrpc_1.Emitter();
        /**
         * Event raised when an EOF message is received on the channel.
         */
        this.onEof = this.eofEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        /**
         * Gets or sets a value indicating whether `maxWindowSize is locked, so that it cannot be
         * changed after the channel is opened.
         */
        /* @internal */
        this.isMaxWindowSizeLocked = false;
        this.remoteWindowSize = remoteMaxWindowSize;
        this.maxWindowSizeValue = SshChannel.defaultMaxWindowSize;
        this.windowSize = this.maxWindowSizeValue;
        this.maxPacketSize = Math.min(remoteMaxPacketSize, SshChannel.defaultMaxPacketSize);
    }
    get session() {
        return this.connectionService.session;
    }
    get isClosed() {
        return this.localClosed || this.remoteClosed;
    }
    /**
     * Gets the maximum window size for received data. The other side will not send more
     * data than the window size until it receives an acknowledgement that some of the data was
     * received and processed by this side.
     */
    get maxWindowSize() {
        return this.maxWindowSizeValue;
    }
    /**
     * Sets the maximum window size for received data. The other side will not send more
     * data than the window size until it receives an acknowledgement that some of the data was
     * received and processed by this side.
     *
     * The default value is `defaultMaxWindowSize`. The value may be configured for a channel
     * opened by this side by setting `ChannelOpenMessage.maxWindowSize` in the message object
     * passed to `SshSession.openChannel()`, or for a channel opened by the other side by
     * assigning to this property while handling the `SshSession.onChannelOpening` event.
     * Changing the maximum window size at any other time is not valid because the other
     * side would not be aware of the change.
     */
    set maxWindowSize(value) {
        if (this.isMaxWindowSizeLocked) {
            throw new Error('Cannot change the max window size after opening the channel.');
        }
        if (value < this.maxPacketSize) {
            throw new Error('Maximum window size cannot be less than maximum packet size.');
        }
        this.maxWindowSizeValue = value;
    }
    /**
     * Sends a channel request and waits for a response.
     *
     * Note if `wantReply` is `false`, this method returns `true` immediately after sending the
     * request, without waiting for a reply.
     *
     * @returns The authorization status of the response; if false, the other side denied the
     * request.
     * @throws `ObjectDisposedError` if the channel was closed before sending the request.
     * @throws `SshChannelError` if the channel was closed while waiting for a reply to the request.
     */
    async request(request, cancellation) {
        if (!request)
            throw new TypeError('Request is required.');
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        request.recipientChannel = this.remoteChannelId;
        if (!request.wantReply) {
            // If a reply is not requested, there's no need to set up a completion source.
            await this.session.sendMessage(request, cancellation);
            return true;
        }
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellation.onCancellationRequested(() => {
                requestCompletionSource.reject(new cancellation_1.CancellationError());
            });
        }
        this.requestCompletionSources.enqueue(requestCompletionSource);
        await this.session.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
    }
    async send(data, cancellation) {
        return this.sendCommon(data, undefined, cancellation);
    }
    async sendExtendedData(dataTypeCode, data, cancellation) {
        return this.sendCommon(data, dataTypeCode, cancellation);
    }
    async sendCommon(data, extendedDataType, cancellation) {
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if (data.length === 0) {
            await this.sendEof();
            return;
        }
        else if (this.sentEof) {
            throw new Error('Cannot send more data after EOF.');
        }
        // Prevent out-of-order message chunks even if the caller does not await.
        // Also don't send until the channel is fully opened.
        await this.sendSemaphore.wait(cancellation);
        try {
            let offset = 0;
            let count = data.length;
            while (count > 0) {
                let packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
                while (packetSize === 0) {
                    if (!this.openSendingWindowCompletionSource) {
                        this.openSendingWindowCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
                    }
                    this.session.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.channelWaitForWindowAdjust, `${this} send window is full. Waiting for window adjustment before sending.`);
                    await (0, cancellation_1.withCancellation)(this.openSendingWindowCompletionSource.promise, cancellation);
                    this.openSendingWindowCompletionSource = null;
                    packetSize = Math.min(Math.min(this.remoteWindowSize, this.maxPacketSize), count);
                }
                let msg;
                if (extendedDataType !== undefined) {
                    msg = new connectionMessages_1.ChannelExtendedDataMessage();
                    msg.dataTypeCode = extendedDataType;
                }
                else {
                    msg = new connectionMessages_1.ChannelDataMessage();
                }
                msg.recipientChannel = this.remoteChannelId;
                // Unfortunately the data must be copied to a new buffer at this point
                // to ensure it is still available to be re-sent later in case of disconnect.
                msg.data = Buffer.from(data.slice(offset, offset + packetSize));
                await this.session.sendMessage(msg, cancellation);
                this.remoteWindowSize -= packetSize;
                count -= packetSize;
                offset += packetSize;
                this.metrics.addBytesSent(packetSize);
            }
        }
        finally {
            this.sendSemaphore.tryRelease();
        }
    }
    /* @internal */
    enableSending() {
        this.sendSemaphore.tryRelease();
    }
    async sendEof(cancellation) {
        if (this.sentEof) {
            return;
        }
        await this.sendSemaphore.wait(cancellation);
        try {
            this.sentEof = true;
            const msg = new connectionMessages_1.ChannelEofMessage();
            msg.recipientChannel = this.remoteChannelId;
            await this.session.sendMessage(msg, cancellation);
        }
        finally {
            this.sendSemaphore.tryRelease();
        }
    }
    /* @internal */
    async handleRequest(request, cancellation) {
        if (!request.requestType) {
            throw new errors_1.SshConnectionError('Channel request type not specified.', transportMessages_1.SshDisconnectReason.protocolError);
        }
        if (request.requestType === connectionMessages_1.ChannelRequestType.exitStatus) {
            const signal = new connectionMessages_1.ChannelSignalMessage();
            request.convertTo(signal);
            this.exitStatus = signal.exitStatus;
            return true;
        }
        else if (request.requestType === connectionMessages_1.ChannelRequestType.exitSignal) {
            const signal = new connectionMessages_1.ChannelSignalMessage();
            request.convertTo(signal);
            this.exitSignal = signal.exitSignal;
            this.exitErrorMessage = signal.errorMessage;
            return true;
        }
        else if (request.requestType === connectionMessages_1.ChannelRequestType.signal) {
            const signal = new connectionMessages_1.ChannelSignalMessage();
            request.convertTo(signal);
        }
        const args = new sshRequestEventArgs_1.SshRequestEventArgs(request.requestType, request, this.session.principal, cancellation);
        const serviceType = (0, serviceActivation_1.findService)(this.session.config.services, (a) => (!a.channelType || a.channelType === this.channelType) &&
            a.channelRequest === request.requestType);
        await this.sendSemaphore.wait(cancellation);
        try {
            let response = null;
            if (serviceType) {
                // A service was configured for activation via this session request type.
                const service = this.session.activateService(serviceType);
                // `onChannelRequest` should really be 'protected internal'.
                await service.onChannelRequest(this, args, cancellation);
            }
            else {
                this.requestEmitter.fire(args);
            }
            // TODO: do not block requests in TS (similar to CS)
            // see https://dev.azure.com/devdiv/DevDiv/_git/SSH/commit/0b84a48811e2f015107c73bf4584b6c3b676a6de
            if (args.responsePromise) {
                response = await args.responsePromise;
                args.isAuthorized = response instanceof connectionMessages_1.ChannelSuccessMessage;
            }
            if (request.wantReply) {
                if (args.isAuthorized) {
                    response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelSuccessMessage();
                    response.recipientChannel = this.remoteChannelId;
                }
                else {
                    response = response !== null && response !== void 0 ? response : new connectionMessages_1.ChannelFailureMessage();
                    response.recipientChannel = this.remoteChannelId;
                }
                await this.session.sendMessage(response, cancellation);
            }
        }
        finally {
            this.sendSemaphore.tryRelease();
        }
        return args.isAuthorized || false;
    }
    /* @internal */
    handleResponse(result) {
        const requestCompletionSource = this.requestCompletionSources.dequeue();
        if (requestCompletionSource) {
            requestCompletionSource.resolve(result);
        }
    }
    /* @internal */
    handleDataReceived(data) {
        this.metrics.addBytesReceived(data.length);
        // DataReceived handler is to adjust the window when it's done with the data.
        this.dataReceivedEmitter.fire(data);
    }
    handleExtendedDataReceived(data) {
        this.metrics.addBytesReceived(data.data.length);
        this.extendedDataReceivedEmitter.fire(data);
    }
    /**
     * Adjusts the local receiving window size by the specified amount, notifying
     * the remote side that it is free to send more data.
     *
     * This method MUST be called either immediately or eventually by the
     * `onDataReceived` event handler as incoming data is processed.
     */
    adjustWindow(messageLength) {
        if (this.disposed)
            return;
        this.windowSize -= messageLength;
        if (this.windowSize <= this.maxWindowSizeValue / 2) {
            const windowAdjustMessage = new connectionMessages_1.ChannelWindowAdjustMessage();
            windowAdjustMessage.recipientChannel = this.remoteChannelId;
            windowAdjustMessage.bytesToAdd = this.maxWindowSizeValue - this.windowSize;
            this.windowSize = this.maxWindowSizeValue;
            this.session.sendMessage(windowAdjustMessage).catch((e) => {
                this.session.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.channelWindowAdjustFailed, `Error sending window adjust message: ${e.message}`, e);
            });
        }
    }
    /* @internal */
    adjustRemoteWindow(bytesToAdd) {
        this.remoteWindowSize += bytesToAdd;
        if (this.openSendingWindowCompletionSource) {
            this.openSendingWindowCompletionSource.resolve(undefined);
        }
    }
    /* @internal */
    handleEof() {
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelEofReceived, `${this} EOF received.`);
        this.eofEmitter.fire();
    }
    close(exitStatusOrSignal, errorMessage, cancellation) {
        if (exitStatusOrSignal instanceof Error) {
            const error = exitStatusOrSignal;
            if (!this.localClosed) {
                this.localClosed = true;
                this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, `${this} Closed: ${error.message}`);
                this.closedEmitter.fire(new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(error));
            }
            this.disposeInternal();
            return;
        }
        if (typeof exitStatusOrSignal === 'number') {
            return this.closeWithStatus(exitStatusOrSignal, errorMessage);
        }
        else if (typeof exitStatusOrSignal === 'string') {
            return this.closeWithSignal(exitStatusOrSignal, errorMessage, cancellation);
        }
        else {
            return this.closeDefault(exitStatusOrSignal);
        }
    }
    async closeDefault(cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
            this.remoteClosed = true;
            await this.sendSemaphore.wait(cancellation);
            try {
                const closeMessage = new connectionMessages_1.ChannelCloseMessage();
                closeMessage.recipientChannel = this.remoteChannelId;
                await this.session.sendMessage(closeMessage);
            }
            catch (e) {
                // The session was already closed.
            }
            finally {
                this.sendSemaphore.tryRelease();
            }
        }
        if (!this.localClosed) {
            this.localClosed = true;
            const closedMessage = this.raiseClosedEvent();
        }
        this.disposeInternal();
    }
    async closeWithStatus(exitStatus, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
            this.exitStatus = exitStatus;
            const signalMessage = new connectionMessages_1.ChannelSignalMessage();
            signalMessage.recipientChannel = this.remoteChannelId;
            signalMessage.exitStatus = exitStatus;
            await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
    }
    async closeWithSignal(exitSignal, errorMessage, cancellation) {
        if (!this.remoteClosed && !this.localClosed) {
            this.exitSignal = exitSignal;
            this.exitErrorMessage = errorMessage;
            const signalMessage = new connectionMessages_1.ChannelSignalMessage();
            signalMessage.recipientChannel = this.remoteChannelId;
            signalMessage.exitSignal = exitSignal;
            signalMessage.errorMessage = errorMessage;
            await this.session.sendMessage(signalMessage);
        }
        await this.closeDefault(cancellation);
    }
    /* @internal */
    handleClose() {
        if (!this.localClosed) {
            this.localClosed = true;
            const closedMessage = this.raiseClosedEvent(true);
        }
        this.disposeInternal();
    }
    raiseClosedEvent(closedByRemote = false) {
        const metricsMessage = ` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`;
        const originMessage = closedByRemote ? 'remotely' : 'locally';
        let closedMessage;
        let args;
        if (typeof this.exitStatus !== 'undefined') {
            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitStatus);
            closedMessage = `${this} closed ${originMessage}: status=${this.exitStatus}`;
        }
        else if (typeof this.exitSignal !== 'undefined') {
            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitSignal, this.exitErrorMessage);
            closedMessage = `${this} closed ${originMessage}: signal=${this.exitSignal} ${this.exitErrorMessage}`;
        }
        else {
            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs();
            closedMessage = `${this} closed ${originMessage}.`;
        }
        this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, closedMessage + metricsMessage);
        this.closedEmitter.fire(args);
        return closedMessage;
    }
    dispose() {
        if (!this.disposed && !this.localClosed) {
            if (!this.remoteClosed) {
                this.remoteClosed = true;
                const closeMessage = new connectionMessages_1.ChannelCloseMessage();
                closeMessage.recipientChannel = this.remoteChannelId;
                this.session.sendMessage(closeMessage).catch((e) => {
                    // The session was already closed, or some other sending error occurred.
                    // The details have already been traced.
                });
            }
            const message = this.session.isClosed ? `${this.session} closed.` : `${this} disposed.`;
            this.session.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.channelClosed, message);
            const args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs('SIGABRT', message);
            this.localClosed = true;
            this.closedEmitter.fire(args);
        }
        this.disposeInternal();
    }
    disposeInternal() {
        if (this.disposed)
            return;
        this.disposed = true;
        this.cancelPendingRequests();
        this.connectionService.removeChannel(this);
        this.sendSemaphore.dispose();
    }
    /**
     * Pipes one SSH channel into another, relaying all data between them.
     * @param toChannel Channel to which the current channel will be connected via the pipe.
     * @returns A promise that resolves when the channels are closed.
     */
    pipe(toChannel) {
        return pipeExtensions_1.PipeExtensions.pipeChannel(this, toChannel);
    }
    cancelPendingRequests() {
        for (const completion of this.requestCompletionSources) {
            completion.resolve(false);
        }
    }
    toString() {
        return `SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`;
    }
}
exports.SshChannel = SshChannel;
SshChannel.sessionChannelType = 'session';
/**
 * Default maximum packet size. Channel data payloads larger than the max packet size will
 * be broken into chunks before sending. The actual `maxPacketSize` may be smaller (but
 * never larger) than the default if requested by the other side.
 */
SshChannel.defaultMaxPacketSize = connectionMessages_1.ChannelOpenMessage.defaultMaxPacketSize;
/**
 * Default maximum window size for received data. The other side will not send more data than
 * the window size until it receives an acknowledgement that some of the data was received and
 * processed by this side. A non-default `maxWindowSize` may be configured at the time of
 * opening the channel.
 */
SshChannel.defaultMaxWindowSize = connectionMessages_1.ChannelOpenMessage.defaultMaxWindowSize;
//# sourceMappingURL=sshChannel.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshClientSession.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshClientSession = void 0;
const sshSession_1 = __webpack_require__(/*! ./sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const sshAuthenticatingEventArgs_1 = __webpack_require__(/*! ./events/sshAuthenticatingEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshAuthenticatingEventArgs.js");
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const cancellation_1 = __webpack_require__(/*! ./util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
const authenticationService_1 = __webpack_require__(/*! ./services/authenticationService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js");
const connectionService_1 = __webpack_require__(/*! ./services/connectionService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
/**
 * The client side of an SSH session. Extends the base `SshSession` class to
 * support client authentication.
 */
class SshClientSession extends sshSession_1.SshSession {
    constructor(config) {
        super(config, true);
        this.serviceRequests = new Map();
        this.clientAuthCompletion = null;
    }
    /**
     * Attempts to authenticate both the server and client.
     *
     * This method must be called only after encrypting the session. It is equivalent
     * to calling both `authenticateServer()` and `authenticateClient()` and waiting on
     * both results.
     *
     * @returns `true` if authentication succeeded, `false` if it failed.
     */
    async authenticate(clientCredentials, cancellation) {
        const serverAuthenticated = await this.authenticateServer(cancellation);
        if (!serverAuthenticated) {
            return false;
        }
        const clientAuthenticated = await this.authenticateClient(clientCredentials, cancellation);
        if (!clientAuthenticated) {
            return false;
        }
        return true;
    }
    /**
     * Triggers server authentication by invoking the `authenticating` event with
     * the verified server host key.
     *
     * This method must be called only after encrypting the session. It does not wait for any
     * further message exchange with the server, since the server host key would have already
     * been obtained during the key-exchange.
     *
     * @returns `true` if authentication succeeded, `false` if it failed.
     */
    async authenticateServer(cancellation) {
        if (!(this.kexService && this.kexService.hostKey)) {
            throw new Error('Encrypt the session before authenticating.');
        }
        try {
            // Raise an Authenticating event that allows handlers to do verification
            // of the host key and return a principal for the server.
            this.principal = await this.raiseAuthenticatingEvent(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.serverPublicKey, {
                publicKey: this.kexService.hostKey,
            }, cancellation));
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.authenticationError, `Error while authenticating server: ${e.message}`, e);
            throw e;
        }
        if (!this.principal) {
            await this.close(transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable, 'Server authentication failed.');
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.serverAuthenticationFailed, `${this} server authentication failed.`);
            return false;
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} server authenticated.`);
        return true;
    }
    /* @internal */
    authenticateClient(credentials, callbackOrCancellation, cancellation) {
        if (!credentials) {
            throw new TypeError('A credentials object is required.');
        }
        if (typeof callbackOrCancellation === 'function') {
            return this.authenticateClientWithCompletion(credentials, callbackOrCancellation, cancellation);
        }
        else {
            return new Promise((resolve, reject) => this.authenticateClientWithCompletion(credentials, (err, result) => {
                if (err)
                    reject(err);
                else
                    resolve(result);
            }, callbackOrCancellation));
        }
    }
    async authenticateClientWithCompletion(credentials, callback, cancellation) {
        this.clientAuthCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
        this.clientAuthCompletion.promise.then((result) => callback(undefined, result), (err) => callback(err));
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellation.onCancellationRequested((e) => {
                if (this.clientAuthCompletion) {
                    this.clientAuthCompletion.reject(new cancellation_1.CancellationError());
                }
            });
        }
        let authService = this.getService(authenticationService_1.AuthenticationService);
        if (!authService) {
            const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
            serviceRequestMessage.serviceName = authenticationService_1.AuthenticationService.serviceName;
            await this.sendMessage(serviceRequestMessage, cancellation);
            // Assume the service request is accepted, without waiting for an accept message.
            // (If not, the following auth requests will fail anyway.)
            authService = this.activateService(authenticationService_1.AuthenticationService);
        }
        await authService.authenticateClient(credentials, cancellation);
    }
    /* @internal */
    onAuthenticationComplete(success) {
        if (success) {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticated, `${this} client authenticated.`);
        }
        else {
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.clientAuthenticationFailed, `${this} client authentication failed.`);
        }
        if (this.clientAuthCompletion) {
            this.clientAuthCompletion.resolve(success);
            this.clientAuthCompletion = null;
        }
    }
    /**
     * Sends a request for a service and waits for a response.
     *
     * @param serviceName Name of the service to be requested.
     * @param cancellation Optional cancellation token.
     * @returns A promise that resolves when the service request has been accepted.
     *
     * If the server does not accept the service request, it will disconnect the session.
     */
    async requestService(serviceName, cancellation) {
        let sendRequest = false;
        let completion = this.serviceRequests.get(serviceName);
        if (!completion) {
            completion = new promiseCompletionSource_1.PromiseCompletionSource();
            this.serviceRequests.set(serviceName, completion);
            sendRequest = true;
        }
        if (sendRequest) {
            const requestMessage = new transportMessages_1.ServiceRequestMessage();
            requestMessage.serviceName = serviceName;
            await this.sendMessage(requestMessage, cancellation);
        }
        await completion.promise;
    }
    /* @internal */
    async handleServiceAcceptMessage(message, cancellation) {
        const completion = this.serviceRequests.get(message.serviceName);
        completion === null || completion === void 0 ? void 0 : completion.resolve(true);
    }
    async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        if (!this.connectionService) {
            // Authentication must have been skipped, meaning there was no
            // connection service request sent yet. Send it now, and assume
            // it is accepted without waiting for a response.
            const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();
            serviceRequestMessage.serviceName = connectionService_1.ConnectionService.serviceName;
            await this.sendMessage(serviceRequestMessage, cancellation);
        }
        return await super.openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation);
    }
    /* @internal */
    handleDisconnected() {
        if (this.reconnecting) {
            this.reconnecting = false;
            return false;
        }
        return super.handleDisconnected();
    }
    /**
     * Call instead of `connect()` to reconnect to a prior session instead of connecting
     * a new session.
     * @param stream A new stream that has just (re-) connected to the server.
     * @param cancellation Optional cancellation token.
     * @returns True if reconnect succeeded, false if the server declined the reconnect
     * request or reconnect session validation failed. In the case of a false return value,
     * retrying is unlikely to succeed.
     * @throws {SshConnectionError} There was a problem connecting to or communicating with
     * the server; retrying may still succeed if connectivity is restored.
     * @throws {SshReconnectError} Reconnect failed for some reason other than a communication
     * issue: see the `failureReason` property of the error. Retrying is unlikely to succeed,
     * unless the specific error condition can be addressed.
     */
    async reconnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.clientSessionReconnecting, 'Attempting to reconnect...');
        if (this.isClosed) {
            throw new errors_1.ObjectDisposedError(this);
        }
        else if (this.isConnected) {
            throw new Error('Already connected.');
        }
        if (!this.protocol) {
            throw new Error('The session was never previously connected.');
        }
        if (this.reconnecting) {
            throw new Error('Already reconnecting.');
        }
        this.reconnecting = true;
        try {
            await this.reconnectInternal(stream, cancellation);
        }
        finally {
            this.reconnecting = false;
        }
    }
    async reconnectInternal(stream, cancellation) {
        var _a, _b, _c, _d, _e, _f;
        const previousSessionId = this.sessionId;
        const previousProtocolInstance = this.protocol;
        const previousHostKey = (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.hostKey;
        if (!previousSessionId ||
            !previousProtocolInstance ||
            !this.kexService ||
            !previousHostKey ||
            !((_b = previousProtocolInstance.extensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            throw new Error('Reconnect was not enabled for this session.');
        }
        let newSessionId;
        try {
            // Reconnecting will temporarily create a new session ID.
            this.sessionId = null;
            await this.connect(stream, cancellation);
            if (!this.sessionId || !this.algorithms || !this.algorithms.signer) {
                throw new Error('Session is not encrypted.');
            }
            // Ensure the client is not reconnecting to a different server.
            const newHostKey = this.kexService.hostKey;
            const newHostPublicKey = !newHostKey ? null : await newHostKey.getPublicKeyBytes();
            const previousHostPublicKey = await previousHostKey.getPublicKeyBytes();
            if (!newHostPublicKey ||
                !previousHostPublicKey ||
                !newHostPublicKey.equals(previousHostPublicKey)) {
                const message = 'The server host key is different.';
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
                throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.differentServerHostKey);
            }
            newSessionId = this.sessionId;
        }
        catch (e) {
            // Restore the previous protocol instance so reconnect may be attempted again.
            this.protocol = previousProtocolInstance;
            super.handleDisconnected();
            throw e;
        }
        finally {
            // Restore the previous session ID and host key for the reconnected session.
            this.sessionId = previousSessionId;
            this.kexService.hostKey = previousHostKey;
        }
        const reconnectToken = await this.createReconnectToken(previousSessionId, newSessionId);
        const reconnectRequest = new transportMessages_1.SessionReconnectRequestMessage();
        reconnectRequest.requestType = "session-reconnect@microsoft.com" /* ExtensionRequestTypes.sessionReconnect */;
        reconnectRequest.clientReconnectToken = reconnectToken;
        reconnectRequest.lastReceivedSequenceNumber = previousProtocolInstance.lastIncomingSequence;
        reconnectRequest.wantReply = true;
        const response = await this.requestResponse(reconnectRequest, transportMessages_1.SessionReconnectResponseMessage, transportMessages_1.SessionReconnectFailureMessage, cancellation);
        if (response instanceof transportMessages_1.SessionReconnectFailureMessage) {
            const reason = (_c = response.reasonCode) !== null && _c !== void 0 ? _c : transportMessages_1.SshReconnectFailureReason.unknownServerFailure;
            const message = (_d = response.description) !== null && _d !== void 0 ? _d : 'The server rejected the reconnect request.';
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
            // Restore the previous protocol instance so reconnect may be attempted again.
            this.protocol = previousProtocolInstance;
            throw new errors_1.SshReconnectError(message, reason);
        }
        if (!this.verifyReconnectToken(previousSessionId, newSessionId, (_e = response.serverReconnectToken) !== null && _e !== void 0 ? _e : Buffer.alloc(0))) {
            const message = 'The reconnect token provided by the server was invalid.';
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.invalidServerReconnectToken);
        }
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, 'Reconnect request was accepted by the server.');
        // Re-send lost messages.
        const messagesToResend = previousProtocolInstance.getSentMessages(((_f = response.lastReceivedSequenceNumber) !== null && _f !== void 0 ? _f : 0) + 1);
        if (!messagesToResend) {
            const message = 'Client is unable to re-send messages requested by the server.';
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.clientSessionReconnectFailed, `Reconnection failed: ${message}`);
            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.clientDroppedMessages);
        }
        let count = 0;
        for (const message of messagesToResend) {
            await this.sendMessage(message, cancellation);
            count++;
        }
        // Now the session is fully reconnected!
        previousProtocolInstance.dispose();
        this.metrics.addReconnection();
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.clientSessionReconnecting, `${this} reconnected. Re-sent ${count} dropped messages.`);
    }
    dispose() {
        if (this.clientAuthCompletion) {
            this.clientAuthCompletion.reject(new errors_1.ObjectDisposedError(this));
        }
        super.dispose();
    }
}
exports.SshClientSession = SshClientSession;
//# sourceMappingURL=sshClientSession.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshRpcMessageStream.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshRpcMessageStream = void 0;
const rpc = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const sshData_1 = __webpack_require__(/*! ./io/sshData */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshData.js");
const contentLengthHeaderPrefix = 'Content-Length: ';
const headersSeparator = '\r\n\r\n';
class SshRpcMessageReader {
    constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.partialMessageEmitter = new rpc.Emitter();
        this.callback = null;
        this.messageBuffer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));
        this.headersLength = null;
        this.messageLength = null;
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.onPartialMessage = this.partialMessageEmitter.event;
        this.eventRegistration = this.channel.onDataReceived(this.onDataReceived.bind(this));
        this.channel.onClosed((e) => {
            if (e.error) {
                this.errorEmitter.fire(e.error);
            }
            // Note: we always want to fire a close event to avoid the rpc connection
            // to be used. After the event any usage of the rpc message connection will
            // throw an error with this code: ConnectionErrors.Closed
            this.closeEmitter.fire();
        });
    }
    listen(callback) {
        this.callback = callback;
        return rpc.Disposable.create(() => {
            this.callback = null;
        });
    }
    dispose() {
        if (this.eventRegistration) {
            this.eventRegistration.dispose();
        }
    }
    onDataReceived(data) {
        this.messageBuffer.write(data);
        this.channel.adjustWindow(data.length);
        // In case of recursion, the `data` might have already been a slice of the message buffer,
        // but it could have been invalidated by expansion during write() above.
        data = this.messageBuffer.toBuffer();
        if (this.messageLength === null) {
            const headersEnd = data.indexOf(headersSeparator);
            if (headersEnd < 0) {
                return; // Wait for more data.
            }
            const headers = data.slice(0, headersEnd).toString();
            if (!headers.startsWith(contentLengthHeaderPrefix)) {
                throw new Error(`Message does not start with JSON-RPC headers.\n${headers}`);
            }
            this.headersLength = headersEnd + headersSeparator.length;
            this.messageLength = parseInt(headers.substr(contentLengthHeaderPrefix.length, headersEnd - contentLengthHeaderPrefix.length), 10);
        }
        const position = this.messageBuffer.position;
        const totalLength = this.headersLength + this.messageLength;
        if (position >= totalLength) {
            if (this.callback) {
                const messageJson = data.slice(this.headersLength, totalLength).toString();
                let message;
                try {
                    message = JSON.parse(messageJson);
                }
                catch (e) {
                    if (!(e instanceof Error))
                        throw e;
                    throw new Error(`Failed to parse JSON-RPC message: ${e.message}\n${messageJson}`);
                }
                this.callback(message);
            }
            this.messageLength = null;
            this.messageBuffer.position = 0;
            if (position > totalLength) {
                // Recursively receive the remaining data, which will cause it
                // to be copied to the beginning of the buffer;
                this.onDataReceived(data.slice(totalLength));
            }
        }
    }
}
class SshRpcMessageWriter {
    constructor(channel) {
        this.channel = channel;
        this.errorEmitter = new rpc.Emitter();
        this.closeEmitter = new rpc.Emitter();
        this.onError = this.errorEmitter.event;
        this.onClose = this.closeEmitter.event;
        this.channel.onClosed((e) => {
            if (e.error) {
                this.errorEmitter.fire([
                    e.error,
                    (e.errorMessage && { jsonrpc: e.errorMessage }) || undefined,
                    e.exitStatus,
                ]);
            }
            this.closeEmitter.fire();
        });
    }
    write(message) {
        const messageJson = JSON.stringify(message);
        const messageData = buffer_1.Buffer.from(messageJson);
        const headerData = buffer_1.Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);
        const data = buffer_1.Buffer.alloc(headerData.length + messageData.length);
        headerData.copy(data, 0);
        messageData.copy(data, headerData.length);
        return this.channel.send(data).catch((e) => {
            this.errorEmitter.fire([e, undefined, undefined]);
        });
    }
    end() { }
    dispose() { }
}
class SshRpcMessageStream {
    constructor(channel) {
        this.reader = new SshRpcMessageReader(channel);
        this.writer = new SshRpcMessageWriter(channel);
    }
}
exports.SshRpcMessageStream = SshRpcMessageStream;
//# sourceMappingURL=sshRpcMessageStream.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshServerSession.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshServerSession = void 0;
const sshSession_1 = __webpack_require__(/*! ./sshSession */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
/**
 * The server side of an SSH session. Extends the base `SshSession` class
 * to support host authentication.
 */
class SshServerSession extends sshSession_1.SshSession {
    constructor(config, reconnectableSessions) {
        super(config, false);
        this.clientAuthenticatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClientAuthenticated = this.clientAuthenticatedEmitter.event;
        this.reconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onReconnected = this.reconnectedEmitter.event;
        /**
         * Gets or sets credentials and/or credential callbacks for authenticating the session.
         */
        this.credentials = { publicKeys: [] };
        const enableReconnect = config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);
        if (enableReconnect && !reconnectableSessions) {
            throw new Error('When reconnect is enabled, server sessions require a reference to a ' +
                'shared collection to track reconnectable sessions.');
        }
        else if (!enableReconnect && reconnectableSessions) {
            throw new Error('When reconnect is not enabled, the reconnectable sessions collection ' +
                'is not applicable.');
        }
        this.reconnectableSessions = reconnectableSessions;
    }
    /* @internal */
    async handleServiceRequestMessage(message, cancellation) {
        const service = this.activateService(message.serviceName);
        if (service) {
            const acceptMessage = new transportMessages_1.ServiceAcceptMessage();
            acceptMessage.serviceName = message.serviceName;
            await this.sendMessage(acceptMessage, cancellation);
        }
        else {
            throw new errors_1.SshConnectionError(`Service "${message.serviceName}" not available.`, transportMessages_1.SshDisconnectReason.serviceNotAvailable);
        }
    }
    /* @internal */
    async handleRequestMessage(message, cancellation) {
        var _a;
        if (message.requestType === "session-reconnect@microsoft.com" /* ExtensionRequestTypes.sessionReconnect */ &&
            ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            const reconnectRequest = message.convertTo(new transportMessages_1.SessionReconnectRequestMessage());
            await this.reconnect(reconnectRequest, cancellation);
            // reconnect() handles sending the response message.
            return;
        }
        await super.handleRequestMessage(message, cancellation);
    }
    /* @internal */
    handleClientAuthenticated() {
        this.clientAuthenticatedEmitter.fire();
    }
    /* @internal */
    async enableReconnect(cancellation) {
        await super.enableReconnect(cancellation);
        if (!this.reconnectableSessions.includes(this)) {
            this.reconnectableSessions.push(this);
        }
    }
    /* @internal */
    handleDisconnected() {
        if (this.reconnecting) {
            // Prevent closing the session while reconnecting.
            return true;
        }
        return super.handleDisconnected();
    }
    /**
     * Attempts to reconnect the client to a disconnected server session.
     *
     * If reconnection is successful, the current server session is disposed because the client
     * gets reconnected to a different server session.
     */
    /* @internal */
    async reconnect(reconnectRequest, cancellation) {
        var _a, _b, _c;
        if (!this.reconnectableSessions) {
            throw new Error('Disconnected sessions collection ' +
                'should have been initialized when reconnect is enabled.');
        }
        // Try to find the requested server session in the list of available disconnected
        // server sessions, by validating the reconnect token.
        let reconnectSession;
        for (const reconnectableSession of this.reconnectableSessions) {
            if (reconnectableSession !== this &&
                (await this.verifyReconnectToken(reconnectableSession.sessionId, this.sessionId, (_a = reconnectRequest.clientReconnectToken) !== null && _a !== void 0 ? _a : Buffer.alloc(0)))) {
                reconnectSession = reconnectableSession;
                this.reconnectableSessions.splice(this.reconnectableSessions.indexOf(reconnectSession), 1);
                break;
            }
        }
        if (!reconnectSession || reconnectSession.isClosed) {
            const message = 'Requested reconnect session was not found or ' +
                'the reconnect token provided by the client was invalid.';
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
            const failure = new transportMessages_1.SessionReconnectFailureMessage();
            failure.reasonCode = transportMessages_1.SshReconnectFailureReason.sessionNotFound;
            failure.description = message;
            await this.sendMessage(failure, cancellation);
            return;
        }
        const messagesToResend = reconnectSession.protocol.getSentMessages(((_b = reconnectRequest.lastReceivedSequenceNumber) !== null && _b !== void 0 ? _b : 0) + 1);
        if (!messagesToResend) {
            // Messages are not available from requested sequence number.
            // Restore the current session protocol and put the old session back in the collection.
            this.reconnectableSessions.push(reconnectSession);
            const message = 'Server is unable to re-send messages requested by the client.';
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.serverSessionReconnectFailed, `Reconnect failed: ${message}`);
            const failure = new transportMessages_1.SessionReconnectFailureMessage();
            failure.reasonCode = transportMessages_1.SshReconnectFailureReason.serverDroppedMessages;
            failure.description = message;
            await this.sendMessage(failure, cancellation);
            return;
        }
        const responseMessage = new transportMessages_1.SessionReconnectResponseMessage();
        responseMessage.serverReconnectToken = await this.createReconnectToken(reconnectSession.sessionId, this.sessionId);
        responseMessage.lastReceivedSequenceNumber = reconnectSession.protocol.lastIncomingSequence;
        await this.sendMessage(responseMessage, cancellation);
        try {
            reconnectSession.reconnecting = true;
            // Ensure the old connection is disconnected before switching over to the new one.
            (_c = reconnectSession.protocol) === null || _c === void 0 ? void 0 : _c.dispose();
            while (reconnectSession.isConnected) {
                await new Promise((resolve) => setTimeout(() => resolve(), 5));
            }
            // Move this session's protocol instance over to the reconnected session.
            reconnectSession.protocol = this.protocol;
            reconnectSession.protocol.kexService = reconnectSession.kexService;
            this.protocol = undefined;
            // Re-send the lost messages that the client requested.
            for (const message of messagesToResend) {
                await reconnectSession.sendMessage(message, cancellation);
            }
            // Now this server session is invalid because the client reconnected to another one.
            this.dispose(new errors_1.SshConnectionError('Reconnected.', transportMessages_1.SshDisconnectReason.none));
        }
        finally {
            reconnectSession.reconnecting = false;
        }
        this.reconnectableSessions.push(reconnectSession);
        reconnectSession.metrics.addReconnection();
        // Restart the message loop for the reconnected session.
        reconnectSession.processMessages().catch((e) => {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.serverSessionReconnecting, `${reconnectSession} reconnected. Re-sent ${messagesToResend.length} dropped messages.`);
        // Notify event listeners about the successful reconnection.
        reconnectSession.reconnectedEmitter.fire();
    }
    dispose(error) {
        if (this.reconnectableSessions) {
            const index = this.reconnectableSessions.indexOf(this);
            if (index >= 0) {
                this.reconnectableSessions.splice(index, 1);
            }
        }
        super.dispose(error);
    }
}
exports.SshServerSession = SshServerSession;
//# sourceMappingURL=sshServerSession.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshSession.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshSession = void 0;
const trace_1 = __webpack_require__(/*! ./trace */ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const sshSessionConfiguration_1 = __webpack_require__(/*! ./sshSessionConfiguration */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js");
const sshChannel_1 = __webpack_require__(/*! ./sshChannel */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshChannel.js");
const sshVersionInfo_1 = __webpack_require__(/*! ./sshVersionInfo */ "../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js");
const sshProtocol_1 = __webpack_require__(/*! ./io/sshProtocol */ "../../node_modules/@microsoft/dev-tunnels-ssh/io/sshProtocol.js");
const keyExchangeService_1 = __webpack_require__(/*! ./services/keyExchangeService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js");
const serviceActivation_1 = __webpack_require__(/*! ./services/serviceActivation */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/serviceActivation.js");
const connectionService_1 = __webpack_require__(/*! ./services/connectionService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js");
const authenticationService_1 = __webpack_require__(/*! ./services/authenticationService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js");
const sshMessage_1 = __webpack_require__(/*! ./messages/sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
const kexMessages_1 = __webpack_require__(/*! ./messages/kexMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/kexMessages.js");
const connectionMessages_1 = __webpack_require__(/*! ./messages/connectionMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/connectionMessages.js");
const authenticationMessages_1 = __webpack_require__(/*! ./messages/authenticationMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/authenticationMessages.js");
const transportMessages_1 = __webpack_require__(/*! ./messages/transportMessages */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/transportMessages.js");
const sessionMetrics_1 = __webpack_require__(/*! ./metrics/sessionMetrics */ "../../node_modules/@microsoft/dev-tunnels-ssh/metrics/sessionMetrics.js");
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const sshSessionClosedEventArgs_1 = __webpack_require__(/*! ./events/sshSessionClosedEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshSessionClosedEventArgs.js");
const sshRequestEventArgs_1 = __webpack_require__(/*! ./events/sshRequestEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshRequestEventArgs.js");
const sshAlgorithms_1 = __webpack_require__(/*! ./algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
const cancellation_1 = __webpack_require__(/*! ./util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
const semaphore_1 = __webpack_require__(/*! ./util/semaphore */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js");
const pipeExtensions_1 = __webpack_require__(/*! ./pipeExtensions */ "../../node_modules/@microsoft/dev-tunnels-ssh/pipeExtensions.js");
const queue_1 = __webpack_require__(/*! ./util/queue */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js");
const progress_1 = __webpack_require__(/*! ./progress */ "../../node_modules/@microsoft/dev-tunnels-ssh/progress.js");
const sshReportProgressEventArgs_1 = __webpack_require__(/*! ./events/sshReportProgressEventArgs */ "../../node_modules/@microsoft/dev-tunnels-ssh/events/sshReportProgressEventArgs.js");
/**
 * Allows SSH sessions to keep track of the session number for progress
 * reporting purposes.
 */
let sessionCounter = 0;
/**
 * Base class for an SSH server or client connection; coordinates high-level SSH
 * protocol details and dispatches messages to registered internal services.
 * Enables opening and accepting `SshChannel` instances.
 */
class SshSession {
    get algorithms() {
        return this.protocol ? this.protocol.algorithms : null;
    }
    /**
     * Gets an object containing claims about the server or client on the
     * other end of the session, or `null` if the session is not authenticated.
     *
     * This property is initially `null` for an unauthenticated session. On
     * successful authentication, the session Authenticating event handler
     * provides a Task that returns a principal that is stored here.
     */
    get principal() {
        return this.principalValue;
    }
    /* @internal */
    set principal(value) {
        this.principalValue = value;
    }
    constructor(config, isClientSession) {
        this.config = config;
        this.remoteVersion = null;
        this.activatedServices = new Map();
        this.connectionService = null;
        this.requestHandlers = new queue_1.Queue();
        this.blockedMessages = [];
        this.blockedMessagesSemaphore = new semaphore_1.Semaphore(1);
        this.connected = false;
        this.disposed = false;
        /**
         * Gets an object that reports current and cumulative measurements about the session.
         */
        this.metrics = new sessionMetrics_1.SessionMetrics();
        /* @internal */
        this.reconnecting = false;
        this.sessionId = null;
        this.principalValue = null;
        this.authenticatingEmitter = new vscode_jsonrpc_1.Emitter();
        /**
         * Event that is raised when a client or server is requesting authentication.
         *
         * See `SshAuthenticationType` for a description of the different authentication
         * methods and how they map to the event-args object.
         *
         * After validating the credentials, the event handler must set the
         * `SshAuthenticatingEventArgs.authenticationPromise` property to a task that
         * resolves to a principal object to indicate successful authentication. That principal will
         * then be associated with the sesssion as the `principal` property.
         */
        this.onAuthenticating = this.authenticatingEmitter.event;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onClosed = this.closedEmitter.event;
        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisconnected = this.disconnectedEmitter.event;
        this.serviceActivatedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onServiceActivated = this.serviceActivatedEmitter.event;
        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();
        this.onChannelOpening = this.channelOpeningEmitter.event;
        this.requestEmitter = new vscode_jsonrpc_1.Emitter();
        this.onRequest = this.requestEmitter.event;
        this.reportProgressEmitter = new vscode_jsonrpc_1.Emitter();
        /**
         * Event that is raised to report connection progress.
         *
         * See `Progress` for a description of the different progress events that can be reported.
         */
        this.onReportProgress = this.reportProgressEmitter.event;
        /**
         * Gets or sets a function that handles trace messages associated with the session.
         *
         * By default, no messages are traced. To enable tracing, set this property to a function
         * that routes the message to console.log, a file, or anywhere else.
         *
         * @param level Level of message: error, warning, info, or verbose
         * @param eventId Integer identifier of the event being traced.
         * @param msg Message (non-localized) describing the event.
         */
        this.trace = (level, eventId, msg, err) => { };
        this.isClientSession = isClientSession;
        this.sessionNumber = ++sessionCounter;
        if (!config)
            throw new TypeError('Session configuration is required.');
        if (!config.keyExchangeAlgorithms.find((a) => !!a)) {
            if (config.encryptionAlgorithms.length > 0 &&
                config.encryptionAlgorithms.indexOf(null) < 0) {
                throw new Error('Encryption requires a key-exchange algorithm to be configured.');
            }
            else if (config.hmacAlgorithms.length > 0 && config.hmacAlgorithms.indexOf(null) < 0) {
                throw new Error('HMAC requires a key-exchange algorithm to be configured.');
            }
            else if (config.publicKeyAlgorithms.length > 0 &&
                config.publicKeyAlgorithms.indexOf(null) < 0) {
                throw new Error('Host authentication requires a key-exchange algorithm to be configured.');
            }
            // No key exchange, no encryption, no HMAC.
            this.kexService = null;
            this.activateService(connectionService_1.ConnectionService);
        }
        else {
            this.kexService = new keyExchangeService_1.KeyExchangeService(this);
        }
        config.onConfigurationChanged(() => {
            const protocol = this.protocol;
            if (protocol) {
                protocol.traceChannelData = config.traceChannelData;
            }
        });
    }
    get isConnected() {
        return this.connected;
    }
    get isClosed() {
        return this.disposed;
    }
    get services() {
        return [...this.activatedServices.values()];
    }
    get channels() {
        var _a, _b;
        return (_b = (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.channels) !== null && _b !== void 0 ? _b : [];
    }
    get protocolExtensions() {
        var _a;
        return ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.extensions) || null;
    }
    /**
     * Gets an activated service instance by type.
     *
     * @returns The service instance, or `null` if the service has not been activated.
     */
    getService(serviceType) {
        const service = this.activatedServices.get(serviceType);
        return service ? service : null;
    }
    /* @internal */
    activateService(serviceTypeOrName) {
        let serviceType;
        if (typeof serviceTypeOrName === 'function') {
            serviceType = serviceTypeOrName;
        }
        else {
            const serviceName = serviceTypeOrName;
            serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.serviceRequest === serviceName);
            if (!serviceType) {
                return null;
            }
        }
        let activatedService = this.activatedServices.get(serviceType);
        if (!activatedService) {
            if (!this.config.services.has(serviceType)) {
                throw new Error(`Service type not configured: ${serviceType.name}`);
            }
            const serviceConfig = this.config.services.get(serviceType);
            activatedService = new serviceType(this, serviceConfig);
            // This service is maintained in a separate member because it is accessed frequently.
            if (serviceType === connectionService_1.ConnectionService) {
                this.connectionService = activatedService;
            }
            this.activatedServices.set(serviceType, activatedService);
            this.serviceActivatedEmitter.fire(activatedService);
        }
        return activatedService;
    }
    async connect(stream, cancellation) {
        if (!stream)
            throw new TypeError('A session stream is required.');
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if (!this.connectPromise) {
            this.connectPromise = this.doConnect(stream, cancellation);
        }
        await this.connectPromise;
    }
    async doConnect(stream, cancellation) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionConnecting, `${this} ${this.reconnecting ? 're' : ''}connecting...`);
        this.raiseReportProgress(progress_1.Progress.OpeningSshSessionConnection);
        this.protocol = new sshProtocol_1.SshProtocol(stream, this.config, this.metrics, this.trace);
        this.protocol.kexService = this.kexService;
        this.raiseReportProgress(progress_1.Progress.StartingProtocolVersionExchange);
        await this.exchangeVersions(cancellation);
        if (this.kexService) {
            await this.encrypt(cancellation);
        }
        else {
            // When there's no key-exchange service configured, send a key-exchange init message
            // that specifies "none" for all algorithms.
            await this.sendMessage(kexMessages_1.KeyExchangeInitMessage.none, cancellation);
            // When encrypting, the key-exchange step will wait on the version-exchange.
            // When not encrypting, it must be directly awaited.
            await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
            this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
            this.connected = true;
        }
        this.processMessages().catch((e) => {
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.unknownError, `Unhandled error processing messages: ${e.message}`, e);
        });
        this.raiseReportProgress(progress_1.Progress.OpenedSshSessionConnection);
    }
    async exchangeVersions(cancellation) {
        const writePromise = this.protocol.writeProtocolVersion(SshSession.localVersion.toString(), cancellation);
        const readPromise = this.protocol.readProtocolVersion(cancellation);
        // Don't wait for and verify the other side's version info yet.
        // Instead save a promise that can be awaited later.
        this.versionExchangePromise = readPromise.then(async (remoteVersion) => {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.protocolVersion, `Local version: ${SshSession.localVersion}, remote version: ${remoteVersion}`);
            let errorMessage;
            const remoteVersionInfo = sshVersionInfo_1.SshVersionInfo.tryParse(remoteVersion);
            if (remoteVersionInfo) {
                this.remoteVersion = remoteVersionInfo;
                if (remoteVersionInfo.protocolVersion === '2.0') {
                    return;
                }
                errorMessage =
                    `Remote SSH version ${this.remoteVersion} is not supported. ` +
                        'This library only supports SSH v2.0.';
            }
            else {
                errorMessage = `Could not parse remote SSH version ${remoteVersion}`;
            }
            await this.close(transportMessages_1.SshDisconnectReason.protocolVersionNotSupported, errorMessage, new Error(errorMessage));
        });
        await writePromise;
    }
    async encrypt(cancellation) {
        var _a, _b;
        const protocol = this.protocol;
        if (!protocol)
            throw new errors_1.ObjectDisposedError(this);
        await protocol.considerReExchange(true, cancellation);
        // Ensure the protocol version has been received before receiving any messages.
        await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);
        this.raiseReportProgress(progress_1.Progress.CompletedProtocolVersionExchange);
        this.connected = true;
        this.raiseReportProgress(progress_1.Progress.StartingKeyExchange);
        let message = null;
        while (!this.isClosed &&
            !((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) &&
            !(message instanceof transportMessages_1.DisconnectMessage)) {
            message = await protocol.receiveMessage(cancellation);
            if (!message) {
                break;
            }
            await this.handleMessage(message, cancellation);
        }
        this.raiseReportProgress(progress_1.Progress.CompletedKeyExchange);
        if (!((_b = this.protocol) === null || _b === void 0 ? void 0 : _b.algorithms)) {
            throw new errors_1.SshConnectionError('Session closed while encrypting.', transportMessages_1.SshDisconnectReason.connectionLost);
        }
        else if (this.protocol.algorithms.cipher) {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionEncrypted, `${this} encrypted.`);
        }
    }
    /* @internal */
    async processMessages() {
        var _a;
        this.connected = true;
        while (!this.disposed) {
            const protocol = this.protocol;
            if (!protocol) {
                break;
            }
            let message = null;
            try {
                message = await protocol.receiveMessage();
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                let reason = transportMessages_1.SshDisconnectReason.protocolError;
                if (e instanceof errors_1.SshConnectionError) {
                    reason = (_a = e.reason) !== null && _a !== void 0 ? _a : reason;
                }
                else {
                    this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.receiveMessageFailed, `Error receiving message: ${e.message}`, e);
                }
                await this.close(reason, e.message, e);
            }
            if (!message) {
                await this.close(transportMessages_1.SshDisconnectReason.connectionLost, 'Connection lost.');
                break;
            }
            try {
                await this.handleMessage(message);
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.handleMessageFailed, `Error handling ${message}: ${e.message}`, e);
                await this.close(transportMessages_1.SshDisconnectReason.protocolError, e.message, e);
            }
        }
        this.connected = false;
    }
    /**
     * Checks whether the session is in a state that allows requests, such as session requests
     * and open-channel requests.
     *
     * A session with disabled crypto (no key-exchange service) always allows requests. A
     * session with enabled crypto does not allow requests until the first key-exchange has
     * completed (algorithms are negotiated). If the negotiated algorithms enabled encryption,
     * then the session must be authenticated (have a principal) before allowing requests.
     */
    /* @internal */
    get canAcceptRequests() {
        var _a;
        return (!this.kexService ||
            (!!((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) && (!this.protocol.algorithms.cipher || !!this.principal)));
    }
    async sendMessage(message, cancellation) {
        var _a, _b;
        if (!message)
            throw new TypeError('Message expected.');
        if (cancellation && cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
        const protocol = this.protocol;
        if (!protocol || this.disposed) {
            throw new errors_1.ObjectDisposedError(this);
        }
        // Delay sending messages if in the middle of a key (re-)exchange.
        if (this.kexService &&
            this.kexService.exchanging &&
            message.messageType > 4 &&
            (message.messageType < 20 || message.messageType > 49)) {
            this.blockedMessages.push(message);
            return;
        }
        await this.blockedMessagesSemaphore.wait(cancellation);
        let result;
        try {
            result = await protocol.sendMessage(message, cancellation);
            this.blockedMessagesSemaphore.release();
        }
        catch (e) {
            this.blockedMessagesSemaphore.release();
            if (e instanceof errors_1.SshConnectionError) {
                const ce = e;
                if (ce.reason === transportMessages_1.SshDisconnectReason.connectionLost &&
                    ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
                    // Connection-lost error when reconnect is enabled. Don't throw an error;
                    // the message will remain in the reconnect message cache and will be re-sent
                    // upon reconnection.
                    return;
                }
            }
            if (!(e instanceof Error))
                throw e;
            this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sendMessageFailed, `Error sending ${message}: ${e.message}`, e);
            throw e;
        }
        if (!result) {
            // Sending failed due to a closed stream, but don't throw when reconnect is enabled.
            // In that case the sent message is buffered and will be re-sent after reconnecting.
            if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
                throw new errors_1.SshConnectionError('Session disconnected.', transportMessages_1.SshDisconnectReason.connectionLost);
            }
        }
    }
    /**
     * Handles an incoming message. Can be overridden by subclasses to handle additional
     * message types that are registered via `SshSessionConfiguration.messages`.
     */
    handleMessage(message, cancellation) {
        var _a;
        if (message instanceof connectionMessages_1.ConnectionMessage && this.connectionService) {
            return this.connectionService.handleMessage(message, cancellation);
        }
        else if (message instanceof kexMessages_1.NewKeysMessage) {
            return this.handleNewKeysMessage(message, cancellation);
        }
        else if (message instanceof kexMessages_1.KeyExchangeMessage) {
            return this.handleKeyExchangeMessage(message, cancellation);
        }
        else if (message instanceof authenticationMessages_1.AuthenticationMessage) {
            return (_a = this.getService(authenticationService_1.AuthenticationService)) === null || _a === void 0 ? void 0 : _a.handleMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.ServiceRequestMessage) {
            return this.handleServiceRequestMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.ServiceAcceptMessage) {
            return this.handleServiceAcceptMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.SessionRequestMessage) {
            return this.handleRequestMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.SessionRequestSuccessMessage) {
            return this.handleRequestSuccessMessage(message);
        }
        else if (message instanceof transportMessages_1.SessionRequestFailureMessage) {
            return this.handleRequestFailureMessage(message);
        }
        else if (message instanceof transportMessages_1.ExtensionInfoMessage) {
            return this.handleExtensionInfoMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.DisconnectMessage) {
            return this.handleDisconnectMessage(message);
        }
        else if (message instanceof transportMessages_1.UnimplementedMessage) {
            return this.handleUnimplementedMessage(message, cancellation);
        }
        else if (message instanceof transportMessages_1.DebugMessage) {
            return this.handleDebugMessage(message);
        }
        else if (message instanceof transportMessages_1.IgnoreMessage) {
            // Do nothing for ignore message
            return;
        }
        else if (message instanceof sshMessage_1.SshMessage) {
            throw new Error(`Unhandled message type: ${message.constructor.name}`);
        }
        else {
            throw new TypeError('Message argument was ' + (message ? 'invalid type.' : 'null.'));
        }
    }
    /* @internal */
    async handleRequestMessage(message, cancellation) {
        var _a;
        let result = false;
        let response = null;
        if (message.requestType === "initial-channel-request@microsoft.com" /* ExtensionRequestTypes.initialChannelRequest */ &&
            this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest)) {
            const sessionChannelRequest = message.convertTo(new transportMessages_1.SessionChannelRequestMessage());
            const remoteChannelId = sessionChannelRequest.senderChannel;
            const channel = this.channels.find((c) => c.remoteChannelId === remoteChannelId);
            if (channel && sessionChannelRequest.request) {
                sessionChannelRequest.request.wantReply = false; // Avoid redundant reply
                result = await channel.handleRequest(sessionChannelRequest.request, cancellation);
            }
        }
        else if (message.requestType === "enable-session-reconnect@microsoft.com" /* ExtensionRequestTypes.enableSessionReconnect */ &&
            ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            if (!this.protocol.incomingMessagesHaveReconnectInfo) {
                // Starting immediately after this message, all incoming messages include
                // an extra field or two after the payload.
                this.protocol.incomingMessagesHaveReconnectInfo = true;
                this.protocol.incomingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
                result = true;
            }
        }
        else if (!this.canAcceptRequests) {
            this.trace(trace_1.TraceLevel.Warning, trace_1.SshTraceEventIds.sessionRequestFailed, 'Session request blocked because the session is not yet authenticated.');
            result = false;
        }
        else {
            const args = new sshRequestEventArgs_1.SshRequestEventArgs(message.requestType || '', message, this.principal, cancellation);
            const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.sessionRequest === message.requestType);
            if (serviceType) {
                // A service was configured for activation via this session request type.
                const service = this.activateService(serviceType);
                // `onSessionRequest` should really be 'protected internal'.
                await service.onSessionRequest(args, cancellation);
            }
            else {
                // Raise a request event to let an event listener handle this request.
                this.raiseSessionRequest(args);
            }
            // TODO: do not block requests in TS (similar to CS)
            // see https://dev.azure.com/devdiv/DevDiv/_git/SSH/commit/0b84a48811e2f015107c73bf4584b6c3b676a6de
            if (args.responsePromise) {
                response = await args.responsePromise;
                result = response instanceof transportMessages_1.SessionRequestSuccessMessage;
            }
            else {
                result = args.isAuthorized || false;
            }
        }
        if (message.wantReply) {
            if (result) {
                if (!(response instanceof transportMessages_1.SessionRequestSuccessMessage)) {
                    response = new transportMessages_1.SessionRequestSuccessMessage();
                }
            }
            else {
                if (!(response instanceof transportMessages_1.SessionRequestFailureMessage)) {
                    response = new transportMessages_1.SessionRequestFailureMessage();
                }
            }
            await this.sendMessage(response, cancellation);
        }
    }
    /* @internal */
    raiseReportProgress(progress) {
        const args = new sshReportProgressEventArgs_1.SshReportProgressEventArgs(progress, this.sessionNumber);
        this.reportProgressEmitter.fire(args);
    }
    /* @internal */
    raiseSessionRequest(args) {
        this.requestEmitter.fire(args);
    }
    /* @internal */
    async handleServiceRequestMessage(message, cancellation) {
        // Do nothing. Subclasses may override.
    }
    /* @internal */
    async handleServiceAcceptMessage(message, cancellation) {
        // Do nothing. Subclasses may override.
    }
    async handleKeyExchangeMessage(message, cancellation) {
        if (this.kexService) {
            await this.kexService.handleMessage(message, cancellation);
        }
        else if (!(message instanceof kexMessages_1.KeyExchangeInitMessage && message.allowsNone)) {
            // The other side required some security, but it's not configured here.
            await this.close(transportMessages_1.SshDisconnectReason.keyExchangeFailed, 'Encryption is disabled.');
        }
    }
    /* @internal */
    async handleNewKeysMessage(message, cancellation) {
        var _a;
        try {
            await this.blockedMessagesSemaphore.wait(cancellation);
            await this.protocol.handleNewKeys(cancellation);
            if ((_a = this.algorithms) === null || _a === void 0 ? void 0 : _a.isExtensionInfoRequested) {
                await this.sendExtensionInfo(cancellation);
            }
            try {
                // Send messages that were blocked during key exchange.
                while (this.blockedMessages.length > 0) {
                    const blockedMessage = this.blockedMessages.shift();
                    if (!this.protocol)
                        throw new errors_1.ObjectDisposedError(this);
                    await this.protocol.sendMessage(blockedMessage, cancellation);
                }
            }
            catch (e) {
                if (!(e instanceof Error))
                    throw e;
                await this.close(transportMessages_1.SshDisconnectReason.protocolError, undefined, e);
            }
        }
        finally {
            this.blockedMessagesSemaphore.release();
        }
    }
    async handleUnimplementedMessage(message, cancellation) {
        if (message.unimplementedMessageType !== undefined) {
            // Received a message type that is unimplemented by this side.
            // Send a reply to inform the other side.
            await this.sendMessage(message, cancellation);
        }
        else {
            // This is a reply indicating this side previously sent a message type
            // that is not implemented by the other side. It has already been traced.
        }
    }
    handleDebugMessage(message) {
        if (message.message) {
            this.trace(message.alwaysDisplay ? trace_1.TraceLevel.Info : trace_1.TraceLevel.Verbose, trace_1.SshTraceEventIds.debugMessage, message.message);
        }
    }
    /* @internal */
    async raiseAuthenticatingEvent(args) {
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionAuthenticating, `${this} Authenticating(${args})`);
        this.raiseReportProgress(progress_1.Progress.StartingSessionAuthentication);
        this.authenticatingEmitter.fire(args);
        let authPromise = args.authenticationPromise;
        if (!authPromise) {
            authPromise = Promise.resolve(null);
        }
        const principal = await authPromise;
        this.raiseReportProgress(progress_1.Progress.CompletedSessionAuthentication);
        return principal;
    }
    /**
     * Sends a session request and waits for a response.
     *
     * Note if `wantReply` is `false`, this method returns `true` immediately after sending
     * the request, without waiting for a response.
     *
     * @returns The authorization status of the response; if `false`, the other side denied the
     * request.
     */
    async request(request, cancellation) {
        if (!request)
            throw new TypeError('Request is required.');
        if (!request.wantReply) {
            await this.sendMessage(request, cancellation);
            return true;
        }
        const response = await this.requestResponse(request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);
        return response instanceof transportMessages_1.SessionRequestSuccessMessage;
    }
    /**
     * Sends a session request and waits for a specific type of success or failure message.
     *
     * @returns The success or failure response message.
     */
    async requestResponse(request, successType, failureType, cancellation) {
        if (!request)
            throw new TypeError('Request is required.');
        if (!successType)
            throw new TypeError('Success response type is required.');
        if (!failureType)
            throw new TypeError('Failure response type is required.');
        request.wantReply = true;
        const requestHandler = (err, result) => {
            var _a, _b;
            if (err) {
                requestCompletionSource.reject(err);
            }
            else if (requestHandler.isCancelled) {
                // The completion source was already rejected with a cancellation error.
                return;
            }
            else if (result instanceof transportMessages_1.SessionRequestFailureMessage) {
                const failure = (_a = result === null || result === void 0 ? void 0 : result.convertTo(new failureType(), true)) !== null && _a !== void 0 ? _a : null;
                requestCompletionSource.resolve(failure);
            }
            else if (result instanceof transportMessages_1.SessionRequestSuccessMessage) {
                // Make a copy of the response message because the continuation may be
                // asynchronous; meanwhile the receive buffer will be re-used.
                const success = (_b = result === null || result === void 0 ? void 0 : result.convertTo(new successType(), true)) !== null && _b !== void 0 ? _b : null;
                requestCompletionSource.resolve(success);
            }
            else {
                requestCompletionSource.reject(new Error('Unknown response message type.'));
            }
        };
        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellation.onCancellationRequested(() => {
                requestHandler.isCancelled = true;
                requestCompletionSource.reject(new cancellation_1.CancellationError());
            });
        }
        this.requestHandlers.enqueue(requestHandler);
        await this.sendMessage(request, cancellation);
        return await requestCompletionSource.promise;
    }
    handleRequestSuccessMessage(message) {
        this.invokeRequestHandler(message, undefined, undefined);
    }
    handleRequestFailureMessage(message) {
        this.invokeRequestHandler(undefined, message, undefined);
    }
    invokeRequestHandler(success, failure, error) {
        let requestHandler;
        while ((requestHandler = this.requestHandlers.dequeue())) {
            requestHandler(error, success !== null && success !== void 0 ? success : failure);
            // An error is provided if the session is disposing. In that case,
            // all pending requests should fail with that error.
            if (!error) {
                break;
            }
        }
    }
    async acceptChannel(channelTypeOrCancellation, cancellation) {
        const channelType = typeof channelTypeOrCancellation === 'string' ? channelTypeOrCancellation : undefined;
        if (!cancellation && typeof channelTypeOrCancellation === 'object')
            cancellation = channelTypeOrCancellation;
        this.activateService(connectionService_1.ConnectionService);
        // Prepare to accept the channel before connecting. This ensures that if the channel
        // open request comes in immediately after connecting then the channel won't be missed
        // in case of a task scheduling delay.
        const acceptPromise = this.connectionService.acceptChannel(channelType || sshChannel_1.SshChannel.sessionChannelType, cancellation);
        return await acceptPromise;
    }
    async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {
        let openMessage;
        if (typeof channelTypeOrOpenMessageOrCancellation === 'string' ||
            channelTypeOrOpenMessageOrCancellation === null) {
            openMessage = new connectionMessages_1.ChannelOpenMessage();
            openMessage.channelType =
                channelTypeOrOpenMessageOrCancellation !== null && channelTypeOrOpenMessageOrCancellation !== void 0 ? channelTypeOrOpenMessageOrCancellation : sshChannel_1.SshChannel.sessionChannelType;
        }
        else if (channelTypeOrOpenMessageOrCancellation instanceof connectionMessages_1.ChannelOpenMessage) {
            openMessage = channelTypeOrOpenMessageOrCancellation;
        }
        else {
            openMessage = new connectionMessages_1.ChannelOpenMessage();
            openMessage.channelType = sshChannel_1.SshChannel.sessionChannelType;
            cancellation = channelTypeOrOpenMessageOrCancellation;
        }
        if (initialRequestOrCancellation instanceof connectionMessages_1.ChannelRequestMessage) {
            return await this.openChannelWithInitialRequest(openMessage, initialRequestOrCancellation, cancellation);
        }
        else if (!cancellation && initialRequestOrCancellation !== null) {
            cancellation = initialRequestOrCancellation;
        }
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        return await completionSource.promise;
    }
    async openChannelWithInitialRequest(openMessage, initialRequest, cancellation) {
        var _a;
        this.activateService(connectionService_1.ConnectionService);
        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();
        const channelId = await this.connectionService.openChannel(openMessage, completionSource, cancellation);
        if (cancellation) {
            if (cancellation.isCancellationRequested)
                throw new cancellation_1.CancellationError();
            cancellation.onCancellationRequested(() => completionSource.reject(new cancellation_1.CancellationError()));
        }
        let channel;
        let requestResult;
        const isExtensionSupported = this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest) &&
            ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest));
        if (isExtensionSupported === false) {
            // The local or remote side definitely doesn't support this extension. Just send a
            // normal channel request after waiting for the channel open confirmation.
            channel = await completionSource.promise;
            requestResult = await channel.request(initialRequest, cancellation);
        }
        else {
            // The remote side does or might support this extension. If uncertain then a reply
            // is required.
            const wantReply = initialRequest.wantReply || isExtensionSupported === undefined;
            // Send the initial channel request message BEFORE waiting for the
            // channel open confirmation.
            const sessionRequest = new transportMessages_1.SessionChannelRequestMessage();
            sessionRequest.requestType = "initial-channel-request@microsoft.com" /* ExtensionRequestTypes.initialChannelRequest */;
            sessionRequest.senderChannel = channelId;
            sessionRequest.request = initialRequest;
            sessionRequest.wantReply = wantReply;
            const requestPromise = this.request(sessionRequest, cancellation);
            // Wait for the channel open confirmation.
            channel = await completionSource.promise;
            if (!wantReply) {
                requestResult = true;
            }
            else {
                // Wait for the response to the initial channel request.
                requestResult = await requestPromise;
                if (!requestResult && isExtensionSupported === undefined) {
                    // The initial request failed. This could be because the other side doesn't
                    // support the initial-request extension or because the request was denied.
                    // Try sending the request again as a regular channel request.
                    requestResult = await channel.request(initialRequest);
                }
            }
        }
        if (!requestResult) {
            // The regular request still failed, so close the channel and throw.
            await channel.close();
            throw new Error('The initial channel request was denied.');
        }
        return channel;
    }
    /* @internal */
    async handleChannelOpening(args, cancellation, resolveService = true) {
        if (resolveService) {
            const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.channelType === args.channel.channelType && !a.channelRequest);
            if (serviceType) {
                // A service was configured for activation via this channel type.
                const service = this.activateService(serviceType);
                // `onChannelOpening` should really be 'protected internal'.
                await service.onChannelOpening(args, cancellation);
                return;
            }
        }
        args.cancellation = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;
        this.channelOpeningEmitter.fire(args);
    }
    /* @internal */
    async sendExtensionInfo(cancellation) {
        if (!this.protocol)
            return;
        const message = new transportMessages_1.ExtensionInfoMessage();
        message.extensionInfo = {};
        for (const extensionName of this.config.protocolExtensions) {
            if (extensionName === sshSessionConfiguration_1.SshProtocolExtensionNames.serverSignatureAlgorithms) {
                // Send the list of enabled host key signature algorithms.
                const publicKeyAlgorithms = Array.from(new Set((0, sshAlgorithms_1.algorithmNames)(this.config.publicKeyAlgorithms))).join(',');
                message.extensionInfo[extensionName] = publicKeyAlgorithms;
            }
            else {
                message.extensionInfo[extensionName] = '';
            }
        }
        await this.protocol.sendMessage(message, cancellation);
    }
    async handleExtensionInfoMessage(message, cancellation) {
        if (!this.protocol) {
            return;
        }
        this.protocol.extensions = new Map();
        const proposedExtensions = message.extensionInfo;
        if (!proposedExtensions) {
            return;
        }
        for (const extensionName of this.config.protocolExtensions) {
            const proposedExtension = message.extensionInfo[extensionName];
            if (typeof proposedExtension === 'string') {
                this.protocol.extensions.set(extensionName, proposedExtension);
            }
        }
        if (this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect)) {
            await this.enableReconnect(cancellation);
        }
    }
    async close(reason, message, error) {
        var _a, _b, _c;
        if (this.disposed || !this.connected) {
            return;
        }
        this.connected = false;
        this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} Close(${transportMessages_1.SshDisconnectReason[reason]}, "${message || ''}")`);
        if (reason !== transportMessages_1.SshDisconnectReason.connectionLost) {
            try {
                const disconnectMessage = new transportMessages_1.DisconnectMessage();
                disconnectMessage.reasonCode = reason;
                disconnectMessage.description = message || '';
                await ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.sendMessage(disconnectMessage));
            }
            catch (e) {
                // Already disconnected.
            }
        }
        else if (this.handleDisconnected()) {
            // Keep the session in a disconnected (but not closed) state.
            (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionDisconnected, `${this} disconnected.`);
            this.disconnectedEmitter.fire();
            return;
        }
        this.disposed = true;
        this.closedError = error;
        error = error !== null && error !== void 0 ? error : new errors_1.SshConnectionError(message, reason);
        if (error) {
            (_c = this.connectionService) === null || _c === void 0 ? void 0 : _c.close(error);
        }
        this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(reason, message || 'Disconnected.', error));
        this.dispose();
    }
    /* @internal */
    handleDisconnected() {
        var _a, _b;
        this.connectPromise = undefined;
        (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.abortKeyExchange();
        if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {
            return false;
        }
        return true;
    }
    async handleDisconnectMessage(message) {
        var _a;
        const description = message.description || 'Received disconnect message.';
        await this.close((_a = message.reasonCode) !== null && _a !== void 0 ? _a : transportMessages_1.SshDisconnectReason.none, description);
    }
    dispose(error) {
        var _a, _b;
        const closedError = error !== null && error !== void 0 ? error : (this.closedError instanceof errors_1.SshConnectionError
            ? this.closedError
            : new errors_1.SshConnectionError(this.constructor.name + ' disposed.'));
        if (!this.disposed) {
            this.trace(trace_1.TraceLevel.Info, trace_1.SshTraceEventIds.sessionClosing, `${this} disposed.`);
            this.disposed = true;
            this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(transportMessages_1.SshDisconnectReason.none, closedError.message, closedError));
        }
        // Cancel any pending requests.
        this.invokeRequestHandler(undefined, undefined, closedError);
        this.metrics.close();
        // Dispose the connection service before other services, to ensure
        // channels are disposed before services that work with them.
        (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.dispose();
        for (const service of this.activatedServices.values()) {
            if (service !== this.connectionService) {
                service.dispose();
            }
        }
        this.activatedServices.clear();
        (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();
        this.protocol = undefined;
    }
    /* @internal */
    async enableReconnect(cancellation) {
        var _a;
        try {
            // Ensure no other messages are sent in the middle of turning this on.
            await this.blockedMessagesSemaphore.wait();
            // This should not be done during a key-exchange, however that should never
            // be the case since the EnableSessionReconnectRequest is sent in response
            // to an ExtensionInfo message which is sent in response to a NewKeys message.
            // So a key exchange just finished and won't be restarted again soon.
            if ((_a = this.kexService) === null || _a === void 0 ? void 0 : _a.exchanging) {
                this.trace(trace_1.TraceLevel.Error, trace_1.SshTraceEventIds.sessionReconnectInitFailed, 'Failed to initialize session reconnect because a key-exchange was in-progress.');
            }
            else {
                // Send the message indicating reconnect message tracking is starting.
                const enableReconnectMessage = new transportMessages_1.SessionRequestMessage("enable-session-reconnect@microsoft.com" /* ExtensionRequestTypes.enableSessionReconnect */, false);
                await this.protocol.sendMessage(enableReconnectMessage, cancellation);
                // Start using the protocol extensions that include an extra field or two
                // with every sent message.
                if (this.protocol) {
                    this.protocol.outgoingMessagesHaveReconnectInfo = true;
                    this.protocol.outgoingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);
                }
            }
            this.blockedMessagesSemaphore.release();
        }
        catch (e) {
            // This is not in a finally block because the semaphore must be released before
            // the call to close() which tries to send a message.
            this.blockedMessagesSemaphore.release();
            if (e instanceof Error) {
                await this.close(transportMessages_1.SshDisconnectReason.protocolError, undefined, e);
            }
            throw e;
        }
    }
    /* @internal */
    async createReconnectToken(previousSessionId, newSessionId) {
        // To generate the reconnect token, combine the old session ID and new (re-negotiated)
        // session ID and sign the result using the new negotiated HMAC algorithm and key. This
        // proves that the old (secret) session ID is known while not disclosing it, and also
        // prevents replay attacks.
        const reconnectToken = await this.algorithms.signer.sign(buffer_1.Buffer.concat([previousSessionId, newSessionId]));
        return reconnectToken;
    }
    /* @internal */
    async verifyReconnectToken(previousSessionId, newSessionId, reconnectToken) {
        const result = await this.algorithms.verifier.verify(buffer_1.Buffer.concat([previousSessionId, newSessionId]), reconnectToken);
        return result;
    }
    /**
     * Pipes one SSH session into another, relaying all data between them.
     *
     * Any new channels opened from the remote side of either session will be piped into a
     * new channel in the other session. Any channels opened before connecting the session pipe,
     * or any channels opened from the local side, will not be piped.
     *
     * @param toSession Session to which the current session will be connected via the pipe.
     * @returns A promise that resolves when the sessions are closed.
     */
    pipe(toSession) {
        return pipeExtensions_1.PipeExtensions.pipeSession(this, toSession);
    }
    toString() {
        return this.constructor.name;
    }
}
exports.SshSession = SshSession;
SshSession.localVersion = sshVersionInfo_1.SshVersionInfo.getLocalVersion();
//# sourceMappingURL=sshSession.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionAlgorithms.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshSessionAlgorithms = void 0;
class SshSessionAlgorithms {
    dispose() {
        if (this.cipher)
            this.cipher.dispose();
        if (this.decipher)
            this.decipher.dispose();
        if (this.signer)
            this.signer.dispose();
        if (this.verifier)
            this.verifier.dispose();
    }
}
exports.SshSessionAlgorithms = SshSessionAlgorithms;
//# sourceMappingURL=sshSessionAlgorithms.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshSessionConfiguration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshSessionConfiguration = exports.SshProtocolExtensionNames = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const sshAlgorithms_1 = __webpack_require__(/*! ./algorithms/sshAlgorithms */ "../../node_modules/@microsoft/dev-tunnels-ssh/algorithms/sshAlgorithms.js");
const keyExchangeService_1 = __webpack_require__(/*! ./services/keyExchangeService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/keyExchangeService.js");
const connectionService_1 = __webpack_require__(/*! ./services/connectionService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/connectionService.js");
const authenticationService_1 = __webpack_require__(/*! ./services/authenticationService */ "../../node_modules/@microsoft/dev-tunnels-ssh/services/authenticationService.js");
const sshMessage_1 = __webpack_require__(/*! ./messages/sshMessage */ "../../node_modules/@microsoft/dev-tunnels-ssh/messages/sshMessage.js");
var SshProtocolExtensionNames;
(function (SshProtocolExtensionNames) {
    /**
     * Lists host key signature algorithms enabled by the sender.
     *
     * This is a "standard" protocol extension supported by most SSH implementations.
     */
    SshProtocolExtensionNames["serverSignatureAlgorithms"] = "server-sig-algs";
    /**
     * An optimization that enables sending an initial channel request without
     * waiting for a channel open confirmation message.
     */
    SshProtocolExtensionNames["openChannelRequest"] = "open-channel-request@microsoft.com";
    /**
     * Enables reconnecting to a session that was recently disconnected.
     */
    SshProtocolExtensionNames["sessionReconnect"] = "session-reconnect@microsoft.com";
    /**
     * Enables continual latency measurements between client and server.
     *
     * This extension requires that the reconnect extension is also enabled, because
     * it leverages some of the session history info for reconnect to compute latency.
     */
    SshProtocolExtensionNames["sessionLatency"] = "session-latency@microsoft.com";
})(SshProtocolExtensionNames = exports.SshProtocolExtensionNames || (exports.SshProtocolExtensionNames = {}));
/**
 * Specifies the sets of algorithms and other configuration for an SSH session.
 *
 * Each collection of algorithms is in order of preference. Server and client
 * negotiate the most-preferred algorithm that is supported by both.
 */
class SshSessionConfiguration {
    constructor(useSecurity = true) {
        /**
         * Gets the protocol extensions that are enabled for the session.
         */
        this.protocolExtensions = [];
        /**
         * Gets a dictionary that maps from service types to service configuration objects.
         *
         * Service types must extend the `SshService` abstract class.
         *
         * The service configuration object is passed to the service constructor upon activation.
         */
        this.services = new Map();
        /**
         * Gets the list of enabled authentication methods.
         *
         * Add or remove `AuthenticationMethod` constants to restrict which client authentication
         * methods the client will try or the server will allow. In any case, the client or server must
         * handle the `SshSession.onAuthenticating` event to perform authentication.
         */
        this.authenticationMethods = [];
        /**
         * Gets a dictionary that maps from known message numbers to message types.
         *
         * Message types must extend the `SshMessage` abstract class. Message subclasses that do
         * not have a distinct message type from their base class must not be included in this map.
         */
        this.messages = new Map();
        /**
         * Gets a dictionary that maps from message context to message type mappings for each context.
         *
         * Services like `AuthenticationService` may set the current message context to
         * disambiguate when the same message number may be re-used in different contexts.
         */
        this.contextualMessages = new Map();
        /**
         * Gets the collection of algorithms that are enabled for key exchange.
         *
         * Client and server sides negotiate which of these algorithms will be used.
         *
         * If this collection includes `null`, and if negotiation selects it, then the session is
         * allowed to skip key exchange and connect with no security of any kind: No key exchange,
         * no authentication, no encryption, no HMAC, and no compression.
         */
        this.keyExchangeAlgorithms = [];
        /**
         * Gets the collection of algorithms that are enabled for server (host) and client
         * public-key authentication.
         *
         * Client and server sides negotiate which of these algorithms will be used.
         */
        this.publicKeyAlgorithms = [];
        /*
         * Gets the collection of algorithms that are enabled for encryption.
         *
         * Client and server sides negotiate which of these algorithms will be used.
         */
        this.encryptionAlgorithms = [];
        /**
         * Gets the collection of algorithms that are enabled for message integrity (HMAC).
         *
         * Client and server sides negotiate which of these algorithms will be used.
         */
        this.hmacAlgorithms = [];
        /**
         * Gets the collection of algorithms that are enabled for message compression.
         *
         * Client and server sides negotiate which of these algorithms will be used.
         */
        this.compressionAlgorithms = [];
        this.traceChannelDataValue = false;
        this.configurationChangedEmitter = new vscode_jsonrpc_1.Emitter();
        /* @internal */
        this.onConfigurationChanged = this.configurationChangedEmitter.event;
        /**
         * Gets or sets the number of times the server will allow a client to attempt to
         * authenticate.
         *
         * The default value is 5.
         *
         * This setting applies only to server sessions. If the client has failed to authenticate
         * after the maximum number of atttempts, the server will close the session.
         *
         * The SSH protocol allows a client to make multiple attempts to authenticate with
         * the server, e.g. to find which public key algorithm a server will support, or to
         * retry a mis-typed password. This maximum prevents unlimited retries, which would
         * make it easier to "guess" a password.
         *
         * In certain applications the server may only support a single authentication method
         * (which is not a typed password). Then it could be appropriate to set this value to 1.
         */
        this.maxClientAuthenticationAttempts = 5;
        /**
         * Gets or sets whether the client sends a key-exchange "guess" message before receiving
         * the server's key-exchange algorithm preferences, slightly reducing the time to connect.
         *
         * This setting only applies to client sessions. (The server always supports the option when
         * used by a client.)
         *
         * The "guess" mechanism is somewhat ambiguously defined in the SSH protocol spec, and as
         * a result is not implemented or incorrectly implemented by some server implementations,
         * including older versions of this library. Therefore it is disabled in the default
         * configuration, and should only be enabled when connecting to a known-good server.
         */
        this.enableKeyExchangeGuess = false;
        /* @internal */
        this.keyRotationThreshold = 512 * 1024 * 1024; // 0.5 GiB;
        this.protocolExtensions.push(SshProtocolExtensionNames.serverSignatureAlgorithms);
        this.protocolExtensions.push(SshProtocolExtensionNames.openChannelRequest);
        this.services.set(keyExchangeService_1.KeyExchangeService, null);
        this.services.set(connectionService_1.ConnectionService, null);
        this.services.set(authenticationService_1.AuthenticationService, null);
        this.authenticationMethods.push("none" /* AuthenticationMethod.none */, "password" /* AuthenticationMethod.password */, "publickey" /* AuthenticationMethod.publicKey */, "keyboard-interactive" /* AuthenticationMethod.keyboardInteractive */);
        for (const [messageKey, messageType] of sshMessage_1.SshMessage.index) {
            if (typeof messageKey === 'number') {
                this.messages.set(messageKey, messageType);
            }
            else {
                const [messageNumber, messageContext] = messageKey;
                let contextMessageTypes = this.contextualMessages.get(messageContext);
                if (!contextMessageTypes) {
                    contextMessageTypes = new Map();
                    this.contextualMessages.set(messageContext, contextMessageTypes);
                }
                contextMessageTypes.set(messageNumber, messageType);
            }
        }
        if (useSecurity) {
            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup16Sha512);
            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup14Sha256);
            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha512);
            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha256);
            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384);
            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp256);
            ////this.encryptionAlgorithms.push(SshAlgorithms.encryption.aes256Cbc);
            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Gcm);
            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Ctr);
            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512Etm);
            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256Etm);
            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512);
            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256);
        }
        else {
            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.none);
            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.none);
            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.none);
            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.none);
        }
        this.compressionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.compression.none);
    }
    /**
     * Adds a service to the configuration.
     */
    addService(serviceType, serviceConfig) {
        if (this.services.has(serviceType)) {
            throw new Error('Duplicate service entry.');
        }
        this.services.set(serviceType, serviceConfig);
    }
    getKeyExchangeAlgorithm(name) {
        return this.getAlgorithm(name, this.keyExchangeAlgorithms);
    }
    getPublicKeyAlgorithm(name) {
        return this.getAlgorithm(name, this.publicKeyAlgorithms);
    }
    getEncryptionAlgorithm(name) {
        return this.getAlgorithm(name, this.encryptionAlgorithms);
    }
    getHmacAlgorithm(name) {
        return this.getAlgorithm(name, this.hmacAlgorithms);
    }
    getCompressionAlgorithm(name) {
        return this.getAlgorithm(name, this.compressionAlgorithms);
    }
    getAlgorithm(name, collection) {
        const algorithm = collection.find((a) => (a ? a.name === name : false));
        if (!algorithm) {
            if (name === 'none') {
                return null;
            }
            throw new Error('Algorithm not found: ' + name);
        }
        return algorithm;
    }
    get traceChannelData() {
        return this.traceChannelDataValue;
    }
    /**
     * Enables tracing of all channel data messages.
     *
     * Unlike other configuration, this option may be adjusted any time while the session
     * is active. Channel data tracing produces a large volume of trace events, so it is
     * primarily meant only for debugging.
     */
    set traceChannelData(value) {
        if (value !== this.traceChannelDataValue) {
            this.traceChannelDataValue = value;
            this.configurationChangedEmitter.fire();
        }
    }
}
exports.SshSessionConfiguration = SshSessionConfiguration;
//# sourceMappingURL=sshSessionConfiguration.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshStream.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshStream = void 0;
const promiseCompletionSource_1 = __webpack_require__(/*! ./util/promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const stream_1 = __webpack_require__(/*! stream */ "stream");
/**
 * Adapts an SshChannel as a Readable+Writable stream.
 */
class SshStream extends stream_1.Duplex {
    constructor(channel) {
        let readPaused = null;
        super({
            async write(chunk, encoding, cb) {
                let error;
                try {
                    let buffer;
                    if (typeof chunk === 'string') {
                        buffer = Buffer.from(chunk, encoding);
                    }
                    else if (chunk instanceof Buffer || chunk instanceof Uint8Array) {
                        buffer = chunk;
                    }
                    else {
                        throw new Error('Unsupported chunk type: ' + typeof chunk);
                    }
                    await channel.send(buffer);
                }
                catch (e) {
                    if (!(e instanceof Error))
                        throw e;
                    error = e;
                }
                if (cb) {
                    cb(error);
                }
            },
            async writev(chunks, cb) {
                let error;
                try {
                    if (chunks.length === 1) {
                        return this.write(chunks[0].chunk, chunks[0].encoding, cb);
                    }
                    else {
                        function BufferReduce(accumulator, chunk) {
                            if (chunk.chunk instanceof Buffer || chunk.chunk instanceof Uint8Array) {
                                return accumulator + chunk.chunk.length;
                            }
                            else {
                                throw new Error('Unsupported chunk type: ' + typeof chunk.chunk);
                            }
                        }
                        const totalLength = chunks.reduce(BufferReduce, 0);
                        const singleBuffer = Buffer.alloc(totalLength);
                        let singleBufferIndex = 0;
                        for (let i = 0; i < chunks.length; i++) {
                            chunks[i].chunk.copy(singleBuffer, singleBufferIndex);
                            singleBufferIndex += chunks[i].chunk.length;
                        }
                        await channel.send(singleBuffer);
                    }
                }
                catch (e) {
                    if (!(e instanceof Error))
                        throw e;
                    error = e;
                }
                if (cb) {
                    cb(error);
                }
            },
            async final(cb) {
                let error;
                try {
                    await channel.close();
                }
                catch (e) {
                    if (!(e instanceof Error))
                        throw e;
                    error = e;
                }
                if (cb) {
                    cb(error);
                }
            },
            read() {
                if (readPaused) {
                    readPaused.resolve();
                    readPaused = null;
                }
            },
        });
        channel.onDataReceived(async (data) => {
            const buffer = Buffer.alloc(data.length);
            data.copy(buffer);
            const result = this.push(buffer);
            // Our flow control isn't great. Once we hit the highWaterMark,
            // we stop adjusting the SSH window until our own reader has caught up,
            // and then *all* the data received and buffered in the interim suddenly
            // gets 'adjusted' so that we tend to be somewhat choppy about adjusting the window.
            // Improving this would require that we know when the data we push gets passed to
            // the Duplex reader, and I don't think there's a way to get that notification.
            // So I suspect we'd have to dump Duplex and implement the stream ourselves.
            if (!result) {
                if (!readPaused) {
                    readPaused = new promiseCompletionSource_1.PromiseCompletionSource();
                }
                await readPaused.promise;
            }
            // Notify the channel that the data has been consumed and more data may be sent.
            channel.adjustWindow(buffer.length);
        });
        channel.onClosed(() => {
            this.push(null);
        });
        this.channel = channel;
    }
    /**
     * Destroys the stream and closes the underlying SSH channel.
     */
    destroy(error) {
        void this.channel.close().catch();
        super.destroy(error);
        return this;
    }
    toString() {
        return `SshStream(Channel Type: ${this.channel.channelType}, Id: ${this.channel.channelId}, RemoteId: ${this.channel.remoteChannelId})`;
    }
}
exports.SshStream = SshStream;
//# sourceMappingURL=sshStream.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/sshVersionInfo.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshVersionInfo = void 0;
const packageJson = __webpack_require__(/*! ./package.json */ "../../node_modules/@microsoft/dev-tunnels-ssh/package.json");
const packageName = packageJson.name.replace(/^@\w+\//, ''); // Strip scope from name.
const packageVersion = packageJson.version;
/**
 * Parses the SSH software name and version from the version string exchanged via the
 * initial packets sent between client and server.
 */
class SshVersionInfo {
    /**
     * Attempts to parse an SSH version string into a version info object.
     */
    static tryParse(versionString) {
        if (!versionString) {
            throw new TypeError('Version string expected.');
        }
        if (!versionString.startsWith('SSH-')) {
            return null;
        }
        const firstDashIndex = 3;
        const secondDashIndex = versionString.indexOf('-', firstDashIndex + 1);
        if (secondDashIndex <= 0) {
            return null;
        }
        const protocolVersion = versionString.substring(firstDashIndex + 1, secondDashIndex);
        if (!/^\d+\.\d+$/.test(protocolVersion)) {
            return null;
        }
        let name;
        let version;
        const nameAndVersion = versionString.substring(secondDashIndex + 1);
        const spaceIndex = nameAndVersion.indexOf(' ');
        const lastUnderscoreBeforeSpace = nameAndVersion.lastIndexOf('_', spaceIndex >= 0 ? spaceIndex : nameAndVersion.length - 1);
        if (lastUnderscoreBeforeSpace >= 0) {
            name = nameAndVersion.substring(0, lastUnderscoreBeforeSpace).replace(/_/g, ' ');
            // Ignore any non-digit characters after the version.
            version = nameAndVersion.substring(lastUnderscoreBeforeSpace + 1);
            for (let i = 0; i < version.length; i++) {
                const c = version[i];
                if (!(c >= '0' && c <= '9') && c !== '.') {
                    version = version.substring(0, i);
                    break;
                }
            }
            if (!/^\d+(\.\d+)*$/.test(version)) {
                version = null;
            }
        }
        else {
            name = nameAndVersion;
            version = null;
        }
        return new SshVersionInfo(versionString, protocolVersion, name, version);
    }
    /**
     * Gets the version info for the current SSH library.
     */
    static getLocalVersion() {
        const protocolVersion = '2.0';
        const versionString = `SSH-${protocolVersion}-${packageName}_${packageVersion}`;
        return new SshVersionInfo(versionString, protocolVersion, packageName, packageVersion);
    }
    constructor(versionString, protocolVersion, name, version) {
        this.versionString = versionString;
        this.protocolVersion = protocolVersion;
        this.name = name;
        this.version = version;
    }
    /** Returns the original SSH version string that was parsed. */
    toString() {
        return this.versionString;
    }
    /**
     * Gets a value indicating whether this version info represents some version of
     * this library.
     */
    get isVsSsh() {
        return this.isVsSshCS || this.isVsSshTS;
    }
    get isVsSshCS() {
        return this.name === 'Microsoft.VisualStudio.Ssh' || this.name === 'Microsoft.DevTunnels.Ssh';
    }
    get isVsSshTS() {
        return this.name === 'vs-ssh' || this.name === 'dev-tunnels-ssh';
    }
}
exports.SshVersionInfo = SshVersionInfo;
//# sourceMappingURL=sshVersionInfo.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/streams.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/streams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketStream = exports.NodeStream = exports.BaseStream = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const cancellation_1 = __webpack_require__(/*! ./util/cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
function handleCancellation(reject, cancellation) {
    if (cancellation) {
        if (cancellation.isCancellationRequested) {
            reject(new cancellation_1.CancellationError());
        }
        else {
            cancellation.onCancellationRequested(() => {
                reject(new cancellation_1.CancellationError());
            });
        }
    }
}
/**
 * Base class for stream adapters.
 */
class BaseStream {
    constructor() {
        this.incomingData = [];
        this.pendingReads = [];
        this.error = null;
        this.disposed = false;
        this.closedEmitter = new vscode_jsonrpc_1.Emitter();
        this.closed = this.closedEmitter.event;
    }
    onData(data) {
        while (this.pendingReads.length > 0) {
            const read = this.pendingReads.shift();
            if (read.count >= data.length) {
                // This read operation consumes all of the incoming data.
                read.resolve(data);
                return;
            }
            else {
                // This read operation consumes part of the incoming data.
                const readData = data.slice(0, read.count);
                data = data.slice(read.count);
                read.resolve(readData);
            }
        }
        this.incomingData.push(data);
    }
    onEnd() {
        while (this.pendingReads.length > 0) {
            const read = this.pendingReads.shift();
            read.resolve(null);
        }
        this.incomingData.push(buffer_1.Buffer.alloc(0));
    }
    onError(error) {
        if (!this.error) {
            this.error = error;
        }
        while (this.pendingReads.length > 0) {
            const read = this.pendingReads.shift();
            read.reject(error);
        }
    }
    async read(count, cancellation) {
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if (this.incomingData.length > 0) {
            // Consume data that has already arrived.
            let data = this.incomingData[0];
            if (data.length === 0) {
                // Reached the end of the stream.
                return null;
            }
            else if (count >= data.length) {
                // Consuming the whole chunk.
                this.incomingData.shift();
            }
            else {
                // Consuming part of the chunk.
                this.incomingData[0] = data.slice(count);
                data = data.slice(0, count);
            }
            return data;
        }
        else if (this.error) {
            throw this.error;
        }
        else {
            // Wait for more data to arrive.
            return await new Promise((resolve, reject) => {
                if (cancellation) {
                    if (cancellation.isCancellationRequested) {
                        reject(new cancellation_1.CancellationError());
                        return;
                    }
                    cancellation.onCancellationRequested(() => {
                        // Discard any pending reads that use this cancellation token.
                        for (let i = 0; i < this.pendingReads.length; i++) {
                            if (Object.is(cancellation, this.pendingReads[i].cancellation)) {
                                const read = this.pendingReads.splice(i--, 1)[0];
                                read.reject(new cancellation_1.CancellationError());
                            }
                        }
                    });
                }
                this.pendingReads.push({ count, resolve, reject, cancellation });
            });
        }
    }
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            const error = new errors_1.ObjectDisposedError(this);
            this.onError(error);
            this.fireOnClose(error);
        }
    }
    fireOnClose(error) {
        this.closedEmitter.fire({ error });
    }
    get isDisposed() {
        return this.disposed;
    }
}
exports.BaseStream = BaseStream;
/**
 * Stream adapter for a Node.js Socket, Duplex stream, or Readable/Writable stream pair.
 */
class NodeStream extends BaseStream {
    constructor(duplexOrReadStream, writeStream) {
        super();
        if (!duplexOrReadStream)
            throw new TypeError('Duplex or Readable/Writable stream are required.');
        this.readStream = duplexOrReadStream;
        this.writeStream = writeStream || duplexOrReadStream;
        this.readStream.on('data', this.onData.bind(this));
        this.readStream.on('end', this.onEnd.bind(this));
        this.readStream.on('error', this.onError.bind(this));
        this.readStream.on('close', () => {
            this.onEnd();
            this.fireOnClose();
        });
    }
    async write(data, cancellation) {
        if (!data)
            throw new TypeError('Data is required.');
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        return new Promise((resolve, reject) => {
            handleCancellation(reject, cancellation);
            this.writeStream.write(data, (err) => {
                if (!err) {
                    resolve();
                }
                else {
                    reject(err);
                }
            });
        });
    }
    async close(error, cancellation) {
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        await new Promise((resolve, reject) => {
            handleCancellation(reject, cancellation);
            this.writeStream.end(resolve);
        });
        this.disposed = true;
        this.onError(error || new errors_1.ObjectDisposedError(this));
        this.closedEmitter.fire({ error });
    }
    dispose() {
        if (!this.disposed) {
            const error = new errors_1.ObjectDisposedError(this);
            this.readStream.destroy(error);
            this.writeStream.destroy(error);
        }
        super.dispose();
    }
}
exports.NodeStream = NodeStream;
/**
 * Stream adapter for a browser websocket.
 */
class WebSocketStream extends BaseStream {
    constructor(websocket) {
        super();
        this.websocket = websocket;
        if (!websocket)
            throw new TypeError('WebSocket is required.');
        if (typeof websocket.binaryType === 'string' &&
            websocket.binaryType !== 'arraybuffer') {
            throw new Error('WebSocket must use arraybuffer binary type.');
        }
        websocket.onmessage = (e) => {
            this.onData(buffer_1.Buffer.from(e.data));
        };
        websocket.onclose = (e) => {
            if (e.wasClean) {
                this.onEnd();
            }
            else {
                const error = new Error(e.reason);
                error.code = e.code;
                this.onError(error);
            }
        };
    }
    get protocol() {
        return this.websocket.protocol;
    }
    async write(data, cancellation) {
        if (!data)
            throw new TypeError('Data is required.');
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if ('readyState' in this.websocket) {
            if (this.websocket.readyState === 2 /* WebSocketReadyState.Closing */ ||
                this.websocket.readyState === 3 /* WebSocketReadyState.Closed */) {
                throw new DOMException('WebSocket is already in CLOSING or CLOSED state.', 'InvalidStateError');
            }
        }
        this.websocket.send(data);
    }
    async close(error, cancellation) {
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if (!error) {
            this.websocket.close();
        }
        else {
            const code = typeof error.code === 'number' ? error.code : undefined;
            this.websocket.close(code, error.message);
        }
        this.disposed = true;
        this.closedEmitter.fire({ error });
        this.onError(error || new Error('Stream closed.'));
    }
    dispose() {
        if (!this.disposed) {
            this.websocket.close();
        }
        super.dispose();
    }
}
exports.WebSocketStream = WebSocketStream;
//# sourceMappingURL=streams.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/trace.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/trace.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshTraceEventIds = exports.TraceLevel = void 0;
/**
 * SSH trace event level.
 */
var TraceLevel;
(function (TraceLevel) {
    TraceLevel["Error"] = "error";
    TraceLevel["Warning"] = "warning";
    TraceLevel["Info"] = "info";
    TraceLevel["Verbose"] = "verbose";
})(TraceLevel = exports.TraceLevel || (exports.TraceLevel = {}));
// Events defined below should stay in sync with those in C#.
const baseEventId = 9000;
class SshTraceEventIds {
}
exports.SshTraceEventIds = SshTraceEventIds;
// Error / Warning events
SshTraceEventIds.unknownError = baseEventId + 0;
SshTraceEventIds.streamReadError = baseEventId + 1;
SshTraceEventIds.streamWriteError = baseEventId + 2;
SshTraceEventIds.streamCloseError = baseEventId + 3;
SshTraceEventIds.sendMessageFailed = baseEventId + 4;
SshTraceEventIds.receiveMessageFailed = baseEventId + 5;
SshTraceEventIds.handleMessageFailed = baseEventId + 6;
SshTraceEventIds.serverAuthenticationFailed = baseEventId + 7;
SshTraceEventIds.clientAuthenticationFailed = baseEventId + 8;
SshTraceEventIds.authenticationError = baseEventId + 9;
SshTraceEventIds.channelWindowAdjustFailed = baseEventId + 10;
SshTraceEventIds.channelWaitForWindowAdjust = baseEventId + 11;
SshTraceEventIds.sessionReconnectInitFailed = baseEventId + 20;
SshTraceEventIds.serverSessionReconnectFailed = baseEventId + 21;
SshTraceEventIds.clientSessionReconnectFailed = baseEventId + 22;
SshTraceEventIds.sessionRequestFailed = baseEventId + 23;
SshTraceEventIds.channelRequestFailed = baseEventId + 24;
SshTraceEventIds.serverListenFailed = baseEventId + 50;
SshTraceEventIds.portForwardServerListenFailed = baseEventId + 51;
SshTraceEventIds.portForwardRequestInvalid = baseEventId + 52;
SshTraceEventIds.portForwardChannelInvalid = baseEventId + 53;
SshTraceEventIds.portForwardChannelOpenFailed = baseEventId + 54;
SshTraceEventIds.portForwardConnectionFailed = baseEventId + 55;
SshTraceEventIds.metricsError = baseEventId + 61;
// Info / Verbose events
SshTraceEventIds.protocolVersion = baseEventId + 100;
SshTraceEventIds.sendingMessage = baseEventId + 101;
SshTraceEventIds.receivingMessage = baseEventId + 102;
SshTraceEventIds.sendingChannelData = baseEventId + 103;
SshTraceEventIds.receivingChannelData = baseEventId + 104;
SshTraceEventIds.sessionEncrypted = baseEventId + 110;
SshTraceEventIds.sessionAuthenticating = baseEventId + 111;
SshTraceEventIds.sessionAuthenticated = baseEventId + 112;
SshTraceEventIds.sessionClosing = baseEventId + 113;
SshTraceEventIds.sessionConnecting = baseEventId + 114;
SshTraceEventIds.channelOpened = baseEventId + 120;
SshTraceEventIds.channelOpenFailed = baseEventId + 121;
SshTraceEventIds.channelEofReceived = baseEventId + 122;
SshTraceEventIds.channelClosed = baseEventId + 123;
SshTraceEventIds.serverListening = baseEventId + 150;
SshTraceEventIds.serverClientConnected = baseEventId + 151;
SshTraceEventIds.portForwardServerListening = baseEventId + 152;
SshTraceEventIds.portForwardConnectionAccepted = baseEventId + 153;
SshTraceEventIds.portForwardChannelOpened = baseEventId + 154;
SshTraceEventIds.portForwardChannelClosed = baseEventId + 155;
SshTraceEventIds.portForwardConnectionOpened = baseEventId + 156;
SshTraceEventIds.portForwardConnectionClosed = baseEventId + 157;
SshTraceEventIds.sessionDisconnected = baseEventId + 160;
SshTraceEventIds.clientSessionReconnecting = baseEventId + 161;
SshTraceEventIds.serverSessionReconnecting = baseEventId + 162;
SshTraceEventIds.clientSessionStartReconnecting = baseEventId + 163;
SshTraceEventIds.algorithmNegotiation = baseEventId + 170;
SshTraceEventIds.debugMessage = baseEventId + 200;
//# sourceMappingURL=trace.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withCancellation = exports.CancellationError = exports.CancellationTokenSource = exports.CancellationToken = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return vscode_jsonrpc_1.CancellationToken; } }));
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return vscode_jsonrpc_1.CancellationTokenSource; } }));
/**
 * Error thrown when an operation is cancelled via a CancellationToken.
 */
class CancellationError extends Error {
    constructor(message) {
        super(message || 'Operation cancelled.');
    }
}
exports.CancellationError = CancellationError;
function withCancellation(promise, cancellation) {
    if (!cancellation) {
        return promise;
    }
    return Promise.race([
        promise,
        new Promise((resolve, reject) => {
            if (cancellation.isCancellationRequested) {
                reject(new CancellationError());
            }
            else {
                cancellation.onCancellationRequested(() => {
                    reject(new CancellationError());
                });
            }
        }),
    ]);
}
exports.withCancellation = withCancellation;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiseCompletionSource = void 0;
class PromiseCompletionSource {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    resolve(result) { }
    reject(e) { }
}
exports.PromiseCompletionSource = PromiseCompletionSource;
//# sourceMappingURL=promiseCompletionSource.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/util/queue.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Queue = void 0;
/**
 * Generic iterable queue implementation using an auto-expanding circular array buffer.
 * Designed to be more efficient for high-volume use compared to a simpler JS queue using
 * `Array.shift()` (which would cause a lot of allocations).
 */
class Queue {
    constructor() {
        this.array = new Array();
        this.first = 0;
        this.count = 0;
        /**
         * The version is incremented upon any changes to the queue, so that any iterators can detect the
         * change and become invalid. `MAX_SAFE_INTEGER` is 2^53-1 so this isn't likely to ever overflow.
         */
        this.version = 0;
    }
    /**
     * Gets the current size of the queue.
     */
    get size() {
        return this.count;
    }
    /**
     * Adds an item to the end of the queue.
     */
    enqueue(item) {
        if (this.count === this.array.length) {
            const newArray = new Array(Math.max(16, this.count * 2));
            for (let i = 0; i < this.count; i++) {
                newArray[i] = this.array[(this.first + i) % this.count];
            }
            this.array = newArray;
            this.first = 0;
        }
        this.array[(this.first + this.count) % this.array.length] = item;
        this.count++;
        this.version++;
    }
    /**
     * Removes an item from the front of the queue.
     * @returns The removed item, or `undefined` if the queue is empty.
     */
    dequeue() {
        if (this.count === 0)
            return undefined;
        const item = this.array[this.first];
        this.array[this.first] = undefined; // Allow the item to be GC'd.
        this.first = (this.first + 1) % this.array.length;
        this.count--;
        this.version++;
        return item;
    }
    /**
     * Gets the item at the front of the queue without removing it.
     * @returns The front item, or `undefined` if the queue is empty.
     */
    peek() {
        if (this.count === 0)
            return undefined;
        const item = this.array[this.first];
        return item;
    }
    /**
     * Clears the queue.
     */
    clear() {
        this.first = 0;
        this.count = 0;
        this.array.fill(undefined); // Allow items to be GC'd.
        this.version++;
    }
    /**
     * Creates an iterator over the items in the queue.
     * (Any changes to the queue will invalidate the iterator.)
     */
    *[Symbol.iterator]() {
        const iteratorVersion = this.version;
        for (let i = 0; i < this.count; i++) {
            const item = this.array[(this.first + i) % this.array.length];
            yield item;
            if (this.version !== iteratorVersion) {
                throw new Error('Iterator is invalid due to changes in the collection.');
            }
        }
    }
}
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/util/semaphore.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const promiseCompletionSource_1 = __webpack_require__(/*! ./promiseCompletionSource */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/promiseCompletionSource.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../../node_modules/@microsoft/dev-tunnels-ssh/util/cancellation.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/@microsoft/dev-tunnels-ssh/errors.js");
/**
 * Semaphore-like object that allows multiple awaiters to coordinate exclusive access to a resource.
 */
class Semaphore {
    /**
     * Creates a new semaphore instance.
     * @param initialCount Optional initial count. Defaults to 0.
     */
    constructor(initialCount = 0) {
        this.completions = [];
        this.disposed = false;
        this.count = initialCount;
    }
    /**
     * Gets the current available count of the semaphore.
     */
    get currentCount() {
        return this.count;
    }
    /**
     * Releases the semaphore, increasing the available count or unblicking one or more awaiters.
     * @param releaseCount Optional specified count to release. Defaults to 1.
     * @returns The previous count (before release).
     */
    release(releaseCount = 1) {
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        const previousCount = this.count;
        for (; releaseCount > 0; releaseCount--) {
            if (this.completions.length > 0) {
                // Something is waiting on the semaphore.
                // Remove and complete the wait without incrementing the count.
                const completion = this.completions.shift();
                completion.resolve(true);
            }
            else {
                // Nothing is currently waiting on the semaphore. Increment the available count.
                this.count++;
            }
        }
        return previousCount;
    }
    /**
     * Releases the semaphore, but does not throw an `ObjectDisposedError` if it is already disposed.
     */
    tryRelease() {
        try {
            this.release();
        }
        catch (e) {
            if (!(e instanceof errors_1.ObjectDisposedError)) {
                throw e;
            }
        }
    }
    async wait(timeoutOrCancellation, cancellation) {
        const millisecondsTimeout = typeof timeoutOrCancellation === 'number' ? timeoutOrCancellation : undefined;
        if (typeof cancellation === 'undefined' && typeof timeoutOrCancellation === 'object') {
            cancellation = timeoutOrCancellation;
        }
        if (this.disposed)
            throw new errors_1.ObjectDisposedError(this);
        if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)
            throw new cancellation_1.CancellationError();
        if (this.count > 0) {
            // The semaphore is available now.
            this.count--;
            return true;
        }
        else if (millisecondsTimeout === 0) {
            // The semaphore is not available and the caller doesn't want to wait.
            return false;
        }
        else {
            const completion = new promiseCompletionSource_1.PromiseCompletionSource();
            this.completions.push(completion);
            // Start with a promise that completes with `true` when the wait succeeds.
            const promises = [completion.promise];
            if (millisecondsTimeout) {
                // Race against a promise that completes with `false` when the timeout expires.
                promises.push(new Promise((resolve) => setTimeout(() => resolve(false), millisecondsTimeout)));
            }
            if (cancellation) {
                // Race against a promise that throws when the cancellation token is cancelled.
                const cancellationCompletion = new promiseCompletionSource_1.PromiseCompletionSource();
                cancellation.onCancellationRequested(() => {
                    cancellationCompletion.reject(new cancellation_1.CancellationError());
                });
                promises.push(cancellationCompletion.promise);
            }
            if (await Promise.race(promises)) {
                // The wait succeeded.
                return true;
            }
            else {
                // The wait timed out. Remove the (not-completed) completion from the array.
                const completionIndex = this.completions.indexOf(completion);
                if (completionIndex >= 0)
                    this.completions.splice(completionIndex, 1);
                return false;
            }
        }
    }
    /**
     * Disposes the semaphore and throws a diposed error to any awaiters.
     */
    dispose() {
        if (this.disposed)
            return;
        this.disposed = true;
        for (const completion of this.completions) {
            completion.reject(new errors_1.ObjectDisposedError(this));
        }
        this.completions.splice(0, this.completions.length);
        this.count = 0;
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ "../../node_modules/abort-controller/dist/abort-controller.js":
/*!********************************************************************!*\
  !*** ../../node_modules/abort-controller/dist/abort-controller.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({ value: true }));

var eventTargetShim = __webpack_require__(/*! event-target-shim */ "../../node_modules/event-target-shim/dist/event-target-shim.js");

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
class AbortSignal extends eventTargetShim.EventTarget {
    /**
     * AbortSignal cannot be constructed directly.
     */
    constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
    }
    /**
     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
     */
    get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
    }
}
eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
    const signal = Object.create(AbortSignal.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
        return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true },
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal",
    });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
class AbortController {
    /**
     * Initialize this controller.
     */
    constructor() {
        signals.set(this, createAbortSignal());
    }
    /**
     * Returns the `AbortSignal` object associated with this object.
     */
    get signal() {
        return getSignal(this);
    }
    /**
     * Abort and signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        abortSignal(getSignal(this));
    }
}
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true },
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController",
    });
}

exports.AbortController = AbortController;
exports.AbortSignal = AbortSignal;
exports["default"] = AbortController;

module.exports = AbortController
module.exports.AbortController = module.exports["default"] = AbortController
module.exports.AbortSignal = AbortSignal
//# sourceMappingURL=abort-controller.js.map


/***/ }),

/***/ "../../node_modules/ansi-colors/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/ansi-colors/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * ansi-colors <https://github.com/doowb/ansi-colors>
 *
 * Copyright (c) 2015-2017, Brian Woodward.
 * Released under the MIT License.
 */



/**
 * Module dependencies
 */

var wrap = __webpack_require__(/*! ansi-wrap */ "../../node_modules/ansi-wrap/index.js");

/**
 * Wrap a string with ansi codes to create a black background.
 *
 * ```js
 * console.log(colors.bgblack('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgblack
 */

exports.bgblack = function bgblack(message) {
  return wrap(40, 49, message);
};

/**
 * Wrap a string with ansi codes to create a blue background.
 *
 * ```js
 * console.log(colors.bgblue('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgblue
 */

exports.bgblue = function bgblue(message) {
  return wrap(44, 49, message);
};

/**
 * Wrap a string with ansi codes to create a cyan background.
 *
 * ```js
 * console.log(colors.bgcyan('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgcyan
 */

exports.bgcyan = function bgcyan(message) {
  return wrap(46, 49, message);
};

/**
 * Wrap a string with ansi codes to create a green background.
 *
 * ```js
 * console.log(colors.bggreen('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bggreen
 */

exports.bggreen = function bggreen(message) {
  return wrap(42, 49, message);
};

/**
 * Wrap a string with ansi codes to create a magenta background.
 *
 * ```js
 * console.log(colors.bgmagenta('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgmagenta
 */

exports.bgmagenta = function bgmagenta(message) {
  return wrap(45, 49, message);
};

/**
 * Wrap a string with ansi codes to create a red background.
 *
 * ```js
 * console.log(colors.bgred('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgred
 */

exports.bgred = function bgred(message) {
  return wrap(41, 49, message);
};

/**
 * Wrap a string with ansi codes to create a white background.
 *
 * ```js
 * console.log(colors.bgwhite('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgwhite
 */

exports.bgwhite = function bgwhite(message) {
  return wrap(47, 49, message);
};

/**
 * Wrap a string with ansi codes to create a yellow background.
 *
 * ```js
 * console.log(colors.bgyellow('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bgyellow
 */

exports.bgyellow = function bgyellow(message) {
  return wrap(43, 49, message);
};

/**
 * Wrap a string with ansi codes to create black text.
 *
 * ```js
 * console.log(colors.black('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  black
 */

exports.black = function black(message) {
  return wrap(30, 39, message);
};

/**
 * Wrap a string with ansi codes to create blue text.
 *
 * ```js
 * console.log(colors.blue('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  blue
 */

exports.blue = function blue(message) {
  return wrap(34, 39, message);
};

/**
 * Wrap a string with ansi codes to create bold text.
 *
 * ```js
 * console.log(colors.bold('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  bold
 */

exports.bold = function bold(message) {
  return wrap(1, 22, message);
};

/**
 * Wrap a string with ansi codes to create cyan text.
 *
 * ```js
 * console.log(colors.cyan('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  cyan
 */

exports.cyan = function cyan(message) {
  return wrap(36, 39, message);
};

/**
 * Wrap a string with ansi codes to create dim text.
 *
 * ```js
 * console.log(colors.dim('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  dim
 */

exports.dim = function dim(message) {
  return wrap(2, 22, message);
};

/**
 * Wrap a string with ansi codes to create gray text.
 *
 * ```js
 * console.log(colors.gray('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  gray
 */

exports.gray = function gray(message) {
  return wrap(90, 39, message);
};

/**
 * Wrap a string with ansi codes to create green text.
 *
 * ```js
 * console.log(colors.green('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  green
 */

exports.green = function green(message) {
  return wrap(32, 39, message);
};

/**
 * Wrap a string with ansi codes to create grey text.
 *
 * ```js
 * console.log(colors.grey('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  grey
 */

exports.grey = function grey(message) {
  return wrap(90, 39, message);
};

/**
 * Wrap a string with ansi codes to create hidden text.
 *
 * ```js
 * console.log(colors.hidden('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  hidden
 */

exports.hidden = function hidden(message) {
  return wrap(8, 28, message);
};

/**
 * Wrap a string with ansi codes to create inverse text.
 *
 * ```js
 * console.log(colors.inverse('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  inverse
 */

exports.inverse = function inverse(message) {
  return wrap(7, 27, message);
};

/**
 * Wrap a string with ansi codes to create italic text.
 *
 * ```js
 * console.log(colors.italic('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  italic
 */

exports.italic = function italic(message) {
  return wrap(3, 23, message);
};

/**
 * Wrap a string with ansi codes to create magenta text.
 *
 * ```js
 * console.log(colors.magenta('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  magenta
 */

exports.magenta = function magenta(message) {
  return wrap(35, 39, message);
};

/**
 * Wrap a string with ansi codes to create red text.
 *
 * ```js
 * console.log(colors.red('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  red
 */

exports.red = function red(message) {
  return wrap(31, 39, message);
};

/**
 * Wrap a string with ansi codes to reset ansi colors currently on the string.
 *
 * ```js
 * console.log(colors.reset('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  reset
 */

exports.reset = function reset(message) {
  return wrap(0, 0, message);
};

/**
 * Wrap a string with ansi codes to add a strikethrough to the text.
 *
 * ```js
 * console.log(colors.strikethrough('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  strikethrough
 */

exports.strikethrough = function strikethrough(message) {
  return wrap(9, 29, message);
};

/**
 * Wrap a string with ansi codes to underline the text.
 *
 * ```js
 * console.log(colors.underline('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  underline
 */

exports.underline = function underline(message) {
  return wrap(4, 24, message);
};

/**
 * Wrap a string with ansi codes to create white text.
 *
 * ```js
 * console.log(colors.white('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  white
 */

exports.white = function white(message) {
  return wrap(37, 39, message);
};

/**
 * Wrap a string with ansi codes to create yellow text.
 *
 * ```js
 * console.log(colors.yellow('some string'));
 * ```
 *
 * @param  {string} message String to wrap with ansi codes.
 * @return {string} Wrapped string
 * @api public
 * @name  yellow
 */

exports.yellow = function yellow(message) {
  return wrap(33, 39, message);
};


/***/ }),

/***/ "../../node_modules/ansi-regex/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/ansi-regex/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ "../../node_modules/ansi-wrap/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/ansi-wrap/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


module.exports = function(a, b, msg) {
  return '\u001b['+ a + 'm' + msg + '\u001b[' + b + 'm';
};


/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var CorrelationContextManager_1 = __webpack_require__(/*! ./CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js");
var events_1 = __webpack_require__(/*! events */ "events");
/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
var OpenTelemetryScopeManagerWrapper = (function () {
    function OpenTelemetryScopeManagerWrapper() {
    }
    OpenTelemetryScopeManagerWrapper.prototype.active = function () {
        var _this = this;
        var context = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        return __assign({}, context, { getValue: function (key) {
                // todo: lazy import activeSymbol from opentelemetry/api
                if (!_this._activeSymbol) {
                    _this._activeSymbol = key;
                    return context;
                }
                if (key === _this._activeSymbol) {
                    return context;
                }
                return false;
            }, setValue: function () { } });
    };
    OpenTelemetryScopeManagerWrapper.prototype.with = function (span, fn) {
        var parentSpanId = span.parentSpanId;
        var name = span.name;
        var correlationContext = OpenTelemetryScopeManagerWrapper._spanToContext(span, parentSpanId, name);
        return CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, fn)();
    };
    OpenTelemetryScopeManagerWrapper.prototype.bind = function (target) {
        if (typeof target === "function") {
            return CorrelationContextManager_1.CorrelationContextManager.wrapCallback(target);
        }
        else if (target instanceof events_1.EventEmitter) {
            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(target);
        }
        return target;
    };
    OpenTelemetryScopeManagerWrapper.prototype.enable = function () {
        CorrelationContextManager_1.CorrelationContextManager.enable();
        return this;
    };
    OpenTelemetryScopeManagerWrapper.prototype.disable = function () {
        CorrelationContextManager_1.CorrelationContextManager.disable();
        return this;
    };
    OpenTelemetryScopeManagerWrapper._spanToContext = function (span, parentSpanId, name) {
        var _parentId = parentSpanId ? "|" + span.context().traceId + "." + parentSpanId + "." : span.context().traceId;
        var context = __assign({}, span.context(), { traceFlags: span.context().traceFlags.toString() });
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.spanToContextObject(context, _parentId, name);
        return correlationContext;
    };
    return OpenTelemetryScopeManagerWrapper;
}());
exports.OpenTelemetryScopeManagerWrapper = OpenTelemetryScopeManagerWrapper;
exports.AsyncScopeManager = new OpenTelemetryScopeManagerWrapper();
//# sourceMappingURL=AsyncHooksScopeManager.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/Console.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/Console.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js");
var AutoCollectConsole = (function () {
    function AutoCollectConsole(client) {
        if (!!AutoCollectConsole.INSTANCE) {
            throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
        }
        this._client = client;
        AutoCollectConsole.INSTANCE = this;
    }
    AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {
        if (DiagChannel.IsInitialized) {
            (__webpack_require__(/*! ./diagnostic-channel/console.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js").enable)(isEnabled && collectConsoleLog, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/bunyan.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js").enable)(isEnabled, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/winston.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js").enable)(isEnabled, this._client);
        }
    };
    AutoCollectConsole.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectConsole.prototype.dispose = function () {
        AutoCollectConsole.INSTANCE = null;
        this.enable(false, false);
    };
    AutoCollectConsole._methodNames = ["debug", "info", "log", "warn", "error"];
    return AutoCollectConsole;
}());
module.exports = AutoCollectConsole;
//# sourceMappingURL=Console.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Logging = __webpack_require__(/*! ../Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js");
var Traceparent = __webpack_require__(/*! ../Library/Traceparent */ "../../node_modules/applicationinsights/out/Library/Traceparent.js");
var Tracestate = __webpack_require__(/*! ../Library/Tracestate */ "../../node_modules/applicationinsights/out/Library/Tracestate.js");
var HttpRequestParser = __webpack_require__(/*! ./HttpRequestParser */ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js");
var CorrelationContextManager = (function () {
    function CorrelationContextManager() {
    }
    /**
     *  Provides the current Context.
     *  The context is the most recent one entered into for the current
     *  logical chain of execution, including across asynchronous calls.
     */
    CorrelationContextManager.getCurrentContext = function () {
        if (!CorrelationContextManager.enabled) {
            return null;
        }
        var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);
        if (context === undefined) {
            return null;
        }
        return context;
    };
    /**
     *  A helper to generate objects conforming to the CorrelationContext interface
     */
    CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
        parentId = parentId || operationId;
        if (this.enabled) {
            return {
                operation: {
                    name: operationName,
                    id: operationId,
                    parentId: parentId,
                    traceparent: traceparent,
                    tracestate: tracestate
                },
                customProperties: new CustomPropertiesImpl(correlationContextHeader)
            };
        }
        return null;
    };
    CorrelationContextManager.spanToContextObject = function (spanContext, parentId, name) {
        var traceContext = new Traceparent();
        traceContext.traceId = spanContext.traceId;
        traceContext.spanId = spanContext.spanId;
        traceContext.traceFlag = spanContext.traceFlags || Traceparent.DEFAULT_TRACE_FLAG;
        traceContext.parentId = parentId;
        return CorrelationContextManager.generateContextObject(traceContext.traceId, traceContext.parentId, name, null, traceContext);
    };
    /**
     *  Runs a function inside a given Context.
     *  All logical children of the execution path that entered this Context
     *  will receive this Context object on calls to GetCurrentContext.
     */
    CorrelationContextManager.runWithContext = function (context, fn) {
        if (CorrelationContextManager.enabled) {
            return CorrelationContextManager.session.bind(fn, (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, _a))();
        }
        else {
            return fn();
        }
        var _a;
    };
    /**
     * Wrapper for cls-hooked bindEmitter method
     */
    CorrelationContextManager.wrapEmitter = function (emitter) {
        if (CorrelationContextManager.enabled) {
            CorrelationContextManager.session.bindEmitter(emitter);
        }
    };
    /**
     *  Patches a callback to restore the correct Context when getCurrentContext
     *  is run within it. This is necessary if automatic correlation fails to work
     *  with user-included libraries.
     *
     *  The supplied callback will be given the same context that was present for
     *  the call to wrapCallback.  */
    CorrelationContextManager.wrapCallback = function (fn, context) {
        if (CorrelationContextManager.enabled) {
            return CorrelationContextManager.session.bind(fn, context ? (_a = {},
                _a[CorrelationContextManager.CONTEXT_NAME] = context,
                _a) : undefined);
        }
        return fn;
        var _a;
    };
    /**
     *  Enables the CorrelationContextManager.
     */
    CorrelationContextManager.enable = function (forceClsHooked) {
        if (this.enabled) {
            return;
        }
        if (!this.isNodeVersionCompatible()) {
            this.enabled = false;
            return;
        }
        if (!CorrelationContextManager.hasEverEnabled) {
            this.forceClsHooked = forceClsHooked;
            this.hasEverEnabled = true;
            if (typeof this.cls === "undefined") {
                if ((CorrelationContextManager.forceClsHooked === true) || (CorrelationContextManager.forceClsHooked === undefined && CorrelationContextManager.shouldUseClsHooked())) {
                    this.cls = __webpack_require__(/*! cls-hooked */ "../../node_modules/cls-hooked/index.js");
                }
                else {
                    this.cls = __webpack_require__(/*! continuation-local-storage */ "../../node_modules/continuation-local-storage/context.js");
                }
            }
            CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session");
            DiagChannel.registerContextPreservation(function (cb) {
                return CorrelationContextManager.session.bind(cb);
            });
        }
        this.enabled = true;
    };
    CorrelationContextManager.startOperation = function (context, request) {
        var traceContext = context && context.traceContext || null;
        var spanContext = context && context.traceId
            ? context
            : null;
        var headers = context && context.headers;
        if (spanContext) {
            var traceparent = new Traceparent("00-" + spanContext.traceId + "-" + spanContext.spanId + "-01");
            var tracestate = new Tracestate(spanContext.tracestate);
            var correlationContext = CorrelationContextManager.generateContextObject(spanContext.traceId, "|" + spanContext.traceId + "." + spanContext.spanId + ".", typeof request === "string" ? request : "", undefined, traceparent, tracestate);
            return correlationContext;
        }
        // AzFunction TraceContext available
        if (traceContext) {
            var traceparent = new Traceparent(traceContext.traceparent);
            var tracestate = new Tracestate(traceContext.tracestate);
            var parser = typeof request === "object"
                ? new HttpRequestParser(request)
                : null;
            var correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, typeof request === "string"
                ? request
                : parser.getOperationName({}), parser && parser.getCorrelationContextHeader() || undefined, traceparent, tracestate);
            return correlationContext;
        }
        // No TraceContext available, parse as http.IncomingMessage
        if (headers) {
            var traceparent = new Traceparent(headers.traceparent);
            var tracestate = new Tracestate(headers.tracestate);
            var parser = new HttpRequestParser(context);
            var correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, parser.getOperationName({}), parser.getCorrelationContextHeader(), traceparent, tracestate);
            return correlationContext;
        }
        Logging.warn("startOperation was called with invalid arguments", arguments);
        return null;
    };
    /**
     *  Disables the CorrelationContextManager.
     */
    CorrelationContextManager.disable = function () {
        this.enabled = false;
    };
    /**
     * Reset the namespace
     */
    CorrelationContextManager.reset = function () {
        if (CorrelationContextManager.hasEverEnabled) {
            CorrelationContextManager.session = null;
            CorrelationContextManager.session = this.cls.createNamespace('AI-CLS-Session');
        }
    };
    /**
     *  Reports if CorrelationContextManager is able to run in this environment
     */
    CorrelationContextManager.isNodeVersionCompatible = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);
    };
    /**
     * We only want to use cls-hooked when it uses async_hooks api (8.2+), else
     * use async-listener (plain -cls)
     */
    CorrelationContextManager.shouldUseClsHooked = function () {
        var nodeVer = process.versions.node.split(".");
        return (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2);
    };
    /**
     * A TypeError is triggered by cls-hooked for node [8.0, 8.2)
     * @internal Used in tests only
     */
    CorrelationContextManager.canUseClsHooked = function () {
        var nodeVer = process.versions.node.split(".");
        var greater800 = (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0);
        var less820 = (parseInt(nodeVer[0]) < 8) || (parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2);
        var greater470 = parseInt(nodeVer[0]) > 4 || (parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7); // cls-hooked requires node 4.7+
        return !(greater800 && less820) && greater470;
    };
    CorrelationContextManager.enabled = false;
    CorrelationContextManager.hasEverEnabled = false;
    CorrelationContextManager.forceClsHooked = undefined; // true: use cls-hooked, false: use cls, undefined: choose based on node version
    CorrelationContextManager.CONTEXT_NAME = "ApplicationInsights-Context";
    return CorrelationContextManager;
}());
exports.CorrelationContextManager = CorrelationContextManager;
var CustomPropertiesImpl = (function () {
    function CustomPropertiesImpl(header) {
        this.props = [];
        this.addHeaderData(header);
    }
    CustomPropertiesImpl.prototype.addHeaderData = function (header) {
        var keyvals = header ? header.split(", ") : [];
        this.props = keyvals.map(function (keyval) {
            var parts = keyval.split("=");
            return { key: parts[0], value: parts[1] };
        }).concat(this.props);
    };
    CustomPropertiesImpl.prototype.serializeToHeader = function () {
        return this.props.map(function (keyval) {
            return keyval.key + "=" + keyval.value;
        }).join(", ");
    };
    CustomPropertiesImpl.prototype.getProperty = function (prop) {
        for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
                return keyval.value;
            }
        }
        return;
    };
    // TODO: Strictly according to the spec, properties which are recieved from
    // an incoming request should be left untouched, while we may add our own new
    // properties. The logic here will need to change to track that.
    CustomPropertiesImpl.prototype.setProperty = function (prop, val) {
        if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {
            Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val);
            return;
        }
        for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
                keyval.value = val;
                return;
            }
        }
        this.props.push({ key: prop, value: val });
    };
    CustomPropertiesImpl.bannedCharacters = /[,=]/;
    return CustomPropertiesImpl;
}());
//# sourceMappingURL=CorrelationContextManager.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/Exceptions.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/Exceptions.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";

var AutoCollectExceptions = (function () {
    function AutoCollectExceptions(client) {
        if (!!AutoCollectExceptions.INSTANCE) {
            throw new Error("Exception tracking should be configured from the applicationInsights object");
        }
        AutoCollectExceptions.INSTANCE = this;
        this._client = client;
        // Only use for 13.7.0+
        var nodeVer = process.versions.node.split(".");
        AutoCollectExceptions._canUseUncaughtExceptionMonitor = parseInt(nodeVer[0]) > 13 || (parseInt(nodeVer[0]) === 13 && parseInt(nodeVer[1]) >= 7);
    }
    AutoCollectExceptions.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectExceptions.prototype.enable = function (isEnabled) {
        var _this = this;
        if (isEnabled) {
            this._isInitialized = true;
            var self = this;
            if (!this._exceptionListenerHandle) {
                // For scenarios like Promise.reject(), an error won't be passed to the handle. Create a placeholder
                // error for these scenarios.
                var handle = function (reThrow, name, error) {
                    if (error === void 0) { error = new Error(AutoCollectExceptions._FALLBACK_ERROR_MESSAGE); }
                    _this._client.trackException({ exception: error });
                    _this._client.flush({ isAppCrashing: true });
                    // only rethrow when we are the only listener
                    if (reThrow && name && process.listeners(name).length === 1) {
                        console.error(error);
                        process.exit(1);
                    }
                };
                if (AutoCollectExceptions._canUseUncaughtExceptionMonitor) {
                    // Node.js >= 13.7.0, use uncaughtExceptionMonitor. It handles both promises and exceptions
                    this._exceptionListenerHandle = handle.bind(this, false, undefined); // never rethrows
                    process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);
                }
                else {
                    this._exceptionListenerHandle = handle.bind(this, true, AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME);
                    this._rejectionListenerHandle = handle.bind(this, false, undefined); // never rethrows
                    process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                    process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
                }
            }
        }
        else {
            if (this._exceptionListenerHandle) {
                if (AutoCollectExceptions._canUseUncaughtExceptionMonitor) {
                    process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);
                }
                else {
                    process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                    process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
                }
                this._exceptionListenerHandle = undefined;
                this._rejectionListenerHandle = undefined;
                delete this._exceptionListenerHandle;
                delete this._rejectionListenerHandle;
            }
        }
    };
    AutoCollectExceptions.prototype.dispose = function () {
        AutoCollectExceptions.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectExceptions.INSTANCE = null;
    AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = "uncaughtExceptionMonitor";
    AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME = "uncaughtException";
    AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME = "unhandledRejection";
    AutoCollectExceptions._RETHROW_EXIT_MESSAGE = "Application Insights Rethrow Exception Handler";
    AutoCollectExceptions._FALLBACK_ERROR_MESSAGE = "A promise was rejected without providing an error. Application Insights generated this error stack for you.";
    AutoCollectExceptions._canUseUncaughtExceptionMonitor = false;
    return AutoCollectExceptions;
}());
module.exports = AutoCollectExceptions;
//# sourceMappingURL=Exceptions.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/HeartBeat.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/HeartBeat.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");
var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var Util = __webpack_require__(/*! ../Library/Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var Context = __webpack_require__(/*! ../Library/Context */ "../../node_modules/applicationinsights/out/Library/Context.js");
var AutoCollectHttpDependencies = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js");
var AIMS_URI = "http://169.254.169.254/metadata/instance/compute";
var AIMS_API_VERSION = "api-version=2017-12-01";
var AIMS_FORMAT = "format=json";
var ConnectionErrorMessage = "ENETUNREACH";
var HeartBeat = (function () {
    function HeartBeat(client) {
        this._collectionInterval = 900000;
        this._vmData = {};
        this._azInst_vmId = "";
        this._azInst_subscriptionId = "";
        this._azInst_osType = "";
        if (!HeartBeat.INSTANCE) {
            HeartBeat.INSTANCE = this;
        }
        this._isInitialized = false;
        this._client = client;
    }
    HeartBeat.prototype.enable = function (isEnabled, config) {
        var _this = this;
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
        }
        if (isEnabled) {
            if (!this._handle) {
                this._handle = setInterval(function () { return _this.trackHeartBeat(config, function () { }); }, this._collectionInterval);
                this._handle.unref(); // Allow the app to terminate even while this loop is going on
            }
        }
        else {
            if (this._handle) {
                clearInterval(this._handle);
                this._handle = null;
            }
        }
    };
    HeartBeat.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    HeartBeat.isEnabled = function () {
        return HeartBeat.INSTANCE && HeartBeat.INSTANCE._isEnabled;
    };
    HeartBeat.prototype.trackHeartBeat = function (config, callback) {
        var _this = this;
        var waiting = false;
        var properties = {};
        var sdkVersion = Context.sdkVersion; // "node" or "node-nativeperf"
        properties["sdk"] = sdkVersion;
        properties["osType"] = os.type();
        if (process.env.WEBSITE_SITE_NAME) {
            properties["appSrv_SiteName"] = process.env.WEBSITE_SITE_NAME || "";
            properties["appSrv_wsStamp"] = process.env.WEBSITE_HOME_STAMPNAME || "";
            properties["appSrv_wsHost"] = process.env.WEBSITE_HOSTNAME || "";
        }
        else if (process.env.FUNCTIONS_WORKER_RUNTIME) {
            properties["azfunction_appId"] = process.env.WEBSITE_HOSTNAME;
        }
        else if (config) {
            if (this._isVM === undefined) {
                waiting = true;
                this._getAzureComputeMetadata(config, function () {
                    if (_this._isVM && Object.keys(_this._vmData).length > 0) {
                        properties["azInst_vmId"] = _this._vmData["vmId"] || "";
                        properties["azInst_subscriptionId"] = _this._vmData["subscriptionId"] || "";
                        properties["azInst_osType"] = _this._vmData["osType"] || "";
                        _this._azInst_vmId = _this._vmData["vmId"] || "";
                        _this._azInst_subscriptionId = _this._vmData["subscriptionId"] || "";
                        _this._azInst_osType = _this._vmData["osType"] || "";
                    }
                    _this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties: properties });
                    callback();
                });
            }
            else if (this._isVM) {
                properties["azInst_vmId"] = this._azInst_vmId;
                properties["azInst_subscriptionId"] = this._azInst_subscriptionId;
                properties["azInst_osType"] = this._azInst_osType;
            }
        }
        if (!waiting) {
            this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties: properties });
            callback();
        }
    };
    HeartBeat.prototype.dispose = function () {
        HeartBeat.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    HeartBeat.prototype._getAzureComputeMetadata = function (config, callback) {
        var _this = this;
        var metadataRequestUrl = AIMS_URI + "?" + AIMS_API_VERSION + "&" + AIMS_FORMAT;
        var requestOptions = (_a = {
                method: 'GET'
            },
            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,
            _a.headers = {
                "Metadata": "True",
            },
            _a);
        var req = Util.makeRequest(config, metadataRequestUrl, requestOptions, function (res) {
            if (res.statusCode === 200) {
                // Success; VM
                _this._isVM = true;
                var virtualMachineData_1 = "";
                res.on('data', function (data) {
                    virtualMachineData_1 += data;
                });
                res.on('end', function () {
                    _this._vmData = _this._isJSON(virtualMachineData_1) ? JSON.parse(virtualMachineData_1) : {};
                    callback();
                });
            }
            else {
                // else Retry on next heartbeat metrics call
                callback();
            }
        });
        if (req) {
            req.on('error', function (error) {
                // Unable to contact endpoint.
                // Do nothing for now.
                if (error && error.message && error.message.indexOf(ConnectionErrorMessage) > -1) {
                    _this._isVM = false; // confirm it's not in VM
                }
                // errors other than connect ENETUNREACH - retry
                callback();
            });
            req.end();
        }
        var _a;
    };
    HeartBeat.prototype._isJSON = function (str) {
        try {
            return (JSON.parse(str) && !!str);
        }
        catch (e) {
            return false;
        }
    };
    return HeartBeat;
}());
module.exports = HeartBeat;
//# sourceMappingURL=HeartBeat.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var Logging = __webpack_require__(/*! ../Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Util = __webpack_require__(/*! ../Library/Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js");
var HttpDependencyParser = __webpack_require__(/*! ./HttpDependencyParser */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js");
var CorrelationContextManager_1 = __webpack_require__(/*! ./CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js");
var CorrelationIdManager = __webpack_require__(/*! ../Library/CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
var Traceparent = __webpack_require__(/*! ../Library/Traceparent */ "../../node_modules/applicationinsights/out/Library/Traceparent.js");
var DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js");
var AutoCollectHttpDependencies = (function () {
    function AutoCollectHttpDependencies(client) {
        if (!!AutoCollectHttpDependencies.INSTANCE) {
            throw new Error("Client request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpDependencies.INSTANCE = this;
        this._client = client;
    }
    AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._initialize();
        }
        if (DiagChannel.IsInitialized) {
            (__webpack_require__(/*! ./diagnostic-channel/azure-coretracing.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js").enable)(true, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/mongodb.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js").enable)(isEnabled, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/mysql.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js").enable)(isEnabled, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/redis.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js").enable)(isEnabled, this._client);
            (__webpack_require__(/*! ./diagnostic-channel/postgres.sub */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js").enable)(isEnabled, this._client);
        }
    };
    AutoCollectHttpDependencies.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectHttpDependencies.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = true;
        var originalGet = http.get;
        var originalRequest = http.request;
        var originalHttpsRequest = https.request;
        var clientRequestPatch = function (request, options) {
            var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] &&
                !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag];
            // If someone else patched traceparent headers onto this request
            if (options.headers && options.headers['user-agent'] && options.headers['user-agent'].toString().indexOf('azsdk-js') !== -1) {
                shouldCollect = false;
            }
            request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = true;
            if (request && options && shouldCollect) {
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
                AutoCollectHttpDependencies.trackRequest(_this._client, { options: options, request: request });
            }
        };
        // On node >= v0.11.12 and < 9.0 (excluding 8.9.0) https.request just calls http.request (with additional options).
        // On node < 0.11.12, 8.9.0, and 9.0 > https.request is handled separately
        // Patch both and leave a flag to not double-count on versions that just call through
        // We add the flag to both http and https to protect against strange double collection in other scenarios
        http.request = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));
            clientRequestPatch(request, options);
            return request;
        };
        https.request = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options].concat(requestArgs));
            clientRequestPatch(request, options);
            return request;
        };
        // Node 8 calls http.request from http.get using a local reference!
        // We have to patch .get manually in this case and can't just assume request is enough
        // We have to replace the entire method in this case. We can't call the original.
        // This is because calling the original will give us no chance to set headers as it internally does .end().
        http.get = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = http.request).call.apply(_a, [http, options].concat(requestArgs));
            request.end();
            return request;
            var _a;
        };
        https.get = function (options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = https.request).call.apply(_a, [https, options].concat(requestArgs));
            request.end();
            return request;
            var _a;
        };
    };
    /**
     * Tracks an outgoing request. Because it may set headers this method must be called before
     * writing content to or ending the request.
     */
    AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {
        if (!telemetry.options || !telemetry.request || !client) {
            Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
            return;
        }
        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);
        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var uniqueRequestId;
        var uniqueTraceparent;
        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {
            currentContext.operation.traceparent.updateSpanId();
            uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();
        }
        else if (CorrelationIdManager.w3cEnabled) {
            // Start an operation now so that we can include the w3c headers in the outgoing request
            var traceparent = new Traceparent();
            uniqueTraceparent = traceparent.toString();
            uniqueRequestId = traceparent.getBackCompatRequestId();
        }
        else {
            uniqueRequestId = currentContext && currentContext.operation && (currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + '.');
        }
        // Add the source correlationId to the request headers, if a value was not already provided.
        // The getHeader/setHeader methods aren't available on very old Node versions, and
        // are not included in the v0.10 type declarations currently used. So check if the
        // methods exist before invoking them.
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {
            if (client.config && client.config.correlationId) {
                // getHeader returns "any" type in newer versions of node. In basic scenarios, this will be <string | string[] | number>, but could be modified to anything else via middleware
                var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
                try {
                    Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
                }
                catch (err) {
                    Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
                }
                if (currentContext && currentContext.operation) {
                    try {
                        telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);
                        // Also set legacy headers
                        if (!client.config.ignoreLegacyHeaders) {
                            telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);
                            telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);
                        }
                        // Set W3C headers, if available
                        if (uniqueTraceparent || currentContext.operation.traceparent) {
                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());
                        }
                        else if (CorrelationIdManager.w3cEnabled) {
                            // should never get here since we set uniqueTraceparent above for the w3cEnabled scenario
                            var traceparent = new Traceparent().toString();
                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
                        }
                        if (currentContext.operation.tracestate) {
                            var tracestate = currentContext.operation.tracestate.toString();
                            if (tracestate) {
                                telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
                            }
                        }
                        var correlationContextHeader = currentContext.customProperties.serializeToHeader();
                        if (correlationContextHeader) {
                            telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
                        }
                    }
                    catch (err) {
                        Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
                    }
                }
            }
        }
        // Collect dependency telemetry about the request when it finishes.
        if (telemetry.request.on) {
            telemetry.request.on('response', function (response) {
                requestParser.onResponse(response);
                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
                dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
                dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
                dependencyTelemetry.contextObjects["http.ClientResponse"] = response;
                client.trackDependency(dependencyTelemetry);
            });
            telemetry.request.on('error', function (e) {
                requestParser.onError(e);
                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
                dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
                dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
                dependencyTelemetry.contextObjects["Error"] = e;
                client.trackDependency(dependencyTelemetry);
            });
        }
    };
    AutoCollectHttpDependencies.prototype.dispose = function () {
        AutoCollectHttpDependencies.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectHttpDependencies.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';
    AutoCollectHttpDependencies.requestNumber = 1;
    AutoCollectHttpDependencies.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';
    return AutoCollectHttpDependencies;
}());
module.exports = AutoCollectHttpDependencies;
//# sourceMappingURL=HttpDependencies.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var url = __webpack_require__(/*! url */ "url");
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Util = __webpack_require__(/*! ../Library/Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js");
var RequestParser = __webpack_require__(/*! ./RequestParser */ "../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js");
var CorrelationIdManager = __webpack_require__(/*! ../Library/CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
/**
 * Helper class to read data from the request/response objects and convert them into the telemetry contract
 */
var HttpDependencyParser = (function (_super) {
    __extends(HttpDependencyParser, _super);
    function HttpDependencyParser(requestOptions, request) {
        var _this = _super.call(this) || this;
        if (request && request.method && requestOptions) {
            // The ClientRequest.method property isn't documented, but is always there.
            _this.method = request.method;
            _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request);
            _this.startTime = +new Date();
        }
        return _this;
    }
    /**
     * Called when the ClientRequest emits an error event.
     */
    HttpDependencyParser.prototype.onError = function (error) {
        this._setStatus(undefined, error);
    };
    /**
     * Called when the ClientRequest emits a response event.
     */
    HttpDependencyParser.prototype.onResponse = function (response) {
        this._setStatus(response.statusCode, undefined);
        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
    };
    /**
     * Gets a dependency data contract object for a completed ClientRequest.
     */
    HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {
        var urlObject = url.parse(this.url);
        urlObject.search = undefined;
        urlObject.hash = undefined;
        var dependencyName = this.method.toUpperCase() + " " + urlObject.pathname;
        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        var remoteDependencyTarget = urlObject.hostname;
        if (urlObject.port) {
            remoteDependencyTarget += ":" + urlObject.port;
        }
        if (this.correlationId) {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;
            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {
                remoteDependencyTarget += " | " + this.correlationId;
            }
        }
        else {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        }
        var dependencyTelemetry = {
            id: dependencyId,
            name: dependencyName,
            data: this.url,
            duration: this.duration,
            success: this._isSuccess(),
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            properties: this.properties || {},
            dependencyTypeName: remoteDependencyType,
            target: remoteDependencyTarget
        };
        if (baseTelemetry && baseTelemetry.time) {
            dependencyTelemetry.time = baseTelemetry.time;
        }
        else if (this.startTime) {
            dependencyTelemetry.time = new Date(this.startTime);
        }
        // We should keep any parameters the user passed in
        // Except the fields defined above in requestTelemetry, which take priority
        // Except the properties field, where they're merged instead, with baseTelemetry taking priority
        if (baseTelemetry) {
            // Copy missing fields
            for (var key in baseTelemetry) {
                if (!dependencyTelemetry[key]) {
                    dependencyTelemetry[key] = baseTelemetry[key];
                }
            }
            // Merge properties
            if (baseTelemetry.properties) {
                for (var key in baseTelemetry.properties) {
                    dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
                }
            }
        }
        return dependencyTelemetry;
    };
    /**
     * Builds a URL from request options, using the same logic as http.request(). This is
     * necessary because a ClientRequest object does not expose a url property.
     */
    HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {
        if (typeof options === 'string') {
            if (options.indexOf("http://") === 0 || options.indexOf("https://") === 0) {
                // protocol exists, parse normally
                options = url.parse(options);
            }
            else {
                // protocol not found, insert http/https where appropriate
                var parsed = url.parse(options);
                if (parsed.host === "443") {
                    options = url.parse("https://" + options);
                }
                else {
                    options = url.parse("http://" + options);
                }
            }
        }
        else if (options && typeof url.URL === 'function' && options instanceof url.URL) {
            return url.format(options);
        }
        else {
            // Avoid modifying the original options object.
            var originalOptions_1 = options;
            options = {};
            if (originalOptions_1) {
                Object.keys(originalOptions_1).forEach(function (key) {
                    options[key] = originalOptions_1[key];
                });
            }
        }
        // Oddly, url.format ignores path and only uses pathname and search,
        // so create them from the path, if path was specified
        if (options.path) {
            var parsedQuery = url.parse(options.path);
            options.pathname = parsedQuery.pathname;
            options.search = parsedQuery.search;
        }
        // Similarly, url.format ignores hostname and port if host is specified,
        // even if host doesn't have the port, but http.request does not work
        // this way. It will use the port if one is not specified in host,
        // effectively treating host as hostname, but will use the port specified
        // in host if it exists.
        if (options.host && options.port) {
            // Force a protocol so it will parse the host as the host, not path.
            // It is discarded and not used, so it doesn't matter if it doesn't match
            var parsedHost = url.parse("http://" + options.host);
            if (!parsedHost.port && options.port) {
                options.hostname = options.host;
                delete options.host;
            }
        }
        // Mix in default values used by http.request and others
        options.protocol = options.protocol || (request.agent && request.agent.protocol) || (request.protocol) || undefined;
        options.hostname = options.hostname || 'localhost';
        return url.format(options);
    };
    return HttpDependencyParser;
}(RequestParser));
module.exports = HttpDependencyParser;
//# sourceMappingURL=HttpDependencyParser.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var url = __webpack_require__(/*! url */ "url");
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Util = __webpack_require__(/*! ../Library/Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js");
var RequestParser = __webpack_require__(/*! ./RequestParser */ "../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js");
var CorrelationIdManager = __webpack_require__(/*! ../Library/CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
var Tracestate = __webpack_require__(/*! ../Library/Tracestate */ "../../node_modules/applicationinsights/out/Library/Tracestate.js");
var Traceparent = __webpack_require__(/*! ../Library/Traceparent */ "../../node_modules/applicationinsights/out/Library/Traceparent.js");
/**
 * Helper class to read data from the request/response objects and convert them into the telemetry contract
 */
var HttpRequestParser = (function (_super) {
    __extends(HttpRequestParser, _super);
    function HttpRequestParser(request, requestId) {
        var _this = _super.call(this) || this;
        if (request) {
            _this.method = request.method;
            _this.url = _this._getAbsoluteUrl(request);
            _this.startTime = +new Date();
            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;
            _this.parseHeaders(request, requestId);
            if (request.connection) {
                _this.connectionRemoteAddress = request.connection.remoteAddress;
                _this.legacySocketRemoteAddress = request.connection["socket"] && request.connection["socket"].remoteAddress;
            }
        }
        return _this;
    }
    HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {
        this._setStatus(undefined, error);
        // This parameter is only for overrides. setStatus handles this internally for the autocollected case
        if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
        }
    };
    HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {
        this._setStatus(response.statusCode, undefined);
        // This parameter is only for overrides. setStatus handles this internally for the autocollected case
        if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
        }
    };
    HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {
        var requestTelemetry = {
            id: this.requestId,
            name: this.method + " " + url.parse(this.url).pathname,
            url: this.url,
            /*
            See https://github.com/microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250
            for reference
            */
            source: this.sourceCorrelationId,
            duration: this.duration,
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            success: this._isSuccess(),
            properties: this.properties
        };
        if (baseTelemetry && baseTelemetry.time) {
            requestTelemetry.time = baseTelemetry.time;
        }
        else if (this.startTime) {
            requestTelemetry.time = new Date(this.startTime);
        }
        // We should keep any parameters the user passed in
        // Except the fields defined above in requestTelemetry, which take priority
        // Except the properties field, where they're merged instead, with baseTelemetry taking priority
        if (baseTelemetry) {
            // Copy missing fields
            for (var key in baseTelemetry) {
                if (!requestTelemetry[key]) {
                    requestTelemetry[key] = baseTelemetry[key];
                }
            }
            // Merge properties
            if (baseTelemetry.properties) {
                for (var key in baseTelemetry.properties) {
                    requestTelemetry.properties[key] = baseTelemetry.properties[key];
                }
            }
        }
        return requestTelemetry;
    };
    HttpRequestParser.prototype.getRequestTags = function (tags) {
        // create a copy of the context for requests since client info will be used here
        var newTags = {};
        for (var key in tags) {
            newTags[key] = tags[key];
        }
        // don't override tags if they are already set
        newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp();
        newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId("ai_session");
        newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId("ai_user");
        newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId("ai_authUser");
        newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags);
        newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags);
        newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags);
        return newTags;
    };
    HttpRequestParser.prototype.getOperationId = function (tags) {
        return tags[HttpRequestParser.keys.operationId] || this.operationId;
    };
    HttpRequestParser.prototype.getOperationParentId = function (tags) {
        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);
    };
    HttpRequestParser.prototype.getOperationName = function (tags) {
        return tags[HttpRequestParser.keys.operationName] || this.method + " " + url.parse(this.url).pathname;
    };
    HttpRequestParser.prototype.getRequestId = function () {
        return this.requestId;
    };
    HttpRequestParser.prototype.getCorrelationContextHeader = function () {
        return this.correlationContextHeader;
    };
    HttpRequestParser.prototype.getTraceparent = function () {
        return this.traceparent;
    };
    HttpRequestParser.prototype.getTracestate = function () {
        return this.tracestate;
    };
    HttpRequestParser.prototype.getLegacyRootId = function () {
        return this.legacyRootId;
    };
    HttpRequestParser.prototype._getAbsoluteUrl = function (request) {
        if (!request.headers) {
            return request.url;
        }
        var encrypted = request.connection ? request.connection.encrypted : null;
        var requestUrl = url.parse(request.url);
        var pathName = requestUrl.pathname;
        var search = requestUrl.search;
        var absoluteUrl = url.format({
            protocol: encrypted ? "https" : "http",
            host: request.headers.host,
            pathname: pathName,
            search: search
        });
        return absoluteUrl;
    };
    HttpRequestParser.prototype._getIp = function () {
        // regex to match ipv4 without port
        // Note: including the port would cause the payload to be rejected by the data collector
        var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;
        var check = function (str) {
            var results = ipMatch.exec(str);
            if (results) {
                return results[0];
            }
        };
        var ip = check(this.rawHeaders["x-forwarded-for"])
            || check(this.rawHeaders["x-client-ip"])
            || check(this.rawHeaders["x-real-ip"])
            || check(this.connectionRemoteAddress)
            || check(this.socketRemoteAddress)
            || check(this.legacySocketRemoteAddress);
        // node v12 returns this if the address is "localhost"
        if (!ip
            && this.connectionRemoteAddress
            && this.connectionRemoteAddress.substr
            && this.connectionRemoteAddress.substr(0, 2) === "::") {
            ip = "127.0.0.1";
        }
        return ip;
    };
    HttpRequestParser.prototype._getId = function (name) {
        var cookie = (this.rawHeaders && this.rawHeaders["cookie"] &&
            typeof this.rawHeaders["cookie"] === 'string' && this.rawHeaders["cookie"]) || "";
        var value = HttpRequestParser.parseId(Util.getCookie(name, cookie));
        return value;
    };
    /**
     * Sets this operation's operationId, parentId, requestId (and legacyRootId, if necessary) based on this operation's traceparent
     */
    HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function () {
        // Set operationId
        this.operationId = this.traceparent.traceId;
        if (this.traceparent.legacyRootId) {
            this.legacyRootId = this.traceparent.legacyRootId;
        }
        // Set parentId with existing spanId
        this.parentId = this.traceparent.parentId;
        // Update the spanId and set the current requestId
        this.traceparent.updateSpanId();
        this.requestId = this.traceparent.getBackCompatRequestId();
    };
    HttpRequestParser.prototype.parseHeaders = function (request, requestId) {
        this.rawHeaders = request.headers || request.rawHeaders;
        this.userAgent = request.headers && request.headers["user-agent"];
        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);
        if (request.headers) {
            var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader]; // w3c header
            var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader]; // w3c header
            var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader]; // default AI header
            var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader]; // legacy AI header
            var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader]; // legacy AI header
            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];
            if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {
                // Parse W3C Trace Context headers
                this.traceparent = new Traceparent(traceparentHeader); // new traceparent is always created from this
                this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader); // discard tracestate if no traceparent is present
                this.setBackCompatFromThisTraceContext();
            }
            else if (requestIdHeader) {
                // Parse AI headers
                if (CorrelationIdManager.w3cEnabled) {
                    this.traceparent = new Traceparent(null, requestIdHeader);
                    this.setBackCompatFromThisTraceContext();
                }
                else {
                    this.parentId = requestIdHeader;
                    this.requestId = CorrelationIdManager.generateRequestId(this.parentId);
                    this.operationId = CorrelationIdManager.getRootId(this.requestId);
                }
            }
            else {
                // Legacy fallback
                if (CorrelationIdManager.w3cEnabled) {
                    this.traceparent = new Traceparent();
                    this.traceparent.parentId = legacy_parentId;
                    this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;
                    this.setBackCompatFromThisTraceContext();
                }
                else {
                    this.parentId = legacy_parentId;
                    this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);
                    this.correlationContextHeader = null;
                    this.operationId = CorrelationIdManager.getRootId(this.requestId);
                }
            }
            if (requestId) {
                // For the scenarios that don't guarantee an AI-created context,
                // override the requestId with the provided one.
                this.requestId = requestId;
                this.operationId = CorrelationIdManager.getRootId(this.requestId);
            }
        }
    };
    HttpRequestParser.parseId = function (cookieValue) {
        var cookieParts = cookieValue.split("|");
        if (cookieParts.length > 0) {
            return cookieParts[0];
        }
        return ""; // old behavior was to return "" for incorrect parsing
    };
    HttpRequestParser.keys = new Contracts.ContextTagKeys();
    return HttpRequestParser;
}(RequestParser));
module.exports = HttpRequestParser;
//# sourceMappingURL=HttpRequestParser.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var Logging = __webpack_require__(/*! ../Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Util = __webpack_require__(/*! ../Library/Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js");
var HttpRequestParser = __webpack_require__(/*! ./HttpRequestParser */ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js");
var CorrelationContextManager_1 = __webpack_require__(/*! ./CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js");
var AutoCollectPerformance = __webpack_require__(/*! ./Performance */ "../../node_modules/applicationinsights/out/AutoCollection/Performance.js");
var AutoCollectHttpRequests = (function () {
    function AutoCollectHttpRequests(client) {
        if (!!AutoCollectHttpRequests.INSTANCE) {
            throw new Error("Server request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpRequests.INSTANCE = this;
        this._client = client;
    }
    AutoCollectHttpRequests.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled;
        // Autocorrelation requires automatic monitoring of incoming server requests
        // Disabling autocollection but enabling autocorrelation will still enable
        // request monitoring but will not produce request events
        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {
            this.useAutoCorrelation(this._isAutoCorrelating);
            this._initialize();
        }
    };
    AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled, forceClsHooked) {
        if (isEnabled && !this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);
        }
        else if (!isEnabled && this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.disable();
        }
        this._isAutoCorrelating = isEnabled;
    };
    AutoCollectHttpRequests.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {
        return this._isAutoCorrelating;
    };
    AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {
        if (!this._isAutoCorrelating) {
            return;
        }
        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
    };
    AutoCollectHttpRequests.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = true;
        var wrapOnRequestHandler = function (onRequest) {
            if (!onRequest) {
                return undefined;
            }
            if (typeof onRequest !== 'function') {
                throw new Error('onRequest handler must be a function');
            }
            return function (request, response) {
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
                var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];
                if (request && shouldCollect) {
                    // Set up correlation context
                    var requestParser_1 = new HttpRequestParser(request);
                    var correlationContext = _this._generateCorrelationContext(requestParser_1);
                    // Note: Check for if correlation is enabled happens within this method.
                    // If not enabled, function will directly call the callback.
                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {
                        if (_this._isEnabled) {
                            // Mark as auto collected
                            request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;
                            // Auto collect request
                            AutoCollectHttpRequests.trackRequest(_this._client, { request: request, response: response }, requestParser_1);
                        }
                        if (typeof onRequest === "function") {
                            onRequest(request, response);
                        }
                    });
                }
                else {
                    if (typeof onRequest === "function") {
                        onRequest(request, response);
                    }
                }
            };
        };
        // The `http.createServer` function will instantiate a new http.Server object.
        // Inside the Server's constructor, it is using addListener to register the
        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:
        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching
        //    the http.createServer call. Or
        // 2) Overwrite the http.createServer method and add a patched addListener to the
        //    fresh server instance. This seems more stable for possible future changes as
        //    it also covers the case where the Server might not use addListener to manage
        //    the callback internally.
        //    And also as long as the constructor uses addListener to add the handle, it is
        //    ok to patch the addListener after construction only. Because if we would patch
        //    the prototype one and the createServer method, we would wrap the handler twice
        //    in case of the constructor call.
        var wrapServerEventHandler = function (server) {
            var originalAddListener = server.addListener.bind(server);
            server.addListener = function (eventType, eventHandler) {
                switch (eventType) {
                    case 'request':
                    case 'checkContinue':
                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));
                    default:
                        return originalAddListener(eventType, eventHandler);
                }
            };
            // on is an alias to addListener only
            server.on = server.addListener;
        };
        var originalHttpServer = http.createServer;
        // options parameter was added in Node.js v9.6.0, v8.12.0
        // function createServer(requestListener?: RequestListener): Server;
        // function createServer(options: ServerOptions, requestListener?: RequestListener): Server;
        http.createServer = function (param1, param2) {
            // todo: get a pointer to the server so the IP address can be read from server.address
            if (param2 && typeof param2 === 'function') {
                var server = originalHttpServer(param1, wrapOnRequestHandler(param2));
                wrapServerEventHandler(server);
                return server;
            }
            else {
                var server = originalHttpServer(wrapOnRequestHandler(param1));
                wrapServerEventHandler(server);
                return server;
            }
        };
        var originalHttpsServer = https.createServer;
        https.createServer = function (options, onRequest) {
            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));
            wrapServerEventHandler(server);
            return server;
        };
    };
    /**
     * Tracks a request synchronously (doesn't wait for response 'finish' event)
     */
    AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {
        if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
        }
        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
        // store data about the request
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));
        // Overwrite correlation context with request parser results
        if (correlationContext) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
    };
    /**
     * Tracks a request by listening to the response 'finish' event
     */
    AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {
        if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
        }
        // store data about the request
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {
            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
        }
        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)
        if (correlationContext && !_requestParser) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        // response listeners
        if (telemetry.response.once) {
            telemetry.response.once("finish", function () {
                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);
            });
        }
        // track a failed request if an error is emitted
        if (telemetry.request.on) {
            telemetry.request.on("error", function (error) {
                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);
            });
        }
    };
    /**
     * Add the target correlationId to the response headers, if not already provided.
     */
    AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {
        if (client.config && client.config.correlationId &&
            response.getHeader && response.setHeader && !response.headersSent) {
            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
        }
    };
    AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {
        if (error) {
            requestParser.onError(error, ellapsedMilliseconds);
        }
        else {
            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
        }
        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);
        if (telemetry.tagOverrides) {
            for (var key in telemetry.tagOverrides) {
                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
            }
        }
        var legacyRootId = requestParser.getLegacyRootId();
        if (legacyRootId) {
            requestTelemetry.properties["ai_legacyRootId"] = legacyRootId;
        }
        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};
        requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request;
        requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response;
        client.trackRequest(requestTelemetry);
    };
    AutoCollectHttpRequests.prototype.dispose = function () {
        AutoCollectHttpRequests.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
        CorrelationContextManager_1.CorrelationContextManager.disable();
        this._isAutoCorrelating = false;
    };
    AutoCollectHttpRequests.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';
    return AutoCollectHttpRequests;
}());
module.exports = AutoCollectHttpRequests;
//# sourceMappingURL=HttpRequests.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/NativePerformance.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/NativePerformance.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Config = __webpack_require__(/*! ../Library/Config */ "../../node_modules/applicationinsights/out/Library/Config.js");
var Context = __webpack_require__(/*! ../Library/Context */ "../../node_modules/applicationinsights/out/Library/Context.js");
var Logging = __webpack_require__(/*! ../Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var AutoCollectNativePerformance = (function () {
    function AutoCollectNativePerformance(client) {
        this._disabledMetrics = {};
        // Note: Only 1 instance of this can exist. So when we reconstruct this object,
        // just disable old native instance and reset JS member variables
        if (AutoCollectNativePerformance.INSTANCE) {
            AutoCollectNativePerformance.INSTANCE.dispose();
        }
        AutoCollectNativePerformance.INSTANCE = this;
        this._client = client;
    }
    /**
     *  Reports if NativePerformance is able to run in this environment
     */
    AutoCollectNativePerformance.isNodeVersionCompatible = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) >= 6;
    };
    /**
     * Start instance of native metrics agent.
     *
     * @param {boolean} isEnabled
     * @param {number} [collectionInterval=60000]
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype.enable = function (isEnabled, disabledMetrics, collectionInterval) {
        var _this = this;
        if (disabledMetrics === void 0) { disabledMetrics = {}; }
        if (collectionInterval === void 0) { collectionInterval = 60000; }
        if (!AutoCollectNativePerformance.isNodeVersionCompatible()) {
            return;
        }
        if (AutoCollectNativePerformance._metricsAvailable == undefined && isEnabled && !this._isInitialized) {
            // Try to require in the native-metrics library. If it's found initialize it, else do nothing and never try again.
            try {
                var NativeMetricsEmitters = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'applicationinsights-native-metrics'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                AutoCollectNativePerformance._emitter = new NativeMetricsEmitters();
                AutoCollectNativePerformance._metricsAvailable = true;
                Logging.info("Native metrics module successfully loaded!");
            }
            catch (err) {
                // Package not available. Never try again
                AutoCollectNativePerformance._metricsAvailable = false;
                return;
            }
        }
        this._isEnabled = isEnabled;
        this._disabledMetrics = disabledMetrics;
        if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
        }
        // Enable the emitter if we were able to construct one
        if (this._isEnabled && AutoCollectNativePerformance._emitter) {
            // enable self
            AutoCollectNativePerformance._emitter.enable(true, collectionInterval);
            this._handle = setInterval(function () { return _this._trackNativeMetrics(); }, collectionInterval);
            this._handle.unref();
        }
        else if (AutoCollectNativePerformance._emitter) {
            // disable self
            AutoCollectNativePerformance._emitter.enable(false);
            if (this._handle) {
                clearInterval(this._handle);
                this._handle = undefined;
            }
        }
    };
    /**
     * Cleanup this instance of AutoCollectNativePerformance
     *
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype.dispose = function () {
        this.enable(false);
    };
    /**
     * Parse environment variable and overwrite isEnabled based on respective fields being set
     *
     * @private
     * @static
     * @param {(boolean | IDisabledExtendedMetrics)} collectExtendedMetrics
     * @returns {(boolean | IDisabledExtendedMetrics)}
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.parseEnabled = function (collectExtendedMetrics) {
        var disableAll = process.env[Config.ENV_nativeMetricsDisableAll];
        var individualOptOuts = process.env[Config.ENV_nativeMetricsDisablers];
        // case 1: disable all env var set, RETURN with isEnabled=false
        if (disableAll) {
            return { isEnabled: false, disabledMetrics: {} };
        }
        // case 2: individual env vars set, RETURN with isEnabled=true, disabledMetrics={...}
        if (individualOptOuts) {
            var optOutsArr = individualOptOuts.split(",");
            var disabledMetrics = {};
            if (optOutsArr.length > 0) {
                for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
                    var opt = optOutsArr_1[_i];
                    disabledMetrics[opt] = true;
                }
            }
            // case 2a: collectExtendedMetrics is an object, overwrite existing ones if they exist
            if (typeof collectExtendedMetrics === "object") {
                return { isEnabled: true, disabledMetrics: __assign({}, collectExtendedMetrics, disabledMetrics) };
            }
            // case 2b: collectExtendedMetrics is a boolean, set disabledMetrics as is
            return { isEnabled: collectExtendedMetrics, disabledMetrics: disabledMetrics };
        }
        // case 4: no env vars set, input arg is a boolean, RETURN with isEnabled=collectExtendedMetrics, disabledMetrics={}
        if (typeof collectExtendedMetrics === "boolean") {
            return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };
        }
        else {
            // case 5: no env vars set, input arg is object, RETURN with isEnabled=true, disabledMetrics=collectExtendedMetrics
            return { isEnabled: true, disabledMetrics: collectExtendedMetrics };
        }
    };
    /**
     * Trigger an iteration of native metrics collection
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackNativeMetrics = function () {
        var shouldSendAll = true;
        if (typeof this._isEnabled !== "object") {
            shouldSendAll = this._isEnabled;
        }
        if (shouldSendAll) {
            this._trackGarbageCollection();
            this._trackEventLoop();
            this._trackHeapUsage();
        }
    };
    /**
     * Tracks garbage collection stats for this interval. One custom metric is sent per type of garbage
     * collection that occurred during this collection interval.
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackGarbageCollection = function () {
        if (this._disabledMetrics.gc) {
            return;
        }
        var gcData = AutoCollectNativePerformance._emitter.getGCData();
        for (var gc in gcData) {
            var metrics = gcData[gc].metrics;
            var name_1 = gc + " Garbage Collection Duration";
            var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
            this._client.trackMetric({
                name: name_1,
                value: metrics.total,
                count: metrics.count,
                max: metrics.max,
                min: metrics.min,
                stdDev: stdDev,
                tagOverrides: (_a = {},
                    _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                    _a)
            });
        }
        var _a;
    };
    /**
     * Tracks event loop ticks per interval as a custom metric. Also included in the metric is min/max/avg
     * time spent in event loop for this interval.
     *
     * @private
     * @returns {void}
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackEventLoop = function () {
        if (this._disabledMetrics.loop) {
            return;
        }
        var loopData = AutoCollectNativePerformance._emitter.getLoopData();
        var metrics = loopData.loopUsage;
        if (metrics.count == 0) {
            return;
        }
        var name = "Event Loop CPU Time";
        var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
        this._client.trackMetric({
            name: name,
            value: metrics.total,
            count: metrics.count,
            min: metrics.min,
            max: metrics.max,
            stdDev: stdDev,
            tagOverrides: (_a = {},
                _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _a)
        });
        var _a;
    };
    /**
     * Track heap memory usage metrics as a custom metric.
     *
     * @private
     * @memberof AutoCollectNativePerformance
     */
    AutoCollectNativePerformance.prototype._trackHeapUsage = function () {
        if (this._disabledMetrics.heap) {
            return;
        }
        var memoryUsage = process.memoryUsage();
        var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;
        this._client.trackMetric({
            name: "Memory Usage (Heap)",
            value: heapUsed,
            count: 1,
            tagOverrides: (_a = {},
                _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _a)
        });
        this._client.trackMetric({
            name: "Memory Total (Heap)",
            value: heapTotal,
            count: 1,
            tagOverrides: (_b = {},
                _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _b)
        });
        this._client.trackMetric({
            name: "Memory Usage (Non-Heap)",
            value: rss - heapTotal,
            count: 1,
            tagOverrides: (_c = {},
                _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion,
                _c)
        });
        var _a, _b, _c;
    };
    return AutoCollectNativePerformance;
}());
exports.AutoCollectNativePerformance = AutoCollectNativePerformance;
//# sourceMappingURL=NativePerformance.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/Performance.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/Performance.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");
var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var AutoCollectPerformance = (function () {
    /**
     * @param enableLiveMetricsCounters - enable sending additional live metrics information (dependency metrics, exception metrics, committed memory)
     */
    function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {
        if (collectionInterval === void 0) { collectionInterval = 60000; }
        if (enableLiveMetricsCounters === void 0) { enableLiveMetricsCounters = false; }
        this._lastIntervalRequestExecutionTime = 0; // the sum of durations which took place during from app start until last interval
        this._lastIntervalDependencyExecutionTime = 0;
        if (!AutoCollectPerformance.INSTANCE) {
            AutoCollectPerformance.INSTANCE = this;
        }
        this._isInitialized = false;
        this._client = client;
        this._collectionInterval = collectionInterval;
        this._enableLiveMetricsCounters = enableLiveMetricsCounters;
    }
    AutoCollectPerformance.prototype.enable = function (isEnabled, collectionInterval) {
        var _this = this;
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
        }
        if (isEnabled) {
            if (!this._handle) {
                this._lastCpus = os.cpus();
                this._lastRequests = {
                    totalRequestCount: AutoCollectPerformance._totalRequestCount,
                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
                    time: +new Date
                };
                this._lastDependencies = {
                    totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
                    totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
                    time: +new Date
                };
                this._lastExceptions = {
                    totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
                    time: +new Date
                };
                if (typeof process.cpuUsage === 'function') {
                    this._lastAppCpuUsage = process.cpuUsage();
                }
                this._lastHrtime = process.hrtime();
                this._collectionInterval = collectionInterval || this._collectionInterval;
                this._handle = setInterval(function () { return _this.trackPerformance(); }, this._collectionInterval);
                this._handle.unref(); // Allow the app to terminate even while this loop is going on
            }
        }
        else {
            if (this._handle) {
                clearInterval(this._handle);
                this._handle = undefined;
            }
        }
    };
    AutoCollectPerformance.countRequest = function (duration, success) {
        var durationMs;
        if (!AutoCollectPerformance.isEnabled()) {
            return;
        }
        if (typeof duration === 'string') {
            // dependency duration is passed in as "00:00:00.123" by autocollectors
            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong
        }
        else if (typeof duration === 'number') {
            durationMs = duration;
        }
        else {
            return;
        }
        AutoCollectPerformance._intervalRequestExecutionTime += durationMs;
        if (success === false) {
            AutoCollectPerformance._totalFailedRequestCount++;
        }
        AutoCollectPerformance._totalRequestCount++;
    };
    AutoCollectPerformance.countException = function () {
        AutoCollectPerformance._totalExceptionCount++;
    };
    AutoCollectPerformance.countDependency = function (duration, success) {
        var durationMs;
        if (!AutoCollectPerformance.isEnabled()) {
            return;
        }
        if (typeof duration === 'string') {
            // dependency duration is passed in as "00:00:00.123" by autocollectors
            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong
        }
        else if (typeof duration === 'number') {
            durationMs = duration;
        }
        else {
            return;
        }
        AutoCollectPerformance._intervalDependencyExecutionTime += durationMs;
        if (success === false) {
            AutoCollectPerformance._totalFailedDependencyCount++;
        }
        AutoCollectPerformance._totalDependencyCount++;
    };
    AutoCollectPerformance.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectPerformance.isEnabled = function () {
        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;
    };
    AutoCollectPerformance.prototype.trackPerformance = function () {
        this._trackCpu();
        this._trackMemory();
        this._trackNetwork();
        this._trackDependencyRate();
        this._trackExceptionRate();
    };
    AutoCollectPerformance.prototype._trackCpu = function () {
        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary
        // to find the delta since the last measurement
        var cpus = os.cpus();
        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
            var totalUser = 0;
            var totalSys = 0;
            var totalNice = 0;
            var totalIdle = 0;
            var totalIrq = 0;
            for (var i = 0; !!cpus && i < cpus.length; i++) {
                var cpu = cpus[i];
                var lastCpu = this._lastCpus[i];
                var name = "% cpu(" + i + ") ";
                var model = cpu.model;
                var speed = cpu.speed;
                var times = cpu.times;
                var lastTimes = lastCpu.times;
                // user cpu time (or) % CPU time spent in user space
                var user = (times.user - lastTimes.user) || 0;
                totalUser += user;
                // system cpu time (or) % CPU time spent in kernel space
                var sys = (times.sys - lastTimes.sys) || 0;
                totalSys += sys;
                // user nice cpu time (or) % CPU time spent on low priority processes
                var nice = (times.nice - lastTimes.nice) || 0;
                totalNice += nice;
                // idle cpu time (or) % CPU time spent idle
                var idle = (times.idle - lastTimes.idle) || 0;
                totalIdle += idle;
                // irq (or) % CPU time spent servicing/handling hardware interrupts
                var irq = (times.irq - lastTimes.irq) || 0;
                totalIrq += irq;
            }
            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)
            var appCpuPercent = undefined;
            if (typeof process.cpuUsage === 'function') {
                var appCpuUsage = process.cpuUsage();
                var hrtime = process.hrtime();
                var totalApp = ((appCpuUsage.user - this._lastAppCpuUsage.user) + (appCpuUsage.system - this._lastAppCpuUsage.system)) || 0;
                if (typeof this._lastHrtime !== 'undefined' && this._lastHrtime.length === 2) {
                    var elapsedTime = ((hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3) || 0; // convert to microseconds
                    appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);
                }
                // Set previous
                this._lastAppCpuUsage = appCpuUsage;
                this._lastHrtime = hrtime;
            }
            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: ((combinedTotal - totalIdle) / combinedTotal) * 100 });
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || ((totalUser / combinedTotal) * 100) });
        }
        this._lastCpus = cpus;
    };
    AutoCollectPerformance.prototype._trackMemory = function () {
        var freeMem = os.freemem();
        var usedMem = process.memoryUsage().rss;
        var committedMemory = os.totalmem() - freeMem;
        this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });
        this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });
        // Only supported by quickpulse service
        if (this._enableLiveMetricsCounters) {
            this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });
        }
    };
    AutoCollectPerformance.prototype._trackNetwork = function () {
        // track total request counters
        var lastRequests = this._lastRequests;
        var requests = {
            totalRequestCount: AutoCollectPerformance._totalRequestCount,
            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
            time: +new Date
        };
        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;
        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;
        var elapsedMs = requests.time - lastRequests.time;
        var elapsedSeconds = elapsedMs / 1000;
        var averageRequestExecutionTime = ((AutoCollectPerformance._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests) || 0; // default to 0 in case no requests in this interval
        this._lastIntervalRequestExecutionTime = AutoCollectPerformance._intervalRequestExecutionTime; // reset
        if (elapsedMs > 0) {
            var requestsPerSec = intervalRequests / elapsedSeconds;
            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });
            // Only send duration to live metrics if it has been updated!
            if (!this._enableLiveMetricsCounters || intervalRequests > 0) {
                this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });
            }
            // Only supported by quickpulse service
            if (this._enableLiveMetricsCounters) {
                this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });
            }
        }
        this._lastRequests = requests;
    };
    // Static counter is accumulated externally. Report the rate to client here
    // Note: This is currently only used with QuickPulse client
    AutoCollectPerformance.prototype._trackDependencyRate = function () {
        if (this._enableLiveMetricsCounters) {
            var lastDependencies = this._lastDependencies;
            var dependencies = {
                totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
                totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
                time: +new Date
            };
            var intervalDependencies = (dependencies.totalDependencyCount - lastDependencies.totalDependencyCount) || 0;
            var intervalFailedDependencies = (dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount) || 0;
            var elapsedMs = dependencies.time - lastDependencies.time;
            var elapsedSeconds = elapsedMs / 1000;
            var averageDependencyExecutionTime = ((AutoCollectPerformance._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies) || 0;
            this._lastIntervalDependencyExecutionTime = AutoCollectPerformance._intervalDependencyExecutionTime; // reset
            if (elapsedMs > 0) {
                var dependenciesPerSec = intervalDependencies / elapsedSeconds;
                var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });
                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });
                // redundant check for livemetrics, but kept for consistency w/ requests
                // Only send duration to live metrics if it has been updated!
                if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {
                    this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });
                }
            }
            this._lastDependencies = dependencies;
        }
    };
    // Static counter is accumulated externally. Report the rate to client here
    // Note: This is currently only used with QuickPulse client
    AutoCollectPerformance.prototype._trackExceptionRate = function () {
        if (this._enableLiveMetricsCounters) {
            var lastExceptions = this._lastExceptions;
            var exceptions = {
                totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
                time: +new Date
            };
            var intervalExceptions = (exceptions.totalExceptionCount - lastExceptions.totalExceptionCount) || 0;
            var elapsedMs = exceptions.time - lastExceptions.time;
            var elapsedSeconds = elapsedMs / 1000;
            if (elapsedMs > 0) {
                var exceptionsPerSec = intervalExceptions / elapsedSeconds;
                this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });
            }
            this._lastExceptions = exceptions;
        }
    };
    AutoCollectPerformance.prototype.dispose = function () {
        AutoCollectPerformance.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
    };
    AutoCollectPerformance._totalRequestCount = 0;
    AutoCollectPerformance._totalFailedRequestCount = 0;
    AutoCollectPerformance._lastRequestExecutionTime = 0;
    AutoCollectPerformance._totalDependencyCount = 0;
    AutoCollectPerformance._totalFailedDependencyCount = 0;
    AutoCollectPerformance._lastDependencyExecutionTime = 0;
    AutoCollectPerformance._totalExceptionCount = 0;
    AutoCollectPerformance._intervalDependencyExecutionTime = 0;
    AutoCollectPerformance._intervalRequestExecutionTime = 0;
    return AutoCollectPerformance;
}());
module.exports = AutoCollectPerformance;
//# sourceMappingURL=Performance.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";

/**
 * Base class for helpers that read data from HTTP request/response objects and convert them
 * into the telemetry contract objects.
 */
var RequestParser = (function () {
    function RequestParser() {
    }
    /**
     * Gets a url parsed out from request options
     */
    RequestParser.prototype.getUrl = function () {
        return this.url;
    };
    RequestParser.prototype.RequestParser = function () {
        this.startTime = +new Date();
    };
    RequestParser.prototype._setStatus = function (status, error) {
        var endTime = +new Date();
        this.duration = endTime - this.startTime;
        this.statusCode = status;
        var properties = this.properties || {};
        if (error) {
            if (typeof error === "string") {
                properties["error"] = error;
            }
            else if (error instanceof Error) {
                properties["error"] = error.message;
            }
            else if (typeof error === "object") {
                for (var key in error) {
                    properties[key] = error[key] && error[key].toString && error[key].toString();
                }
            }
        }
        this.properties = properties;
    };
    RequestParser.prototype._isSuccess = function () {
        return (0 < this.statusCode) && (this.statusCode < 400);
    };
    return RequestParser;
}());
module.exports = RequestParser;
//# sourceMappingURL=RequestParser.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var AsyncHooksScopeManager_1 = __webpack_require__(/*! ../AsyncHooksScopeManager */ "../../node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js");
var Constants = __webpack_require__(/*! ../../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
function filterSpanAttributes(attributes) {
    var newAttributes = __assign({}, attributes);
    Object.keys(Constants.SpanAttribute).forEach(function (key) {
        delete newAttributes[key];
    });
    return newAttributes;
}
function spanToTelemetryContract(span) {
    var id = "|" + span.context().traceId + "." + span.context().spanId + ".";
    var duration = Math.round(span._duration[0] * 1e3 + span._duration[1] / 1e6);
    var isHttp = ((span.attributes.component || "").toUpperCase() === Constants.DependencyTypeName.Http) || (!!span.attributes[Constants.SpanAttribute.HttpUrl]);
    var isGrpc = (span.attributes.component || "").toLowerCase() === Constants.DependencyTypeName.Grpc;
    if (isHttp) {
        // Read http span attributes
        var method = span.attributes[Constants.SpanAttribute.HttpMethod] || "GET";
        var url = new URL(span.attributes[Constants.SpanAttribute.HttpUrl]);
        var host = span.attributes[Constants.SpanAttribute.HttpHost] || url.host;
        var port = span.attributes[Constants.SpanAttribute.HttpPort] || url.port || null;
        var pathname = url.pathname || "/";
        // Translate to AI Dependency format
        var name_1 = method + " " + pathname;
        var dependencyTypeName = Constants.DependencyTypeName.Http;
        var target = port ? host + ":" + port : host;
        var data = url.toString();
        var resultCode = span.attributes[Constants.SpanAttribute.HttpStatusCode] || span.status.code || 0;
        var success = resultCode < 400; // Status.OK
        return {
            id: id, name: name_1, dependencyTypeName: dependencyTypeName,
            target: target, data: data,
            success: success, duration: duration,
            url: data,
            resultCode: String(resultCode),
            properties: filterSpanAttributes(span.attributes)
        };
    }
    else if (isGrpc) {
        var method = span.attributes[Constants.SpanAttribute.GrpcMethod] || "rpc";
        var service = span.attributes[Constants.SpanAttribute.GrpcService];
        var name_2 = service ? method + " " + service : span.name;
        return {
            id: id, duration: duration, name: name_2,
            target: service,
            data: service || name_2,
            url: service || name_2,
            dependencyTypeName: Constants.DependencyTypeName.Grpc,
            resultCode: String(span.status.code || 0),
            success: span.status.code === 0,
            properties: filterSpanAttributes(span.attributes),
        };
    }
    else {
        var name_3 = span.name;
        var links = span.links && span.links.map(function (link) {
            return {
                operation_Id: link.spanContext.traceId,
                id: link.spanContext.spanId
            };
        });
        return {
            id: id, duration: duration, name: name_3,
            target: span.attributes["peer.address"],
            data: span.attributes["peer.address"] || name_3,
            url: span.attributes["peer.address"] || name_3,
            dependencyTypeName: span.kind === AsyncHooksScopeManager_1.SpanKind.INTERNAL ? Constants.DependencyTypeName.InProc : (span.attributes.component || span.name),
            resultCode: String(span.status.code || 0),
            success: span.status.code === 0,
            properties: __assign({}, filterSpanAttributes(span.attributes), { "_MS.links": links || undefined }),
        };
    }
}
exports.spanToTelemetryContract = spanToTelemetryContract;
//# sourceMappingURL=SpanParser.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var Traceparent = __webpack_require__(/*! ../../Library/Traceparent */ "../../node_modules/applicationinsights/out/Library/Traceparent.js");
var SpanParser = __webpack_require__(/*! ./SpanParser */ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js");
var AsyncHooksScopeManager_1 = __webpack_require__(/*! ../AsyncHooksScopeManager */ "../../node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js");
var clients = [];
exports.subscriber = function (event) {
    var span = event.data;
    var telemetry = SpanParser.spanToTelemetryContract(span);
    var spanContext = span.context();
    var traceparent = new Traceparent();
    traceparent.traceId = spanContext.traceId;
    traceparent.spanId = spanContext.spanId;
    traceparent.traceFlag = spanContext.traceFlags.toString();
    traceparent.parentId = span.parentSpanId ? "|" + spanContext.traceId + "." + span.parentSpanId + "." : null;
    AsyncHooksScopeManager_1.AsyncScopeManager.with(span, function () {
        clients.forEach(function (client) {
            if (span.kind === AsyncHooksScopeManager_1.SpanKind.SERVER) {
                // Server or Consumer
                client.trackRequest(telemetry);
            }
            else if (span.kind === AsyncHooksScopeManager_1.SpanKind.CLIENT || span.kind === AsyncHooksScopeManager_1.SpanKind.INTERNAL) {
                // Client or Producer or Internal
                client.trackDependency(telemetry);
            }
            // else - ignore producer/consumer spans for now until it is clear how this sdk should interpret them
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("azure-coretracing", exports.subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("azure-coretracing", exports.subscriber);
        }
    }
}
exports.enable = enable;
//# sourceMappingURL=azure-coretracing.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
// Mapping from bunyan levels defined at https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L256
var bunyanToAILevelMap = {
    10: Contracts_1.SeverityLevel.Verbose,
    20: Contracts_1.SeverityLevel.Verbose,
    30: Contracts_1.SeverityLevel.Information,
    40: Contracts_1.SeverityLevel.Warning,
    50: Contracts_1.SeverityLevel.Error,
    60: Contracts_1.SeverityLevel.Critical,
};
var subscriber = function (event) {
    var message = event.data.result;
    clients.forEach(function (client) {
        var AIlevel = bunyanToAILevelMap[event.data.level];
        if (message instanceof Error) {
            client.trackException({ exception: (message) });
        }
        else {
            client.trackTrace({ message: message, severity: AIlevel });
        }
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("bunyan", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
        }
    }
}
exports.enable = enable;
function dispose() {
    diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
    clients = [];
}
exports.dispose = dispose;
//# sourceMappingURL=bunyan.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
var subscriber = function (event) {
    var message = event.data.message;
    clients.forEach(function (client) {
        if (message instanceof Error) {
            client.trackException({ exception: message });
        }
        else {
            // Message can have a trailing newline
            if (message.lastIndexOf("\n") == message.length - 1) {
                message = message.substring(0, message.length - 1);
            }
            client.trackTrace({ message: message, severity: (event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information) });
        }
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("console", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("console", subscriber);
        }
    }
}
exports.enable = enable;
function dispose() {
    diagnostic_channel_1.channel.unsubscribe("console", subscriber);
    clients = [];
}
exports.dispose = dispose;
//# sourceMappingURL=console.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AsyncHooksScopeManager_1 = __webpack_require__(/*! ../AsyncHooksScopeManager */ "../../node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js");
var Logging = __webpack_require__(/*! ../../Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
exports.IsInitialized = !process.env["APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL"];
var TAG = "DiagnosticChannel";
if (exports.IsInitialized) {
    var publishers = __webpack_require__(/*! diagnostic-channel-publishers */ "../../node_modules/diagnostic-channel-publishers/dist/src/index.js");
    var individualOptOuts = process.env["APPLICATION_INSIGHTS_NO_PATCH_MODULES"] || "";
    var unpatchedModules = individualOptOuts.split(",");
    var modules = {
        bunyan: publishers.bunyan,
        console: publishers.console,
        mongodb: publishers.mongodb,
        mongodbCore: publishers.mongodbCore,
        mysql: publishers.mysql,
        redis: publishers.redis,
        pg: publishers.pg,
        pgPool: publishers.pgPool,
        winston: publishers.winston,
        azuresdk: publishers.azuresdk
    };
    for (var mod in modules) {
        if (unpatchedModules.indexOf(mod) === -1) {
            modules[mod].enable();
            Logging.info(TAG, "Subscribed to " + mod + " events");
        }
    }
    if (unpatchedModules.length > 0) {
        Logging.info(TAG, "Some modules will not be patched", unpatchedModules);
    }
}
else {
    Logging.info(TAG, "Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");
}
function registerContextPreservation(cb) {
    if (!exports.IsInitialized) {
        return;
    }
    var diagChannel = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
    diagChannel.channel.addContextPreservation(cb);
    diagChannel.channel.spanContextPropagator = AsyncHooksScopeManager_1.AsyncScopeManager;
}
exports.registerContextPreservation = registerContextPreservation;
//# sourceMappingURL=initialization.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
exports.subscriber = function (event) {
    if (event.data.event.commandName === "ismaster") {
        // suppress noisy ismaster commands
        return;
    }
    clients.forEach(function (client) {
        var dbName = (event.data.startedData && event.data.startedData.databaseName) || "Unknown database";
        client.trackDependency({
            target: dbName,
            data: event.data.event.commandName,
            name: event.data.event.commandName,
            duration: event.data.event.duration,
            success: event.data.succeeded,
            /* TODO: transmit result code from mongo */
            resultCode: event.data.succeeded ? "0" : "1",
            time: event.data.startedData.time,
            dependencyTypeName: 'mongodb'
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("mongodb", exports.subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("mongodb", exports.subscriber);
        }
    }
}
exports.enable = enable;
//# sourceMappingURL=mongodb.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
exports.subscriber = function (event) {
    clients.forEach(function (client) {
        var queryObj = event.data.query || {};
        var sqlString = queryObj.sql || "Unknown query";
        var success = !event.data.err;
        var connection = queryObj._connection || {};
        var connectionConfig = connection.config || {};
        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
        client.trackDependency({
            target: dbName,
            data: sqlString,
            name: sqlString,
            duration: event.data.duration,
            success: success,
            /* TODO: transmit result code from mysql */
            resultCode: success ? "0" : "1",
            time: event.data.time,
            dependencyTypeName: "mysql"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("mysql", exports.subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("mysql", exports.subscriber);
        }
    }
}
exports.enable = enable;
//# sourceMappingURL=mysql.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
exports.subscriber = function (event) {
    clients.forEach(function (client) {
        var q = event.data.query;
        var sql = (q.preparable && q.preparable.text) || q.plan || q.text || "unknown query";
        var success = !event.data.error;
        var conn = event.data.database.host + ":" + event.data.database.port;
        client.trackDependency({
            target: conn,
            data: sql,
            name: sql,
            duration: event.data.duration,
            success: success,
            resultCode: success ? "0" : "1",
            time: event.data.time,
            dependencyTypeName: "postgres"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("postgres", exports.subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("postgres", exports.subscriber);
        }
    }
}
exports.enable = enable;
//# sourceMappingURL=postgres.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
exports.subscriber = function (event) {
    clients.forEach(function (client) {
        if (event.data.commandObj.command === "info") {
            // We don't want to report 'info', it's irrelevant
            return;
        }
        client.trackDependency({
            target: event.data.address,
            name: event.data.commandObj.command,
            data: event.data.commandObj.command,
            duration: event.data.duration,
            success: !event.data.err,
            /* TODO: transmit result code from redis */
            resultCode: event.data.err ? "1" : "0",
            time: event.data.time,
            dependencyTypeName: "redis"
        });
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("redis", exports.subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("redis", exports.subscriber);
        }
    }
}
exports.enable = enable;
//# sourceMappingURL=redis.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var clients = [];
var winstonToAILevelMap = {
    syslog: function (og) {
        var map = {
            emerg: Contracts_1.SeverityLevel.Critical,
            alert: Contracts_1.SeverityLevel.Critical,
            crit: Contracts_1.SeverityLevel.Critical,
            error: Contracts_1.SeverityLevel.Error,
            warning: Contracts_1.SeverityLevel.Warning,
            notice: Contracts_1.SeverityLevel.Information,
            info: Contracts_1.SeverityLevel.Information,
            debug: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];
    },
    npm: function (og) {
        var map = {
            error: Contracts_1.SeverityLevel.Error,
            warn: Contracts_1.SeverityLevel.Warning,
            info: Contracts_1.SeverityLevel.Information,
            verbose: Contracts_1.SeverityLevel.Verbose,
            debug: Contracts_1.SeverityLevel.Verbose,
            silly: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];
    },
    unknown: function (og) {
        return Contracts_1.SeverityLevel.Information;
    }
};
var subscriber = function (event) {
    var message = event.data.message;
    clients.forEach(function (client) {
        if (message instanceof Error) {
            client.trackException({
                exception: message,
                properties: event.data.meta
            });
        }
        else {
            var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
            client.trackTrace({
                message: message,
                severity: AIlevel,
                properties: event.data.meta
            });
        }
    });
};
function enable(enabled, client) {
    if (enabled) {
        if (clients.length === 0) {
            diagnostic_channel_1.channel.subscribe("winston", subscriber);
        }
        ;
        clients.push(client);
    }
    else {
        clients = clients.filter(function (c) { return c != client; });
        if (clients.length === 0) {
            diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
        }
    }
}
exports.enable = enable;
function dispose() {
    diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
    clients = [];
}
exports.dispose = dispose;
//# sourceMappingURL=winston.sub.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Constants.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Constants.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
exports.DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
exports.DEFAULT_LIVEMETRICS_HOST = "rt.services.visualstudio.com";
var QuickPulseCounter;
(function (QuickPulseCounter) {
    // Memory
    QuickPulseCounter["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // CPU
    QuickPulseCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // Request
    QuickPulseCounter["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseCounter["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseCounter["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseCounter["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseCounter["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseCounter["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseCounter["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));
var PerformanceCounter;
(function (PerformanceCounter) {
    // Memory
    PerformanceCounter["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounter["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    // CPU
    PerformanceCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounter["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    // Requests
    PerformanceCounter["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounter["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {}));
;
/**
 * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*
 */
exports.PerformanceToQuickPulseCounter = (_a = {},
    _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME,
    _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE,
    _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION,
    // Remap quick pulse only counters
    _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES,
    _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE,
    _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE,
    _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
    _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION,
    _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE,
    _a);
exports.QuickPulseDocumentType = {
    Event: "Event",
    Exception: "Exception",
    Trace: "Trace",
    Metric: "Metric",
    Request: "Request",
    Dependency: "RemoteDependency",
    Availability: "Availability",
    PageView: "PageView",
};
exports.QuickPulseType = {
    Event: "EventTelemetryDocument",
    Exception: "ExceptionTelemetryDocument",
    Trace: "TraceTelemetryDocument",
    Metric: "MetricTelemetryDocument",
    Request: "RequestTelemetryDocument",
    Dependency: "DependencyTelemetryDocument",
    Availability: "AvailabilityTelemetryDocument",
    PageView: "PageViewTelemetryDocument",
};
exports.TelemetryTypeStringToQuickPulseType = {
    EventData: exports.QuickPulseType.Event,
    ExceptionData: exports.QuickPulseType.Exception,
    MessageData: exports.QuickPulseType.Trace,
    MetricData: exports.QuickPulseType.Metric,
    RequestData: exports.QuickPulseType.Request,
    RemoteDependencyData: exports.QuickPulseType.Dependency,
    AvailabilityData: exports.QuickPulseType.Availability,
    PageViewData: exports.QuickPulseType.PageView
};
exports.TelemetryTypeStringToQuickPulseDocumentType = {
    EventData: exports.QuickPulseDocumentType.Event,
    ExceptionData: exports.QuickPulseDocumentType.Exception,
    MessageData: exports.QuickPulseDocumentType.Trace,
    MetricData: exports.QuickPulseDocumentType.Metric,
    RequestData: exports.QuickPulseDocumentType.Request,
    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,
    AvailabilityData: exports.QuickPulseDocumentType.Availability,
    PageViewData: exports.QuickPulseDocumentType.PageView
};
// OpenTelemetry Span Attributes
exports.SpanAttribute = {
    // HTTP
    HttpHost: "http.host",
    HttpMethod: "http.method",
    HttpPort: "http.port",
    HttpStatusCode: "http.status_code",
    HttpUrl: "http.url",
    HttpUserAgent: "http.user_agent",
    // GRPC
    GrpcMethod: "grpc.method",
    GrpcService: "rpc.service",
};
exports.DependencyTypeName = {
    Grpc: "GRPC",
    Http: "HTTP",
    InProc: "InProc",
};
exports.HeartBeatMetricName = "HeartBeat";
var _a;
//# sourceMappingURL=Constants.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Constants.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Constants.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Generated_1 = __webpack_require__(/*! ./Generated */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js");
var RemoteDependencyDataConstants = (function () {
    function RemoteDependencyDataConstants() {
    }
    RemoteDependencyDataConstants.TYPE_HTTP = "Http";
    RemoteDependencyDataConstants.TYPE_AI = "Http (tracked component)";
    return RemoteDependencyDataConstants;
}());
exports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;
function domainSupportsProperties(domain) {
    return "properties" in domain ||
        domain instanceof Generated_1.EventData ||
        domain instanceof Generated_1.ExceptionData ||
        domain instanceof Generated_1.MessageData ||
        domain instanceof Generated_1.MetricData ||
        domain instanceof Generated_1.PageViewData ||
        domain instanceof Generated_1.RemoteDependencyData ||
        domain instanceof Generated_1.RequestData;
}
exports.domainSupportsProperties = domainSupportsProperties;
//# sourceMappingURL=Constants.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js ***!
  \*******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * Instances of AvailabilityData represent the result of executing an availability test.
 */
var AvailabilityData = (function (_super) {
    __extends(AvailabilityData, _super);
    function AvailabilityData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return AvailabilityData;
}(Domain));
module.exports = AvailabilityData;
//# sourceMappingURL=AvailabilityData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Data struct to contain only C section with custom fields.
 */
var Base = (function () {
    function Base() {
    }
    return Base;
}());
module.exports = Base;
//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js ***!
  \*****************************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

var ContextTagKeys = (function () {
    function ContextTagKeys() {
        this.applicationVersion = "ai.application.ver";
        this.deviceId = "ai.device.id";
        this.deviceLocale = "ai.device.locale";
        this.deviceModel = "ai.device.model";
        this.deviceOEMName = "ai.device.oemName";
        this.deviceOSVersion = "ai.device.osVersion";
        this.deviceType = "ai.device.type";
        this.locationIp = "ai.location.ip";
        this.operationId = "ai.operation.id";
        this.operationName = "ai.operation.name";
        this.operationParentId = "ai.operation.parentId";
        this.operationSyntheticSource = "ai.operation.syntheticSource";
        this.operationCorrelationVector = "ai.operation.correlationVector";
        this.sessionId = "ai.session.id";
        this.sessionIsFirst = "ai.session.isFirst";
        this.userAccountId = "ai.user.accountId";
        this.userId = "ai.user.id";
        this.userAuthUserId = "ai.user.authUserId";
        this.cloudRole = "ai.cloud.role";
        this.cloudRoleInstance = "ai.cloud.roleInstance";
        this.internalSdkVersion = "ai.internal.sdkVersion";
        this.internalAgentVersion = "ai.internal.agentVersion";
        this.internalNodeName = "ai.internal.nodeName";
    }
    return ContextTagKeys;
}());
module.exports = ContextTagKeys;
//# sourceMappingURL=ContextTagKeys.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Base = __webpack_require__(/*! ./Base */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js");
"use strict";
/**
 * Data struct to contain both B and C sections.
 */
var Data = (function (_super) {
    __extends(Data, _super);
    function Data() {
        return _super.call(this) || this;
    }
    return Data;
}(Base));
module.exports = Data;
//# sourceMappingURL=Data.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// THIS FILE WAS AUTOGENERATED
var DataPointType = __webpack_require__(/*! ./DataPointType */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js");
"use strict";
/**
 * Metric data single measurement.
 */
var DataPoint = (function () {
    function DataPoint() {
        this.kind = DataPointType.Measurement;
    }
    return DataPoint;
}());
module.exports = DataPoint;
//# sourceMappingURL=DataPoint.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Type of the metric data measurement.
 */
var DataPointType;
(function (DataPointType) {
    DataPointType[DataPointType["Measurement"] = 0] = "Measurement";
    DataPointType[DataPointType["Aggregation"] = 1] = "Aggregation";
})(DataPointType || (DataPointType = {}));
module.exports = DataPointType;
//# sourceMappingURL=DataPointType.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * The abstract common base of all domains.
 */
var Domain = (function () {
    function Domain() {
    }
    return Domain;
}());
module.exports = Domain;
//# sourceMappingURL=Domain.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js ***!
  \***********************************************************************************************/
/***/ ((module) => {

"use strict";

/**
 * System variables for a telemetry item.
 */
var Envelope = (function () {
    function Envelope() {
        this.ver = 1;
        this.sampleRate = 100.0;
        this.tags = {};
    }
    return Envelope;
}());
module.exports = Envelope;
//# sourceMappingURL=Envelope.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.
 */
var EventData = (function (_super) {
    __extends(EventData, _super);
    function EventData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return EventData;
}(Domain));
module.exports = EventData;
//# sourceMappingURL=EventData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js ***!
  \****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.
 */
var ExceptionData = (function (_super) {
    __extends(ExceptionData, _super);
    function ExceptionData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.exceptions = [];
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return ExceptionData;
}(Domain));
module.exports = ExceptionData;
//# sourceMappingURL=ExceptionData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js ***!
  \*******************************************************************************************************/
/***/ ((module) => {

"use strict";

/**
 * Exception details of the exception in a chain.
 */
var ExceptionDetails = (function () {
    function ExceptionDetails() {
        this.hasFullStack = true;
        this.parsedStack = [];
    }
    return ExceptionDetails;
}());
module.exports = ExceptionDetails;
//# sourceMappingURL=ExceptionDetails.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js ***!
  \**************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.
 */
var MessageData = (function (_super) {
    __extends(MessageData, _super);
    function MessageData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        return _this;
    }
    return MessageData;
}(Domain));
module.exports = MessageData;
//# sourceMappingURL=MessageData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js ***!
  \*************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.
 */
var MetricData = (function (_super) {
    __extends(MetricData, _super);
    function MetricData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.metrics = [];
        _this.properties = {};
        return _this;
    }
    return MetricData;
}(Domain));
module.exports = MetricData;
//# sourceMappingURL=MetricData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js ***!
  \***************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var EventData = __webpack_require__(/*! ./EventData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js");
"use strict";
/**
 * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.
 */
var PageViewData = (function (_super) {
    __extends(PageViewData, _super);
    function PageViewData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return PageViewData;
}(EventData));
module.exports = PageViewData;
//# sourceMappingURL=PageViewData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js ***!
  \***********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.
 */
var RemoteDependencyData = (function (_super) {
    __extends(RemoteDependencyData, _super);
    function RemoteDependencyData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.success = true;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return RemoteDependencyData;
}(Domain));
module.exports = RemoteDependencyData;
//# sourceMappingURL=RemoteDependencyData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js ***!
  \**************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// THIS FILE WAS AUTOGENERATED
var Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
"use strict";
/**
 * An instance of Request represents completion of an external request to the application to do work and contains a summary of that request execution and the results.
 */
var RequestData = (function (_super) {
    __extends(RequestData, _super);
    function RequestData() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
    }
    return RequestData;
}(Domain));
module.exports = RequestData;
//# sourceMappingURL=RequestData.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Defines the level of severity for the event.
 */
var SeverityLevel;
(function (SeverityLevel) {
    SeverityLevel[SeverityLevel["Verbose"] = 0] = "Verbose";
    SeverityLevel[SeverityLevel["Information"] = 1] = "Information";
    SeverityLevel[SeverityLevel["Warning"] = 2] = "Warning";
    SeverityLevel[SeverityLevel["Error"] = 3] = "Error";
    SeverityLevel[SeverityLevel["Critical"] = 4] = "Critical";
})(SeverityLevel || (SeverityLevel = {}));
module.exports = SeverityLevel;
//# sourceMappingURL=SeverityLevel.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

/**
 * Stack frame information.
 */
var StackFrame = (function () {
    function StackFrame() {
    }
    return StackFrame;
}());
module.exports = StackFrame;
//# sourceMappingURL=StackFrame.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// THIS FILE WAS AUTOGENERATED

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AvailabilityData = __webpack_require__(/*! ./AvailabilityData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js");
exports.Base = __webpack_require__(/*! ./Base */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js");
exports.ContextTagKeys = __webpack_require__(/*! ./ContextTagKeys */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js");
exports.Data = __webpack_require__(/*! ./Data */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js");
exports.DataPoint = __webpack_require__(/*! ./DataPoint */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js");
exports.DataPointType = __webpack_require__(/*! ./DataPointType */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js");
exports.Domain = __webpack_require__(/*! ./Domain */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js");
exports.Envelope = __webpack_require__(/*! ./Envelope */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js");
exports.EventData = __webpack_require__(/*! ./EventData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js");
exports.ExceptionData = __webpack_require__(/*! ./ExceptionData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js");
exports.ExceptionDetails = __webpack_require__(/*! ./ExceptionDetails */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js");
exports.MessageData = __webpack_require__(/*! ./MessageData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js");
exports.MetricData = __webpack_require__(/*! ./MetricData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js");
exports.PageViewData = __webpack_require__(/*! ./PageViewData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js");
exports.RemoteDependencyData = __webpack_require__(/*! ./RemoteDependencyData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js");
exports.RequestData = __webpack_require__(/*! ./RequestData */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js");
exports.SeverityLevel = __webpack_require__(/*! ./SeverityLevel */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js");
exports.StackFrame = __webpack_require__(/*! ./StackFrame */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Converts the user-friendly enumeration TelemetryType to the underlying schema baseType value
 * @param type Type to convert to BaseData string
 */
function telemetryTypeToBaseType(type) {
    switch (type) {
        case TelemetryType.Event:
            return "EventData";
        case TelemetryType.Exception:
            return "ExceptionData";
        case TelemetryType.Trace:
            return "MessageData";
        case TelemetryType.Metric:
            return "MetricData";
        case TelemetryType.Request:
            return "RequestData";
        case TelemetryType.Dependency:
            return "RemoteDependencyData";
        case TelemetryType.Availability:
            return "AvailabilityData";
        case TelemetryType.PageView:
            return "PageViewData";
    }
    return undefined;
}
exports.telemetryTypeToBaseType = telemetryTypeToBaseType;
/**
 * Converts the schema baseType value to the user-friendly enumeration TelemetryType
 * @param baseType BaseData string to convert to TelemetryType
 */
function baseTypeToTelemetryType(baseType) {
    switch (baseType) {
        case "EventData":
            return TelemetryType.Event;
        case "ExceptionData":
            return TelemetryType.Exception;
        case "MessageData":
            return TelemetryType.Trace;
        case "MetricData":
            return TelemetryType.Metric;
        case "RequestData":
            return TelemetryType.Request;
        case "RemoteDependencyData":
            return TelemetryType.Dependency;
        case "AvailabilityData":
            return TelemetryType.Availability;
        case "PageViewData":
            return TelemetryType.PageView;
    }
    return undefined;
}
exports.baseTypeToTelemetryType = baseTypeToTelemetryType;
exports.TelemetryTypeString = {
    Event: "EventData",
    Exception: "ExceptionData",
    Trace: "MessageData",
    Metric: "MetricData",
    Request: "RequestData",
    Dependency: "RemoteDependencyData",
    Availability: "AvailabilityData",
    PageView: "PageViewData",
};
/**
 * Telemetry types supported by this SDK
 */
var TelemetryType;
(function (TelemetryType) {
    TelemetryType[TelemetryType["Event"] = 0] = "Event";
    TelemetryType[TelemetryType["Exception"] = 1] = "Exception";
    TelemetryType[TelemetryType["Trace"] = 2] = "Trace";
    TelemetryType[TelemetryType["Metric"] = 3] = "Metric";
    TelemetryType[TelemetryType["Request"] = 4] = "Request";
    TelemetryType[TelemetryType["Dependency"] = 5] = "Dependency";
    TelemetryType[TelemetryType["Availability"] = 6] = "Availability";
    TelemetryType[TelemetryType["PageView"] = 7] = "PageView";
})(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));
//# sourceMappingURL=TelemetryType.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(/*! ./TelemetryType */ "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Declarations/Contracts/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(/*! ./Constants */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Constants.js"));
__export(__webpack_require__(/*! ./Generated */ "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js"));
__export(__webpack_require__(/*! ./TelemetryTypes */ "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Channel.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Channel.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Channel = (function () {
    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
        this._buffer = [];
        this._lastSend = 0;
        this._isDisabled = isDisabled;
        this._getBatchSize = getBatchSize;
        this._getBatchIntervalMs = getBatchIntervalMs;
        this._sender = sender;
    }
    /**
     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)
     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.
     * @param value if true events that occurred while client is offline will be cached on disk
     * @param resendInterval The wait interval for resending cached events.
     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.
     * @returns {Configuration} this class
     */
    Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
    };
    /**
     * Add a telemetry item to the send buffer
     */
    Channel.prototype.send = function (envelope) {
        var _this = this;
        // if master off switch is set, don't send any data
        if (this._isDisabled()) {
            // Do not send/save data
            return;
        }
        // validate input
        if (!envelope) {
            Logging.warn("Cannot send null/undefined telemetry");
            return;
        }
        // check if the incoming payload is too large, truncate if necessary
        var payload = this._stringify(envelope);
        if (typeof payload !== "string") {
            return;
        }
        // enqueue the payload
        this._buffer.push(payload);
        // flush if we would exceed the max-size limit by adding this item
        if (this._buffer.length >= this._getBatchSize()) {
            this.triggerSend(false);
            return;
        }
        // ensure an invocation timeout is set if anything is in the buffer
        if (!this._timeoutHandle && this._buffer.length > 0) {
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = null;
                _this.triggerSend(false);
            }, this._getBatchIntervalMs());
        }
    };
    /**
     * Immediately send buffered data
     */
    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {
        var bufferIsEmpty = this._buffer.length < 1;
        if (!bufferIsEmpty) {
            // compose an array of payloads
            var batch = this._buffer.join("\n");
            // invoke send
            if (isNodeCrashing) {
                this._sender.saveOnCrash(batch);
                if (typeof callback === "function") {
                    callback("data saved on crash");
                }
            }
            else {
                this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);
            }
        }
        // update lastSend time to enable throttling
        this._lastSend = +new Date;
        // clear buffer
        this._buffer.length = 0;
        clearTimeout(this._timeoutHandle);
        this._timeoutHandle = null;
        if (bufferIsEmpty && typeof callback === "function") {
            callback("no data to send");
        }
    };
    Channel.prototype._stringify = function (envelope) {
        try {
            return JSON.stringify(envelope);
        }
        catch (error) {
            Logging.warn("Failed to serialize payload", error, envelope);
        }
    };
    return Channel;
}());
module.exports = Channel;
//# sourceMappingURL=Channel.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Config.js":
/*!********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Config.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var CorrelationIdManager = __webpack_require__(/*! ./CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
var ConnectionStringParser = __webpack_require__(/*! ./ConnectionStringParser */ "../../node_modules/applicationinsights/out/Library/ConnectionStringParser.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var url = __webpack_require__(/*! url */ "url");
var Config = (function () {
    function Config(setupString) {
        var _this = this;
        this.endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT;
        var connectionStringEnv = process.env[Config.ENV_connectionString];
        var csCode = ConnectionStringParser.parse(setupString);
        var csEnv = ConnectionStringParser.parse(connectionStringEnv);
        var iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0
            ? null // CS was valid but instrumentation key was not provided, null and grab from env var
            : setupString; // CS was invalid, so it must be an ikey
        this.instrumentationKey = csCode.instrumentationkey || iKeyCode /* === instrumentationKey */ || csEnv.instrumentationkey || Config._getInstrumentationKey();
        // validate ikey. If fails throw a warning
        if (!Config._validateInstrumentationKey(this.instrumentationKey)) {
            Logging.warn("An invalid instrumentation key was provided. There may be resulting telemetry loss", this.instrumentationKey);
        }
        this.endpointUrl = (csCode.ingestionendpoint || csEnv.ingestionendpoint || this.endpointBase) + "/v2/track";
        this.maxBatchSize = 250;
        this.maxBatchIntervalMs = 15000;
        this.disableAppInsights = false;
        this.samplingPercentage = 100;
        this.correlationIdRetryIntervalMs = 30 * 1000;
        this.correlationHeaderExcludedDomains = [
            "*.core.windows.net",
            "*.core.chinacloudapi.cn",
            "*.core.cloudapi.de",
            "*.core.usgovcloudapi.net",
            "*.core.microsoft.scloud",
            "*.core.eaglex.ic.gov"
        ];
        this.setCorrelationId = function (correlationId) { return _this.correlationId = correlationId; };
        this.proxyHttpUrl = process.env[Config.ENV_http_proxy] || undefined;
        this.proxyHttpsUrl = process.env[Config.ENV_https_proxy] || undefined;
        this.httpAgent = undefined;
        this.httpsAgent = undefined;
        this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config.ENV_profileQueryEndpoint] || this.endpointBase;
        this._quickPulseHost = csCode.liveendpoint || csEnv.liveendpoint || process.env[Config.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST;
        // Parse quickPulseHost if it starts with http(s)://
        if (this._quickPulseHost.match(/^https?:\/\//)) {
            this._quickPulseHost = url.parse(this._quickPulseHost).host;
        }
    }
    Object.defineProperty(Config.prototype, "profileQueryEndpoint", {
        get: function () {
            return this._profileQueryEndpoint;
        },
        set: function (endpoint) {
            CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);
            this._profileQueryEndpoint = endpoint;
            this.correlationId = CorrelationIdManager.correlationIdPrefix; // Reset the correlationId while we wait for the new query
            CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Config.prototype, "quickPulseHost", {
        get: function () {
            return this._quickPulseHost;
        },
        set: function (host) {
            this._quickPulseHost = host;
        },
        enumerable: true,
        configurable: true
    });
    Config._getInstrumentationKey = function () {
        // check for both the documented env variable and the azure-prefixed variable
        var iKey = process.env[Config.ENV_iKey]
            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]
            || process.env[Config.legacy_ENV_iKey]
            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];
        if (!iKey || iKey == "") {
            throw new Error("Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server");
        }
        return iKey;
    };
    /**
    * Validate UUID Format
    * Specs taken from breeze repo
    * The definition of a VALID instrumentation key is as follows:
    * Not none
    * Not empty
    * Every character is a hex character [0-9a-f]
    * 32 characters are separated into 5 sections via 4 dashes
    * First section has 8 characters
    * Second section has 4 characters
    * Third section has 4 characters
    * Fourth section has 4 characters
    * Fifth section has 12 characters
    */
    Config._validateInstrumentationKey = function (iKey) {
        var UUID_Regex = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$';
        var regexp = new RegExp(UUID_Regex);
        return regexp.test(iKey);
    };
    // Azure adds this prefix to all environment variables
    Config.ENV_azurePrefix = "APPSETTING_";
    // This key is provided in the readme
    Config.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY";
    Config.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY";
    Config.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT";
    Config.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST";
    // Azure Connection String
    Config.ENV_connectionString = "APPLICATIONINSIGHTS_CONNECTION_STRING";
    // Native Metrics Opt Outs
    Config.ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC";
    Config.ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS";
    Config.ENV_http_proxy = "http_proxy";
    Config.ENV_https_proxy = "https_proxy";
    return Config;
}());
module.exports = Config;
//# sourceMappingURL=Config.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/ConnectionStringParser.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/ConnectionStringParser.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var ConnectionStringParser = (function () {
    function ConnectionStringParser() {
    }
    ConnectionStringParser.parse = function (connectionString) {
        if (!connectionString) {
            return {};
        }
        var kvPairs = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR);
        var result = kvPairs.reduce(function (fields, kv) {
            var kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
                var key = kvParts[0].toLowerCase();
                var value = kvParts[1];
                fields[key] = value;
            }
            return fields;
        }, {});
        if (Object.keys(result).length > 0) {
            // this is a valid connection string, so parse the results
            if (result.endpointsuffix) {
                // use endpoint suffix where overrides are not provided
                var locationPrefix = result.location ? result.location + "." : "";
                result.ingestionendpoint = result.ingestionendpoint || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
                result.liveendpoint = result.liveendpoint || ("https://" + locationPrefix + "live." + result.endpointsuffix);
            }
            // apply the default endpoints
            result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;
        }
        return result;
    };
    ConnectionStringParser._FIELDS_SEPARATOR = ";";
    ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR = "=";
    return ConnectionStringParser;
}());
module.exports = ConnectionStringParser;
//# sourceMappingURL=ConnectionStringParser.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Context.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Context.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");
var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Context = (function () {
    function Context(packageJsonPath) {
        this.keys = new Contracts.ContextTagKeys();
        this.tags = {};
        this._loadApplicationContext(packageJsonPath);
        this._loadDeviceContext();
        this._loadInternalContext();
    }
    Context.prototype._loadApplicationContext = function (packageJsonPath) {
        // note: this should return the host package.json
        packageJsonPath = packageJsonPath || path.resolve(__dirname, "../../../../package.json");
        if (!Context.appVersion[packageJsonPath]) {
            Context.appVersion[packageJsonPath] = "unknown";
            try {
                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
                if (packageJson && typeof packageJson.version === "string") {
                    Context.appVersion[packageJsonPath] = packageJson.version;
                }
            }
            catch (exception) {
                Logging.info("unable to read app version: ", exception);
            }
        }
        this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];
    };
    Context.prototype._loadDeviceContext = function () {
        this.tags[this.keys.deviceId] = "";
        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();
        this.tags[this.keys.deviceOSVersion] = os && (os.type() + " " + os.release());
        this.tags[this.keys.cloudRole] = Context.DefaultRoleName;
        // not yet supported tags
        this.tags["ai.device.osArchitecture"] = os && os.arch();
        this.tags["ai.device.osPlatform"] = os && os.platform();
    };
    Context.prototype._loadInternalContext = function () {
        // note: this should return the sdk package.json
        var packageJsonPath = path.resolve(__dirname, "../../package.json");
        if (!Context.sdkVersion) {
            Context.sdkVersion = "unknown";
            try {
                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
                if (packageJson && typeof packageJson.version === "string") {
                    Context.sdkVersion = packageJson.version;
                }
            }
            catch (exception) {
                Logging.info("unable to read app version: ", exception);
            }
        }
        this.tags[this.keys.internalSdkVersion] = "node:" + Context.sdkVersion;
    };
    Context.DefaultRoleName = "Web";
    Context.appVersion = {};
    Context.sdkVersion = null;
    return Context;
}());
module.exports = Context;
//# sourceMappingURL=Context.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var CorrelationIdManager = (function () {
    function CorrelationIdManager() {
    }
    CorrelationIdManager.queryCorrelationId = function (config, callback) {
        // GET request to `${this.endpointBase}/api/profiles/${this.instrumentationKey}/appId`
        // If it 404s, the iKey is bad and we should give up
        // If it fails otherwise, try again later
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        if (CorrelationIdManager.completedLookups.hasOwnProperty(appIdUrlString)) {
            callback(CorrelationIdManager.completedLookups[appIdUrlString]);
            return;
        }
        else if (CorrelationIdManager.pendingLookups[appIdUrlString]) {
            CorrelationIdManager.pendingLookups[appIdUrlString].push(callback);
            return;
        }
        CorrelationIdManager.pendingLookups[appIdUrlString] = [callback];
        var fetchAppId = function () {
            if (!CorrelationIdManager.pendingLookups[appIdUrlString]) {
                // This query has been cancelled.
                return;
            }
            var requestOptions = {
                method: 'GET',
                // Ensure this request is not captured by auto-collection.
                // Note: we don't refer to the property in HttpDependencyParser because that would cause a cyclical dependency
                disableAppInsightsAutoCollection: true
            };
            Logging.info(CorrelationIdManager.TAG, requestOptions);
            var req = Util.makeRequest(config, appIdUrlString, requestOptions, function (res) {
                if (res.statusCode === 200) {
                    // Success; extract the appId from the body
                    var appId_1 = "";
                    res.setEncoding("utf-8");
                    res.on('data', function (data) {
                        appId_1 += data;
                    });
                    res.on('end', function () {
                        Logging.info(CorrelationIdManager.TAG, appId_1);
                        var result = CorrelationIdManager.correlationIdPrefix + appId_1;
                        CorrelationIdManager.completedLookups[appIdUrlString] = result;
                        if (CorrelationIdManager.pendingLookups[appIdUrlString]) {
                            CorrelationIdManager.pendingLookups[appIdUrlString].forEach(function (cb) { return cb(result); });
                        }
                        delete CorrelationIdManager.pendingLookups[appIdUrlString];
                    });
                }
                else if (res.statusCode >= 400 && res.statusCode < 500) {
                    // Not found, probably a bad key. Do not try again.
                    CorrelationIdManager.completedLookups[appIdUrlString] = undefined;
                    delete CorrelationIdManager.pendingLookups[appIdUrlString];
                }
                else {
                    // Retry after timeout.
                    setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);
                }
            });
            if (req) {
                req.on('error', function (error) {
                    // Unable to contact endpoint.
                    // Do nothing for now.
                    Logging.warn(CorrelationIdManager.TAG, error);
                });
                req.end();
            }
        };
        setTimeout(fetchAppId, 0);
    };
    CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        var pendingLookups = CorrelationIdManager.pendingLookups[appIdUrlString];
        if (pendingLookups) {
            CorrelationIdManager.pendingLookups[appIdUrlString] = pendingLookups.filter(function (cb) { return cb != callback; });
            if (CorrelationIdManager.pendingLookups[appIdUrlString].length == 0) {
                delete CorrelationIdManager.pendingLookups[appIdUrlString];
            }
        }
    };
    /**
     * Generate a request Id according to https://github.com/lmolkova/correlation/blob/master/hierarchical_request_id.md
     * @param parentId
     */
    CorrelationIdManager.generateRequestId = function (parentId) {
        if (parentId) {
            parentId = parentId[0] == '|' ? parentId : '|' + parentId;
            if (parentId[parentId.length - 1] !== '.') {
                parentId += '.';
            }
            var suffix = (CorrelationIdManager.currentRootId++).toString(16);
            return CorrelationIdManager.appendSuffix(parentId, suffix, '_');
        }
        else {
            return CorrelationIdManager.generateRootId();
        }
    };
    /**
     * Given a hierarchical identifier of the form |X.*
     * return the root identifier X
     * @param id
     */
    CorrelationIdManager.getRootId = function (id) {
        var endIndex = id.indexOf('.');
        if (endIndex < 0) {
            endIndex = id.length;
        }
        var startIndex = id[0] === '|' ? 1 : 0;
        return id.substring(startIndex, endIndex);
    };
    CorrelationIdManager.generateRootId = function () {
        return '|' + Util.w3cTraceId() + '.';
    };
    CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {
        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) {
            return parentId + suffix + delimiter;
        }
        // Combined identifier would be too long, so we must truncate it.
        // We need 9 characters of space: 8 for the overflow ID, 1 for the
        // overflow delimiter '#'
        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;
        if (parentId.length > trimPosition) {
            for (; trimPosition > 1; --trimPosition) {
                var c = parentId[trimPosition - 1];
                if (c === '.' || c === '_') {
                    break;
                }
            }
        }
        if (trimPosition <= 1) {
            // parentId is not a valid ID
            return CorrelationIdManager.generateRootId();
        }
        suffix = Util.randomu32().toString(16);
        while (suffix.length < 8) {
            suffix = '0' + suffix;
        }
        return parentId.substring(0, trimPosition) + suffix + '#';
    };
    CorrelationIdManager.TAG = "CorrelationIdManager";
    CorrelationIdManager.correlationIdPrefix = "cid-v1:";
    CorrelationIdManager.w3cEnabled = true;
    // To avoid extraneous HTTP requests, we maintain a queue of callbacks waiting on a particular appId lookup,
    // as well as a cache of completed lookups so future requests can be resolved immediately.
    CorrelationIdManager.pendingLookups = {};
    CorrelationIdManager.completedLookups = {};
    CorrelationIdManager.requestIdMaxLength = 1024;
    CorrelationIdManager.currentRootId = Util.randomu32();
    return CorrelationIdManager;
}());
module.exports = CorrelationIdManager;
//# sourceMappingURL=CorrelationIdManager.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/EnvelopeFactory.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/EnvelopeFactory.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var CorrelationContextManager_1 = __webpack_require__(/*! ../AutoCollection/CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js");
/**
 * Manages the logic of creating envelopes from Telemetry objects
 */
var EnvelopeFactory = (function () {
    function EnvelopeFactory() {
    }
    /**
     * Creates envelope ready to be sent by Channel
     * @param telemetry Telemetry data
     * @param telemetryType Type of telemetry
     * @param commonProperties Bag of custom common properties to be added to the envelope
     * @param context Client context
     * @param config Client configuration
     */
    EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {
        var data = null;
        switch (telemetryType) {
            case Contracts.TelemetryType.Trace:
                data = EnvelopeFactory.createTraceData(telemetry);
                break;
            case Contracts.TelemetryType.Dependency:
                data = EnvelopeFactory.createDependencyData(telemetry);
                break;
            case Contracts.TelemetryType.Event:
                data = EnvelopeFactory.createEventData(telemetry);
                break;
            case Contracts.TelemetryType.Exception:
                data = EnvelopeFactory.createExceptionData(telemetry);
                break;
            case Contracts.TelemetryType.Request:
                data = EnvelopeFactory.createRequestData(telemetry);
                break;
            case Contracts.TelemetryType.Metric:
                data = EnvelopeFactory.createMetricData(telemetry);
                break;
            case Contracts.TelemetryType.Availability:
                data = EnvelopeFactory.createAvailabilityData(telemetry);
                break;
            case Contracts.TelemetryType.PageView:
                data = EnvelopeFactory.createPageViewData(telemetry);
                break;
        }
        if (commonProperties && Contracts.domainSupportsProperties(data.baseData)) {
            if (data && data.baseData) {
                // if no properties are specified just add the common ones
                if (!data.baseData.properties) {
                    data.baseData.properties = commonProperties;
                }
                else {
                    // otherwise, check each of the common ones
                    for (var name in commonProperties) {
                        // only override if the property `name` has not been set on this item
                        if (!data.baseData.properties[name]) {
                            data.baseData.properties[name] = commonProperties[name];
                        }
                    }
                }
            }
            // sanitize properties
            data.baseData.properties = Util.validateStringMap(data.baseData.properties);
        }
        var iKey = config ? config.instrumentationKey || "" : "";
        var envelope = new Contracts.Envelope();
        envelope.data = data;
        envelope.iKey = iKey;
        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars "data"
        envelope.name =
            "Microsoft.ApplicationInsights." +
                iKey.replace(/-/g, "") +
                "." +
                data.baseType.substr(0, data.baseType.length - 4);
        envelope.tags = this.getTags(context, telemetry.tagOverrides);
        envelope.time = (new Date()).toISOString();
        envelope.ver = 1;
        envelope.sampleRate = config ? config.samplingPercentage : 100;
        // Exclude metrics from sampling by default
        if (telemetryType === Contracts.TelemetryType.Metric) {
            envelope.sampleRate = 100;
        }
        return envelope;
    };
    EnvelopeFactory.createTraceData = function (telemetry) {
        var trace = new Contracts.MessageData();
        trace.message = telemetry.message;
        trace.properties = telemetry.properties;
        if (!isNaN(telemetry.severity)) {
            trace.severityLevel = telemetry.severity;
        }
        else {
            trace.severityLevel = Contracts.SeverityLevel.Information;
        }
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);
        data.baseData = trace;
        return data;
    };
    EnvelopeFactory.createDependencyData = function (telemetry) {
        var remoteDependency = new Contracts.RemoteDependencyData();
        if (typeof telemetry.name === "string") {
            remoteDependency.name = telemetry.name.length > 1024 ? telemetry.name.slice(0, 1021) + '...' : telemetry.name;
        }
        remoteDependency.data = telemetry.data;
        remoteDependency.target = telemetry.target;
        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);
        remoteDependency.success = telemetry.success;
        remoteDependency.type = telemetry.dependencyTypeName;
        remoteDependency.properties = telemetry.properties;
        remoteDependency.resultCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');
        if (telemetry.id) {
            remoteDependency.id = telemetry.id;
        }
        else {
            remoteDependency.id = Util.w3cTraceId();
        }
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);
        data.baseData = remoteDependency;
        return data;
    };
    EnvelopeFactory.createEventData = function (telemetry) {
        var event = new Contracts.EventData();
        event.name = telemetry.name;
        event.properties = telemetry.properties;
        event.measurements = telemetry.measurements;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);
        data.baseData = event;
        return data;
    };
    EnvelopeFactory.createExceptionData = function (telemetry) {
        var exception = new Contracts.ExceptionData();
        exception.properties = telemetry.properties;
        if (!isNaN(telemetry.severity)) {
            exception.severityLevel = telemetry.severity;
        }
        else {
            exception.severityLevel = Contracts.SeverityLevel.Error;
        }
        exception.measurements = telemetry.measurements;
        exception.exceptions = [];
        var stack = telemetry.exception["stack"];
        var exceptionDetails = new Contracts.ExceptionDetails();
        exceptionDetails.message = telemetry.exception.message;
        exceptionDetails.typeName = telemetry.exception.name;
        exceptionDetails.parsedStack = this.parseStack(stack);
        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;
        exception.exceptions.push(exceptionDetails);
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);
        data.baseData = exception;
        return data;
    };
    EnvelopeFactory.createRequestData = function (telemetry) {
        var requestData = new Contracts.RequestData();
        if (telemetry.id) {
            requestData.id = telemetry.id;
        }
        else {
            requestData.id = Util.w3cTraceId();
        }
        requestData.name = telemetry.name;
        requestData.url = telemetry.url;
        requestData.source = telemetry.source;
        requestData.duration = Util.msToTimeSpan(telemetry.duration);
        requestData.responseCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');
        requestData.success = telemetry.success;
        requestData.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);
        data.baseData = requestData;
        return data;
    };
    EnvelopeFactory.createMetricData = function (telemetry) {
        var metrics = new Contracts.MetricData(); // todo: enable client-batching of these
        metrics.metrics = [];
        var metric = new Contracts.DataPoint();
        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;
        metric.kind = Contracts.DataPointType.Aggregation;
        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;
        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;
        metric.name = telemetry.name;
        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;
        metric.value = telemetry.value;
        metrics.metrics.push(metric);
        metrics.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);
        data.baseData = metrics;
        return data;
    };
    EnvelopeFactory.createAvailabilityData = function (telemetry) {
        var availabilityData = new Contracts.AvailabilityData();
        if (telemetry.id) {
            availabilityData.id = telemetry.id;
        }
        else {
            availabilityData.id = Util.w3cTraceId();
        }
        availabilityData.name = telemetry.name;
        availabilityData.duration = Util.msToTimeSpan(telemetry.duration);
        availabilityData.success = telemetry.success;
        availabilityData.runLocation = telemetry.runLocation;
        availabilityData.message = telemetry.message;
        availabilityData.measurements = telemetry.measurements;
        availabilityData.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability);
        data.baseData = availabilityData;
        return data;
    };
    EnvelopeFactory.createPageViewData = function (telemetry) {
        var pageViewData = new Contracts.PageViewData();
        pageViewData.name = telemetry.name;
        pageViewData.duration = Util.msToTimeSpan(telemetry.duration);
        pageViewData.url = telemetry.url;
        pageViewData.measurements = telemetry.measurements;
        pageViewData.properties = telemetry.properties;
        var data = new Contracts.Data();
        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.PageView);
        data.baseData = pageViewData;
        return data;
    };
    EnvelopeFactory.getTags = function (context, tagOverrides) {
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        // Make a copy of context tags so we don't alter the actual object
        // Also perform tag overriding
        var newTags = {};
        if (context && context.tags) {
            for (var key in context.tags) {
                newTags[key] = context.tags[key];
            }
        }
        if (tagOverrides) {
            for (var key in tagOverrides) {
                newTags[key] = tagOverrides[key];
            }
        }
        // Fill in internally-populated values if not already set
        if (correlationContext) {
            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;
            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;
            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;
        }
        return newTags;
    };
    EnvelopeFactory.parseStack = function (stack) {
        var parsedStack = undefined;
        if (typeof stack === "string") {
            var frames = stack.split("\n");
            parsedStack = [];
            var level = 0;
            var totalSizeInBytes = 0;
            for (var i = 0; i <= frames.length; i++) {
                var frame = frames[i];
                if (_StackFrame.regex.test(frame)) {
                    var parsedFrame = new _StackFrame(frames[i], level++);
                    totalSizeInBytes += parsedFrame.sizeInBytes;
                    parsedStack.push(parsedFrame);
                }
            }
            // DP Constraint - exception parsed stack must be < 32KB
            // remove frames from the middle to meet the threshold
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes > exceptionParsedStackThreshold) {
                var left = 0;
                var right = parsedStack.length - 1;
                var size = 0;
                var acceptedLeft = left;
                var acceptedRight = right;
                while (left < right) {
                    // check size
                    var lSize = parsedStack[left].sizeInBytes;
                    var rSize = parsedStack[right].sizeInBytes;
                    size += lSize + rSize;
                    if (size > exceptionParsedStackThreshold) {
                        // remove extra frames from the middle
                        var howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }
                    // update pointers
                    acceptedLeft = left;
                    acceptedRight = right;
                    left++;
                    right--;
                }
            }
        }
        return parsedStack;
    };
    return EnvelopeFactory;
}());
var _StackFrame = (function () {
    function _StackFrame(frame, level) {
        this.sizeInBytes = 0;
        this.level = level;
        this.method = "<no_method>";
        this.assembly = Util.trim(frame);
        var matches = frame.match(_StackFrame.regex);
        if (matches && matches.length >= 5) {
            this.method = Util.trim(matches[2]) || this.method;
            this.fileName = Util.trim(matches[4]) || "<no_filename>";
            this.line = parseInt(matches[5]) || 0;
        }
        this.sizeInBytes += this.method.length;
        this.sizeInBytes += this.fileName.length;
        this.sizeInBytes += this.assembly.length;
        // todo: these might need to be removed depending on how the back-end settles on their size calculation
        this.sizeInBytes += _StackFrame.baseSize;
        this.sizeInBytes += this.level.toString().length;
        this.sizeInBytes += this.line.toString().length;
    }
    // regex to match stack frames from ie/chrome/ff
    // methodName=$2, fileName=$4, lineNo=$5, column=$6
    _StackFrame.regex = /^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/;
    _StackFrame.baseSize = 58; //'{"method":"","level":,"assembly":"","fileName":"","line":}'.length
    return _StackFrame;
}());
module.exports = EnvelopeFactory;
//# sourceMappingURL=EnvelopeFactory.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Functions.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Functions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=Functions.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Logging.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Logging.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

var Logging = (function () {
    function Logging() {
    }
    Logging.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (Logging.enableDebug) {
            console.info(Logging.TAG + message, optionalParams);
        }
    };
    Logging.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!Logging.disableWarnings) {
            console.warn(Logging.TAG + message, optionalParams);
        }
    };
    Logging.enableDebug = false;
    Logging.disableWarnings = false;
    Logging.disableErrors = false;
    Logging.TAG = "ApplicationInsights:";
    return Logging;
}());
module.exports = Logging;
//# sourceMappingURL=Logging.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/NodeClient.js":
/*!************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/NodeClient.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TelemetryClient = __webpack_require__(/*! ./TelemetryClient */ "../../node_modules/applicationinsights/out/Library/TelemetryClient.js");
var ServerRequestTracking = __webpack_require__(/*! ../AutoCollection/HttpRequests */ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js");
var ClientRequestTracking = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
/**
 * Application Insights Telemetry Client for Node.JS. Provides the Application Insights TelemetryClient API
 * in addition to Node-specific helper functions.
 * Construct a new TelemetryClient to have an instance with a different configuration than the default client.
 * In most cases, `appInsights.defaultClient` should be used instead.
 */
var NodeClient = (function (_super) {
    __extends(NodeClient, _super);
    function NodeClient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Log RequestTelemetry from HTTP request and response. This method will log immediately without waiting for request completion
     * and it requires duration parameter to be specified on NodeHttpRequestTelemetry object.
     * Use trackNodeHttpRequest function to log the telemetry after request completion
     * @param telemetry Object encapsulating incoming request, response and duration information
     */
    NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {
        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {
            ServerRequestTracking.trackRequestSync(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
        }
    };
    /**
     * Log RequestTelemetry from HTTP request and response. This method will `follow` the request to completion.
     * Use trackNodeHttpRequestSync function to log telemetry immediately without waiting for request completion
     * @param telemetry Object encapsulating incoming request and response information
     */
    NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {
        if (telemetry.duration || telemetry.error) {
            Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.");
        }
        if (telemetry && telemetry.request && telemetry.response) {
            ServerRequestTracking.trackRequest(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
        }
    };
    /**
     * Log DependencyTelemetry from outgoing HTTP request. This method will instrument the outgoing request and append
     * the specified headers and will log the telemetry when outgoing request is complete
     * @param telemetry Object encapsulating outgoing request information
     */
    NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {
        if (telemetry && telemetry.request) {
            ClientRequestTracking.trackRequest(this, telemetry);
        }
        else {
            Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
        }
    };
    return NodeClient;
}(TelemetryClient));
module.exports = NodeClient;
//# sourceMappingURL=NodeClient.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var os = __webpack_require__(/*! os */ "os");
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var StreamId = Util.w3cTraceId(); // Create a guid
var QuickPulseEnvelopeFactory = (function () {
    function QuickPulseEnvelopeFactory() {
    }
    QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function (metrics, documents, config, context) {
        var machineName = (os && typeof os.hostname === "function"
            && os.hostname()) || "Unknown"; // Note: os.hostname() was added in node v0.3.3
        var instance = (context.tags
            && context.keys
            && context.keys.cloudRoleInstance
            && context.tags[context.keys.cloudRoleInstance]) || machineName;
        var envelope = {
            Documents: documents.length > 0 ? documents : null,
            InstrumentationKey: config.instrumentationKey || "",
            Metrics: metrics.length > 0 ? metrics : null,
            InvariantVersion: 1,
            Timestamp: "/Date(" + Date.now() + ")/",
            Version: context.tags[context.keys.internalSdkVersion],
            StreamId: StreamId,
            MachineName: machineName,
            Instance: instance
        };
        return envelope;
    };
    QuickPulseEnvelopeFactory.createQuickPulseMetric = function (telemetry) {
        var data;
        data = {
            Name: telemetry.name,
            Value: telemetry.value,
            Weight: telemetry.count || 1
        };
        return data;
    };
    QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function (envelope) {
        switch (envelope.data.baseType) {
            case Contracts.TelemetryTypeString.Event:
                return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);
            case Contracts.TelemetryTypeString.Exception:
                return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);
            case Contracts.TelemetryTypeString.Trace:
                return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);
            case Contracts.TelemetryTypeString.Dependency:
                return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);
            case Contracts.TelemetryTypeString.Request:
                return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);
        }
        return null;
    };
    QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var name = envelope.data.baseData.name;
        var eventDocument = __assign({}, document, { Name: name });
        return eventDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var severityLevel = envelope.data.baseData.severityLevel || 0;
        var traceDocument = __assign({}, document, { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });
        return traceDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var exceptionDetails = envelope.data.baseData.exceptions;
        var exception = '';
        var exceptionMessage = '';
        var exceptionType = '';
        // Try to fill exception information from first error only
        if (exceptionDetails && exceptionDetails.length > 0) {
            // Try to grab the stack from parsedStack or stack
            if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {
                exceptionDetails[0].parsedStack.forEach(function (err) {
                    exception += err.assembly + "\n";
                });
            }
            else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {
                exception = exceptionDetails[0].stack;
            }
            exceptionMessage = exceptionDetails[0].message;
            exceptionType = exceptionDetails[0].typeName;
        }
        var exceptionDocument = __assign({}, document, { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });
        return exceptionDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var requestDocument = __assign({}, document, { Name: baseData.name, Success: baseData.success, Duration: baseData.duration, ResponseCode: baseData.responseCode, OperationName: baseData.name // TODO: is this correct?
         });
        return requestDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var dependencyDocument = __assign({}, document, { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document.OperationId, DependencyTypeName: baseData.type });
        return dependencyDocument;
    };
    QuickPulseEnvelopeFactory.createQuickPulseDocument = function (envelope) {
        var documentType;
        var __type;
        var operationId, properties;
        if (envelope.data.baseType) {
            __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];
            documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];
        }
        else {
            // Remark: This should never be hit because createQuickPulseDocument is only called within
            // valid baseType values
            Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType);
        }
        operationId = envelope.tags[QuickPulseEnvelopeFactory.keys.operationId];
        properties = QuickPulseEnvelopeFactory.aggregateProperties(envelope);
        var document = {
            DocumentType: documentType,
            __type: __type,
            OperationId: operationId,
            Version: "1.0",
            Properties: properties
        };
        return document;
    };
    QuickPulseEnvelopeFactory.aggregateProperties = function (envelope) {
        var properties = [];
        // Collect measurements
        var meas = (envelope.data.baseData).measurements || {};
        for (var key in meas) {
            if (meas.hasOwnProperty(key)) {
                var value = meas[key];
                var property = { key: key, value: value };
                properties.push(property);
            }
        }
        // Collect properties
        var props = (envelope.data.baseData).properties || {};
        for (var key in props) {
            if (props.hasOwnProperty(key)) {
                var value = props[key];
                var property = { key: key, value: value };
                properties.push(property);
            }
        }
        return properties;
    };
    QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys();
    return QuickPulseEnvelopeFactory;
}());
module.exports = QuickPulseEnvelopeFactory;
//# sourceMappingURL=QuickPulseEnvelopeFactory.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/QuickPulseSender.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/QuickPulseSender.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var https = __webpack_require__(/*! https */ "https");
var AutoCollectHttpDependencies = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var QuickPulseUtil = __webpack_require__(/*! ./QuickPulseUtil */ "../../node_modules/applicationinsights/out/Library/QuickPulseUtil.js");
var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var QuickPulseConfig = {
    method: "POST",
    time: "x-ms-qps-transmission-time",
    subscribed: "x-ms-qps-subscribed"
};
var QuickPulseSender = (function () {
    function QuickPulseSender(config) {
        this._config = config;
        this._consecutiveErrors = 0;
    }
    QuickPulseSender.prototype.ping = function (envelope, done) {
        this._submitData(envelope, done, "ping");
    };
    QuickPulseSender.prototype.post = function (envelope, done) {
        // Important: When POSTing data, envelope must be an array
        this._submitData([envelope], done, "post");
    };
    QuickPulseSender.prototype._submitData = function (envelope, done, postOrPing) {
        var _this = this;
        var payload = JSON.stringify(envelope);
        var options = (_a = {},
            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,
            _a.host = this._config.quickPulseHost,
            _a.method = QuickPulseConfig.method,
            _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey,
            _a.headers = (_b = {
                    'Expect': '100-continue'
                },
                _b[QuickPulseConfig.time] = QuickPulseUtil.getTransmissionTime(),
                _b['Content-Type'] = 'application\/json',
                _b['Content-Length'] = Buffer.byteLength(payload),
                _b),
            _a);
        // HTTPS only
        if (this._config.httpsAgent) {
            options.agent = this._config.httpsAgent;
        }
        else {
            options.agent = Util.tlsRestrictedAgent;
        }
        var req = https.request(options, function (res) {
            var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true";
            _this._consecutiveErrors = 0;
            done(shouldPOSTData, res);
        });
        req.on("error", function (error) {
            // Unable to contact qps endpoint.
            // Do nothing for now.
            _this._consecutiveErrors++;
            // LOG every error, but WARN instead when X number of consecutive errors occur
            var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
            if (_this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN === 0) {
                notice = "Live Metrics endpoint could not be reached " + _this._consecutiveErrors + " consecutive times. Most recent error:";
                Logging.warn(QuickPulseSender.TAG, notice, error);
            }
            else {
                // Potentially transient error, do not change the ping/post state yet.
                Logging.info(QuickPulseSender.TAG, notice, error);
            }
            done();
        });
        req.write(payload);
        req.end();
        var _a, _b;
    };
    QuickPulseSender.TAG = "QuickPulseSender";
    QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25;
    return QuickPulseSender;
}());
module.exports = QuickPulseSender;
//# sourceMappingURL=QuickPulseSender.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/QuickPulseStateManager.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/QuickPulseStateManager.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var Config = __webpack_require__(/*! ./Config */ "../../node_modules/applicationinsights/out/Library/Config.js");
var QuickPulseEnvelopeFactory = __webpack_require__(/*! ./QuickPulseEnvelopeFactory */ "../../node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js");
var QuickPulseSender = __webpack_require__(/*! ./QuickPulseSender */ "../../node_modules/applicationinsights/out/Library/QuickPulseSender.js");
var Constants = __webpack_require__(/*! ../Declarations/Constants */ "../../node_modules/applicationinsights/out/Declarations/Constants.js");
var Context = __webpack_require__(/*! ./Context */ "../../node_modules/applicationinsights/out/Library/Context.js");
/** State Container for sending to the QuickPulse Service */
var QuickPulseStateManager = (function () {
    function QuickPulseStateManager(iKey, context) {
        this._isCollectingData = false;
        this._lastSuccessTime = Date.now();
        this._lastSendSucceeded = true;
        this._metrics = {};
        this._documents = [];
        this._collectors = [];
        this.config = new Config(iKey);
        this.context = context || new Context();
        this._sender = new QuickPulseSender(this.config);
        this._isEnabled = false;
    }
    /**
     *
     * @param collector
     */
    QuickPulseStateManager.prototype.addCollector = function (collector) {
        this._collectors.push(collector);
    };
    /**
     * Override of TelemetryClient.trackMetric
     */
    QuickPulseStateManager.prototype.trackMetric = function (telemetry) {
        this._addMetric(telemetry);
    };
    /**
     * Add a document to the current buffer
     * @param envelope
     */
    QuickPulseStateManager.prototype.addDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
        if (document) {
            this._documents.push(document);
        }
    };
    /**
     * Enable or disable communication with QuickPulseService
     * @param isEnabled
     */
    QuickPulseStateManager.prototype.enable = function (isEnabled) {
        if (isEnabled && !this._isEnabled) {
            this._isEnabled = true;
            this._goQuickPulse();
        }
        else if (!isEnabled && this._isEnabled) {
            this._isEnabled = false;
            clearTimeout(this._handle);
            this._handle = undefined;
        }
    };
    /**
     * Enable or disable all collectors in this instance
     * @param enable
     */
    QuickPulseStateManager.prototype.enableCollectors = function (enable) {
        this._collectors.forEach(function (collector) {
            collector.enable(enable);
        });
    };
    /**
     * Add the metric to this buffer. If same metric already exists in this buffer, add weight to it
     * @param telemetry
     */
    QuickPulseStateManager.prototype._addMetric = function (telemetry) {
        var value = telemetry.value;
        var count = telemetry.count || 1;
        var name = Constants.PerformanceToQuickPulseCounter[telemetry.name];
        if (name) {
            if (this._metrics[name]) {
                this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count);
                this._metrics[name].Weight += count;
            }
            else {
                this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);
                this._metrics[name].Name = name;
                this._metrics[name].Weight = 1;
            }
        }
    };
    QuickPulseStateManager.prototype._resetQuickPulseBuffer = function () {
        delete this._metrics;
        this._metrics = {};
        this._documents.length = 0;
    };
    QuickPulseStateManager.prototype._goQuickPulse = function () {
        var _this = this;
        // Create envelope from Documents and Metrics
        var metrics = Object.keys(this._metrics).map(function (k) { return _this._metrics[k]; });
        var envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);
        // Clear this document, metric buffer
        this._resetQuickPulseBuffer();
        // Send it to QuickPulseService, if collecting
        if (this._isCollectingData) {
            this._post(envelope);
        }
        else {
            this._ping(envelope);
        }
        var currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : QuickPulseStateManager.PING_INTERVAL;
        if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {
            // Haven't posted successfully in 20 seconds, so wait 60 seconds and ping
            this._isCollectingData = false;
            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;
        }
        else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {
            // Haven't pinged successfully in 60 seconds, so wait another 60 seconds
            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;
        }
        this._lastSendSucceeded = null;
        this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);
        this._handle.unref(); // Don't block apps from terminating
    };
    QuickPulseStateManager.prototype._ping = function (envelope) {
        this._sender.ping(envelope, this._quickPulseDone.bind(this));
    };
    QuickPulseStateManager.prototype._post = function (envelope) {
        this._sender.post(envelope, this._quickPulseDone.bind(this));
    };
    /**
     * Change the current QPS send state. (shouldPOST == undefined) --> error, but do not change the state yet.
     */
    QuickPulseStateManager.prototype._quickPulseDone = function (shouldPOST, res) {
        if (shouldPOST != undefined) {
            if (this._isCollectingData !== shouldPOST) {
                Logging.info("Live Metrics sending data", shouldPOST);
                this.enableCollectors(shouldPOST);
            }
            this._isCollectingData = shouldPOST;
            if (res && res.statusCode < 300 && res.statusCode >= 200) {
                this._lastSuccessTime = Date.now();
                this._lastSendSucceeded = true;
            }
            else {
                this._lastSendSucceeded = false;
            }
        }
        else {
            // Received an error, keep the state as is
            this._lastSendSucceeded = false;
        }
    };
    QuickPulseStateManager.MAX_POST_WAIT_TIME = 20000;
    QuickPulseStateManager.MAX_PING_WAIT_TIME = 60000;
    QuickPulseStateManager.FALLBACK_INTERVAL = 60000;
    QuickPulseStateManager.PING_INTERVAL = 5000;
    QuickPulseStateManager.POST_INTERVAL = 1000;
    return QuickPulseStateManager;
}());
module.exports = QuickPulseStateManager;
//# sourceMappingURL=QuickPulseStateManager.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/QuickPulseUtil.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/QuickPulseUtil.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";

/**
 * @description UTC time the request was made. Expressed as the number of 100-nanosecond intervals that have elapsed since 12:00:00 midnight on January 1, 0001. This is used for clock skew calculations, so the value can never be stale (cached).
 *
 * @example
 * 8/5/2020 10:15:00 PM UTC => 637322625000000000
 * 8/5/2020 10:15:01 PM UTC => 637322625010000000
 *
 * @returns {number}
 */
var getTransmissionTime = function () {
    return (Date.now() + 62135596800000) * 10000;
};
module.exports = { getTransmissionTime: getTransmissionTime };
//# sourceMappingURL=QuickPulseUtil.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";

module.exports = {
    /**
     * Request-Context header
     */
    requestContextHeader: "request-context",
    /**
     * Source instrumentation header that is added by an application while making http
     * requests and retrieved by the other application when processing incoming requests.
     */
    requestContextSourceKey: "appId",
    /**
     * Target instrumentation header that is added to the response and retrieved by the
     * calling application when processing incoming responses.
     */
    requestContextTargetKey: "appId",
    /**
     * Request-Id header
     */
    requestIdHeader: "request-id",
    /**
     * Legacy Header containing the id of the immediate caller
     */
    parentIdHeader: "x-ms-request-id",
    /**
     * Legacy Header containing the correlation id that kept the same for every telemetry item
     * across transactions
     */
    rootIdHeader: "x-ms-request-root-id",
    /**
     * Correlation-Context header
     *
     * Not currently actively used, but the contents should be passed from incoming to outgoing requests
     */
    correlationContextHeader: "correlation-context",
    /**
     * W3C distributed tracing protocol header
     */
    traceparentHeader: "traceparent",
    /**
     * W3C distributed tracing protocol state header
     */
    traceStateHeader: "tracestate"
};
//# sourceMappingURL=RequestResponseHeaders.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Sender.js":
/*!********************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Sender.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fs = __webpack_require__(/*! fs */ "fs");
var os = __webpack_require__(/*! os */ "os");
var path = __webpack_require__(/*! path */ "path");
var zlib = __webpack_require__(/*! zlib */ "zlib");
var child_process = __webpack_require__(/*! child_process */ "child_process");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var AutoCollectHttpDependencies = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js");
var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var Sender = (function () {
    function Sender(config, onSuccess, onError) {
        this._config = config;
        this._onSuccess = onSuccess;
        this._onError = onError;
        this._enableDiskRetryMode = false;
        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;
        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;
        this._numConsecutiveFailures = 0;
        this._resendTimer = null;
        if (!Sender.OS_PROVIDES_FILE_PROTECTION) {
            // Node's chmod levels do not appropriately restrict file access on Windows
            // Use the built-in command line tool ICACLS on Windows to properly restrict
            // access to the temporary directory used for disk retry mode.
            if (Sender.USE_ICACLS) {
                // This should be async - but it's currently safer to have this synchronous
                // This guarantees we can immediately fail setDiskRetryMode if we need to
                try {
                    Sender.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(Sender.ICACLS_PATH);
                }
                catch (e) { }
                if (!Sender.OS_PROVIDES_FILE_PROTECTION) {
                    Logging.warn(Sender.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
                }
            }
            else {
                // chmod works everywhere else
                Sender.OS_PROVIDES_FILE_PROTECTION = true;
            }
        }
    }
    /**
    * Enable or disable offline mode
    */
    Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {
        this._enableDiskRetryMode = Sender.OS_PROVIDES_FILE_PROTECTION && value;
        if (typeof resendInterval === 'number' && resendInterval >= 0) {
            this._resendInterval = Math.floor(resendInterval);
        }
        if (typeof maxBytesOnDisk === 'number' && maxBytesOnDisk >= 0) {
            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);
        }
        if (value && !Sender.OS_PROVIDES_FILE_PROTECTION) {
            this._enableDiskRetryMode = false;
            Logging.warn(Sender.TAG, "Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.");
        }
    };
    Sender.prototype.send = function (payload, callback) {
        var _this = this;
        var endpointUrl = this._config.endpointUrl;
        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent
        var options = {
            method: "POST",
            withCredentials: false,
            headers: {
                "Content-Type": "application/x-json-stream"
            }
        };
        zlib.gzip(payload, function (err, buffer) {
            var dataToSend = buffer;
            if (err) {
                Logging.warn(err);
                dataToSend = payload; // something went wrong so send without gzip
                options.headers["Content-Length"] = payload.length.toString();
            }
            else {
                options.headers["Content-Encoding"] = "gzip";
                options.headers["Content-Length"] = buffer.length;
            }
            Logging.info(Sender.TAG, options);
            // Ensure this request is not captured by auto-collection.
            options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;
            var requestCallback = function (res) {
                res.setEncoding("utf-8");
                //returns empty if the data is accepted
                var responseString = "";
                res.on("data", function (data) {
                    responseString += data;
                });
                res.on("end", function () {
                    _this._numConsecutiveFailures = 0;
                    Logging.info(Sender.TAG, responseString);
                    if (typeof _this._onSuccess === "function") {
                        _this._onSuccess(responseString);
                    }
                    if (typeof callback === "function") {
                        callback(responseString);
                    }
                    if (_this._enableDiskRetryMode) {
                        // try to send any cached events if the user is back online
                        if (res.statusCode === 200) {
                            if (!_this._resendTimer) {
                                _this._resendTimer = setTimeout(function () {
                                    _this._resendTimer = null;
                                    _this._sendFirstFileOnDisk();
                                }, _this._resendInterval);
                                _this._resendTimer.unref();
                            }
                            // store to disk in case of burst throttling
                        }
                        else if (res.statusCode === 408 ||
                            res.statusCode === 429 ||
                            res.statusCode === 439 ||
                            res.statusCode === 500 ||
                            res.statusCode === 503) {
                            // TODO: Do not support partial success (206) until _sendFirstFileOnDisk checks payload age
                            _this._storeToDisk(payload);
                        }
                    }
                });
            };
            var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);
            req.on("error", function (error) {
                // todo: handle error codes better (group to recoverable/non-recoverable and persist)
                _this._numConsecutiveFailures++;
                // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data
                // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors
                // Continue informing on each failure if verbose logging is being used
                if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {
                    var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
                    if (_this._enableDiskRetryMode) {
                        notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:";
                    }
                    Logging.warn(Sender.TAG, notice, error);
                }
                else {
                    var notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
                    Logging.info(Sender.TAG, notice, error);
                }
                _this._onErrorHelper(error);
                if (typeof callback === "function") {
                    var errorMessage = "error sending telemetry";
                    if (error && (typeof error.toString === "function")) {
                        errorMessage = error.toString();
                    }
                    callback(errorMessage);
                }
                if (_this._enableDiskRetryMode) {
                    _this._storeToDisk(payload);
                }
            });
            req.write(dataToSend);
            req.end();
        });
    };
    Sender.prototype.saveOnCrash = function (payload) {
        if (this._enableDiskRetryMode) {
            this._storeToDiskSync(payload);
        }
    };
    Sender.prototype._runICACLS = function (args, callback) {
        var aclProc = child_process.spawn(Sender.ICACLS_PATH, args, { windowsHide: true });
        aclProc.on("error", function (e) { return callback(e); });
        aclProc.on("close", function (code, signal) {
            return callback(code === 0 ? null : new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
        });
    };
    Sender.prototype._runICACLSSync = function (args) {
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process.spawnSync) {
            var aclProc = child_process.spawnSync(Sender.ICACLS_PATH, args, { windowsHide: true });
            if (aclProc.error) {
                throw aclProc.error;
            }
            else if (aclProc.status !== 0) {
                throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
            }
        }
        else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
    };
    Sender.prototype._getACLIdentity = function (callback) {
        if (Sender.ACL_IDENTITY) {
            return callback(null, Sender.ACL_IDENTITY);
        }
        var psProc = child_process.spawn(Sender.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
            windowsHide: true,
            stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7
        });
        var data = "";
        psProc.stdout.on("data", function (d) { return data += d; });
        psProc.on("error", function (e) { return callback(e, null); });
        psProc.on("close", function (code, signal) {
            Sender.ACL_IDENTITY = data && data.trim();
            return callback(code === 0 ? null : new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"), Sender.ACL_IDENTITY);
        });
    };
    Sender.prototype._getACLIdentitySync = function () {
        if (Sender.ACL_IDENTITY) {
            return Sender.ACL_IDENTITY;
        }
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process.spawnSync) {
            var psProc = child_process.spawnSync(Sender.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
                throw psProc.error;
            }
            else if (psProc.status !== 0) {
                throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
            }
            Sender.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return Sender.ACL_IDENTITY;
        }
        else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
    };
    Sender.prototype._getACLArguments = function (directory, identity) {
        return [directory,
            "/grant", "*S-1-5-32-544:(OI)(CI)F",
            "/grant", identity + ":(OI)(CI)F",
            "/inheritance:r"]; // Remove all inherited permissions
    };
    Sender.prototype._applyACLRules = function (directory, callback) {
        var _this = this;
        if (!Sender.USE_ICACLS) {
            return callback(null);
        }
        // For performance, only run ACL rules if we haven't already during this session
        if (Sender.ACLED_DIRECTORIES[directory] === undefined) {
            // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately
            // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk
            // This is better than the alternative of potentially infinitely spawned processes
            Sender.ACLED_DIRECTORIES[directory] = false;
            // Restrict this directory to only current user and administrator access
            this._getACLIdentity(function (err, identity) {
                if (err) {
                    Sender.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is "not yet tried")
                    return callback(err);
                }
                else {
                    _this._runICACLS(_this._getACLArguments(directory, identity), function (err) {
                        Sender.ACLED_DIRECTORIES[directory] = !err;
                        return callback(err);
                    });
                }
            });
        }
        else {
            return callback(Sender.ACLED_DIRECTORIES[directory] ? null :
                new Error("Setting ACL restrictions did not succeed (cached result)"));
        }
    };
    Sender.prototype._applyACLRulesSync = function (directory) {
        if (Sender.USE_ICACLS) {
            // For performance, only run ACL rules if we haven't already during this session
            if (Sender.ACLED_DIRECTORIES[directory] === undefined) {
                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
                Sender.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures
                return;
            }
            else if (!Sender.ACLED_DIRECTORIES[directory]) {
                throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
        }
    };
    Sender.prototype._confirmDirExists = function (directory, callback) {
        var _this = this;
        fs.lstat(directory, function (err, stats) {
            if (err && err.code === 'ENOENT') {
                fs.mkdir(directory, function (err) {
                    if (err && err.code !== 'EEXIST') {
                        callback(err);
                    }
                    else {
                        _this._applyACLRules(directory, callback);
                    }
                });
            }
            else if (!err && stats.isDirectory()) {
                _this._applyACLRules(directory, callback);
            }
            else {
                callback(err || new Error("Path existed but was not a directory"));
            }
        });
    };
    /**
     * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
     */
    Sender.prototype._getShallowDirectorySize = function (directory, callback) {
        // Get the directory listing
        fs.readdir(directory, function (err, files) {
            if (err) {
                return callback(err, -1);
            }
            var error = null;
            var totalSize = 0;
            var count = 0;
            if (files.length === 0) {
                callback(null, 0);
                return;
            }
            // Query all file sizes
            for (var i = 0; i < files.length; i++) {
                fs.stat(path.join(directory, files[i]), function (err, fileStats) {
                    count++;
                    if (err) {
                        error = err;
                    }
                    else {
                        if (fileStats.isFile()) {
                            totalSize += fileStats.size;
                        }
                    }
                    if (count === files.length) {
                        // Did we get an error?
                        if (error) {
                            callback(error, -1);
                        }
                        else {
                            callback(error, totalSize);
                        }
                    }
                });
            }
        });
    };
    /**
     * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.
     */
    Sender.prototype._getShallowDirectorySizeSync = function (directory) {
        var files = fs.readdirSync(directory);
        var totalSize = 0;
        for (var i = 0; i < files.length; i++) {
            totalSize += fs.statSync(path.join(directory, files[i])).size;
        }
        return totalSize;
    };
    /**
     * Stores the payload as a json file on disk in the temp directory
     */
    Sender.prototype._storeToDisk = function (payload) {
        var _this = this;
        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        // This will create the dir if it does not exist
        // Default permissions on *nix are directory listing from other users but no file creations
        Logging.info(Sender.TAG, "Checking existence of data storage directory: " + directory);
        this._confirmDirExists(directory, function (error) {
            if (error) {
                Logging.warn(Sender.TAG, "Error while checking/creating directory: " + (error && error.message));
                _this._onErrorHelper(error);
                return;
            }
            _this._getShallowDirectorySize(directory, function (err, size) {
                if (err || size < 0) {
                    Logging.warn(Sender.TAG, "Error while checking directory size: " + (err && err.message));
                    _this._onErrorHelper(err);
                    return;
                }
                else if (size > _this._maxBytesOnDisk) {
                    Logging.warn(Sender.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + size);
                    return;
                }
                //create file - file name for now is the timestamp, a better approach would be a UUID but that
                //would require an external dependency
                var fileName = new Date().getTime() + ".ai.json";
                var fileFullPath = path.join(directory, fileName);
                // Mode 600 is w/r for creator and no read access for others (only applies on *nix)
                // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)
                Logging.info(Sender.TAG, "saving data to disk at: " + fileFullPath);
                fs.writeFile(fileFullPath, payload, { mode: 384 }, function (error) { return _this._onErrorHelper(error); });
            });
        });
    };
    /**
     * Stores the payload as a json file on disk using sync file operations
     * this is used when storing data before crashes
     */
    Sender.prototype._storeToDiskSync = function (payload) {
        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        try {
            Logging.info(Sender.TAG, "Checking existence of data storage directory: " + directory);
            if (!fs.existsSync(directory)) {
                fs.mkdirSync(directory);
            }
            // Make sure permissions are valid
            this._applyACLRulesSync(directory);
            var dirSize = this._getShallowDirectorySizeSync(directory);
            if (dirSize > this._maxBytesOnDisk) {
                Logging.info(Sender.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
                return;
            }
            //create file - file name for now is the timestamp, a better approach would be a UUID but that
            //would require an external dependency
            var fileName = new Date().getTime() + ".ai.json";
            var fileFullPath = path.join(directory, fileName);
            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)
            Logging.info(Sender.TAG, "saving data before crash to disk at: " + fileFullPath);
            fs.writeFileSync(fileFullPath, payload, { mode: 384 });
        }
        catch (error) {
            Logging.warn(Sender.TAG, "Error while saving data to disk: " + (error && error.message));
            this._onErrorHelper(error);
        }
    };
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    Sender.prototype._sendFirstFileOnDisk = function () {
        var _this = this;
        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);
        fs.exists(tempDir, function (exists) {
            if (exists) {
                fs.readdir(tempDir, function (error, files) {
                    if (!error) {
                        files = files.filter(function (f) { return path.basename(f).indexOf(".ai.json") > -1; });
                        if (files.length > 0) {
                            var firstFile = files[0];
                            var filePath = path.join(tempDir, firstFile);
                            fs.readFile(filePath, function (error, payload) {
                                if (!error) {
                                    // delete the file first to prevent double sending
                                    fs.unlink(filePath, function (error) {
                                        if (!error) {
                                            _this.send(payload);
                                        }
                                        else {
                                            _this._onErrorHelper(error);
                                        }
                                    });
                                }
                                else {
                                    _this._onErrorHelper(error);
                                }
                            });
                        }
                    }
                    else {
                        _this._onErrorHelper(error);
                    }
                });
            }
        });
    };
    Sender.prototype._onErrorHelper = function (error) {
        if (typeof this._onError === "function") {
            this._onError(error);
        }
    };
    Sender.TAG = "Sender";
    Sender.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe";
    Sender.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe";
    Sender.ACLED_DIRECTORIES = {};
    Sender.ACL_IDENTITY = null;
    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throttling from the service side
    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;
    Sender.MAX_BYTES_ON_DISK = 50 * 1000 * 1000;
    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;
    Sender.TEMPDIR_PREFIX = "appInsights-node";
    Sender.OS_PROVIDES_FILE_PROTECTION = false;
    Sender.USE_ICACLS = os.type() === "Windows_NT";
    return Sender;
}());
module.exports = Sender;
//# sourceMappingURL=Sender.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/TelemetryClient.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/TelemetryClient.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var url = __webpack_require__(/*! url */ "url");
var Config = __webpack_require__(/*! ./Config */ "../../node_modules/applicationinsights/out/Library/Config.js");
var Context = __webpack_require__(/*! ./Context */ "../../node_modules/applicationinsights/out/Library/Context.js");
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
var Channel = __webpack_require__(/*! ./Channel */ "../../node_modules/applicationinsights/out/Library/Channel.js");
var TelemetryProcessors = __webpack_require__(/*! ../TelemetryProcessors */ "../../node_modules/applicationinsights/out/TelemetryProcessors/index.js");
var CorrelationContextManager_1 = __webpack_require__(/*! ../AutoCollection/CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js");
var Sender = __webpack_require__(/*! ./Sender */ "../../node_modules/applicationinsights/out/Library/Sender.js");
var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var EnvelopeFactory = __webpack_require__(/*! ./EnvelopeFactory */ "../../node_modules/applicationinsights/out/Library/EnvelopeFactory.js");
/**
 * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and
 * and manually trigger immediate sending (flushing)
 */
var TelemetryClient = (function () {
    /**
     * Constructs a new client of the client
     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)
     */
    function TelemetryClient(setupString) {
        this._telemetryProcessors = [];
        var config = new Config(setupString);
        this.config = config;
        this.context = new Context();
        this.commonProperties = {};
        var sender = new Sender(this.config);
        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);
    }
    /**
     * Log information about availability of an application
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackAvailability = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Availability);
    };
    /**
     * Log a page view
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackPageView = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.PageView);
    };
    /**
     * Log a trace message
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackTrace = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Trace);
    };
    /**
     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackMetric = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Metric);
    };
    /**
     * Log an exception
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackException = function (telemetry) {
        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {
            telemetry.exception = new Error(telemetry.exception.toString());
        }
        this.track(telemetry, Contracts.TelemetryType.Exception);
    };
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackEvent = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Event);
    };
    /**
     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests
     * that aren't automatically captured or if you've disabled automatic request collection.
     *
     * @param telemetry      Object encapsulating tracking options
     */
    TelemetryClient.prototype.trackRequest = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Request);
    };
    /**
     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies
     * that aren't automatically captured or if you've disabled automatic dependency collection.
     *
     * @param telemetry      Object encapsulating tracking option
     * */
    TelemetryClient.prototype.trackDependency = function (telemetry) {
        if (telemetry && !telemetry.target && telemetry.data) {
            // url.parse().host returns null for non-urls,
            // making this essentially a no-op in those cases
            // If this logic is moved, update jsdoc in DependencyTelemetry.target
            telemetry.target = url.parse(telemetry.data).host;
        }
        this.track(telemetry, Contracts.TelemetryType.Dependency);
    };
    /**
     * Immediately send all queued telemetry.
     * @param options Flush options, including indicator whether app is crashing and callback
     */
    TelemetryClient.prototype.flush = function (options) {
        this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : undefined);
    };
    /**
     * Generic track method for all telemetry types
     * @param data the telemetry to send
     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes
     */
    TelemetryClient.prototype.track = function (telemetry, telemetryType) {
        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
            // Set time on the envelope if it was set on the telemetry item
            if (telemetry.time) {
                envelope.time = telemetry.time.toISOString();
            }
            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
            // Ideally we would have a central place for "internal" telemetry processors and users can configure which ones are in use.
            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.
            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });
            if (accepted) {
                TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);
                this.channel.send(envelope);
            }
        }
        else {
            Logging.warn("track() requires telemetry object and telemetryType to be specified.");
        }
    };
    /**
     * Adds telemetry processor to the collection. Telemetry processors will be called one by one
     * before telemetry item is pushed for sending and in the order they were added.
     *
     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean
     */
    TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {
        this._telemetryProcessors.push(telemetryProcessor);
    };
    /*
     * Removes all telemetry processors
     */
    TelemetryClient.prototype.clearTelemetryProcessors = function () {
        this._telemetryProcessors = [];
    };
    TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {
        var accepted = true;
        var telemetryProcessorsCount = this._telemetryProcessors.length;
        if (telemetryProcessorsCount === 0) {
            return accepted;
        }
        contextObjects = contextObjects || {};
        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        for (var i = 0; i < telemetryProcessorsCount; ++i) {
            try {
                var processor = this._telemetryProcessors[i];
                if (processor) {
                    if (processor.apply(null, [envelope, contextObjects]) === false) {
                        accepted = false;
                        break;
                    }
                }
            }
            catch (error) {
                accepted = true;
                Logging.warn("One of telemetry processors failed, telemetry item will be sent.", error, envelope);
            }
        }
        return accepted;
    };
    return TelemetryClient;
}());
module.exports = TelemetryClient;
//# sourceMappingURL=TelemetryClient.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Traceparent.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Traceparent.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Util = __webpack_require__(/*! ./Util */ "../../node_modules/applicationinsights/out/Library/Util.js");
var CorrelationIdManager = __webpack_require__(/*! ./CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
/**
 * Helper class to manage parsing and validation of traceparent header. Also handles hierarchical
 * back-compatibility headers generated from traceparent. W3C traceparent spec is documented at
 * https://www.w3.org/TR/trace-context/#traceparent-field
 */
var Traceparent = (function () {
    function Traceparent(traceparent, parentId) {
        this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;
        this.version = Traceparent.DEFAULT_VERSION;
        if (traceparent && typeof traceparent === "string") {
            // If incoming request contains traceparent: parse it, set operation, parent and telemetry id accordingly. traceparent should be injected into outgoing requests. request-id should be injected in back-compat format |traceId.spanId. so that older SDKs could understand it.
            if (traceparent.split(",").length > 1) {
                this.traceId = Util.w3cTraceId();
                this.spanId = Util.w3cTraceId().substr(0, 16);
            }
            else {
                var traceparentArr = traceparent.trim().split("-");
                var len = traceparentArr.length;
                if (len >= 4) {
                    this.version = traceparentArr[0];
                    this.traceId = traceparentArr[1];
                    this.spanId = traceparentArr[2];
                    this.traceFlag = traceparentArr[3];
                }
                else {
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                // Version validation
                if (!this.version.match(/^[0-9a-f]{2}$/g)) {
                    this.version = Traceparent.DEFAULT_VERSION;
                    this.traceId = Util.w3cTraceId();
                }
                if (this.version === "00" && len !== 4) {
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                if (this.version === "ff") {
                    this.version = Traceparent.DEFAULT_VERSION;
                    this.traceId = Util.w3cTraceId();
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                }
                if (!this.version.match(/^0[0-9a-f]$/g)) {
                    this.version = Traceparent.DEFAULT_VERSION;
                }
                // TraceFlag validation
                if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {
                    this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;
                    this.traceId = Util.w3cTraceId();
                }
                // Validate TraceId, regenerate new traceid if invalid
                if (!Traceparent.isValidTraceId(this.traceId)) {
                    this.traceId = Util.w3cTraceId();
                }
                // Validate Span Id, discard entire traceparent if invalid
                if (!Traceparent.isValidSpanId(this.spanId)) {
                    this.spanId = Util.w3cTraceId().substr(0, 16);
                    this.traceId = Util.w3cTraceId();
                }
                // Save backCompat parentId
                this.parentId = this.getBackCompatRequestId();
            }
        }
        else if (parentId) {
            // If incoming request contains only request-id, new traceid and spanid should be started, request-id value should be used as a parent. Root part of request-id should be stored in custom dimension on the request telemetry if root part is different from traceid. On the outgoing request side, request-id should be emitted in the |traceId.spanId. format.
            this.parentId = parentId.slice(); // copy
            var operationId = CorrelationIdManager.getRootId(parentId);
            if (!Traceparent.isValidTraceId(operationId)) {
                this.legacyRootId = operationId;
                operationId = Util.w3cTraceId();
            }
            if (parentId.indexOf("|") !== -1) {
                parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1);
            }
            this.traceId = operationId;
            this.spanId = parentId;
        }
        else {
            // Fallback default constructor
            // if request does not contain any correlation headers, see case p2
            this.traceId = Util.w3cTraceId();
            this.spanId = Util.w3cTraceId().substr(0, 16);
        }
    }
    Traceparent.isValidTraceId = function (id) {
        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
    };
    Traceparent.isValidSpanId = function (id) {
        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
    };
    Traceparent.prototype.getBackCompatRequestId = function () {
        return "|" + this.traceId + "." + this.spanId + ".";
    };
    Traceparent.prototype.toString = function () {
        return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
    };
    Traceparent.prototype.updateSpanId = function () {
        this.spanId = Util.w3cTraceId().substr(0, 16);
    };
    Traceparent.DEFAULT_TRACE_FLAG = "01";
    Traceparent.DEFAULT_VERSION = "00";
    return Traceparent;
}());
module.exports = Traceparent;
//# sourceMappingURL=Traceparent.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Tracestate.js":
/*!************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Tracestate.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

/**
 * Helper class to manage parsing and strict-validation of tracestate header. W3C tracestate spec
 * is documented at https://www.w3.org/TR/trace-context/#header-value
 * @class Tracestate
 */
var Tracestate = (function () {
    // if true, performs strict tracestate header checking, else just passes it along
    function Tracestate(id) {
        this.fieldmap = [];
        if (!id) {
            return;
        }
        this.fieldmap = this.parseHeader(id);
    }
    Tracestate.prototype.toString = function () {
        var fieldarr = this.fieldmap;
        if (!fieldarr || fieldarr.length == 0) {
            return null;
        }
        return fieldarr.join(", ");
    };
    Tracestate.validateKeyChars = function (key) {
        var keyParts = key.split("@");
        if (keyParts.length == 2) {
            // Parse for tenant@vendor format
            var tenant = keyParts[0].trim();
            var vendor = keyParts[1].trim();
            var tenantValid = Boolean(tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/));
            var vendorValid = Boolean(vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
            return tenantValid && vendorValid;
        }
        else if (keyParts.length == 1) {
            // Parse for standard key format
            return Boolean(key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));
        }
        return false;
    };
    Tracestate.prototype.parseHeader = function (id) {
        var res = [];
        var keydeduper = {};
        var parts = id.split(",");
        if (parts.length > 32)
            return null;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var rawPart = parts_1[_i];
            var part = rawPart.trim(); // trim out whitespace
            if (part.length === 0) {
                continue; // Discard empty pairs, but keep the rest of this tracestate
            }
            var pair = part.split("=");
            // pair should contain exactly one "="
            if (pair.length !== 2) {
                return null; // invalid pair: discard entire tracestate
            }
            // Validate length and charset of this key
            if (!Tracestate.validateKeyChars(pair[0])) {
                return null;
            }
            // Assert uniqueness of this key
            if (keydeduper[pair[0]]) {
                return null; // duplicate key: discard entire tracestate
            }
            else {
                keydeduper[pair[0]] = true;
            }
            // All checks passed -- add this part
            res.push(part);
        }
        return res;
    };
    Tracestate.strict = true;
    return Tracestate;
}());
module.exports = Tracestate;
//# sourceMappingURL=Tracestate.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/Library/Util.js":
/*!******************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/Library/Util.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var url = __webpack_require__(/*! url */ "url");
var constants = __webpack_require__(/*! constants */ "constants");
var Logging = __webpack_require__(/*! ./Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var RequestResponseHeaders = __webpack_require__(/*! ./RequestResponseHeaders */ "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js");
var Util = (function () {
    function Util() {
    }
    /**
     * helper method to access userId and sessionId cookie
     */
    Util.getCookie = function (name, cookie) {
        var value = "";
        if (name && name.length && typeof cookie === "string") {
            var cookieName = name + "=";
            var cookies = cookie.split(";");
            for (var i = 0; i < cookies.length; i++) {
                var cookie = cookies[i];
                cookie = Util.trim(cookie);
                if (cookie && cookie.indexOf(cookieName) === 0) {
                    value = cookie.substring(cookieName.length, cookies[i].length);
                    break;
                }
            }
        }
        return value;
    };
    /**
     * helper method to trim strings (IE8 does not implement String.prototype.trim)
     */
    Util.trim = function (str) {
        if (typeof str === "string") {
            return str.replace(/^\s+|\s+$/g, "");
        }
        else {
            return "";
        }
    };
    /**
     * Convert an array of int32 to Base64 (no '==' at the end).
     * MSB first.
     */
    Util.int32ArrayToBase64 = function (array) {
        var toChar = function (v, i) {
            return String.fromCharCode((v >> i) & 0xFF);
        };
        var int32AsString = function (v) {
            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
        };
        var x = array.map(int32AsString).join("");
        var b = Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary");
        var s = b.toString("base64");
        return s.substr(0, s.indexOf("="));
    };
    /**
     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).
     */
    Util.random32 = function () {
        return (0x100000000 * Math.random()) | 0;
    };
    /**
     * generate a random 32bit number (0x00000000..0xFFFFFFFF).
     */
    Util.randomu32 = function () {
        return Util.random32() + 0x80000000;
    };
    /**
     * generate W3C-compatible trace id
     * https://github.com/w3c/distributed-tracing/blob/master/trace_context/HTTP_HEADER_FORMAT.md#trace-id
     */
    Util.w3cTraceId = function () {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        // rfc4122 version 4 UUID without dashes and with lowercase letters
        var oct = "", tmp;
        for (var a = 0; a < 4; a++) {
            tmp = Util.random32();
            oct +=
                hexValues[tmp & 0xF] +
                    hexValues[tmp >> 4 & 0xF] +
                    hexValues[tmp >> 8 & 0xF] +
                    hexValues[tmp >> 12 & 0xF] +
                    hexValues[tmp >> 16 & 0xF] +
                    hexValues[tmp >> 20 & 0xF] +
                    hexValues[tmp >> 24 & 0xF] +
                    hexValues[tmp >> 28 & 0xF];
        }
        // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];
        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
    };
    Util.w3cSpanId = function () {
        return Util.w3cTraceId().substring(16);
    };
    Util.isValidW3CId = function (id) {
        return id.length === 32 && id !== "00000000000000000000000000000000";
    };
    /**
     * Check if an object is of type Array
     */
    Util.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    /**
     * Check if an object is of type Error
     */
    Util.isError = function (obj) {
        return obj instanceof Error;
    };
    Util.isPrimitive = function (input) {
        var propType = typeof input;
        return propType === "string" || propType === "number" || propType === "boolean";
    };
    /**
     * Check if an object is of type Date
     */
    Util.isDate = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
    };
    /**
     * Convert ms to c# time span format
     */
    Util.msToTimeSpan = function (totalms) {
        if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
        }
        var sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, "");
        var min = "" + Math.floor(totalms / (1000 * 60)) % 60;
        var hour = "" + Math.floor(totalms / (1000 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));
        sec = sec.indexOf(".") < 2 ? "0" + sec : sec;
        min = min.length < 2 ? "0" + min : min;
        hour = hour.length < 2 ? "0" + hour : hour;
        var daysText = days > 0 ? days + "." : "";
        return daysText + hour + ":" + min + ":" + sec;
    };
    /**
     * Using JSON.stringify, by default Errors do not serialize to something useful:
     * Simplify a generic Node Error into a simpler map for customDimensions
     * Custom errors can still implement toJSON to override this functionality
     */
    Util.extractError = function (err) {
        // Error is often subclassed so may have code OR id properties:
        // https://nodejs.org/api/errors.html#errors_error_code
        var looseError = err;
        return {
            message: err.message,
            code: looseError.code || looseError.id || "",
        };
    };
    /**
     * Manually call toJSON if available to pre-convert the value.
     * If a primitive is returned, then the consumer of this function can skip JSON.stringify.
     * This avoids double escaping of quotes for Date objects, for example.
     */
    Util.extractObject = function (origProperty) {
        if (origProperty instanceof Error) {
            return Util.extractError(origProperty);
        }
        if (typeof origProperty.toJSON === "function") {
            return origProperty.toJSON();
        }
        return origProperty;
    };
    /**
     * Validate that an object is of type { [key: string]: string }
     */
    Util.validateStringMap = function (obj) {
        if (typeof obj !== "object") {
            Logging.info("Invalid properties dropped from payload");
            return;
        }
        var map = {};
        for (var field in obj) {
            var property = '';
            var origProperty = obj[field];
            var propType = typeof origProperty;
            if (Util.isPrimitive(origProperty)) {
                property = origProperty.toString();
            }
            else if (origProperty === null || propType === "undefined") {
                property = "";
            }
            else if (propType === "function") {
                Logging.info("key: " + field + " was function; will not serialize");
                continue;
            }
            else {
                var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);
                try {
                    if (Util.isPrimitive(stringTarget)) {
                        property = stringTarget;
                    }
                    else {
                        property = JSON.stringify(stringTarget);
                    }
                }
                catch (e) {
                    property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")";
                    Logging.info("key: " + field + ", could not be serialized");
                }
            }
            map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);
        }
        return map;
    };
    /**
     * Checks if a request url is not on a excluded domain list
     * and if it is safe to add correlation headers
     */
    Util.canIncludeCorrelationHeader = function (client, requestUrl) {
        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {
            return true;
        }
        for (var i = 0; i < excludedDomains.length; i++) {
            var regex = new RegExp(excludedDomains[i].replace(/\./g, "\.").replace(/\*/g, ".*"));
            if (regex.test(url.parse(requestUrl).hostname)) {
                return false;
            }
        }
        return true;
    };
    Util.getCorrelationContextTarget = function (response, key) {
        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
        if (contextHeaders) {
            var keyValues = contextHeaders.split(",");
            for (var i = 0; i < keyValues.length; ++i) {
                var keyValue = keyValues[i].split("=");
                if (keyValue.length == 2 && keyValue[0] == key) {
                    return keyValue[1];
                }
            }
        }
    };
    /**
     * Generate request
     *
     * Proxify the request creation to handle proxy http
     *
     * @param {string} requestUrl url endpoint
     * @param {Object} requestOptions Request option
     * @param {Function} requestCallback callback on request
     * @returns {http.ClientRequest} request object
     */
    Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback) {
        if (requestUrl && requestUrl.indexOf('//') === 0) {
            requestUrl = 'https:' + requestUrl;
        }
        var requestUrlParsed = url.parse(requestUrl);
        var options = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });
        var proxyUrl = undefined;
        if (requestUrlParsed.protocol === 'https:') {
            proxyUrl = config.proxyHttpsUrl || undefined;
        }
        if (requestUrlParsed.protocol === 'http:') {
            proxyUrl = config.proxyHttpUrl || undefined;
        }
        if (proxyUrl) {
            if (proxyUrl.indexOf('//') === 0) {
                proxyUrl = 'http:' + proxyUrl;
            }
            var proxyUrlParsed = url.parse(proxyUrl);
            // https is not supported at the moment
            if (proxyUrlParsed.protocol === 'https:') {
                Logging.info("Proxies that use HTTPS are not supported");
                proxyUrl = undefined;
            }
            else {
                options = __assign({}, options, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || "80", path: requestUrl, headers: __assign({}, options.headers, { Host: requestUrlParsed.hostname }) });
            }
        }
        var isHttps = requestUrlParsed.protocol === 'https:' && !proxyUrl;
        if (isHttps && config.httpsAgent !== undefined) {
            options.agent = config.httpsAgent;
        }
        else if (!isHttps && config.httpAgent !== undefined) {
            options.agent = config.httpAgent;
        }
        else if (isHttps) {
            // HTTPS without a passed in agent. Use one that enforces our TLS rules
            options.agent = Util.tlsRestrictedAgent;
        }
        if (isHttps) {
            return https.request(options, requestCallback);
        }
        else {
            return http.request(options, requestCallback);
        }
    };
    ;
    /**
     * Parse standard <string | string[] | number> request-context header
     */
    Util.safeIncludeCorrelationHeader = function (client, request, correlationHeader) {
        var header; // attempt to cast correlationHeader to string
        if (typeof correlationHeader === "string") {
            header = correlationHeader;
        }
        else if (correlationHeader instanceof Array) {
            header = correlationHeader.join(",");
        }
        else if (correlationHeader && typeof correlationHeader.toString === "function") {
            // best effort attempt: requires well-defined toString
            try {
                header = correlationHeader.toString();
            }
            catch (err) {
                Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
            }
        }
        if (header) {
            Util.addCorrelationIdHeaderFromString(client, request, header);
        }
        else {
            request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
    };
    Util.addCorrelationIdHeaderFromString = function (client, response, correlationHeader) {
        var components = correlationHeader.split(",");
        var key = RequestResponseHeaders.requestContextSourceKey + "=";
        var found = components.some(function (value) { return value.substring(0, key.length) === key; });
        if (!found) {
            response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
    };
    Util.MAX_PROPERTY_LENGTH = 8192;
    Util.tlsRestrictedAgent = new https.Agent({
        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 |
            constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
    });
    return Util;
}());
module.exports = Util;
//# sourceMappingURL=Util.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var AutoCollectPerformance = __webpack_require__(/*! ../AutoCollection/Performance */ "../../node_modules/applicationinsights/out/AutoCollection/Performance.js");
var TelemetryType = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
function performanceMetricsTelemetryProcessor(envelope, client) {
    // If live metrics is enabled, forward all telemetry there
    if (client) {
        client.addDocument(envelope);
    }
    // Increment rate counters (for standard metrics and live metrics)
    switch (envelope.data.baseType) {
        case TelemetryType.TelemetryTypeString.Exception:
            AutoCollectPerformance.countException();
            break;
        case TelemetryType.TelemetryTypeString.Request:
            var requestData = envelope.data.baseData;
            AutoCollectPerformance.countRequest(requestData.duration, requestData.success);
            break;
        case TelemetryType.TelemetryTypeString.Dependency:
            var remoteDependencyData = envelope.data.baseData;
            AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);
            break;
    }
    return true;
}
exports.performanceMetricsTelemetryProcessor = performanceMetricsTelemetryProcessor;
//# sourceMappingURL=PerformanceMetricsTelemetryProcessor.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Contracts = __webpack_require__(/*! ../Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
/**
 *  A telemetry processor that handles sampling.
 */
function samplingTelemetryProcessor(envelope, contextObjects) {
    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope
    var isSampledIn = false;
    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
        return true;
    }
    else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {
        // Exclude MetricData telemetry from sampling
        return true;
    }
    else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {
        // If we're using dependency correlation, sampling should retain all telemetry from a given request
        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;
    }
    else {
        // If we're not using dependency correlation, sampling should use a random distribution on each item
        isSampledIn = (Math.random() * 100) < samplingPercentage;
    }
    return isSampledIn;
}
exports.samplingTelemetryProcessor = samplingTelemetryProcessor;
/** Ported from AI .NET SDK */
function getSamplingHashCode(input) {
    var csharpMin = -2147483648;
    var csharpMax = 2147483647;
    var hash = 5381;
    if (!input) {
        return 0;
    }
    while (input.length < 8) {
        input = input + input;
    }
    for (var i = 0; i < input.length; i++) {
        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)
        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);
    }
    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
    return (hash / csharpMax) * 100;
}
exports.getSamplingHashCode = getSamplingHashCode;
//# sourceMappingURL=SamplingTelemetryProcessor.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/TelemetryProcessors/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/TelemetryProcessors/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(/*! ./SamplingTelemetryProcessor */ "../../node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js"));
__export(__webpack_require__(/*! ./PerformanceMetricsTelemetryProcessor */ "../../node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/applicationinsights/out/applicationinsights.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/applicationinsights/out/applicationinsights.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CorrelationContextManager = __webpack_require__(/*! ./AutoCollection/CorrelationContextManager */ "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js"); // Keep this first
var AutoCollectConsole = __webpack_require__(/*! ./AutoCollection/Console */ "../../node_modules/applicationinsights/out/AutoCollection/Console.js");
var AutoCollectExceptions = __webpack_require__(/*! ./AutoCollection/Exceptions */ "../../node_modules/applicationinsights/out/AutoCollection/Exceptions.js");
var AutoCollectPerformance = __webpack_require__(/*! ./AutoCollection/Performance */ "../../node_modules/applicationinsights/out/AutoCollection/Performance.js");
var HeartBeat = __webpack_require__(/*! ./AutoCollection/HeartBeat */ "../../node_modules/applicationinsights/out/AutoCollection/HeartBeat.js");
var AutoCollectHttpDependencies = __webpack_require__(/*! ./AutoCollection/HttpDependencies */ "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js");
var AutoCollectHttpRequests = __webpack_require__(/*! ./AutoCollection/HttpRequests */ "../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js");
var CorrelationIdManager = __webpack_require__(/*! ./Library/CorrelationIdManager */ "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js");
var Logging = __webpack_require__(/*! ./Library/Logging */ "../../node_modules/applicationinsights/out/Library/Logging.js");
var QuickPulseClient = __webpack_require__(/*! ./Library/QuickPulseStateManager */ "../../node_modules/applicationinsights/out/Library/QuickPulseStateManager.js");
var NativePerformance_1 = __webpack_require__(/*! ./AutoCollection/NativePerformance */ "../../node_modules/applicationinsights/out/AutoCollection/NativePerformance.js");
// We export these imports so that SDK users may use these classes directly.
// They're exposed using "export import" so that types are passed along as expected
exports.TelemetryClient = __webpack_require__(/*! ./Library/NodeClient */ "../../node_modules/applicationinsights/out/Library/NodeClient.js");
exports.Contracts = __webpack_require__(/*! ./Declarations/Contracts */ "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js");
exports.azureFunctionsTypes = __webpack_require__(/*! ./Library/Functions */ "../../node_modules/applicationinsights/out/Library/Functions.js");
var DistributedTracingModes;
(function (DistributedTracingModes) {
    /**
     * (Default) Send Application Insights correlation headers
     */
    DistributedTracingModes[DistributedTracingModes["AI"] = 0] = "AI";
    /**
     * Send both W3C Trace Context headers and back-compatibility Application Insights headers
     */
    DistributedTracingModes[DistributedTracingModes["AI_AND_W3C"] = 1] = "AI_AND_W3C";
})(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));
// Default autocollection configuration
var _isConsole = true;
var _isConsoleLog = false;
var _isExceptions = true;
var _isPerformance = true;
var _isHeartBeat = false; // off by default for now
var _isRequests = true;
var _isDependencies = true;
var _isDiskRetry = true;
var _isCorrelating = true;
var _forceClsHooked;
var _isSendingLiveMetrics = false; // Off by default
var _isNativePerformance = true;
var _disabledExtendedMetrics;
var _diskRetryInterval = undefined;
var _diskRetryMaxBytes = undefined;
var _console;
var _exceptions;
var _performance;
var _heartbeat;
var _nativePerformance;
var _serverRequests;
var _clientRequests;
var _isStarted = false;
var _performanceLiveMetrics;
/**
 * Initializes the default client. Should be called after setting
 * configuration options.
 *
 * @param setupString the Connection String or Instrumentation Key to use. Optional, if
 * this is not specified, the value will be read from the environment
 * variable APPLICATIONINSIGHTS_CONNECTION_STRING or APPINSIGHTS_INSTRUMENTATIONKEY.
 * @returns {Configuration} the configuration class to initialize
 * and start the SDK.
 */
function setup(setupString) {
    if (!exports.defaultClient) {
        exports.defaultClient = new exports.TelemetryClient(setupString);
        _console = new AutoCollectConsole(exports.defaultClient);
        _exceptions = new AutoCollectExceptions(exports.defaultClient);
        _performance = new AutoCollectPerformance(exports.defaultClient);
        _heartbeat = new HeartBeat(exports.defaultClient);
        _serverRequests = new AutoCollectHttpRequests(exports.defaultClient);
        _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient);
        if (!_nativePerformance) {
            _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient);
        }
    }
    else {
        Logging.info("The default client is already setup");
    }
    if (exports.defaultClient && exports.defaultClient.channel) {
        exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);
    }
    return Configuration;
}
exports.setup = setup;
/**
 * Starts automatic collection of telemetry. Prior to calling start no
 * telemetry will be *automatically* collected, though manual collection
 * is enabled.
 * @returns {ApplicationInsights} this class
 */
function start() {
    if (!!exports.defaultClient) {
        _isStarted = true;
        _console.enable(_isConsole, _isConsoleLog);
        _exceptions.enable(_isExceptions);
        _performance.enable(_isPerformance);
        _heartbeat.enable(_isHeartBeat, exports.defaultClient.config);
        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);
        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);
        _serverRequests.enable(_isRequests);
        _clientRequests.enable(_isDependencies);
        if (exports.liveMetricsClient && _isSendingLiveMetrics) {
            exports.liveMetricsClient.enable(_isSendingLiveMetrics);
        }
    }
    else {
        Logging.warn("Start cannot be called before setup");
    }
    return Configuration;
}
exports.start = start;
/**
 * Returns an object that is shared across all code handling a given request.
 * This can be used similarly to thread-local storage in other languages.
 * Properties set on this object will be available to telemetry processors.
 *
 * Do not store sensitive information here.
 * Custom properties set on this object can be exposed in a future SDK
 * release via outgoing HTTP headers.
 * This is to allow for correlating data cross-component.
 *
 * This method will return null if automatic dependency correlation is disabled.
 * @returns A plain object for request storage or null if automatic dependency correlation is disabled.
 */
function getCorrelationContext() {
    if (_isCorrelating) {
        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();
    }
    return null;
}
exports.getCorrelationContext = getCorrelationContext;
function startOperation(context, request) {
    return CorrelationContextManager.CorrelationContextManager.startOperation(context, request);
}
exports.startOperation = startOperation;
/**
 * Returns a function that will get the same correlation context within its
 * function body as the code executing this function.
 * Use this method if automatic dependency correlation is not propagating
 * correctly to an asynchronous callback.
 */
function wrapWithCorrelationContext(fn, context) {
    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn, context);
}
exports.wrapWithCorrelationContext = wrapWithCorrelationContext;
/**
 * The active configuration for global SDK behaviors, such as autocollection.
 */
var Configuration = (function () {
    function Configuration() {
    }
    /**
     * Sets the distributed tracing modes. If W3C mode is enabled, W3C trace context
     * headers (traceparent/tracestate) will be parsed in all incoming requests, and included in outgoing
     * requests. In W3C mode, existing back-compatibility AI headers will also be parsed and included.
     * Enabling W3C mode will not break existing correlation with other Application Insights instrumented
     * services. Default=AI
    */
    Configuration.setDistributedTracingMode = function (value) {
        CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;
        return Configuration;
    };
    /**
     * Sets the state of console and logger tracking (enabled by default for third-party loggers only)
     * @param value if true logger activity will be sent to Application Insights
     * @param collectConsoleLog if true, logger autocollection will include console.log calls (default false)
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {
        if (collectConsoleLog === void 0) { collectConsoleLog = false; }
        _isConsole = value;
        _isConsoleLog = collectConsoleLog;
        if (_isStarted) {
            _console.enable(value, collectConsoleLog);
        }
        return Configuration;
    };
    /**
     * Sets the state of exception tracking (enabled by default)
     * @param value if true uncaught exceptions will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectExceptions = function (value) {
        _isExceptions = value;
        if (_isStarted) {
            _exceptions.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of performance tracking (enabled by default)
     * @param value if true performance counters will be collected every second and sent to Application Insights
     * @param collectExtendedMetrics if true, extended metrics counters will be collected every minute and sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectPerformance = function (value, collectExtendedMetrics) {
        if (collectExtendedMetrics === void 0) { collectExtendedMetrics = true; }
        _isPerformance = value;
        var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics);
        _isNativePerformance = extendedMetricsConfig.isEnabled;
        _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
        if (_isStarted) {
            _performance.enable(value);
            _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);
        }
        return Configuration;
    };
    /**
     * Sets the state of request tracking (enabled by default)
     * @param value if true HeartBeat metric data will be collected every 15 mintues and sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectHeartbeat = function (value) {
        _isHeartBeat = value;
        if (_isStarted) {
            _heartbeat.enable(value, exports.defaultClient.config);
        }
        return Configuration;
    };
    /**
     * Sets the state of request tracking (enabled by default)
     * @param value if true requests will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectRequests = function (value) {
        _isRequests = value;
        if (_isStarted) {
            _serverRequests.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of dependency tracking (enabled by default)
     * @param value if true dependencies will be sent to Application Insights
     * @returns {Configuration} this class
     */
    Configuration.setAutoCollectDependencies = function (value) {
        _isDependencies = value;
        if (_isStarted) {
            _clientRequests.enable(value);
        }
        return Configuration;
    };
    /**
     * Sets the state of automatic dependency correlation (enabled by default)
     * @param value if true dependencies will be correlated with requests
     * @param useAsyncHooks if true, forces use of experimental async_hooks module to provide correlation. If false, instead uses only patching-based techniques. If left blank, the best option is chosen for you based on your version of Node.js.
     * @returns {Configuration} this class
     */
    Configuration.setAutoDependencyCorrelation = function (value, useAsyncHooks) {
        _isCorrelating = value;
        _forceClsHooked = useAsyncHooks;
        if (_isStarted) {
            _serverRequests.useAutoCorrelation(value, useAsyncHooks);
        }
        return Configuration;
    };
    /**
     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)
     * Note that this method only applies to the default client. Disk-backed retry caching is disabled by default for additional clients.
     * For enable for additional clients, use client.channel.setUseDiskRetryCaching(true).
     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.
     * @param value if true events that occured while client is offline will be cached on disk
     * @param resendInterval The wait interval for resending cached events.
     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.
     * @returns {Configuration} this class
     */
    Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
        _isDiskRetry = value;
        _diskRetryInterval = resendInterval;
        _diskRetryMaxBytes = maxBytesOnDisk;
        if (exports.defaultClient && exports.defaultClient.channel) {
            exports.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);
        }
        return Configuration;
    };
    /**
     * Enables debug and warning logging for AppInsights itself.
     * @param enableDebugLogging if true, enables debug logging
     * @param enableWarningLogging if true, enables warning logging
     * @returns {Configuration} this class
     */
    Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {
        if (enableDebugLogging === void 0) { enableDebugLogging = false; }
        if (enableWarningLogging === void 0) { enableWarningLogging = true; }
        Logging.enableDebug = enableDebugLogging;
        Logging.disableWarnings = !enableWarningLogging;
        return Configuration;
    };
    /**
     * Enables communication with Application Insights Live Metrics.
     * @param enable if true, enables communication with the live metrics service
     */
    Configuration.setSendLiveMetrics = function (enable) {
        if (enable === void 0) { enable = false; }
        if (!exports.defaultClient) {
            // Need a defaultClient so that we can add the QPS telemetry processor to it
            Logging.warn("Live metrics client cannot be setup without the default client");
            return Configuration;
        }
        if (!exports.liveMetricsClient && enable) {
            // No qps client exists. Create one and prepare it to be enabled at .start()
            exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config.instrumentationKey);
            _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1000, true);
            exports.liveMetricsClient.addCollector(_performanceLiveMetrics);
            exports.defaultClient.quickPulseClient = exports.liveMetricsClient; // Need this so we can forward all manual tracks to live metrics via PerformanceMetricsTelemetryProcessor
        }
        else if (exports.liveMetricsClient) {
            // qps client already exists; enable/disable it
            exports.liveMetricsClient.enable(enable);
        }
        _isSendingLiveMetrics = enable;
        return Configuration;
    };
    // Convenience shortcut to ApplicationInsights.start
    Configuration.start = start;
    return Configuration;
}());
exports.Configuration = Configuration;
/**
 * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration
*/
function dispose() {
    CorrelationIdManager.w3cEnabled = true; // reset to default
    exports.defaultClient = null;
    _isStarted = false;
    if (_console) {
        _console.dispose();
    }
    if (_exceptions) {
        _exceptions.dispose();
    }
    if (_performance) {
        _performance.dispose();
    }
    if (_heartbeat) {
        _heartbeat.dispose();
    }
    if (_nativePerformance) {
        _nativePerformance.dispose();
    }
    if (_serverRequests) {
        _serverRequests.dispose();
    }
    if (_clientRequests) {
        _clientRequests.dispose();
    }
    if (exports.liveMetricsClient) {
        exports.liveMetricsClient.enable(false);
        _isSendingLiveMetrics = false;
        exports.liveMetricsClient = undefined;
    }
}
exports.dispose = dispose;
//# sourceMappingURL=applicationinsights.js.map

/***/ }),

/***/ "../../node_modules/asn1/lib/ber/errors.js":
/*!*************************************************!*\
  !*** ../../node_modules/asn1/lib/ber/errors.js ***!
  \*************************************************/
/***/ ((module) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function (msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};


/***/ }),

/***/ "../../node_modules/asn1/lib/ber/index.js":
/*!************************************************!*\
  !*** ../../node_modules/asn1/lib/ber/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = __webpack_require__(/*! ./errors */ "../../node_modules/asn1/lib/ber/errors.js");
var types = __webpack_require__(/*! ./types */ "../../node_modules/asn1/lib/ber/types.js");

var Reader = __webpack_require__(/*! ./reader */ "../../node_modules/asn1/lib/ber/reader.js");
var Writer = __webpack_require__(/*! ./writer */ "../../node_modules/asn1/lib/ber/writer.js");


// --- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}


/***/ }),

/***/ "../../node_modules/asn1/lib/ber/reader.js":
/*!*************************************************!*\
  !*** ../../node_modules/asn1/lib/ber/reader.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = __webpack_require__(/*! assert */ "assert");
var Buffer = (__webpack_require__(/*! safer-buffer */ "../../node_modules/safer-buffer/safer.js").Buffer);

var ASN1 = __webpack_require__(/*! ./types */ "../../node_modules/asn1/lib/ber/types.js");
var errors = __webpack_require__(/*! ./errors */ "../../node_modules/asn1/lib/ber/errors.js");


// --- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



// --- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;
}

Object.defineProperty(Reader.prototype, 'length', {
  enumerable: true,
  get: function () { return (this._len); }
});

Object.defineProperty(Reader.prototype, 'offset', {
  enumerable: true,
  get: function () { return (this._offset); }
});

Object.defineProperty(Reader.prototype, 'remain', {
  get: function () { return (this._size - this._offset); }
});

Object.defineProperty(Reader.prototype, 'buffer', {
  get: function () { return (this._buf.slice(this._offset)); }
});


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function (peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function () {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function (offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) === 0x80) {
    lenB &= 0x7f;

    if (lenB === 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function (tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function () {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function () {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function () {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function (tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return retbuf ? Buffer.alloc(0) : '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function (tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.readString(tag, true);
  if (b === null)
    return null;

  var values = [];
  var value = 0;

  for (var i = 0; i < b.length; i++) {
    var byte = b[i] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) === 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function (tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) === 0x80 && i !== 4)
    value -= (1 << (i * 8));

  return value >> 0;
};



// --- Exported API

module.exports = Reader;


/***/ }),

/***/ "../../node_modules/asn1/lib/ber/types.js":
/*!************************************************!*\
  !*** ../../node_modules/asn1/lib/ber/types.js ***!
  \************************************************/
/***/ ((module) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};


/***/ }),

/***/ "../../node_modules/asn1/lib/ber/writer.js":
/*!*************************************************!*\
  !*** ../../node_modules/asn1/lib/ber/writer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = __webpack_require__(/*! assert */ "assert");
var Buffer = (__webpack_require__(/*! safer-buffer */ "../../node_modules/safer-buffer/safer.js").Buffer);
var ASN1 = __webpack_require__(/*! ./types */ "../../node_modules/asn1/lib/ber/types.js");
var errors = __webpack_require__(/*! ./errors */ "../../node_modules/asn1/lib/ber/errors.js");


// --- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


// --- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof (from), 'object');
  assert.ok(to);
  assert.equal(typeof (to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function (key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



// --- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = Buffer.alloc(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];
}

Object.defineProperty(Writer.prototype, 'buffer', {
  get: function () {
    if (this._seq.length)
      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');

    return (this._buf.slice(0, this._offset));
  }
});

Writer.prototype.writeByte = function (b) {
  if (typeof (b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
        (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function () {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function (b, tag) {
  if (typeof (b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof (tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');
  if (typeof (tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function (buf, tag) {
  if (typeof (tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function (strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function (s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof (tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function (b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function (b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function (len) {
  if (typeof (len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw newInvalidAsn1Error('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function (tag) {
  if (typeof (tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function () {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw newInvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function (start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function (len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = Buffer.alloc(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



// --- Exported API

module.exports = Writer;


/***/ }),

/***/ "../../node_modules/asn1/lib/index.js":
/*!********************************************!*\
  !*** ../../node_modules/asn1/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = __webpack_require__(/*! ./ber/index */ "../../node_modules/asn1/lib/ber/index.js");



// --- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};


/***/ }),

/***/ "../../node_modules/async-hook-jl/async-hook.js":
/*!******************************************************!*\
  !*** ../../node_modules/async-hook-jl/async-hook.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const asyncWrap = process.binding('async_wrap');
const TIMERWRAP = asyncWrap.Providers.TIMERWRAP;

const patchs = {
  'nextTick': __webpack_require__(/*! ./patches/next-tick.js */ "../../node_modules/async-hook-jl/patches/next-tick.js"),
  'promise': __webpack_require__(/*! ./patches/promise.js */ "../../node_modules/async-hook-jl/patches/promise.js"),
  'timers': __webpack_require__(/*! ./patches/timers.js */ "../../node_modules/async-hook-jl/patches/timers.js")
};

const ignoreUIDs = new Set();

function State() {
  this.enabled = false;
  this.counter = 0;
}

function Hooks() {
  const initFns = this.initFns = [];
  const preFns = this.preFns = [];
  const postFns = this.postFns = [];
  const destroyFns = this.destroyFns = [];

  this.init = function (uid, provider, parentUid, parentHandle) {
    // Ignore TIMERWRAP, since setTimeout etc. is monkey patched
    if (provider === TIMERWRAP) {
      ignoreUIDs.add(uid);
      return;
    }

    // call hooks
    for (const hook of initFns) {
      hook(uid, this, provider, parentUid, parentHandle);
    }
  };

  this.pre = function (uid) {
    if (ignoreUIDs.has(uid)) return;

    // call hooks
    for (const hook of preFns) {
      hook(uid, this);
    }
  };

  this.post = function (uid, didThrow) {
    if (ignoreUIDs.has(uid)) return;

    // call hooks
    for (const hook of postFns) {
      hook(uid, this, didThrow);
    }
  };

  this.destroy = function (uid) {
    // Cleanup the ignore list if this uid should be ignored
    if (ignoreUIDs.has(uid)) {
      ignoreUIDs.delete(uid);
      return;
    }

    // call hooks
    for (const hook of destroyFns) {
      hook(uid);
    }
  };
}

Hooks.prototype.add = function (hooks) {
  if (hooks.init) this.initFns.push(hooks.init);
  if (hooks.pre) this.preFns.push(hooks.pre);
  if (hooks.post) this.postFns.push(hooks.post);
  if (hooks.destroy) this.destroyFns.push(hooks.destroy);
};

function removeElement(array, item) {
  const index = array.indexOf(item);
  if (index === -1) return;
  array.splice(index, 1);
}

Hooks.prototype.remove = function (hooks) {
  if (hooks.init) removeElement(this.initFns, hooks.init);
  if (hooks.pre) removeElement(this.preFns, hooks.pre);
  if (hooks.post) removeElement(this.postFns, hooks.post);
  if (hooks.destroy) removeElement(this.destroyFns, hooks.destroy);
};

function AsyncHook() {
  this._state = new State();
  this._hooks = new Hooks();

  // expose version for conflict detection
  this.version = (__webpack_require__(/*! ./package.json */ "../../node_modules/async-hook-jl/package.json").version);

  // expose the Providers map
  this.providers = asyncWrap.Providers;

  // apply patches
  for (const key of Object.keys(patchs)) {
    patchs[key].call(this);
  }

  // setup async wrap
  if (process.env.hasOwnProperty('NODE_ASYNC_HOOK_WARNING')) {
    console.warn('warning: you are using async-hook-jl which is unstable.');
  }
  asyncWrap.setupHooks({
    init: this._hooks.init,
    pre: this._hooks.pre,
    post: this._hooks.post,
    destroy: this._hooks.destroy
  });
}
module.exports = AsyncHook;

AsyncHook.prototype.addHooks = function (hooks) {
  this._hooks.add(hooks);
};

AsyncHook.prototype.removeHooks = function (hooks) {
  this._hooks.remove(hooks);
};

AsyncHook.prototype.enable = function () {
  this._state.enabled = true;
  asyncWrap.enable();
};

AsyncHook.prototype.disable = function () {
  this._state.enabled = false;
  asyncWrap.disable();
};

/***/ }),

/***/ "../../node_modules/async-hook-jl/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/async-hook-jl/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AsyncHook = __webpack_require__(/*! ./async-hook.js */ "../../node_modules/async-hook-jl/async-hook.js");

// If a another copy (same version or not) of stack-chain exists it will result
// in wrong stack traces (most likely dublicate callSites).
if (global._asyncHook) {
  // In case the version match, we can simply return the first initialized copy
  if (global._asyncHook.version === (__webpack_require__(/*! ./package.json */ "../../node_modules/async-hook-jl/package.json").version)) {
    module.exports = global._asyncHook;
  }
  // The version don't match, this is really bad. Lets just throw
  else {
    throw new Error('Conflicting version of async-hook-jl found');
  }
} else {
  const stackChain = __webpack_require__(/*! stack-chain */ "../../node_modules/stack-chain/index.js");

  // Remove callSites from this module. AsyncWrap doesn't have any callSites
  // and the hooks are expected to be completely transparent.
  stackChain.filter.attach(function (error, frames) {
    return frames.filter(function (callSite) {
      const filename = callSite.getFileName();
      // filename is not always a string, for example in case of eval it is
      // undefined. So check if the filename is defined.
      return !(filename && filename.slice(0, __dirname.length) === __dirname);
    });
  });

  module.exports = global._asyncHook = new AsyncHook();
}

/***/ }),

/***/ "../../node_modules/async-hook-jl/patches/next-tick.js":
/*!*************************************************************!*\
  !*** ../../node_modules/async-hook-jl/patches/next-tick.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


function NextTickWrap() {}

module.exports = function patch() {
  const hooks = this._hooks;
  const state = this._state;

  const oldNextTick = process.nextTick;
  process.nextTick = function () {
    if (!state.enabled) return oldNextTick.apply(process, arguments);

    const args = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    const callback = args[0];

    if (typeof callback !== 'function') {
      throw new TypeError('callback is not a function');
    }

    const handle = new NextTickWrap();
    const uid = --state.counter;

    // call the init hook
    hooks.init.call(handle, uid, 0, null, null);

    // overwrite callback
    args[0] = function () {
      // call the pre hook
      hooks.pre.call(handle, uid);

      let didThrow = true;
      try {
        callback.apply(this, arguments);
        didThrow = false;
      } finally {
        // If `callback` threw and there is an uncaughtException handler
        // then call the `post` and `destroy` hook after the uncaughtException
        // user handlers have been invoked.
        if(didThrow && process.listenerCount('uncaughtException') > 0) {
          process.once('uncaughtException', function () {
            hooks.post.call(handle, uid, true);
            hooks.destroy.call(null, uid);
          });
        }
      }

      // callback done successfully
      hooks.post.call(handle, uid, false);
      hooks.destroy.call(null, uid);
    };

    return oldNextTick.apply(process, args);
  };
}


/***/ }),

/***/ "../../node_modules/async-hook-jl/patches/promise.js":
/*!***********************************************************!*\
  !*** ../../node_modules/async-hook-jl/patches/promise.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


function PromiseWrap() {}

module.exports = function patchPromise() {
  const hooks = this._hooks;
  const state = this._state;

  const Promise = global.Promise;

  /* As per ECMAScript 2015, .catch must be implemented by calling .then, as
   * such we need needn't patch .catch as well. see:
   * http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch
   */
  const oldThen = Promise.prototype.then;
  Promise.prototype.then = wrappedThen;

  function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {
    if ('function' !== typeof fn) {
      return isOnFulfilled
        ? makeUnhandledResolutionHandler(uid)
        : makeUnhandledRejectionHandler(uid);
    }

    return function wrappedHandler() {
      hooks.pre.call(handle, uid);
      try {
        return fn.apply(this, arguments);
      } finally {
        hooks.post.call(handle, uid, false);
        hooks.destroy.call(null, uid);
      }
    };
  }

  function makeUnhandledResolutionHandler(uid) {
    return function unhandledResolutionHandler(val) {
      hooks.destroy.call(null, uid);
      return val;
    };
  }

  function makeUnhandledRejectionHandler(uid) {
    return function unhandledRejectedHandler(val) {
      hooks.destroy.call(null, uid);
      throw val;
    };
  }

  function wrappedThen(onFulfilled, onRejected) {
    if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);

    const handle = new PromiseWrap();
    const uid = --state.counter;

    hooks.init.call(handle, uid, 0, null, null);

    return oldThen.call(
      this,
      makeWrappedHandler(onFulfilled, handle, uid, true),
      makeWrappedHandler(onRejected, handle, uid, false)
    );
  }
};


/***/ }),

/***/ "../../node_modules/async-hook-jl/patches/timers.js":
/*!**********************************************************!*\
  !*** ../../node_modules/async-hook-jl/patches/timers.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const timers = __webpack_require__(/*! timers */ "timers");

function TimeoutWrap() {}
function IntervalWrap() {}
function ImmediateWrap() {}

const timeoutMap = new Map();
const intervalMap = new Map();
const ImmediateMap = new Map();

let activeCallback = null;
let clearedInCallback = false;

module.exports = function patch() {
  patchTimer(this._hooks, this._state, 'setTimeout', 'clearTimeout', TimeoutWrap, timeoutMap, true);
  patchTimer(this._hooks, this._state, 'setInterval', 'clearInterval', IntervalWrap, intervalMap, false);
  patchTimer(this._hooks, this._state, 'setImmediate', 'clearImmediate', ImmediateWrap, ImmediateMap, true);

  global.setTimeout = timers.setTimeout;
  global.setInterval = timers.setInterval;
  global.setImmediate = timers.setImmediate;

  global.clearTimeout = timers.clearTimeout;
  global.clearInterval = timers.clearInterval;
  global.clearImmediate = timers.clearImmediate;
};

function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
  const oldSetFn = timers[setFn];
  const oldClearFn = timers[clearFn];

  // overwrite set[Timeout]
  timers[setFn] = function () {
    if (!state.enabled) return oldSetFn.apply(timers, arguments);

    const args = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    const callback = args[0];

    if (typeof callback !== 'function') {
      throw new TypeError('"callback" argument must be a function');
    }

    const handle = new Handle();
    const uid = --state.counter;
    let timerId = undefined;

    // call the init hook
    hooks.init.call(handle, uid, 0, null, null);

    // overwrite callback
    args[0] = function () {
      // call the pre hook
      activeCallback = timerId;
      hooks.pre.call(handle, uid);

      let didThrow = true;
      try {
        callback.apply(this, arguments);
        didThrow = false;
      } finally {
        // If `callback` threw and there is an uncaughtException handler
        // then call the `post` and `destroy` hook after the uncaughtException
        // user handlers have been invoked.
        if (didThrow && process.listenerCount('uncaughtException') > 0) {
          process.once('uncaughtException', function () {
            // call the post hook
            hooks.post.call(handle, uid, true);
            // setInterval won't continue
            timerMap.delete(timerId);
            hooks.destroy.call(null, uid);
          });
        }
      }

      // callback done successfully
      hooks.post.call(handle, uid, false);
      activeCallback = null;

      // call the destroy hook if the callback will only be called once
      if (singleCall || clearedInCallback) {
        clearedInCallback = false;
        timerMap.delete(timerId);
        hooks.destroy.call(null, uid);
      }
    };

    timerId = oldSetFn.apply(timers, args);
    // Bind the timerId and uid for later use, in case the clear* function is
    // called.
    timerMap.set(timerId, uid);

    return timerId;
  };

  // overwrite clear[Timeout]
  timers[clearFn] = function (timerId) {
    // If clear* was called within the timer callback, then delay the destroy
    // event to after the post event has been called.
    if (activeCallback === timerId && timerId !== null) {
      clearedInCallback = true;
    }
    // clear should call the destroy hook. Note if timerId doesn't exists
    // it is because asyncWrap wasn't enabled at the time.
    else if (timerMap.has(timerId)) {
      const uid = timerMap.get(timerId);
      timerMap.delete(timerId);
      hooks.destroy.call(null, uid);
    }

    oldClearFn.apply(timers, arguments);
  };
}


/***/ }),

/***/ "../../node_modules/async-listener/es6-wrapped-promise.js":
/*!****************************************************************!*\
  !*** ../../node_modules/async-listener/es6-wrapped-promise.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (Promise, ensureAslWrapper) => {
  // Updates to this class should also be applied to the the ES3 version
  // in index.js.
  return class WrappedPromise extends Promise {
    constructor(executor) {
      var context, args;
      super(wrappedExecutor);
      var promise = this;

      try {
        executor.apply(context, args);
      } catch (err) {
        args[1](err);
      }

      return promise;
      function wrappedExecutor(resolve, reject) {
        context = this;
        args = [wrappedResolve, wrappedReject];

        // These wrappers create a function that can be passed a function and an argument to
        // call as a continuation from the resolve or reject.
        function wrappedResolve(val) {
          ensureAslWrapper(promise, false);
          return resolve(val);
        }

        function wrappedReject(val) {
          ensureAslWrapper(promise, false);
          return reject(val);
        }
      }
    }
  }
};


/***/ }),

/***/ "../../node_modules/async-listener/glue.js":
/*!*************************************************!*\
  !*** ../../node_modules/async-listener/glue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrap = (__webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js").wrap);

/*
 *
 * CONSTANTS
 *
 */
var HAS_CREATE_AL = 1 << 0;
var HAS_BEFORE_AL = 1 << 1;
var HAS_AFTER_AL = 1 << 2;
var HAS_ERROR_AL = 1 << 3;

/**
 * There is one list of currently active listeners that is mutated in place by
 * addAsyncListener and removeAsyncListener. This complicates error-handling,
 * for reasons that are discussed below.
 */
var listeners = [];

/**
 * There can be multiple listeners with the same properties, so disambiguate
 * them by assigning them an ID at creation time.
 */
var uid = 0;

/**
 * Ensure that errors coming from within listeners are handed off to domains,
 * process._fatalException, or uncaughtException without being treated like
 * user errors.
 */
var inAsyncTick = false;

/**
 * Because asynchronous contexts can be nested, and errors can come from anywhere
 * in the stack, a little extra work is required to keep track of where in the
 * nesting we are. Because JS arrays are frequently mutated in place
 */
var listenerStack = [];

/**
 * The error handler on a listener can capture errors thrown during synchronous
 * execution immediately after the listener is added. To capture both
 * synchronous and asynchronous errors, the error handler just uses the
 * "global" list of active listeners, and the rest of the code ensures that the
 * listener list is correct by using a stack of listener lists during
 * asynchronous execution.
 */
var asyncCatcher;

/**
 * The guts of the system -- called each time an asynchronous event happens
 * while one or more listeners are active.
 */
var asyncWrap;

/**
 * Simple helper function that's probably faster than using Array
 * filter methods and can be inlined.
 */
function union(dest, added) {
  var destLength = dest.length;
  var addedLength = added.length;
  var returned = [];

  if (destLength === 0 && addedLength === 0) return returned;

  for (var j  = 0; j < destLength; j++) returned[j] = dest[j];

  if (addedLength === 0) return returned;

  for (var i = 0; i < addedLength; i++) {
    var missing = true;
    for (j = 0; j < destLength; j++) {
      if (dest[j].uid === added[i].uid) {
        missing = false;
        break;
      }
    }
    if (missing) returned.push(added[i]);
  }

  return returned;
}

/*
 * For performance, split error-handlers and asyncCatcher up into two separate
 * code paths.
 */

// 0.9+
if (process._fatalException) {
  /**
   * Error handlers on listeners can throw, the catcher needs to be able to
   * discriminate between exceptions thrown by user code, and exceptions coming
   * from within the catcher itself. Use a global to keep track of which state
   * the catcher is currently in.
   */
  var inErrorTick = false;

  /**
   * Throwing always happens synchronously. If the current array of values for
   * the current list of asyncListeners is put in a module-scoped variable right
   * before a call that can throw, it will always be correct when the error
   * handlers are run.
   */
  var errorValues;

  asyncCatcher = function asyncCatcher(er) {
    var length = listeners.length;
    if (inErrorTick || length === 0) return false;

    var handled = false;

    /*
     * error handlers
     */
    inErrorTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if ((listener.flags & HAS_ERROR_AL) === 0) continue;

      var value = errorValues && errorValues[listener.uid];
      handled = listener.error(value, er) || handled;
    }
    inErrorTick = false;

    /* Test whether there are any listener arrays on the stack. In the case of
     * synchronous throws when the listener is active, there may have been
     * none pushed yet.
     */
    if (listenerStack.length > 0) listeners = listenerStack.pop();
    errorValues = undefined;

    return handled && !inAsyncTick;
  };

  asyncWrap = function asyncWrap(original, list, length) {
    var values = [];

    /*
     * listeners
     */
    inAsyncTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      values[listener.uid] = listener.data;

      if ((listener.flags & HAS_CREATE_AL) === 0) continue;

      var value = listener.create(listener.data);
      if (value !== undefined) values[listener.uid] = value;
    }
    inAsyncTick = false;

    /* One of the main differences between this polyfill and the core
     * asyncListener support is that core avoids creating closures by putting a
     * lot of the state managemnt on the C++ side of Node (and of course also it
     * bakes support for async listeners into the Node C++ API through the
     * AsyncWrap class, which means that it doesn't monkeypatch basically every
     * async method like this does).
     */
    return function () {
      // put the current values where the catcher can see them
      errorValues = values;

      /* More than one listener can end up inside these closures, so save the
       * current listeners on a stack.
       */
      listenerStack.push(listeners);

      /* Activate both the listeners that were active when the closure was
       * created and the listeners that were previously active.
       */
      listeners = union(list, listeners);

      /*
       * before handlers
       */
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_BEFORE_AL) > 0) {
          list[i].before(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // save the return value to pass to the after callbacks
      var returned = original.apply(this, arguments);

      /*
       * after handlers (not run if original throws)
       */
      inAsyncTick = true;
      for (i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_AFTER_AL) > 0) {
          list[i].after(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // back to the previous listener list on the stack
      listeners = listenerStack.pop();
      errorValues = undefined;

      return returned;
    };
  };

  wrap(process, '_fatalException', function (_fatalException) {
    return function _asyncFatalException(er) {
      return asyncCatcher(er) || _fatalException(er);
    };
  });
}
// 0.8 and below
else {
  /**
   * If an error handler in asyncWrap throws, the process must die. Under 0.8
   * and earlier the only way to put a bullet through the head of the process
   * is to rethrow from inside the exception handler, so rethrow and set
   * errorThrew to tell the uncaughtHandler what to do.
   */
  var errorThrew = false;

  /**
   * Under Node 0.8, this handler *only* handles synchronously thrown errors.
   * This simplifies it, which almost but not quite makes up for the hit taken
   * by putting everything in a try-catch.
   */
  asyncCatcher = function uncaughtCatcher(er) {
    // going down hard
    if (errorThrew) throw er;

    var handled = false;

    /*
     * error handlers
     */
    var length = listeners.length;
    for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if ((listener.flags & HAS_ERROR_AL) === 0) continue;
      handled = listener.error(null, er) || handled;
    }

    /* Rethrow if one of the before / after handlers fire, which will bring the
     * process down immediately.
     */
    if (!handled && inAsyncTick) throw er;
  };

  asyncWrap = function asyncWrap(original, list, length) {
    var values = [];

    /*
     * listeners
     */
    inAsyncTick = true;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      values[listener.uid] = listener.data;

      if ((listener.flags & HAS_CREATE_AL) === 0) continue;

      var value = listener.create(listener.data);
      if (value !== undefined) values[listener.uid] = value;
    }
    inAsyncTick = false;

    /* One of the main differences between this polyfill and the core
     * asyncListener support is that core avoids creating closures by putting a
     * lot of the state managemnt on the C++ side of Node (and of course also it
     * bakes support for async listeners into the Node C++ API through the
     * AsyncWrap class, which means that it doesn't monkeypatch basically every
     * async method like this does).
     */
    return function () {
      /*jshint maxdepth:4*/

      // after() handlers don't run if threw
      var threw = false;

      // ...unless the error is handled
      var handled = false;

      /* More than one listener can end up inside these closures, so save the
       * current listeners on a stack.
       */
      listenerStack.push(listeners);

      /* Activate both the listeners that were active when the closure was
       * created and the listeners that were previously active.
       */
      listeners = union(list, listeners);

      /*
       * before handlers
       */
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        if ((list[i].flags & HAS_BEFORE_AL) > 0) {
          list[i].before(this, values[list[i].uid]);
        }
      }
      inAsyncTick = false;

      // save the return value to pass to the after callbacks
      var returned;
      try {
        returned = original.apply(this, arguments);
      }
      catch (er) {
        threw = true;
        for (var i = 0; i < length; ++i) {
          if ((listeners[i].flags & HAS_ERROR_AL) == 0) continue;
          try {
            handled = listeners[i].error(values[list[i].uid], er) || handled;
          }
          catch (x) {
            errorThrew = true;
            throw x;
          }
        }

        if (!handled) {
          // having an uncaughtException handler here alters crash semantics
          process.removeListener('uncaughtException', asyncCatcher);
          process._originalNextTick(function () {
            process.addListener('uncaughtException', asyncCatcher);
          });

          throw er;
        }
      }
      finally {
        /*
         * after handlers (not run if original throws)
         */
        if (!threw || handled) {
          inAsyncTick = true;
          for (i = 0; i < length; ++i) {
            if ((list[i].flags & HAS_AFTER_AL) > 0) {
              list[i].after(this, values[list[i].uid]);
            }
          }
          inAsyncTick = false;
        }

        // back to the previous listener list on the stack
        listeners = listenerStack.pop();
      }


      return returned;
    };
  };

  // will be the first to fire if async-listener is the first module loaded
  process.addListener('uncaughtException', asyncCatcher);
}

// for performance in the case where there are no handlers, just the listener
function simpleWrap(original, list, length) {
  inAsyncTick = true;
  for (var i = 0; i < length; ++i) {
    var listener = list[i];
    if (listener.create) listener.create(listener.data);
  }
  inAsyncTick = false;

  // still need to make sure nested async calls are made in the context
  // of the listeners active at their creation
  return function () {
    listenerStack.push(listeners);
    listeners = union(list, listeners);

    var returned = original.apply(this, arguments);

    listeners = listenerStack.pop();

    return returned;
  };
}

/**
 * Called each time an asynchronous function that's been monkeypatched in
 * index.js is called. If there are no listeners, return the function
 * unwrapped.  If there are any asyncListeners and any of them have callbacks,
 * pass them off to asyncWrap for later use, otherwise just call the listener.
 */
function wrapCallback(original) {
  var length = listeners.length;

  // no context to capture, so avoid closure creation
  if (length === 0) return original;

  // capture the active listeners as of when the wrapped function was called
  var list = listeners.slice();

  for (var i = 0; i < length; ++i) {
    if (list[i].flags > 0) return asyncWrap(original, list, length);
  }

  return simpleWrap(original, list, length);
}

function AsyncListener(callbacks, data) {
  if (typeof callbacks.create === 'function') {
    this.create = callbacks.create;
    this.flags |= HAS_CREATE_AL;
  }

  if (typeof callbacks.before === 'function') {
    this.before = callbacks.before;
    this.flags |= HAS_BEFORE_AL;
  }

  if (typeof callbacks.after === 'function') {
    this.after = callbacks.after;
    this.flags |= HAS_AFTER_AL;
  }

  if (typeof callbacks.error === 'function') {
    this.error = callbacks.error;
    this.flags |= HAS_ERROR_AL;
  }

  this.uid = ++uid;
  this.data = data === undefined ? null : data;
}
AsyncListener.prototype.create = undefined;
AsyncListener.prototype.before = undefined;
AsyncListener.prototype.after  = undefined;
AsyncListener.prototype.error  = undefined;
AsyncListener.prototype.data   = undefined;
AsyncListener.prototype.uid    = 0;
AsyncListener.prototype.flags  = 0;

function createAsyncListener(callbacks, data) {
  if (typeof callbacks !== 'object' || !callbacks) {
    throw new TypeError('callbacks argument must be an object');
  }

  if (callbacks instanceof AsyncListener) {
    return callbacks;
  }
  else {
    return new AsyncListener(callbacks, data);
  }
}

function addAsyncListener(callbacks, data) {
  var listener;
  if (!(callbacks instanceof AsyncListener)) {
    listener = createAsyncListener(callbacks, data);
  }
  else {
    listener = callbacks;
  }

  // Make sure the listener isn't already in the list.
  var registered = false;
  for (var i = 0; i < listeners.length; i++) {
    if (listener === listeners[i]) {
      registered = true;
      break;
    }
  }

  if (!registered) listeners.push(listener);

  return listener;
}

function removeAsyncListener(listener) {
  for (var i = 0; i < listeners.length; i++) {
    if (listener === listeners[i]) {
      listeners.splice(i, 1);
      break;
    }
  }
}

process.createAsyncListener = createAsyncListener;
process.addAsyncListener    = addAsyncListener;
process.removeAsyncListener = removeAsyncListener;

module.exports = wrapCallback;


/***/ }),

/***/ "../../node_modules/async-listener/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/async-listener/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed");

var shimmer      = __webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js")
  , semver       = __webpack_require__(/*! semver */ "../../node_modules/async-listener/node_modules/semver/semver.js")
  , wrap         = shimmer.wrap
  , massWrap     = shimmer.massWrap
  , wrapCallback = __webpack_require__(/*! ./glue.js */ "../../node_modules/async-listener/glue.js")
  , util         = __webpack_require__(/*! util */ "util")
  ;

var v6plus = semver.gte(process.version, '6.0.0');
var v7plus = semver.gte(process.version, '7.0.0');
var v8plus = semver.gte(process.version, '8.0.0');
var v11plus = semver.gte(process.version, '11.0.0');

var net = __webpack_require__(/*! net */ "net");

// From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs
if (v7plus && !net._normalizeArgs) {
  // a polyfill in our polyfill etc so forth -- taken from node master on 2017/03/09
  net._normalizeArgs = function (args) {
    if (args.length === 0) {
      return [{}, null];
    }

    var arg0 = args[0];
    var options = {};
    if (typeof arg0 === 'object' && arg0 !== null) {
      // (options[...][, cb])
      options = arg0;
    } else if (isPipeName(arg0)) {
      // (path[...][, cb])
      options.path = arg0;
    } else {
      // ([port][, host][...][, cb])
      options.port = arg0;
      if (args.length > 1 && typeof args[1] === 'string') {
        options.host = args[1];
      }
    }

    var cb = args[args.length - 1];
    if (typeof cb !== 'function')
      return [options, null];
    else
      return [options, cb];
  }
} else if (!v7plus && !net._normalizeConnectArgs) {
  // a polyfill in our polyfill etc so forth -- taken from node master on 2013/10/30
  net._normalizeConnectArgs = function (args) {
    var options = {};

    function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }

    if (typeof args[0] === 'object' && args[0] !== null) {
      // connect(options, [cb])
      options = args[0];
    }
    else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {
      // connect(path, [cb]);
      options.path = args[0];
    }
    else {
      // connect(port, [host], [cb])
      options.port = args[0];
      if (typeof args[1] === 'string') {
        options.host = args[1];
      }
    }

    var cb = args[args.length - 1];
    return typeof cb === 'function' ? [options, cb] : [options];
  };
}

// In https://github.com/nodejs/node/pull/11796 `_listen2` was renamed
// `_setUpListenHandle`. It's still aliased as `_listen2`, and currently the
// Node internals still call the alias - but who knows for how long. So better
// make sure we use the new name instead if available.
if ('_setUpListenHandle' in net.Server.prototype) {
  wrap(net.Server.prototype, '_setUpListenHandle', wrapSetUpListenHandle);
} else {
  wrap(net.Server.prototype, '_listen2', wrapSetUpListenHandle);
}

function wrapSetUpListenHandle(original) {
  return function () {
    this.on('connection', function (socket) {
      if (socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
      }
    });

    try {
      return original.apply(this, arguments);
    }
    finally {
      // the handle will only not be set in cases where there has been an error
      if (this._handle && this._handle.onconnection) {
        this._handle.onconnection = wrapCallback(this._handle.onconnection);
      }
    }
  };
}

function patchOnRead(ctx) {
  if (ctx && ctx._handle) {
    var handle = ctx._handle;
    if (!handle._originalOnread) {
      handle._originalOnread = handle.onread;
    }
    handle.onread = wrapCallback(handle._originalOnread);
  }
}

wrap(net.Socket.prototype, 'connect', function (original) {
  return function () {
    var args;
    // Node core uses an internal Symbol here to guard against the edge-case
    // where the user accidentally passes in an array. As we don't have access
    // to this Symbol we resort to this hack where we just detect if there is a
    // symbol or not. Checking for the number of Symbols is by no means a fool
    // proof solution, but it catches the most basic cases.
    if (v8plus &&
        Array.isArray(arguments[0]) &&
        Object.getOwnPropertySymbols(arguments[0]).length > 0) {
      // already normalized
      args = arguments[0];
    } else {
      // From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs
      args = v7plus
        ? net._normalizeArgs(arguments)
        : net._normalizeConnectArgs(arguments);
    }
    if (args[1]) args[1] = wrapCallback(args[1]);
    var result = original.apply(this, args);
    patchOnRead(this);
    return result;
  };
});

var http = __webpack_require__(/*! http */ "http");

// NOTE: A rewrite occurred in 0.11 that changed the addRequest signature
// from (req, host, port, localAddress) to (req, options)
// Here, I use the longer signature to maintain 0.10 support, even though
// the rest of the arguments aren't actually used
wrap(http.Agent.prototype, 'addRequest', function (original) {
  return function (req) {
    var onSocket = req.onSocket;
    req.onSocket = wrapCallback(function (socket) {
      patchOnRead(socket);
      return onSocket.apply(this, arguments);
    });
    return original.apply(this, arguments);
  };
});

var childProcess = __webpack_require__(/*! child_process */ "child_process");

function wrapChildProcess(child) {
  if (Array.isArray(child.stdio)) {
    child.stdio.forEach(function (socket) {
      if (socket && socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
        wrap(socket._handle, 'close', activatorFirst);
      }
    });
  }

  if (child._handle) {
    child._handle.onexit = wrapCallback(child._handle.onexit);
  }
}

// iojs v2.0.0+
if (childProcess.ChildProcess) {
  wrap(childProcess.ChildProcess.prototype, 'spawn', function (original) {
    return function () {
      var result = original.apply(this, arguments);
      wrapChildProcess(this);
      return result;
    };
  });
} else {
  massWrap(childProcess, [
    'execFile', // exec is implemented in terms of execFile
    'fork',
    'spawn'
  ], function (original) {
    return function () {
      var result = original.apply(this, arguments);
      wrapChildProcess(result);
      return result;
    };
  });
}

// need unwrapped nextTick for use within < 0.9 async error handling
if (!process._fatalException) {
  process._originalNextTick = process.nextTick;
}

var processors = [];
if (process._nextDomainTick) processors.push('_nextDomainTick');
if (process._tickDomainCallback) processors.push('_tickDomainCallback');

massWrap(
  process,
  processors,
  activator
);
wrap(process, 'nextTick', activatorFirst);

var asynchronizers = [
  'setTimeout',
  'setInterval'
];
if (global.setImmediate) asynchronizers.push('setImmediate');

var timers = __webpack_require__(/*! timers */ "timers");
var patchGlobalTimers = global.setTimeout === timers.setTimeout;

massWrap(
  timers,
  asynchronizers,
  activatorFirst
);

if (patchGlobalTimers) {
  massWrap(
    global,
    asynchronizers,
    activatorFirst
  );
}

var dns = __webpack_require__(/*! dns */ "dns");
massWrap(
  dns,
  [
    'lookup',
    'resolve',
    'resolve4',
    'resolve6',
    'resolveCname',
    'resolveMx',
    'resolveNs',
    'resolveTxt',
    'resolveSrv',
    'reverse'
  ],
  activator
);

if (dns.resolveNaptr) wrap(dns, 'resolveNaptr', activator);

var fs = __webpack_require__(/*! fs */ "fs");
massWrap(
  fs,
  [
    'watch',
    'rename',
    'truncate',
    'chown',
    'fchown',
    'chmod',
    'fchmod',
    'stat',
    'lstat',
    'fstat',
    'link',
    'symlink',
    'readlink',
    'realpath',
    'unlink',
    'rmdir',
    'mkdir',
    'readdir',
    'close',
    'open',
    'utimes',
    'futimes',
    'fsync',
    'write',
    'read',
    'readFile',
    'writeFile',
    'appendFile',
    'watchFile',
    'unwatchFile',
    "exists",
  ],
  activator
);

// only wrap lchown and lchmod on systems that have them.
if (fs.lchown) wrap(fs, 'lchown', activator);
if (fs.lchmod) wrap(fs, 'lchmod', activator);

// only wrap ftruncate in versions of node that have it
if (fs.ftruncate) wrap(fs, 'ftruncate', activator);

// Wrap zlib streams
var zlib;
try { zlib = __webpack_require__(/*! zlib */ "zlib"); } catch (err) { }
if (zlib && zlib.Deflate && zlib.Deflate.prototype) {
  var proto = Object.getPrototypeOf(zlib.Deflate.prototype);
  if (proto._transform) {
    // streams2
    wrap(proto, "_transform", activator);
  }
  else if (proto.write && proto.flush && proto.end) {
    // plain ol' streams
    massWrap(
      proto,
      [
        'write',
        'flush',
        'end'
      ],
      activator
    );
  }
}

// Wrap Crypto
var crypto;
try { crypto = __webpack_require__(/*! crypto */ "crypto"); } catch (err) { }
if (crypto) {

  var toWrap = [
      'pbkdf2',
      'randomBytes',
  ];
  if (!v11plus) {
    toWrap.push('pseudoRandomBytes');
  }

  massWrap(crypto, toWrap, activator);
}

// It is unlikely that any userspace promise implementations have a native
// implementation of both Promise and Promise.toString.
var instrumentPromise = !!global.Promise &&
    Promise.toString() === 'function Promise() { [native code] }' &&
    Promise.toString.toString() === 'function toString() { [native code] }';

// Check that global Promise is native
if (instrumentPromise) {
  // shoult not use any methods that have already been wrapped
  var promiseListener = process.addAsyncListener({
    create: function create() {
      instrumentPromise = false;
    }
  });

  // should not resolve synchronously
  global.Promise.resolve(true).then(function notSync() {
    instrumentPromise = false;
  });

  process.removeAsyncListener(promiseListener);
}

/*
 * Native promises use the microtask queue to make all callbacks run
 * asynchronously to avoid Zalgo issues. Since the microtask queue is not
 * exposed externally, promises need to be modified in a fairly invasive and
 * complex way.
 *
 * The async boundary in promises that must be patched is between the
 * fulfillment of the promise and the execution of any callback that is waiting
 * for that fulfillment to happen. This means that we need to trigger a create
 * when resolve or reject is called and trigger before, after and error handlers
 * around the callback execution. There may be multiple callbacks for each
 * fulfilled promise, so handlers will behave similar to setInterval where
 * there may be multiple before after and error calls for each create call.
 *
 * async-listener monkeypatching has one basic entry point: `wrapCallback`.
 * `wrapCallback` should be called when create should be triggered and be
 * passed a function to wrap, which will execute the body of the async work.
 * The resolve and reject calls can be modified fairly easily to call
 * `wrapCallback`, but at the time of resolve and reject all the work to be done
 * on fulfillment may not be defined, since a call to then, chain or fetch can
 * be made even after the promise has been fulfilled. To get around this, we
 * create a placeholder function which will call a function passed into it,
 * since the call to the main work is being made from within the wrapped
 * function, async-listener will work correctly.
 *
 * There is another complication with monkeypatching Promises. Calls to then,
 * chain and catch each create new Promises that are fulfilled internally in
 * different ways depending on the return value of the callback. When the
 * callback return a Promise, the new Promise is resolved asynchronously after
 * the returned Promise has been also been resolved. When something other than
 * a promise is resolved the resolve call for the new Promise is put in the
 * microtask queue and asynchronously resolved.
 *
 * Then must be wrapped so that its returned promise has a wrapper that can be
 * used to invoke further continuations. This wrapper cannot be created until
 * after the callback has run, since the callback may return either a promise
 * or another value. Fortunately we already have a wrapper function around the
 * callback we can use (the wrapper created by resolve or reject).
 *
 * By adding an additional argument to this wrapper, we can pass in the
 * returned promise so it can have its own wrapper appended. the wrapper
 * function can the call the callback, and take action based on the return
 * value. If a promise is returned, the new Promise can proxy the returned
 * Promise's wrapper (this wrapper may not exist yet, but will by the time the
 * wrapper needs to be invoked). Otherwise, a new wrapper can be create the
 * same way as in resolve and reject. Since this wrapper is created
 * synchronously within another wrapper, it will properly appear as a
 * continuation from within the callback.
 */

if (instrumentPromise) {
  wrapPromise();
}

function wrapPromise() {
  var Promise = global.Promise;

  // Updates to this class should also be applied to the the ES6 version
  // in es6-wrapped-promise.js.
  function wrappedPromise(executor) {
    if (!(this instanceof wrappedPromise)) {
      return Promise(executor);
    }

    if (typeof executor !== 'function') {
      return new Promise(executor);
    }

    var context, args;
    var promise = new Promise(wrappedExecutor);
    promise.__proto__ = wrappedPromise.prototype;

    try {
      executor.apply(context, args);
    } catch (err) {
      args[1](err);
    }

    return promise;

    function wrappedExecutor(resolve, reject) {
      context = this;
      args = [wrappedResolve, wrappedReject];

      // These wrappers create a function that can be passed a function and an argument to
      // call as a continuation from the resolve or reject.
      function wrappedResolve(val) {
        ensureAslWrapper(promise, false);
        return resolve(val);
      }

      function wrappedReject(val) {
        ensureAslWrapper(promise, false);
        return reject(val);
      }
    }
  }

  util.inherits(wrappedPromise, Promise);

  wrap(Promise.prototype, 'then', wrapThen);
  // Node.js <v7 only, alias for .then
  if (Promise.prototype.chain) {
    wrap(Promise.prototype, 'chain', wrapThen);
  }

  if (v6plus) {
    global.Promise = __webpack_require__(/*! ./es6-wrapped-promise.js */ "../../node_modules/async-listener/es6-wrapped-promise.js")(Promise, ensureAslWrapper);
  } else {
    var PromiseFunctions = [
      'all',
      'race',
      'reject',
      'resolve',
      'accept',  // Node.js <v7 only
      'defer'    // Node.js <v7 only
    ];

    PromiseFunctions.forEach(function(key) {
      // don't break `in` by creating a key for undefined entries
      if (typeof Promise[key] === 'function') {
        wrappedPromise[key] = Promise[key];
      }
    });
    global.Promise = wrappedPromise
  }

  function ensureAslWrapper(promise, overwrite) {
    if (!promise.__asl_wrapper || overwrite) {
      promise.__asl_wrapper = wrapCallback(propagateAslWrapper);
    }
  }

  function propagateAslWrapper(ctx, fn, result, next) {
    var nextResult;
    try {
      nextResult = fn.call(ctx, result);
      return {returnVal: nextResult, error: false}
    } catch (err) {
      return {errorVal: err, error: true}
    } finally {
      // Wrap any resulting futures as continuations.
      if (nextResult instanceof Promise) {
        next.__asl_wrapper = function proxyWrapper() {
          var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
          return aslWrapper.apply(this, arguments);
        }
      } else {
        ensureAslWrapper(next, true);
      }
    }
  }

  function wrapThen(original) {
    return function wrappedThen() {
      var promise = this;
      var next = original.apply(promise, Array.prototype.map.call(arguments, bind));

      next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {
        if (promise.__asl_wrapper) {
          promise.__asl_wrapper(ctx, function () {}, null, next);
          return next.__asl_wrapper(ctx, fn, val, last);
        }
        return propagateAslWrapper(ctx, fn, val, last);
      }

      return next;

      // wrap callbacks (success, error) so that the callbacks will be called as a
      // continuations of the resolve or reject call using the __asl_wrapper created above.
      function bind(fn) {
        if (typeof fn !== 'function') return fn;
        return wrapCallback(function (val) {
          var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
          if (result.error) {
            throw result.errorVal
          } else {
            return result.returnVal
          }
        });
      }
    }
  }
}

// Shim activator for functions that have callback last
function activator(fn) {
  var fallback = function () {
    var args;
    var cbIdx = arguments.length - 1;
    if (typeof arguments[cbIdx] === "function") {
      args = Array(arguments.length)
      for (var i = 0; i < arguments.length - 1; i++) {
        args[i] = arguments[i];
      }
      args[cbIdx] = wrapCallback(arguments[cbIdx]);
    }
    return fn.apply(this, args || arguments);
  };
  // Preserve function length for small arg count functions.
  switch (fn.length) {
    case 1:
      return function (cb) {
        if (arguments.length !== 1) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb);
      };
    case 2:
      return function (a, cb) {
        if (arguments.length !== 2) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, cb);
      };
    case 3:
      return function (a, b, cb) {
        if (arguments.length !== 3) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, cb);
      };
    case 4:
      return function (a, b, c, cb) {
        if (arguments.length !== 4) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, cb);
      };
    case 5:
      return function (a, b, c, d, cb) {
        if (arguments.length !== 5) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, d, cb);
      };
    case 6:
      return function (a, b, c, d, e, cb) {
        if (arguments.length !== 6) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, a, b, c, d, e, cb);
      };
    default:
      return fallback;
  }
}

// Shim activator for functions that have callback first
function activatorFirst(fn) {
  var fallback = function () {
    var args;
    if (typeof arguments[0] === "function") {
      args = Array(arguments.length)
      args[0] = wrapCallback(arguments[0]);
      for (var i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
    }
    return fn.apply(this, args || arguments);
  };
  // Preserve function length for small arg count functions.
  switch (fn.length) {
    case 1:
      return function (cb) {
        if (arguments.length !== 1) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb);
      };
    case 2:
      return function (cb, a) {
        if (arguments.length !== 2) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a);
      };
    case 3:
      return function (cb, a, b) {
        if (arguments.length !== 3) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b);
      };
    case 4:
      return function (cb, a, b, c) {
        if (arguments.length !== 4) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c);
      };
    case 5:
      return function (cb, a, b, c, d) {
        if (arguments.length !== 5) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c, d);
      };
    case 6:
      return function (cb, a, b, c, d, e) {
        if (arguments.length !== 6) return fallback.apply(this, arguments);
        if (typeof cb === "function") cb = wrapCallback(cb);
        return fn.call(this, cb, a, b, c, d, e);
      };
    default:
      return fallback;
  }
}

// taken from node master on 2017/03/09
function toNumber(x) {
  return (x = Number(x)) >= 0 ? x : false;
}

// taken from node master on 2017/03/09
function isPipeName(s) {
  return typeof s === 'string' && toNumber(s) === false;
}


/***/ }),

/***/ "../../node_modules/async-listener/node_modules/semver/semver.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/async-listener/node_modules/semver/semver.js ***!
  \***********************************************************************/
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ "../../node_modules/bufferutil/fallback.js":
/*!*************************************************!*\
  !*** ../../node_modules/bufferutil/fallback.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ "../../node_modules/bufferutil/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/bufferutil/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "../../node_modules/bufferutil/fallback.js");
}


/***/ }),

/***/ "../../node_modules/camelcase/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/camelcase/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports["default"] = camelCase;


/***/ }),

/***/ "../../node_modules/cls-hooked/context-legacy.js":
/*!*******************************************************!*\
  !*** ../../node_modules/cls-hooked/context-legacy.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! util */ "util");
const assert = __webpack_require__(/*! assert */ "assert");
const wrapEmitter = __webpack_require__(/*! emitter-listener */ "../../node_modules/emitter-listener/listener.js");
const asyncHook = __webpack_require__(/*! async-hook-jl */ "../../node_modules/async-hook-jl/index.js");

const CONTEXTS_SYMBOL = 'cls@contexts';
const ERROR_SYMBOL = 'error@context';

//const trace = [];

const invertedProviders = [];
for (let key in asyncHook.providers) {
  invertedProviders[asyncHook.providers[key]] = key;
}

const DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;

let currentUid = -1;

module.exports = {
  getNamespace: getNamespace,
  createNamespace: createNamespace,
  destroyNamespace: destroyNamespace,
  reset: reset,
  //trace: trace,
  ERROR_SYMBOL: ERROR_SYMBOL
};

function Namespace(name) {
  this.name = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set = [];
  this.id = null;
  this._contexts = new Map();
}

Namespace.prototype.set = function set(key, value) {
  if (!this.active) {
    throw new Error('No context available. ns.run() or ns.bind() must be called first.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2('    SETTING KEY:' + key + '=' + value + ' in ns:' + this.name + ' uid:' + currentUid + ' active:' +
      util.inspect(this.active, true));
  }
  this.active[key] = value;
  return value;
};

Namespace.prototype.get = function get(key) {
  if (!this.active) {
    if (DEBUG_CLS_HOOKED) {
      debug2('    GETTING KEY:' + key + '=undefined' + ' ' + this.name + ' uid:' + currentUid + ' active:' +
        util.inspect(this.active, true));
    }
    return undefined;
  }
  if (DEBUG_CLS_HOOKED) {
    debug2('    GETTING KEY:' + key + '=' + this.active[key] + ' ' + this.name + ' uid:' + currentUid + ' active:' +
      util.inspect(this.active, true));
  }
  return this.active[key];
};

Namespace.prototype.createContext = function createContext() {
  if (DEBUG_CLS_HOOKED) {
    debug2('   CREATING Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' active:' +
      util.inspect(this.active, true, 2, true));
  }

  let context = Object.create(this.active ? this.active : Object.prototype);
  context._ns_name = this.name;
  context.id = currentUid;

  if (DEBUG_CLS_HOOKED) {
    debug2('   CREATED Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' context:' +
      util.inspect(context, true, 2, true));
  }

  return context;
};

Namespace.prototype.run = function run(fn) {
  let context = this.createContext();
  this.enter(context);
  try {
    if (DEBUG_CLS_HOOKED) {
      debug2(' BEFORE RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
        util.inspect(context));
    }
    fn(context);
    return context;
  }
  catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  }
  finally {
    if (DEBUG_CLS_HOOKED) {
      debug2(' AFTER RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
        util.inspect(context));
    }
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function runAndReturn(fn) {
  var value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

/**
 * Uses global Promise and assumes Promise is cls friendly or wrapped already.
 * @param {function} fn
 * @returns {*}
 */
Namespace.prototype.runPromise = function runPromise(fn) {
  let context = this.createContext();
  this.enter(context);

  let promise = fn(context);
  if (!promise || !promise.then || !promise.catch) {
    throw new Error('fn must return a promise.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2(' BEFORE runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
      util.inspect(context));
  }

  return promise
    .then(result => {
      if (DEBUG_CLS_HOOKED) {
        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
          util.inspect(context));
      }
      this.exit(context);
      return result;
    })
    .catch(err => {
      err[ERROR_SYMBOL] = context;
      if (DEBUG_CLS_HOOKED) {
        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +
          util.inspect(context));
      }
      this.exit(context);
      throw err;
    });
};

Namespace.prototype.bind = function bindFactory(fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    }
    else {
      context = this.active;
    }
  }

  let self = this;
  return function clsBind() {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    }
    catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    }
    finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function enter(context) {
  assert.ok(context, 'context must be provided for entering');
  if (DEBUG_CLS_HOOKED) {
    debug2('  ENTER ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +
      util.inspect(context));
  }

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function exit(context) {
  assert.ok(context, 'context must be provided for exiting');
  if (DEBUG_CLS_HOOKED) {
    debug2('  EXIT ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +
      util.inspect(context));
  }

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, 'can\'t remove top context');
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  let index = this._set.lastIndexOf(context);

  if (index < 0) {
    if (DEBUG_CLS_HOOKED) {
      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));
    }
    assert.ok(index >= 0, 'context not currently entered; can\'t exit. \n' + util.inspect(this) + '\n' +
      util.inspect(context));
  } else {
    assert.ok(index, 'can\'t remove top context');
    this._set.splice(index, 1);
  }
};

Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');

  let namespace = this;
  let thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) {
      return;
    }
    if (!listener[CONTEXTS_SYMBOL]) {
      listener[CONTEXTS_SYMBOL] = Object.create(null);
    }

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace: namespace,
      context: namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
      return unwrapped;
    }

    let wrapped = unwrapped;
    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(unwrappedContexts).forEach(function (name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function fromException(exception) {
  return exception[ERROR_SYMBOL];
};

function getNamespace(name) {
  return process.namespaces[name];
}

function createNamespace(name) {
  assert.ok(name, 'namespace must be given a name.');

  if (DEBUG_CLS_HOOKED) {
    debug2('CREATING NAMESPACE ' + name);
  }
  let namespace = new Namespace(name);
  namespace.id = currentUid;

  asyncHook.addHooks({
    init(uid, handle, provider, parentUid, parentHandle) {
      //parentUid = parentUid || currentUid;  // Suggested usage but appears to work better for tracing modules.
      currentUid = uid;

      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec
      if (parentUid) {
        namespace._contexts.set(uid, namespace._contexts.get(parentUid));
        if (DEBUG_CLS_HOOKED) {
          debug2('PARENTID: ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + provider);
        }
      } else {
        namespace._contexts.set(currentUid, namespace.active);
      }

      if (DEBUG_CLS_HOOKED) {
        debug2('INIT ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + invertedProviders[provider]
          + ' active:' + util.inspect(namespace.active, true));
      }

    },
    pre(uid, handle) {
      currentUid = uid;
      let context = namespace._contexts.get(uid);
      if (context) {
        if (DEBUG_CLS_HOOKED) {
          debug2(' PRE ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +
            util.inspect(context));
        }

        namespace.enter(context);
      } else {
        if (DEBUG_CLS_HOOKED) {
          debug2(' PRE MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));
        }
      }
    },
    post(uid, handle) {
      currentUid = uid;
      let context = namespace._contexts.get(uid);
      if (context) {
        if (DEBUG_CLS_HOOKED) {
          debug2(' POST ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +
            util.inspect(context));
        }

        namespace.exit(context);
      } else {
        if (DEBUG_CLS_HOOKED) {
          debug2(' POST MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));
        }
      }
    },
    destroy(uid) {
      currentUid = uid;

      if (DEBUG_CLS_HOOKED) {
        debug2('DESTROY ' + name + ' uid:' + uid + ' context:' + util.inspect(namespace._contexts.get(currentUid))
          + ' active:' + util.inspect(namespace.active, true));
      }

      namespace._contexts.delete(uid);
    }
  });

  process.namespaces[name] = namespace;
  return namespace;
}

function destroyNamespace(name) {
  let namespace = getNamespace(name);

  assert.ok(namespace, 'can\'t delete nonexistent namespace! "' + name + '"');
  assert.ok(namespace.id, 'don\'t assign to process.namespaces directly! ' + util.inspect(namespace));

  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    });
  }
  process.namespaces = Object.create(null);
}

process.namespaces = {};

if (asyncHook._state && !asyncHook._state.enabled) {
  asyncHook.enable();
}

function debug2(msg) {
  if (process.env.DEBUG) {
    process._rawDebug(msg);
  }
}


/*function debug(from, ns) {
 process._rawDebug('DEBUG: ' + util.inspect({
 from: from,
 currentUid: currentUid,
 context: ns ? ns._contexts.get(currentUid) : 'no ns'
 }, true, 2, true));
 }*/


function getFunctionName(fn) {
  if (!fn) {
    return fn;
  }
  if (typeof fn === 'function') {
    if (fn.name) {
      return fn.name;
    }
    return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
  } else if (fn.constructor && fn.constructor.name) {
    return fn.constructor.name;
  }
}


// Add back to callstack
if (DEBUG_CLS_HOOKED) {
  var stackChain = __webpack_require__(/*! stack-chain */ "../../node_modules/stack-chain/index.js");
  for (var modifier in stackChain.filter._modifiers) {
    stackChain.filter.deattach(modifier);
  }
}


/***/ }),

/***/ "../../node_modules/cls-hooked/context.js":
/*!************************************************!*\
  !*** ../../node_modules/cls-hooked/context.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-len */


const util = __webpack_require__(/*! util */ "util");
const assert = __webpack_require__(/*! assert */ "assert");
const wrapEmitter = __webpack_require__(/*! emitter-listener */ "../../node_modules/emitter-listener/listener.js");
const async_hooks = __webpack_require__(/*! async_hooks */ "async_hooks");

const CONTEXTS_SYMBOL = 'cls@contexts';
const ERROR_SYMBOL = 'error@context';

const DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;

let currentUid = -1;

module.exports = {
  getNamespace: getNamespace,
  createNamespace: createNamespace,
  destroyNamespace: destroyNamespace,
  reset: reset,
  ERROR_SYMBOL: ERROR_SYMBOL
};

function Namespace(name) {
  this.name = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set = [];
  this.id = null;
  this._contexts = new Map();
  this._indent = 0;
}

Namespace.prototype.set = function set(key, value) {
  if (!this.active) {
    throw new Error('No context available. ns.run() or ns.bind() must be called first.');
  }

  this.active[key] = value;

  if (DEBUG_CLS_HOOKED) {
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(indentStr + 'CONTEXT-SET KEY:' + key + '=' + value + ' in ns:' + this.name + ' currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
  }

  return value;
};

Namespace.prototype.get = function get(key) {
  if (!this.active) {
    if (DEBUG_CLS_HOOKED) {
      const asyncHooksCurrentId = async_hooks.currentId();
      const triggerId = async_hooks.triggerAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      //debug2(indentStr + 'CONTEXT-GETTING KEY NO ACTIVE NS:' + key + '=undefined' + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
      debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
    }
    return undefined;
  }
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(indentStr + 'CONTEXT-GETTING KEY:' + key + '=' + this.active[key] + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));
    debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
  }
  return this.active[key];
};

Namespace.prototype.createContext = function createContext() {
  // Prototype inherit existing context if created a new child context within existing context.
  let context = Object.create(this.active ? this.active : Object.prototype);
  context._ns_name = this.name;
  context.id = currentUid;

  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {showHidden:true, depth:2, colors:true})}`);
  }

  return context;
};

Namespace.prototype.run = function run(fn) {
  let context = this.createContext();
  this.enter(context);

  try {
    if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId();
      const asyncHooksCurrentId = async_hooks.executionAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
    }
    fn(context);
    return context;
  } catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  } finally {
    if (DEBUG_CLS_HOOKED) {
      const triggerId = async_hooks.triggerAsyncId();
      const asyncHooksCurrentId = async_hooks.executionAsyncId();
      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function runAndReturn(fn) {
  let value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

/**
 * Uses global Promise and assumes Promise is cls friendly or wrapped already.
 * @param {function} fn
 * @returns {*}
 */
Namespace.prototype.runPromise = function runPromise(fn) {
  let context = this.createContext();
  this.enter(context);

  let promise = fn(context);
  if (!promise || !promise.then || !promise.catch) {
    throw new Error('fn must return a promise.');
  }

  if (DEBUG_CLS_HOOKED) {
    debug2('CONTEXT-runPromise BEFORE: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
  }

  return promise
    .then(result => {
      if (DEBUG_CLS_HOOKED) {
        debug2('CONTEXT-runPromise AFTER then: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
      }
      this.exit(context);
      return result;
    })
    .catch(err => {
      err[ERROR_SYMBOL] = context;
      if (DEBUG_CLS_HOOKED) {
        debug2('CONTEXT-runPromise AFTER catch: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));
      }
      this.exit(context);
      throw err;
    });
};

Namespace.prototype.bind = function bindFactory(fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    } else {
      context = this.active;
    }
  }

  let self = this;
  return function clsBind() {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    } catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    } finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function enter(context) {
  assert.ok(context, 'context must be provided for entering');
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
  }

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function exit(context) {
  assert.ok(context, 'context must be provided for exiting');
  if (DEBUG_CLS_HOOKED) {
    const asyncHooksCurrentId = async_hooks.executionAsyncId();
    const triggerId = async_hooks.triggerAsyncId();
    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);
    debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
  }

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, 'can\'t remove top context');
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  let index = this._set.lastIndexOf(context);

  if (index < 0) {
    if (DEBUG_CLS_HOOKED) {
      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));
    }
    assert.ok(index >= 0, 'context not currently entered; can\'t exit. \n' + util.inspect(this) + '\n' + util.inspect(context));
  } else {
    assert.ok(index, 'can\'t remove top context');
    this._set.splice(index, 1);
  }
};

Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');

  let namespace = this;
  let thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) {
      return;
    }
    if (!listener[CONTEXTS_SYMBOL]) {
      listener[CONTEXTS_SYMBOL] = Object.create(null);
    }

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace: namespace,
      context: namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
      return unwrapped;
    }

    let wrapped = unwrapped;
    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(unwrappedContexts).forEach(function (name) {
      let thunk = unwrappedContexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function fromException(exception) {
  return exception[ERROR_SYMBOL];
};

function getNamespace(name) {
  return process.namespaces[name];
}

function createNamespace(name) {
  assert.ok(name, 'namespace must be given a name.');

  if (DEBUG_CLS_HOOKED) {
    debug2(`NS-CREATING NAMESPACE (${name})`);
  }
  let namespace = new Namespace(name);
  namespace.id = currentUid;

  const hook = async_hooks.createHook({
    init(asyncId, type, triggerId, resource) {
      currentUid = async_hooks.executionAsyncId();

      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec
      // let initContext = namespace.active;
      // if(!initContext && triggerId) {
      //   let parentContext = namespace._contexts.get(triggerId);
      //   if (parentContext) {
      //     namespace.active = parentContext;
      //     namespace._contexts.set(currentUid, parentContext);
      //     if (DEBUG_CLS_HOOKED) {
      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //       debug2(`${indentStr}INIT [${type}] (${name}) WITH PARENT CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //     }
      //   } else if (DEBUG_CLS_HOOKED) {
      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //       debug2(`${indentStr}INIT [${type}] (${name}) MISSING CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //     }
      // }else {
      //   namespace._contexts.set(currentUid, namespace.active);
      //   if (DEBUG_CLS_HOOKED) {
      //     const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
      //     debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);
      //   }
      // }
      if(namespace.active) {
        namespace._contexts.set(asyncId, namespace.active);

        if (DEBUG_CLS_HOOKED) {
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);
        }
      }else if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        const triggerId = async_hooks.triggerAsyncId();
        const triggerIdContext = namespace._contexts.get(triggerId);
        if (triggerIdContext) {
          namespace._contexts.set(asyncId, triggerIdContext);
          if (DEBUG_CLS_HOOKED) {
            const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
          }
        } else if (DEBUG_CLS_HOOKED) {
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
        }
      }


      if(DEBUG_CLS_HOOKED && type === 'PROMISE'){
        debug2(util.inspect(resource, {showHidden: true}));
        const parentId = resource.parentId;
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);
      }

    },
    before(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      let context;

      /*
      if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        //const triggerId = async_hooks.triggerAsyncId();
        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);
      }else{
        context = namespace._contexts.get(currentUid);
      }
      */

      //HACK to work with promises until they are fixed in node > 8.1.1
      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);

      if (context) {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
          namespace._indent += 2;
        }

        namespace.enter(context);

      } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} namespace._contexts:${util.inspect(namespace._contexts, {showHidden:true, depth:2, colors:true})}`);
        namespace._indent += 2;
      }
    },
    after(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      let context; // = namespace._contexts.get(currentUid);
      /*
      if(currentUid === 0){
        // CurrentId will be 0 when triggered from C++. Promise events
        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid
        //const triggerId = async_hooks.triggerAsyncId();
        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);
      }else{
        context = namespace._contexts.get(currentUid);
      }
      */
      //HACK to work with promises until they are fixed in node > 8.1.1
      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);

      if (context) {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          namespace._indent -= 2;
          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
        }

        namespace.exit(context);

      } else if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        namespace._indent -= 2;
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);
      }
    },
    destroy(asyncId) {
      currentUid = async_hooks.executionAsyncId();
      if (DEBUG_CLS_HOOKED) {
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);
        debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(namespace._contexts.get(currentUid))}`);
      }

      namespace._contexts.delete(asyncId);
    }
  });

  hook.enable();

  process.namespaces[name] = namespace;
  return namespace;
}

function destroyNamespace(name) {
  let namespace = getNamespace(name);

  assert.ok(namespace, 'can\'t delete nonexistent namespace! "' + name + '"');
  assert.ok(namespace.id, 'don\'t assign to process.namespaces directly! ' + util.inspect(namespace));

  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    });
  }
  process.namespaces = Object.create(null);
}

process.namespaces = {};

//const fs = require('fs');
function debug2(...args) {
  if (DEBUG_CLS_HOOKED) {
    //fs.writeSync(1, `${util.format(...args)}\n`);
    process._rawDebug(`${util.format(...args)}`);
  }
}

/*function getFunctionName(fn) {
  if (!fn) {
    return fn;
  }
  if (typeof fn === 'function') {
    if (fn.name) {
      return fn.name;
    }
    return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
  } else if (fn.constructor && fn.constructor.name) {
    return fn.constructor.name;
  }
}*/




/***/ }),

/***/ "../../node_modules/cls-hooked/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/cls-hooked/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const semver = __webpack_require__(/*! semver */ "../../node_modules/cls-hooked/node_modules/semver/semver.js");

/**
 * In order to increase node version support, this loads the version of context
 * that is appropriate for the version of on nodejs that is running.
 * Node < v8 - uses AsyncWrap and async-hooks-jl
 * Node >= v8 - uses native async-hooks
 */
if(process && semver.gte(process.versions.node, '8.0.0')){
  module.exports = __webpack_require__(/*! ./context */ "../../node_modules/cls-hooked/context.js");
}else{
  module.exports = __webpack_require__(/*! ./context-legacy */ "../../node_modules/cls-hooked/context-legacy.js");
}


/***/ }),

/***/ "../../node_modules/cls-hooked/node_modules/semver/semver.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/cls-hooked/node_modules/semver/semver.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ "../../node_modules/continuation-local-storage/context.js":
/*!****************************************************************!*\
  !*** ../../node_modules/continuation-local-storage/context.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert      = __webpack_require__(/*! assert */ "assert");
var wrapEmitter = __webpack_require__(/*! emitter-listener */ "../../node_modules/emitter-listener/listener.js");

/*
 *
 * CONSTANTS
 *
 */
var CONTEXTS_SYMBOL = 'cls@contexts';
var ERROR_SYMBOL = 'error@context';

// load polyfill if native support is unavailable
if (!process.addAsyncListener) __webpack_require__(/*! async-listener */ "../../node_modules/async-listener/index.js");

function Namespace(name) {
  this.name   = name;
  // changed in 2.7: no default context
  this.active = null;
  this._set   = [];
  this.id     = null;
}

Namespace.prototype.set = function (key, value) {
  if (!this.active) {
    throw new Error("No context available. ns.run() or ns.bind() must be called first.");
  }

  this.active[key] = value;
  return value;
};

Namespace.prototype.get = function (key) {
  if (!this.active) return undefined;

  return this.active[key];
};

Namespace.prototype.createContext = function () {
  return Object.create(this.active);
};

Namespace.prototype.run = function (fn) {
  var context = this.createContext();
  this.enter(context);
  try {
    fn(context);
    return context;
  }
  catch (exception) {
    if (exception) {
      exception[ERROR_SYMBOL] = context;
    }
    throw exception;
  }
  finally {
    this.exit(context);
  }
};

Namespace.prototype.runAndReturn = function (fn) {
  var value;
  this.run(function (context) {
    value = fn(context);
  });
  return value;
};

Namespace.prototype.bind = function (fn, context) {
  if (!context) {
    if (!this.active) {
      context = this.createContext();
    }
    else {
      context = this.active;
    }
  }

  var self = this;
  return function () {
    self.enter(context);
    try {
      return fn.apply(this, arguments);
    }
    catch (exception) {
      if (exception) {
        exception[ERROR_SYMBOL] = context;
      }
      throw exception;
    }
    finally {
      self.exit(context);
    }
  };
};

Namespace.prototype.enter = function (context) {
  assert.ok(context, "context must be provided for entering");

  this._set.push(this.active);
  this.active = context;
};

Namespace.prototype.exit = function (context) {
  assert.ok(context, "context must be provided for exiting");

  // Fast path for most exits that are at the top of the stack
  if (this.active === context) {
    assert.ok(this._set.length, "can't remove top context");
    this.active = this._set.pop();
    return;
  }

  // Fast search in the stack using lastIndexOf
  var index = this._set.lastIndexOf(context);

  assert.ok(index >= 0, "context not currently entered; can't exit");
  assert.ok(index,      "can't remove top context");

  this._set.splice(index, 1);
};

Namespace.prototype.bindEmitter = function (emitter) {
  assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");

  var namespace  = this;
  var thisSymbol = 'context@' + this.name;

  // Capture the context active at the time the emitter is bound.
  function attach(listener) {
    if (!listener) return;
    if (!listener[CONTEXTS_SYMBOL]) listener[CONTEXTS_SYMBOL] = Object.create(null);

    listener[CONTEXTS_SYMBOL][thisSymbol] = {
      namespace : namespace,
      context   : namespace.active
    };
  }

  // At emit time, bind the listener within the correct context.
  function bind(unwrapped) {
    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;

    var wrapped  = unwrapped;
    var contexts = unwrapped[CONTEXTS_SYMBOL];
    Object.keys(contexts).forEach(function (name) {
      var thunk = contexts[name];
      wrapped = thunk.namespace.bind(wrapped, thunk.context);
    });
    return wrapped;
  }

  wrapEmitter(emitter, attach, bind);
};

/**
 * If an error comes out of a namespace, it will have a context attached to it.
 * This function knows how to find it.
 *
 * @param {Error} exception Possibly annotated error.
 */
Namespace.prototype.fromException = function (exception) {
  return exception[ERROR_SYMBOL];
};

function get(name) {
  return process.namespaces[name];
}

function create(name) {
  assert.ok(name, "namespace must be given a name!");

  var namespace = new Namespace(name);
  namespace.id = process.addAsyncListener({
    create : function () { return namespace.active; },
    before : function (context, storage) { if (storage) namespace.enter(storage); },
    after  : function (context, storage) { if (storage) namespace.exit(storage); },
    error  : function (storage) { if (storage) namespace.exit(storage); }
  });

  process.namespaces[name] = namespace;
  return namespace;
}

function destroy(name) {
  var namespace = get(name);

  assert.ok(namespace,    "can't delete nonexistent namespace!");
  assert.ok(namespace.id, "don't assign to process.namespaces directly!");

  process.removeAsyncListener(namespace.id);
  process.namespaces[name] = null;
}

function reset() {
  // must unregister async listeners
  if (process.namespaces) {
    Object.keys(process.namespaces).forEach(function (name) {
      destroy(name);
    });
  }
  process.namespaces = Object.create(null);
}
if (!process.namespaces) reset(); // call immediately to set up

module.exports = {
  getNamespace     : get,
  createNamespace  : create,
  destroyNamespace : destroy,
  reset            : reset
};


/***/ }),

/***/ "../../node_modules/dateformat/lib/dateformat.js":
/*!*******************************************************!*\
  !*** ../../node_modules/dateformat/lib/dateformat.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

(function(global) {
  'use strict';

  var dateFormat = (function() {
      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
      var timezoneClip = /[^-+\dA-Z]/g;
  
      // Regexes and supporting functions are cached through closure
      return function (date, mask, utc, gmt) {
  
        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
          mask = date;
          date = undefined;
        }
  
        date = date || new Date;
  
        if(!(date instanceof Date)) {
          date = new Date(date);
        }
  
        if (isNaN(date)) {
          throw TypeError('Invalid date');
        }
  
        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
  
        // Allow setting the utc/gmt argument via the mask
        var maskSlice = mask.slice(0, 4);
        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
          mask = mask.slice(4);
          utc = true;
          if (maskSlice === 'GMT:') {
            gmt = true;
          }
        }
  
        var _ = utc ? 'getUTC' : 'get';
        var d = date[_ + 'Date']();
        var D = date[_ + 'Day']();
        var m = date[_ + 'Month']();
        var y = date[_ + 'FullYear']();
        var H = date[_ + 'Hours']();
        var M = date[_ + 'Minutes']();
        var s = date[_ + 'Seconds']();
        var L = date[_ + 'Milliseconds']();
        var o = utc ? 0 : date.getTimezoneOffset();
        var W = getWeek(date);
        var N = getDayOfWeek(date);
        var flags = {
          d:    d,
          dd:   pad(d),
          ddd:  dateFormat.i18n.dayNames[D],
          dddd: dateFormat.i18n.dayNames[D + 7],
          m:    m + 1,
          mm:   pad(m + 1),
          mmm:  dateFormat.i18n.monthNames[m],
          mmmm: dateFormat.i18n.monthNames[m + 12],
          yy:   String(y).slice(2),
          yyyy: y,
          h:    H % 12 || 12,
          hh:   pad(H % 12 || 12),
          H:    H,
          HH:   pad(H),
          M:    M,
          MM:   pad(M),
          s:    s,
          ss:   pad(s),
          l:    pad(L, 3),
          L:    pad(Math.round(L / 10)),
          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
          W:    W,
          N:    N
        };
  
        return mask.replace(token, function (match) {
          if (match in flags) {
            return flags[match];
          }
          return match.slice(1, match.length - 1);
        });
      };
    })();

  dateFormat.masks = {
    'default':               'ddd mmm dd yyyy HH:MM:ss',
    'shortDate':             'm/d/yy',
    'mediumDate':            'mmm d, yyyy',
    'longDate':              'mmmm d, yyyy',
    'fullDate':              'dddd, mmmm d, yyyy',
    'shortTime':             'h:MM TT',
    'mediumTime':            'h:MM:ss TT',
    'longTime':              'h:MM:ss TT Z',
    'isoDate':               'yyyy-mm-dd',
    'isoTime':               'HH:MM:ss',
    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
  };

  // Internationalization strings
  dateFormat.i18n = {
    dayNames: [
      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
    ],
    monthNames: [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
    ],
    timeNames: [
      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
    ]
  };

function pad(val, len) {
  val = String(val);
  len = len || 2;
  while (val.length < len) {
    val = '0' + val;
  }
  return val;
}

/**
 * Get the ISO 8601 week number
 * Based on comments from
 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
 *
 * @param  {Object} `date`
 * @return {Number}
 */
function getWeek(date) {
  // Remove time components of date
  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

  // Change date to Thursday same week
  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

  // Take January 4th as it is always in week 1 (see ISO 8601)
  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

  // Change date to Thursday same week
  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

  // Check if daylight-saving-time-switch occurred and correct for it
  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  targetThursday.setHours(targetThursday.getHours() - ds);

  // Number of weeks between target Thursday and first Thursday
  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
  return 1 + Math.floor(weekDiff);
}

/**
 * Get ISO-8601 numeric representation of the day of the week
 * 1 (for Monday) through 7 (for Sunday)
 * 
 * @param  {Object} `date`
 * @return {Number}
 */
function getDayOfWeek(date) {
  var dow = date.getDay();
  if(dow === 0) {
    dow = 7;
  }
  return dow;
}

/**
 * kind-of shortcut
 * @param  {*} val
 * @return {String}
 */
function kindOf(val) {
  if (val === null) {
    return 'null';
  }

  if (val === undefined) {
    return 'undefined';
  }

  if (typeof val !== 'object') {
    return typeof val;
  }

  if (Array.isArray(val)) {
    return 'array';
  }

  return {}.toString.call(val)
    .slice(8, -1).toLowerCase();
};



  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return dateFormat;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);


/***/ }),

/***/ "../../node_modules/debug/src/browser.js":
/*!***********************************************!*\
  !*** ../../node_modules/debug/src/browser.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/debug/src/common.js":
/*!**********************************************!*\
  !*** ../../node_modules/debug/src/common.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/debug/src/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/debug/src/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/debug/src/node.js":
/*!********************************************!*\
  !*** ../../node_modules/debug/src/node.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "../../node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "../../node_modules/decamelize/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/decamelize/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = function (str, sep) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	sep = typeof sep === 'undefined' ? '_' : sep;

	return str
		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
		.toLowerCase();
};


/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
exports.AzureMonitorSymbol = "Azure_Monitor_Tracer";
var isPatched = false;
/**
 * By default, @azure/core-tracing default tracer is a NoopTracer.
 * This patching changes the default tracer to a patched BasicTracer
 * which emits ended spans as diag-channel events.
 *
 * The @opentelemetry/tracing package must be installed to use these patches
 * https://www.npmjs.com/package/@opentelemetry/tracing
 * @param coreTracing
 */
var azureCoreTracingPatchFunction = function (coreTracing) {
    if (isPatched) {
        // tracer is already cached -- noop
        return coreTracing;
    }
    try {
        var tracing = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@opentelemetry/tracing'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        var opentelemetry = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@opentelemetry/api'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
        var tracerConfig = diagnostic_channel_1.channel.spanContextPropagator
            ? { contextManager: diagnostic_channel_1.channel.spanContextPropagator }
            : undefined;
        new tracing.BasicTracerProvider().register(tracerConfig);
        var tracer_1 = opentelemetry.trace.getTracer("applicationinsights tracer");
        // Patch startSpan instead of using spanProcessor.onStart because parentSpan must be
        // set while the span is constructed
        var startSpanOriginal_1 = tracer_1.startSpan;
        tracer_1.startSpan = function (name, options) {
            // if no parent span was provided, apply the current context
            if (!options || !options.parent) {
                var parentOperation = tracer_1.getCurrentSpan();
                if (parentOperation && parentOperation.operation && parentOperation.operation.traceparent) {
                    options = __assign({}, options, { parent: {
                            traceId: parentOperation.operation.traceparent.traceId,
                            spanId: parentOperation.operation.traceparent.spanId,
                            traceFlags: 1,
                        } });
                }
            }
            var span = startSpanOriginal_1.call(this, name, options);
            var originalEnd = span.end;
            span.end = function () {
                var result = originalEnd.apply(this, arguments);
                diagnostic_channel_1.channel.publish("azure-coretracing", span);
                return result;
            };
            return span;
        };
        tracer_1.getCurrentSpan(); // seed OpenTelemetryScopeManagerWrapper with "active" symbol
        tracer_1[exports.AzureMonitorSymbol] = true;
        coreTracing.setTracer(tracer_1); // recordSpanData is not present on BasicTracer - cast to any
        isPatched = true;
    }
    catch (e) { /* squash errors */ }
    return coreTracing;
};
exports.azureCoreTracing = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: azureCoreTracingPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports.azureCoreTracing);
}
exports.enable = enable;
//# sourceMappingURL=azure-coretracing.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var bunyanPatchFunction = function (originalBunyan) {
    var originalEmit = originalBunyan.prototype._emit;
    originalBunyan.prototype._emit = function (rec, noemit) {
        var ret = originalEmit.apply(this, arguments);
        if (!noemit) {
            var str = ret;
            if (!str) {
                str = originalEmit.call(this, rec, true);
            }
            diagnostic_channel_1.channel.publish("bunyan", { level: rec.level, result: str });
        }
        return ret;
    };
    return originalBunyan;
};
exports.bunyan = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: bunyanPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports.bunyan);
}
exports.enable = enable;
//# sourceMappingURL=bunyan.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/console.pub.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/console.pub.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var stream_1 = __webpack_require__(/*! stream */ "stream");
var consolePatchFunction = function (originalConsole) {
    var aiLoggingOutStream = new stream_1.Writable();
    var aiLoggingErrStream = new stream_1.Writable();
    // Default console is roughly equivalent to `new Console(process.stdout, process.stderr)`
    // We create a version which publishes to the channel and also to stdout/stderr
    aiLoggingOutStream.write = function (chunk) {
        if (!chunk) {
            return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message: message });
        return true;
    };
    aiLoggingErrStream.write = function (chunk) {
        if (!chunk) {
            return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message: message, stderr: true });
        return true;
    };
    var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);
    var consoleMethods = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"];
    var _loop_1 = function (method) {
        var originalMethod = originalConsole[method];
        if (originalMethod) {
            originalConsole[method] = function () {
                if (aiLoggingConsole[method]) {
                    try {
                        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);
                    }
                    catch (e) {
                        // Ignore errors; allow the original method to throw if necessary
                    }
                }
                return originalMethod.apply(originalConsole, arguments);
            };
        }
    };
    for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {
        var method = consoleMethods_1[_i];
        _loop_1(method);
    }
    return originalConsole;
};
exports.console = {
    versionSpecifier: ">= 4.0.0",
    patch: consolePatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("console", exports.console);
    // Force patching of console
    /* tslint:disable-next-line:no-var-requires */
    __webpack_require__(/*! console */ "console");
}
exports.enable = enable;
//# sourceMappingURL=console.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var azuresdk = __webpack_require__(/*! ./azure-coretracing.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js");
exports.azuresdk = azuresdk;
var bunyan = __webpack_require__(/*! ./bunyan.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js");
exports.bunyan = bunyan;
var consolePub = __webpack_require__(/*! ./console.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/console.pub.js");
exports.console = consolePub;
var mongodbCore = __webpack_require__(/*! ./mongodb-core.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js");
exports.mongodbCore = mongodbCore;
var mongodb = __webpack_require__(/*! ./mongodb.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js");
exports.mongodb = mongodb;
var mysql = __webpack_require__(/*! ./mysql.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js");
exports.mysql = mysql;
var pgPool = __webpack_require__(/*! ./pg-pool.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js");
exports.pgPool = pgPool;
var pg = __webpack_require__(/*! ./pg.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js");
exports.pg = pg;
var redis = __webpack_require__(/*! ./redis.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js");
exports.redis = redis;
var tedious = __webpack_require__(/*! ./tedious.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js");
exports.tedious = tedious;
var winston = __webpack_require__(/*! ./winston.pub */ "../../node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js");
exports.winston = winston;
function enable() {
    bunyan.enable();
    consolePub.enable();
    mongodbCore.enable();
    mongodb.enable();
    mysql.enable();
    pg.enable();
    pgPool.enable();
    redis.enable();
    winston.enable();
    azuresdk.enable();
    tedious.enable();
}
exports.enable = enable;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var mongodbcorePatchFunction = function (originalMongoCore) {
    var originalConnect = originalMongoCore.Server.prototype.connect;
    originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        // Messages sent to mongo progress through a pool
        // This can result in context getting mixed between different responses
        // so we wrap the callbacks to restore appropriate state
        var originalWrite = this.s.pool.write;
        this.s.pool.write = function contextPreservingWrite() {
            var cbidx = typeof arguments[1] === "function" ? 1 : 2;
            if (typeof arguments[cbidx] === "function") {
                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
            }
            return originalWrite.apply(this, arguments);
        };
        // Logout is a special case, it doesn't call the write function but instead
        // directly calls into connection.write
        var originalLogout = this.s.pool.logout;
        this.s.pool.logout = function contextPreservingLogout() {
            if (typeof arguments[1] === "function") {
                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
            }
            return originalLogout.apply(this, arguments);
        };
        return ret;
    };
    return originalMongoCore;
};
exports.mongoCore = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: mongodbcorePatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports.mongoCore);
}
exports.enable = enable;
//# sourceMappingURL=mongodb-core.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var mongodbPatchFunction = function (originalMongo) {
    var listener = originalMongo.instrument({
        operationIdGenerator: {
            next: function () {
                return diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
            },
        },
    });
    var eventMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
            event.operationId(function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
        }
        else {
            // fallback -- correlation will not work here
            diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true });
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
            event.operationId(function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
        }
        else {
            // fallback -- correlation will not work here
            diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false });
        }
    });
    return originalMongo;
};
var mongodb3PatchFunction = function (originalMongo) {
    var listener = originalMongo.instrument();
    var eventMap = {};
    var contextMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
            delete contextMap[event.requestId];
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
            delete contextMap[event.requestId];
        }
    });
    return originalMongo;
};
// In mongodb 3.3.0, mongodb-core was merged into mongodb, so the same patching
// can be used here. this.s.pool was changed to this.s.coreTopology.s.pool
var mongodbcorePatchFunction = function (originalMongo) {
    var originalConnect = originalMongo.Server.prototype.connect;
    originalMongo.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        // Messages sent to mongo progress through a pool
        // This can result in context getting mixed between different responses
        // so we wrap the callbacks to restore appropriate state
        var originalWrite = this.s.coreTopology.s.pool.write;
        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {
            var cbidx = typeof arguments[1] === "function" ? 1 : 2;
            if (typeof arguments[cbidx] === "function") {
                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
            }
            return originalWrite.apply(this, arguments);
        };
        // Logout is a special case, it doesn't call the write function but instead
        // directly calls into connection.write
        var originalLogout = this.s.coreTopology.s.pool.logout;
        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {
            if (typeof arguments[1] === "function") {
                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
            }
            return originalLogout.apply(this, arguments);
        };
        return ret;
    };
    return originalMongo;
};
var mongodb330PatchFunction = function (originalMongo) {
    mongodbcorePatchFunction(originalMongo); // apply mongodb-core patches
    var listener = originalMongo.instrument();
    var eventMap = {};
    var contextMap = {};
    listener.on("started", function (event) {
        if (eventMap[event.requestId]) {
            // Note: Mongo can generate 2 completely separate requests
            // which share the same requestId, if a certain race condition is triggered.
            // For now, we accept that this can happen and potentially miss or mislabel some events.
            return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });
        eventMap[event.requestId] = event;
    });
    listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: true }); });
            delete contextMap[event.requestId];
        }
    });
    listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
            delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish("mongodb", { startedData: startedData, event: event, succeeded: false }); });
            delete contextMap[event.requestId];
        }
    });
    return originalMongo;
};
exports.mongo2 = {
    versionSpecifier: ">= 2.0.0 <= 3.0.5",
    patch: mongodbPatchFunction,
};
exports.mongo3 = {
    versionSpecifier: "> 3.0.5 < 3.3.0",
    patch: mongodb3PatchFunction,
};
exports.mongo330 = {
    versionSpecifier: ">= 3.3.0 < 4.0.0",
    patch: mongodb330PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo2);
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo3);
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo330);
}
exports.enable = enable;
//# sourceMappingURL=mongodb.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var path = __webpack_require__(/*! path */ "path");
var mysqlPatchFunction = function (originalMysql, originalMysqlPath) {
    // The `name` passed in here is for debugging purposes,
    // to help distinguish which object is being patched.
    var patchObjectFunction = function (obj, name) {
        return function (func, cbWrapper) {
            var originalFunc = obj[func];
            if (originalFunc) {
                obj[func] = function mysqlContextPreserver() {
                    // Find the callback, if there is one
                    var cbidx = arguments.length - 1;
                    for (var i = arguments.length - 1; i >= 0; --i) {
                        if (typeof arguments[i] === "function") {
                            cbidx = i;
                            break;
                        }
                        else if (typeof arguments[i] !== "undefined") {
                            break;
                        }
                    }
                    var cb = arguments[cbidx];
                    var resultContainer = { result: null, startTime: null, startDate: null };
                    if (typeof cb === "function") {
                        // Preserve context on the callback.
                        // If this is one of the functions that we want to track,
                        // then wrap the callback with the tracking wrapper
                        if (cbWrapper) {
                            resultContainer.startTime = process.hrtime();
                            resultContainer.startDate = new Date();
                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));
                        }
                        else {
                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);
                        }
                    }
                    var result = originalFunc.apply(this, arguments);
                    resultContainer.result = result;
                    return result;
                };
            }
        };
    };
    var patchClassMemberFunction = function (classObject, name) {
        return patchObjectFunction(classObject.prototype, name + ".prototype");
    };
    var connectionCallbackFunctions = [
        "connect", "changeUser",
        "ping", "statistics", "end",
    ];
    var connectionClass = __webpack_require__("../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Connection$")(path.dirname(originalMysqlPath) + "/lib/Connection");
    connectionCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(connectionClass, "Connection")(value); });
    // Connection.createQuery is a static method
    patchObjectFunction(connectionClass, "Connection")("createQuery", function (resultContainer, cb) {
        return function (err) {
            var hrDuration = process.hrtime(resultContainer.startTime);
            /* tslint:disable-next-line:no-bitwise */
            var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;
            diagnostic_channel_1.channel.publish("mysql", { query: resultContainer.result, callbackArgs: arguments, err: err, duration: duration, time: resultContainer.startDate });
            cb.apply(this, arguments);
        };
    });
    var poolCallbackFunctions = [
        "_enqueueCallback",
    ];
    var poolClass = __webpack_require__("../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Pool$")(path.dirname(originalMysqlPath) + "/lib/Pool");
    poolCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(poolClass, "Pool")(value); });
    return originalMysql;
};
exports.mysql = {
    versionSpecifier: ">= 2.0.0 < 3.0.0",
    patch: mysqlPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports.mysql);
}
exports.enable = enable;
//# sourceMappingURL=mysql.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
function postgresPool1PatchFunction(originalPgPool) {
    var originalConnect = originalPgPool.prototype.connect;
    originalPgPool.prototype.connect = function connect(callback) {
        if (callback) {
            arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);
        }
        return originalConnect.apply(this, arguments);
    };
    return originalPgPool;
}
exports.postgresPool1 = {
    versionSpecifier: ">= 1.0.0 < 3.0.0",
    patch: postgresPool1PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports.postgresPool1);
}
exports.enable = enable;
//# sourceMappingURL=pg-pool.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var events_1 = __webpack_require__(/*! events */ "events");
function postgres6PatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query;
    var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    // wherever the callback is passed, find it, save it, and remove it from the call
    // to the the original .query() function
    originalPg.Client.prototype.query = function query(config, values, callback) {
        var data = {
            query: {},
            database: {
                host: this.connectionParameters.host,
                port: this.connectionParameters.port,
            },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
            if (cb && cb[diagnosticOriginalFunc]) {
                cb = cb[diagnosticOriginalFunc];
            }
            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
                var end = process.hrtime(start);
                data.result = res && { rowCount: res.rowCount, command: res.command };
                data.error = err;
                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));
                diagnostic_channel_1.channel.publish("postgres", data);
                // emulate weird internal behavior in pg@6
                // on success, the callback is called *before* query events are emitted
                // on failure, the callback is called *instead of* the query emitting events
                // with no events, that means no promises (since the promise is resolved/rejected in an event handler)
                // since we are always inserting ourselves as a callback, we have to restore the original
                // behavior if the user didn't provide one themselves
                if (err) {
                    if (cb) {
                        return cb.apply(this, arguments);
                    }
                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                        queryResult.emit("error", err);
                    }
                }
                else if (cb) {
                    cb.apply(this, arguments);
                }
            });
            try {
                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
                return trackingCallback;
            }
            catch (e) {
                // this should never happen, but bailout in case it does
                return cb;
            }
        }
        // this function takes too many variations of arguments.
        // this patches any provided callback or creates a new callback if one wasn't provided.
        // since the callback is always called (if provided) in addition to always having a Promisified
        // EventEmitter returned (well, sometimes -- see above), its safe to insert a callback if none was given
        try {
            if (typeof config === "string") {
                if (values instanceof Array) {
                    data.query.preparable = {
                        text: config,
                        args: values,
                    };
                    callback = patchCallback(callback);
                }
                else {
                    data.query.text = config;
                    // pg v6 will, for some reason, accept both
                    // client.query("...", undefined, () => {...})
                    // **and**
                    // client.query("...", () => {...});
                    // Internally, precedence is given to the callback argument
                    if (callback) {
                        callback = patchCallback(callback);
                    }
                    else {
                        values = patchCallback(values);
                    }
                }
            }
            else {
                if (typeof config.name === "string") {
                    data.query.plan = config.name;
                }
                else if (config.values instanceof Array) {
                    data.query.preparable = {
                        text: config.text,
                        args: config.values,
                    };
                }
                else {
                    data.query.text = config.text;
                }
                if (callback) {
                    callback = patchCallback(callback);
                }
                else if (values) {
                    values = patchCallback(values);
                }
                else {
                    config.callback = patchCallback(config.callback);
                }
            }
        }
        catch (e) {
            // if our logic here throws, bail out and just let pg do its thing
            return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = (arguments.length > 3) ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        return queryResult;
    };
    return originalPg;
}
function postgres7PatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query;
    var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    // wherever the callback is passed, find it, save it, and remove it from the call
    // to the the original .query() function
    originalPg.Client.prototype.query = function query(config, values, callback) {
        var _this = this;
        var callbackProvided = !!callback; // Starting in pg@7.x+, Promise is returned only if !callbackProvided
        var data = {
            query: {},
            database: {
                host: this.connectionParameters.host,
                port: this.connectionParameters.port,
            },
            result: null,
            error: null,
            duration: 0,
            time: new Date(),
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
            if (cb && cb[diagnosticOriginalFunc]) {
                cb = cb[diagnosticOriginalFunc];
            }
            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
                var end = process.hrtime(start);
                data.result = res && { rowCount: res.rowCount, command: res.command };
                data.error = err;
                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));
                diagnostic_channel_1.channel.publish("postgres", data);
                if (err) {
                    if (cb) {
                        return cb.apply(this, arguments);
                    }
                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                        queryResult.emit("error", err);
                    }
                }
                else if (cb) {
                    cb.apply(this, arguments);
                }
            });
            try {
                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
                return trackingCallback;
            }
            catch (e) {
                // this should never happen, but bailout in case it does
                return cb;
            }
        }
        // Only try to wrap the callback if it is a function. We want to keep the same
        // behavior of returning a promise only if no callback is provided. Wrapping
        // a nonfunction makes it a function and pg will interpret it as a callback
        try {
            if (typeof config === "string") {
                if (values instanceof Array) {
                    data.query.preparable = {
                        text: config,
                        args: values,
                    };
                    callbackProvided = typeof callback === "function";
                    callback = callbackProvided ? patchCallback(callback) : callback;
                }
                else {
                    data.query.text = config;
                    if (callback) {
                        callbackProvided = typeof callback === "function";
                        callback = callbackProvided ? patchCallback(callback) : callback;
                    }
                    else {
                        callbackProvided = typeof values === "function";
                        values = callbackProvided ? patchCallback(values) : values;
                    }
                }
            }
            else {
                if (typeof config.name === "string") {
                    data.query.plan = config.name;
                }
                else if (config.values instanceof Array) {
                    data.query.preparable = {
                        text: config.text,
                        args: config.values,
                    };
                }
                else {
                    data.query.text = config.text;
                }
                if (callback) {
                    callbackProvided = typeof callback === "function";
                    callback = patchCallback(callback);
                }
                else if (values) {
                    callbackProvided = typeof values === "function";
                    values = callbackProvided ? patchCallback(values) : values;
                }
                else {
                    callbackProvided = typeof config.callback === "function";
                    config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;
                }
            }
        }
        catch (e) {
            // if our logic here throws, bail out and just let pg do its thing
            return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = (arguments.length > 3) ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        if (!callbackProvided) {
            // no callback, so create a pass along promise
            return queryResult
                // pass resolved promise after publishing the event
                .then(function (result) {
                patchCallback()(undefined, result);
                return new _this._Promise(function (resolve, reject) {
                    resolve(result);
                });
            })
                // pass along rejected promise after publishing the error
                .catch(function (error) {
                patchCallback()(error, undefined);
                return new _this._Promise(function (resolve, reject) {
                    reject(error);
                });
            });
        }
        return queryResult;
    };
    return originalPg;
}
exports.postgres6 = {
    versionSpecifier: "6.*",
    patch: postgres6PatchFunction,
};
exports.postgres7 = {
    versionSpecifier: ">=7.* <=8.*",
    patch: postgres7PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres6);
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres7);
}
exports.enable = enable;
//# sourceMappingURL=pg.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var redisPatchFunction = function (originalRedis) {
    var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
    // Note: This is mixing together both context tracking and dependency tracking
    originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {
        if (commandObj) {
            var cb_1 = commandObj.callback;
            if (!cb_1 || !cb_1.pubsubBound) {
                var address_1 = this.address;
                var startTime_1 = process.hrtime();
                var startDate_1 = new Date();
                // Note: augmenting the callback on internal_send_command is correct for context
                // tracking, but may be too low-level for dependency tracking. There are some 'errors'
                // which higher levels expect in some cases
                // However, the only other option is to intercept every individual command.
                commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {
                    var hrDuration = process.hrtime(startTime_1);
                    /* tslint:disable-next-line:no-bitwise */
                    var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;
                    diagnostic_channel_1.channel.publish("redis", { duration: duration, address: address_1, commandObj: commandObj, err: err, result: result, time: startDate_1 });
                    if (typeof cb_1 === "function") {
                        cb_1.apply(this, arguments);
                    }
                });
                commandObj.callback.pubsubBound = true;
            }
        }
        return originalSend.call(this, commandObj);
    };
    return originalRedis;
};
exports.redis = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: redisPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports.redis);
}
exports.enable = enable;
//# sourceMappingURL=redis.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
var tediousPatchFunction = function (originalTedious) {
    var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
    originalTedious.Connection.prototype.makeRequest = function makeRequest() {
        function getPatchedCallback(origCallback) {
            var start = process.hrtime();
            var data = {
                query: {},
                database: {
                    host: null,
                    port: null,
                },
                result: null,
                error: null,
                duration: 0,
            };
            return diagnostic_channel_1.channel.bindToContext(function (err, rowCount, rows) {
                var end = process.hrtime(start);
                data = __assign({}, data, { database: {
                        host: this.connection.config.server,
                        port: this.connection.config.options.port,
                    }, result: !err && { rowCount: rowCount, rows: rows }, query: {
                        text: this.parametersByName.statement.value,
                    }, error: err, duration: Math.ceil((end[0] * 1e3) + (end[1] / 1e6)) });
                diagnostic_channel_1.channel.publish("tedious", data);
                origCallback.call(this, err, rowCount, rows);
            });
        }
        var request = arguments[0];
        arguments[0].callback = getPatchedCallback(request.callback);
        originalMakeRequest.apply(this, arguments);
    };
    return originalTedious;
};
exports.tedious = {
    versionSpecifier: ">= 6.0.0 < 9.0.0",
    patch: tediousPatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports.tedious);
}
exports.enable = enable;
//# sourceMappingURL=tedious.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
var diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ "../../node_modules/diagnostic-channel/dist/src/channel.js");
// register a "filter" with each logger that publishes the data about to be logged
var winston2PatchFunction = function (originalWinston) {
    var originalLog = originalWinston.Logger.prototype.log;
    var curLevels;
    var loggingFilter = function (level, message, meta) {
        var levelKind;
        if (curLevels === originalWinston.config.npm.levels) {
            levelKind = "npm";
        }
        else if (curLevels === originalWinston.config.syslog.levels) {
            levelKind = "syslog";
        }
        else {
            levelKind = "unknown";
        }
        diagnostic_channel_1.channel.publish("winston", { level: level, message: message, meta: meta, levelKind: levelKind });
        return message;
    };
    // whenever someone logs, ensure our filter comes last
    originalWinston.Logger.prototype.log = function log() {
        curLevels = this.levels;
        if (!this.filters || this.filters.length === 0) {
            this.filters = [loggingFilter];
        }
        else if (this.filters[this.filters.length - 1] !== loggingFilter) {
            this.filters = this.filters.filter(function (f) { return f !== loggingFilter; });
            this.filters.push(loggingFilter);
        }
        return originalLog.apply(this, arguments);
    };
    return originalWinston;
};
var winston3PatchFunction = function (originalWinston) {
    var mapLevelToKind = function (winston, level) {
        var levelKind;
        if (winston.config.npm.levels[level] != null) {
            levelKind = "npm";
        }
        else if (winston.config.syslog.levels[level] != null) {
            levelKind = "syslog";
        }
        else {
            levelKind = "unknown";
        }
        return levelKind;
    };
    var AppInsightsTransport = /** @class */ (function (_super) {
        __extends(AppInsightsTransport, _super);
        function AppInsightsTransport(winston, opts) {
            var _this = _super.call(this, opts) || this;
            _this.winston = winston;
            return _this;
        }
        AppInsightsTransport.prototype.log = function (info, callback) {
            // tslint:disable-next-line:prefer-const - try to obtain level from Symbol(level) afterwards
            var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, ["message", "level", "meta"]);
            level = typeof Symbol["for"] === "function" ? info[Symbol["for"]("level")] : level; // Symbol(level) is uncolorized, so prefer getting it from here
            message = info instanceof Error ? info : message; // Winston places Errors at info, strings at info.message
            var levelKind = mapLevelToKind(this.winston, level);
            meta = meta || {}; // Winston _somtimes_ puts metadata inside meta, so start from here
            for (var key in splat) {
                if (splat.hasOwnProperty(key)) {
                    meta[key] = splat[key];
                }
            }
            diagnostic_channel_1.channel.publish("winston", { message: message, level: level, levelKind: levelKind, meta: meta });
            callback();
        };
        return AppInsightsTransport;
    }(originalWinston.Transport));
    // Patch this function
    function patchedConfigure() {
        // Grab highest sev logging level in case of custom logging levels
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
            if (levels.hasOwnProperty(level)) {
                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;
            }
        }
        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
    }
    var origCreate = originalWinston.createLogger;
    originalWinston.createLogger = function patchedCreate() {
        // Grab highest sev logging level in case of custom logging levels
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
            if (levels.hasOwnProperty(level)) {
                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;
            }
        }
        // Add custom app insights transport to the end
        // Remark: Configure is not available until after createLogger()
        // and the Logger prototype is not exported in winston 3.x, so
        // patch both createLogger and configure. Could also call configure
        // again after createLogger, but that would cause configure to be called
        // twice per create.
        var result = origCreate.apply(this, arguments);
        result.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
        var origConfigure = result.configure;
        result.configure = function () {
            origConfigure.apply(this, arguments);
            patchedConfigure.apply(this, arguments);
        };
        return result;
    };
    var origRootConfigure = originalWinston.configure;
    originalWinston.configure = function () {
        origRootConfigure.apply(this, arguments);
        patchedConfigure.apply(this, arguments);
    };
    originalWinston.add(new AppInsightsTransport(originalWinston));
    return originalWinston;
};
exports.winston3 = {
    versionSpecifier: "3.x",
    patch: winston3PatchFunction,
};
exports.winston2 = {
    versionSpecifier: "2.x",
    patch: winston2PatchFunction,
};
function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston2);
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston3);
}
exports.enable = enable;
//# sourceMappingURL=winston.pub.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Connection$":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/ sync ^.*\/lib\/Connection$ ***!
  \*********************************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Connection$";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Pool$":
/*!***************************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel-publishers/dist/src/ sync ^.*\/lib\/Pool$ ***!
  \***************************************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Pool$";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../node_modules/diagnostic-channel/dist/src/channel.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/diagnostic-channel/dist/src/channel.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patchRequire_1 = __webpack_require__(/*! ./patchRequire */ "../../node_modules/diagnostic-channel/dist/src/patchRequire.js");
var patchRequire_2 = __webpack_require__(/*! ./patchRequire */ "../../node_modules/diagnostic-channel/dist/src/patchRequire.js");
exports.makePatchingRequire = patchRequire_2.makePatchingRequire;
var trueFilter = function (publishing) { return true; };
var ContextPreservingEventEmitter = /** @class */ (function () {
    function ContextPreservingEventEmitter() {
        this.version = (__webpack_require__(/*! ./../../package.json */ "../../node_modules/diagnostic-channel/package.json").version); // Allow for future versions to replace things?
        this.subscribers = {};
        this.contextPreservationFunction = function (cb) { return cb; };
        this.knownPatches = {};
        this.currentlyPublishing = false;
    }
    ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {
        var listeners = this.subscribers[name];
        if (listeners) {
            return listeners.some(function (_a) {
                var filter = _a.filter;
                return !filter || filter(false);
            });
        }
        return false;
    };
    ContextPreservingEventEmitter.prototype.publish = function (name, event) {
        if (this.currentlyPublishing) {
            return; // Avoid reentrancy
        }
        var listeners = this.subscribers[name];
        // Note: Listeners called synchronously to preserve context
        if (listeners) {
            var standardEvent_1 = {
                timestamp: Date.now(),
                data: event,
            };
            this.currentlyPublishing = true;
            listeners.forEach(function (_a) {
                var listener = _a.listener, filter = _a.filter;
                try {
                    if (filter && filter(true)) {
                        listener(standardEvent_1);
                    }
                }
                catch (e) {
                    // Subscriber threw an error
                }
            });
            this.currentlyPublishing = false;
        }
    };
    ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter) {
        if (filter === void 0) { filter = trueFilter; }
        if (!this.subscribers[name]) {
            this.subscribers[name] = [];
        }
        this.subscribers[name].push({ listener: listener, filter: filter });
    };
    ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {
        if (filter === void 0) { filter = trueFilter; }
        var listeners = this.subscribers[name];
        if (listeners) {
            for (var index = 0; index < listeners.length; ++index) {
                if (listeners[index].listener === listener && listeners[index].filter === filter) {
                    listeners.splice(index, 1);
                    return true;
                }
            }
        }
        return false;
    };
    // Used for tests
    ContextPreservingEventEmitter.prototype.reset = function () {
        var _this = this;
        this.subscribers = {};
        this.contextPreservationFunction = function (cb) { return cb; };
        // Modify the knownPatches object rather than replace, since a reference will be used in the require patcher
        Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) { return delete _this.knownPatches[prop]; });
    };
    ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {
        return this.contextPreservationFunction(cb);
    };
    ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {
        var previousPreservationStack = this.contextPreservationFunction;
        this.contextPreservationFunction = (function (cb) { return preserver(previousPreservationStack(cb)); });
    };
    ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {
        if (!this.knownPatches[packageName]) {
            this.knownPatches[packageName] = [];
        }
        this.knownPatches[packageName].push(patcher);
    };
    ContextPreservingEventEmitter.prototype.getPatchesObject = function () {
        return this.knownPatches;
    };
    return ContextPreservingEventEmitter;
}());
if (!global.diagnosticsSource) {
    global.diagnosticsSource = new ContextPreservingEventEmitter();
    // TODO: should this only patch require after at least one monkey patch is registered?
    /* tslint:disable-next-line:no-var-requires */
    var moduleModule = __webpack_require__(/*! module */ "module");
    // Note: We pass in the object now before any patches are registered, but the object is passed by reference
    // so any updates made to the object will be visible in the patcher.
    moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());
}
exports.channel = global.diagnosticsSource;
//# sourceMappingURL=channel.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel/dist/src/patchRequire.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/diagnostic-channel/dist/src/patchRequire.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var path = __webpack_require__(/*! path */ "path");
var semver = __webpack_require__(/*! semver */ "../../node_modules/diagnostic-channel/node_modules/semver/semver.js");
/* tslint:disable-next-line:no-var-requires */
var moduleModule = __webpack_require__(/*! module */ "module");
var nativeModules = Object.keys(process.binding("natives"));
var originalRequire = moduleModule.prototype.require;
function makePatchingRequire(knownPatches) {
    var patchedModules = {};
    return function patchedRequire(moduleId) {
        var originalModule = originalRequire.apply(this, arguments);
        if (knownPatches[moduleId]) {
            // Fetch the specific path of the module
            var modulePath = moduleModule._resolveFilename(moduleId, this);
            if (patchedModules.hasOwnProperty(modulePath)) {
                // This module has already been patched, no need to reapply
                return patchedModules[modulePath];
            }
            var moduleVersion = void 0;
            if (nativeModules.indexOf(moduleId) < 0) {
                try {
                    moduleVersion = originalRequire.call(this, path.join(moduleId, "package.json")).version;
                }
                catch (e) {
                    // This should only happen if moduleId is actually a path rather than a module
                    // This is not a supported scenario
                    return originalModule;
                }
            }
            else {
                // This module is implemented natively so we cannot find a package.json
                // Instead, take the version of node itself
                moduleVersion = process.version.substring(1);
            }
            var prereleaseTagIndex = moduleVersion.indexOf("-");
            if (prereleaseTagIndex >= 0) {
                // We ignore prerelease tags to avoid impossible to fix gaps in support
                // e.g. supporting console in >= 4.0.0 would otherwise not include
                // 8.0.0-pre
                moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);
            }
            var modifiedModule = originalModule;
            for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {
                var modulePatcher = _a[_i];
                if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {
                    modifiedModule = modulePatcher.patch(modifiedModule, modulePath);
                }
            }
            return patchedModules[modulePath] = modifiedModule;
        }
        return originalModule;
    };
}
exports.makePatchingRequire = makePatchingRequire;
//# sourceMappingURL=patchRequire.js.map

/***/ }),

/***/ "../../node_modules/diagnostic-channel/node_modules/semver/semver.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/diagnostic-channel/node_modules/semver/semver.js ***!
  \***************************************************************************/
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ "../../node_modules/diffie-hellman/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/diffie-hellman/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var crypto = __webpack_require__(/*! crypto */ "crypto")

// getDiffieHellman
exports.DiffieHellmanGroup = crypto.DiffieHellmanGroup
exports.createDiffieHellmanGroup = crypto.createDiffieHellmanGroup
exports.getDiffieHellman = crypto.getDiffieHellman

// createDiffieHellman
exports.createDiffieHellman = crypto.createDiffieHellman
exports.DiffieHellman = crypto.DiffieHellman


/***/ }),

/***/ "../../node_modules/emitter-listener/listener.js":
/*!*******************************************************!*\
  !*** ../../node_modules/emitter-listener/listener.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var shimmer = __webpack_require__(/*! shimmer */ "../../node_modules/shimmer/index.js");
var wrap    = shimmer.wrap;
var unwrap  = shimmer.unwrap;

// Default to complaining loudly when things don't go according to plan.
// dunderscores are boring
var SYMBOL = 'wrap@before';

// Sets a property on an object, preserving its enumerability.
// This function assumes that the property is already writable.
function defineProperty(obj, name, value) {
  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: enumerable,
    writable: true,
    value: value
  });
}

function _process(self, listeners) {
  var l = listeners.length;
  for (var p = 0; p < l; p++) {
    var listener = listeners[p];
    // set up the listener so that onEmit can do whatever it needs
    var before = self[SYMBOL];
    if (typeof before === 'function') {
      before(listener);
    }
    else if (Array.isArray(before)) {
      var length = before.length;
      for (var i = 0; i < length; i++) before[i](listener);
    }
  }
}

function _listeners(self, event) {
  var listeners;
  listeners = self._events && self._events[event];
  if (!Array.isArray(listeners)) {
    if (listeners) {
      listeners = [listeners];
    }
    else {
      listeners = [];
    }
  }

  return listeners;
}

function _findAndProcess(self, event, before) {
  var after = _listeners(self, event);
  var unprocessed = after.filter(function(fn) { return before.indexOf(fn) === -1; });
  if (unprocessed.length > 0) _process(self, unprocessed);
}

function _wrap(unwrapped, visit) {
  if (!unwrapped) return;

  var wrapped = unwrapped;
  if (typeof unwrapped === 'function') {
    wrapped = visit(unwrapped);
  }
  else if (Array.isArray(unwrapped)) {
    wrapped = [];
    for (var i = 0; i < unwrapped.length; i++) {
      wrapped[i] = visit(unwrapped[i]);
    }
  }
  return wrapped;
}

module.exports = function wrapEmitter(emitter, onAddListener, onEmit) {
  if (!emitter || !emitter.on || !emitter.addListener ||
      !emitter.removeListener || !emitter.emit) {
    throw new Error("can only wrap real EEs");
  }

  if (!onAddListener) throw new Error("must have function to run on listener addition");
  if (!onEmit) throw new Error("must have function to wrap listeners when emitting");

  /* Attach a context to a listener, and make sure that this hook stays
   * attached to the emitter forevermore.
   */
  function adding(on) {
    return function added(event, listener) {
      var existing = _listeners(this, event).slice();

      try {
        var returned = on.call(this, event, listener);
        _findAndProcess(this, event, existing);
        return returned;
      }
      finally {
        // old-style streaming overwrites .on and .addListener, so rewrap
        if (!this.on.__wrapped) wrap(this, 'on', adding);
        if (!this.addListener.__wrapped) wrap(this, 'addListener', adding);
      }
    };
  }

  function emitting(emit) {
    return function emitted(event) {
      if (!this._events || !this._events[event]) return emit.apply(this, arguments);

      var unwrapped = this._events[event];

      /* Ensure that if removeListener gets called, it's working with the
       * unwrapped listeners.
       */
      function remover(removeListener) {
        return function removed() {
          this._events[event] = unwrapped;
          try {
            return removeListener.apply(this, arguments);
          }
          finally {
            unwrapped = this._events[event];
            this._events[event] = _wrap(unwrapped, onEmit);
          }
        };
      }
      wrap(this, 'removeListener', remover);

      try {
        /* At emit time, ensure that whatever else is going on, removeListener will
         * still work while at the same time running whatever hooks are necessary to
         * make sure the listener is run in the correct context.
         */
        this._events[event] = _wrap(unwrapped, onEmit);
        return emit.apply(this, arguments);
      }
      finally {
        /* Ensure that regardless of what happens when preparing and running the
         * listeners, the status quo ante is restored before continuing.
         */
        unwrap(this, 'removeListener');
        this._events[event] = unwrapped;
      }
    };
  }

  // support multiple onAddListeners
  if (!emitter[SYMBOL]) {
    defineProperty(emitter, SYMBOL, onAddListener);
  }
  else if (typeof emitter[SYMBOL] === 'function') {
    defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);
  }
  else if (Array.isArray(emitter[SYMBOL])) {
    emitter[SYMBOL].push(onAddListener);
  }

  // only wrap the core functions once
  if (!emitter.__wrapped) {
    wrap(emitter, 'addListener', adding);
    wrap(emitter, 'on',          adding);
    wrap(emitter, 'emit',        emitting);

    defineProperty(emitter, '__unwrap', function () {
      unwrap(emitter, 'addListener');
      unwrap(emitter, 'on');
      unwrap(emitter, 'emit');
      delete emitter[SYMBOL];
      delete emitter.__wrapped;
    });
    defineProperty(emitter, '__wrapped', true);
  }
};


/***/ }),

/***/ "../../node_modules/event-target-shim/dist/event-target-shim.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/event-target-shim/dist/event-target-shim.js ***!
  \**********************************************************************/
/***/ ((module, exports) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */


Object.defineProperty(exports, "__esModule", ({ value: true }));

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
    if (data.passiveListener != null) {
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) {
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
        }
        return
    }
    if (!data.event.cancelable) {
        return
    }

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
    }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        setCancelFlag(pd(this));
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     * @deprecated
     */
    get srcElement() {
        return pd(this).eventTarget
    },

    /**
     * The flag to stop event bubbling.
     * @type {boolean}
     * @deprecated
     */
    get cancelBubble() {
        return pd(this).stopped
    },
    set cancelBubble(value) {
        if (!value) {
            return
        }
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
            data.event.cancelBubble = true;
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     * @deprecated
     */
    get returnValue() {
        return !pd(this).canceled
    },
    set returnValue(value) {
        if (!value) {
            setCancelFlag(pd(this));
        }
    },

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string} type The event type.
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() {
        // Do nothing.
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).immediateStopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    } else {
                        listeners.delete(eventName);
                    }
                } else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
    );
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
            value: CustomEventTarget,
            configurable: true,
            writable: true,
        },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                // Should ignore duplication.
                return
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
                return
            }

            prev = node;
            node = node.next;
        }
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.')
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
            } else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                } catch (err) {
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) {
                        console.error(err);
                    }
                }
            } else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports["default"] = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute
//# sourceMappingURL=event-target-shim.js.map


/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!**************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdirpSync = (__webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js").mkdirsSync)
const utimesSync = (__webpack_require__(/*! ../util/utimes.js */ "../../node_modules/fs-extra/lib/util/utimes.js").utimesMillisSync)
const stat = __webpack_require__(/*! ../util/stat */ "../../node_modules/fs-extra/lib/util/stat.js")

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirpSync(destParent)
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest)
    fs.chmodSync(dest, srcStat.mode)
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime)
    }
    return
  }
  return copyFileFallback(srcStat, src, dest, opts)
}

function copyFileFallback (srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024
  const _buff = __webpack_require__(/*! ../util/buffer */ "../../node_modules/fs-extra/lib/util/buffer.js")(BUF_LENGTH)

  const fdr = fs.openSync(src, 'r')
  const fdw = fs.openSync(dest, 'w', srcStat.mode)
  let pos = 0

  while (pos < srcStat.size) {
    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
    fs.writeSync(fdw, _buff, 0, bytesRead)
    pos += bytesRead
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

  fs.closeSync(fdr)
  fs.closeSync(fdw)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcStat, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return fs.chmodSync(dest, srcStat.mode)
}

function copyDir (src, dest, opts) {
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (!destStat) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

module.exports = copySync


/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy-sync/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/copy-sync/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  copySync: __webpack_require__(/*! ./copy-sync */ "../../node_modules/fs-extra/lib/copy-sync/copy-sync.js")
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy/copy.js":
/*!****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/copy/copy.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdirp = (__webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js").mkdirs)
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)
const utimes = (__webpack_require__(/*! ../util/utimes */ "../../node_modules/fs-extra/lib/util/utimes.js").utimesMillis)
const stat = __webpack_require__(/*! ../util/stat */ "../../node_modules/fs-extra/lib/util/stat.js")

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts
    opts = {}
  } else if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  cb = cb || function () {}
  opts = opts || {}

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  stat.checkPaths(src, dest, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    })
  })
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path.dirname(dest)
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
    mkdirp(destParent, err => {
      if (err) return cb(err)
      return startCopy(destStat, src, dest, opts, cb)
    })
  })
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error))
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
  })
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    })
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err)
      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
    })
  }
  return copyFileFallback(srcStat, src, dest, opts, cb)
}

function copyFileFallback (srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src)
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
    ws.on('error', err => cb(err))
      .on('open', () => rs.pipe(ws))
      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))
  })
}

function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb)
    }
    return cb()
  })
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return fs.chmod(dest, srcStat.mode, cb)
    })
  })
}

function copyDir (src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  })
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop()
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    })
  })
}

function onLink (destStat, src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
    }

    if (!destStat) {
      return fs.symlink(resolvedSrc, dest, cb)
    } else {
      fs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest)
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      })
    }
  })
}

function copyLink (resolvedSrc, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err)
    return fs.symlink(resolvedSrc, dest, cb)
  })
}

module.exports = copy


/***/ }),

/***/ "../../node_modules/fs-extra/lib/copy/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/copy/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
module.exports = {
  copy: u(__webpack_require__(/*! ./copy */ "../../node_modules/fs-extra/lib/copy/copy.js"))
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/empty/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/empty/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const remove = __webpack_require__(/*! ../remove */ "../../node_modules/fs-extra/lib/remove/index.js")

const emptyDir = u(function emptyDir (dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/file.js":
/*!******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/file.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function createFile (file, callback) {
  function makeFile () {
    fs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback()
    })
  }

  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file)
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err)
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch (e) {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const file = __webpack_require__(/*! ./file */ "../../node_modules/fs-extra/lib/ensure/file.js")
const link = __webpack_require__(/*! ./link */ "../../node_modules/fs-extra/lib/ensure/link.js")
const symlink = __webpack_require__(/*! ./symlink */ "../../node_modules/fs-extra/lib/ensure/symlink.js")

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/link.js":
/*!******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/link.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null)
    })
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink')
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!***************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink')
        return callback(err)
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        })
      } else {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink')
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    exists = fs.existsSync(relativeToDst)
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      }
    } else {
      exists = fs.existsSync(srcpath)
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      }
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!**************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type
  if (type) return callback(null, type)
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
    callback(null, type)
  })
}

function symlinkTypeSync (srcpath, type) {
  let stats

  if (type) return type
  try {
    stats = fs.lstatSync(srcpath)
  } catch (e) {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType,
  symlinkTypeSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/ensure/symlink.js":
/*!*********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const _mkdirs = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const mkdirs = _mkdirs.mkdirs
const mkdirsSync = _mkdirs.mkdirsSync

const _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ "../../node_modules/fs-extra/lib/ensure/symlink-paths.js")
const symlinkPaths = _symlinkPaths.symlinkPaths
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

const _symlinkType = __webpack_require__(/*! ./symlink-type */ "../../node_modules/fs-extra/lib/ensure/symlink-type.js")
const symlinkType = _symlinkType.symlinkType
const symlinkTypeSync = _symlinkType.symlinkTypeSync

const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err => {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/fs/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/fs-extra/lib/fs/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'lchmod',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export all keys:
Object.keys(fs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = fs[key]
})

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

// fs.realpath.native only available in Node v9.2+
if (typeof fs.realpath.native === 'function') {
  exports.realpath.native = u(fs.realpath.native)
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/index.js":
/*!************************************************!*\
  !*** ../../node_modules/fs-extra/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = Object.assign(
  {},
  // Export promiseified graceful-fs:
  __webpack_require__(/*! ./fs */ "../../node_modules/fs-extra/lib/fs/index.js"),
  // Export extra methods:
  __webpack_require__(/*! ./copy-sync */ "../../node_modules/fs-extra/lib/copy-sync/index.js"),
  __webpack_require__(/*! ./copy */ "../../node_modules/fs-extra/lib/copy/index.js"),
  __webpack_require__(/*! ./empty */ "../../node_modules/fs-extra/lib/empty/index.js"),
  __webpack_require__(/*! ./ensure */ "../../node_modules/fs-extra/lib/ensure/index.js"),
  __webpack_require__(/*! ./json */ "../../node_modules/fs-extra/lib/json/index.js"),
  __webpack_require__(/*! ./mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js"),
  __webpack_require__(/*! ./move-sync */ "../../node_modules/fs-extra/lib/move-sync/index.js"),
  __webpack_require__(/*! ./move */ "../../node_modules/fs-extra/lib/move/index.js"),
  __webpack_require__(/*! ./output */ "../../node_modules/fs-extra/lib/output/index.js"),
  __webpack_require__(/*! ./path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js"),
  __webpack_require__(/*! ./remove */ "../../node_modules/fs-extra/lib/remove/index.js")
)

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = __webpack_require__(/*! fs */ "fs")
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, "promises", ({
    get () { return fs.promises }
  }))
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/json/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const jsonFile = __webpack_require__(/*! ./jsonfile */ "../../node_modules/fs-extra/lib/json/jsonfile.js")

jsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ "../../node_modules/fs-extra/lib/json/output-json.js"))
jsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ "../../node_modules/fs-extra/lib/json/output-json-sync.js")
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/jsonfile.js":
/*!********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/json/jsonfile.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const jsonFile = __webpack_require__(/*! jsonfile */ "../../node_modules/jsonfile/index.js")

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/output-json-sync.js":
/*!****************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const jsonFile = __webpack_require__(/*! ./jsonfile */ "../../node_modules/fs-extra/lib/json/jsonfile.js")

function outputJsonSync (file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}

module.exports = outputJsonSync


/***/ }),

/***/ "../../node_modules/fs-extra/lib/json/output-json.js":
/*!***********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/json/output-json.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)
const jsonFile = __webpack_require__(/*! ./jsonfile */ "../../node_modules/fs-extra/lib/json/jsonfile.js")

function outputJson (file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}

module.exports = outputJson


/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/mkdirs/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const mkdirs = u(__webpack_require__(/*! ./mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/mkdirs.js"))
const mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ "../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js")

module.exports = {
  mkdirs,
  mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!*************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const invalidWin32Path = (__webpack_require__(/*! ./win32 */ "../../node_modules/fs-extra/lib/mkdirs/win32.js").invalidWin32Path)

const o777 = parseInt('0777', 8)

function mkdirsSync (p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    if (err0.code === 'ENOENT') {
      if (path.dirname(p) === p) throw err0
      made = mkdirsSync(path.dirname(p), opts, made)
      mkdirsSync(p, opts, made)
    } else {
      // In the case of any other error, just see if there's a dir there
      // already. If so, then hooray!  If not, then something is borked.
      let stat
      try {
        stat = xfs.statSync(p)
      } catch (err1) {
        throw err0
      }
      if (!stat.isDirectory()) throw err0
    }
  }

  return made
}

module.exports = mkdirsSync


/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const invalidWin32Path = (__webpack_require__(/*! ./win32 */ "../../node_modules/fs-extra/lib/mkdirs/win32.js").invalidWin32Path)

const o777 = parseInt('0777', 8)

function mkdirs (p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts }
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.')
    errInval.code = 'EINVAL'
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 & (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}

module.exports = mkdirs


/***/ }),

/***/ "../../node_modules/fs-extra/lib/mkdirs/win32.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path")

// get drive on windows
function getRootPath (p) {
  p = path.normalize(path.resolve(p)).split(path.sep)
  if (p.length > 0) return p[0]
  return null
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/

function invalidWin32Path (p) {
  const rp = getRootPath(p)
  p = p.replace(rp, '')
  return INVALID_PATH_CHARS.test(p)
}

module.exports = {
  getRootPath,
  invalidWin32Path
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/move-sync/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/move-sync/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  moveSync: __webpack_require__(/*! ./move-sync */ "../../node_modules/fs-extra/lib/move-sync/move-sync.js")
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!**************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const copySync = (__webpack_require__(/*! ../copy-sync */ "../../node_modules/fs-extra/lib/copy-sync/index.js").copySync)
const removeSync = (__webpack_require__(/*! ../remove */ "../../node_modules/fs-extra/lib/remove/index.js").removeSync)
const mkdirpSync = (__webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js").mkdirpSync)
const stat = __webpack_require__(/*! ../util/stat */ "../../node_modules/fs-extra/lib/util/stat.js")

function moveSync (src, dest, opts) {
  opts = opts || {}
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat } = stat.checkPathsSync(src, dest, 'move')
  stat.checkParentPathsSync(src, srcStat, dest, 'move')
  mkdirpSync(path.dirname(dest))
  return doRename(src, dest, overwrite)
}

function doRename (src, dest, overwrite) {
  if (overwrite) {
    removeSync(dest)
    return rename(src, dest, overwrite)
  }
  if (fs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    fs.renameSync(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copySync(src, dest, opts)
  return removeSync(src)
}

module.exports = moveSync


/***/ }),

/***/ "../../node_modules/fs-extra/lib/move/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/move/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
module.exports = {
  move: u(__webpack_require__(/*! ./move */ "../../node_modules/fs-extra/lib/move/move.js"))
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/move/move.js":
/*!****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/move/move.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const copy = (__webpack_require__(/*! ../copy */ "../../node_modules/fs-extra/lib/copy/index.js").copy)
const remove = (__webpack_require__(/*! ../remove */ "../../node_modules/fs-extra/lib/remove/index.js").remove)
const mkdirp = (__webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js").mkdirp)
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)
const stat = __webpack_require__(/*! ../util/stat */ "../../node_modules/fs-extra/lib/util/stat.js")

function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  const overwrite = opts.overwrite || opts.clobber || false

  stat.checkPaths(src, dest, 'move', (err, stats) => {
    if (err) return cb(err)
    const { srcStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      mkdirp(path.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, cb)
      })
    })
  })
}

function doRename (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  })
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  })
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  })
}

module.exports = move


/***/ }),

/***/ "../../node_modules/fs-extra/lib/output/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/output/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "../../node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "../../node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding
    encoding = 'utf8'
  }

  const dir = path.dirname(file)
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/path-exists/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/fs-extra/lib/path-exists/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromPromise)
const fs = __webpack_require__(/*! ../fs */ "../../node_modules/fs-extra/lib/fs/index.js")

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/remove/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/remove/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "../../node_modules/universalify/index.js").fromCallback)
const rimraf = __webpack_require__(/*! ./rimraf */ "../../node_modules/fs-extra/lib/remove/rimraf.js")

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/remove/rimraf.js":
/*!********************************************************!*\
  !*** ../../node_modules/fs-extra/lib/remove/rimraf.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const assert = __webpack_require__(/*! assert */ "assert")

const isWindows = (process.platform === 'win32')

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
}

function rimraf (p, options, cb) {
  let busyTries = 0

  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null
    }

    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er) {
    assert(er instanceof Error)
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er)
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er)
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb)
        } else {
          options.unlink(p, cb)
        }
      })
    }
  })
}

function fixWinEPERMSync (p, options, er) {
  let stats

  assert(p)
  assert(options)
  if (er) {
    assert(er instanceof Error)
  }

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er)
  } else {
    options.unlinkSync(p)
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb)
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr)
    } else {
      cb(er)
    }
  })
}

function rmkids (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb)
        }
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st

  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try {
    st = options.lstatSync(p)
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er)
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null)
    } else {
      options.unlinkSync(p)
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr) {
    assert(originalEr instanceof Error)
  }

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options)
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now()
    do {
      try {
        const ret = options.rmdirSync(p, options)
        return ret
      } catch (er) { }
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options)
    return ret
  }
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/buffer.js":
/*!******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/util/buffer.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size)
    } catch (e) {
      return new Buffer(size)
    }
  }
  return new Buffer(size)
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/stat.js":
/*!****************************************************!*\
  !*** ../../node_modules/fs-extra/lib/util/stat.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")

const NODE_VERSION_MAJOR_WITH_BIGINT = 10
const NODE_VERSION_MINOR_WITH_BIGINT = 5
const NODE_VERSION_PATCH_WITH_BIGINT = 0
const nodeVersion = process.versions.node.split('.')
const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)
const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)
const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)

function nodeSupportsBigInt () {
  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
    return true
  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
      return true
    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
        return true
      }
    }
  }
  return false
}

function getStats (src, dest, cb) {
  if (nodeSupportsBigInt()) {
    fs.stat(src, { bigint: true }, (err, srcStat) => {
      if (err) return cb(err)
      fs.stat(dest, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
          return cb(err)
        }
        return cb(null, { srcStat, destStat })
      })
    })
  } else {
    fs.stat(src, (err, srcStat) => {
      if (err) return cb(err)
      fs.stat(dest, (err, destStat) => {
        if (err) {
          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })
          return cb(err)
        }
        return cb(null, { srcStat, destStat })
      })
    })
  }
}

function getStatsSync (src, dest) {
  let srcStat, destStat
  if (nodeSupportsBigInt()) {
    srcStat = fs.statSync(src, { bigint: true })
  } else {
    srcStat = fs.statSync(src)
  }
  try {
    if (nodeSupportsBigInt()) {
      destStat = fs.statSync(dest, { bigint: true })
    } else {
      destStat = fs.statSync(dest)
    }
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, cb) {
  getStats(src, dest, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  })
}

function checkPathsSync (src, dest, funcName) {
  const { srcStat, destStat } = getStatsSync(src, dest)
  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
  if (nodeSupportsBigInt()) {
    fs.stat(destParent, { bigint: true }, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb()
        return cb(err)
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error(errMsg(src, dest, funcName)))
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb)
    })
  } else {
    fs.stat(destParent, (err, destStat) => {
      if (err) {
        if (err.code === 'ENOENT') return cb()
        return cb(err)
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error(errMsg(src, dest, funcName)))
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb)
    })
  }
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    if (nodeSupportsBigInt()) {
      destStat = fs.statSync(destParent, { bigint: true })
    } else {
      destStat = fs.statSync(destParent)
    }
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

module.exports = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir
}


/***/ }),

/***/ "../../node_modules/fs-extra/lib/util/utimes.js":
/*!******************************************************!*\
  !*** ../../node_modules/fs-extra/lib/util/utimes.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
const os = __webpack_require__(/*! os */ "os")
const path = __webpack_require__(/*! path */ "path")

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync () {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')
  const fd = fs.openSync(tmpfile, 'r+')
  fs.futimesSync(fd, d, d)
  fs.closeSync(fd)
  return fs.statSync(tmpfile).mtime > 1435410243000
}

function hasMillisRes (callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))
  tmpfile = path.join(os.tmpdir(), tmpfile)

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862)
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err)
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err)
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err)
        fs.close(fd, err => {
          if (err) return callback(err)
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err)
            callback(null, stats.mtime > 1435410243000)
          })
        })
      })
    })
  })
}

function timeRemoveMillis (timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
  }
}

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr)
      })
    })
  })
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
}


/***/ }),

/***/ "../../node_modules/get-caller-file/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/get-caller-file/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

// Call this function in a another function to find out the file from
// which that function was called from. (Inspects the v8 stack trace)
//
// Inspired by http://stackoverflow.com/questions/13227489
module.exports = function getCallerFile(position) {
    if (position === void 0) { position = 2; }
    if (position >= Error.stackTraceLimit) {
        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');
    }
    var oldPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = new Error().stack;
    Error.prepareStackTrace = oldPrepareStackTrace;
    if (stack !== null && typeof stack === 'object') {
        // stack[0] holds this file
        // stack[1] holds where this function was called
        // stack[2] holds the file we're interested in
        return stack[position] ? stack[position].getFileName() : undefined;
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/get-port/index.js":
/*!********************************************!*\
  !*** ../../node_modules/get-port/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const net = __webpack_require__(/*! net */ "net");

class Locked extends Error {
	constructor(port) {
		super(`${port} is locked`);
	}
}

const lockedPorts = {
	old: new Set(),
	young: new Set()
};

// On this interval, the old locked ports are discarded,
// the young locked ports are moved to old locked ports,
// and a new young set for locked ports are created.
const releaseOldLockedPortsIntervalMs = 1000 * 15;

// Lazily create interval on first use
let interval;

const getAvailablePort = options => new Promise((resolve, reject) => {
	const server = net.createServer();
	server.unref();
	server.on('error', reject);
	server.listen(options, () => {
		const {port} = server.address();
		server.close(() => {
			resolve(port);
		});
	});
});

const portCheckSequence = function * (ports) {
	if (ports) {
		yield * ports;
	}

	yield 0; // Fall back to 0 if anything else failed
};

module.exports = async options => {
	let ports;

	if (options) {
		ports = typeof options.port === 'number' ? [options.port] : options.port;
	}

	if (interval === undefined) {
		interval = setInterval(() => {
			lockedPorts.old = lockedPorts.young;
			lockedPorts.young = new Set();
		}, releaseOldLockedPortsIntervalMs);

		// Does not exist in some environments (Electron, Jest jsdom env, browser, etc).
		if (interval.unref) {
			interval.unref();
		}
	}

	for (const port of portCheckSequence(ports)) {
		try {
			let availablePort = await getAvailablePort({...options, port}); // eslint-disable-line no-await-in-loop
			while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
				if (port !== 0) {
					throw new Locked(port);
				}

				availablePort = await getAvailablePort({...options, port}); // eslint-disable-line no-await-in-loop
			}

			lockedPorts.young.add(availablePort);
			return availablePort;
		} catch (error) {
			if (!['EADDRINUSE', 'EACCES'].includes(error.code) && !(error instanceof Locked)) {
				throw error;
			}
		}
	}

	throw new Error('No available ports found');
};

module.exports.makeRange = (from, to) => {
	if (!Number.isInteger(from) || !Number.isInteger(to)) {
		throw new TypeError('`from` and `to` must be integer numbers');
	}

	if (from < 1024 || from > 65535) {
		throw new RangeError('`from` must be between 1024 and 65535');
	}

	if (to < 1024 || to > 65536) {
		throw new RangeError('`to` must be between 1024 and 65536');
	}

	if (to < from) {
		throw new RangeError('`to` must be greater than or equal to `from`');
	}

	const generator = function * (from, to) {
		for (let port = from; port <= to; port++) {
			yield port;
		}
	};

	return generator(from, to);
};


/***/ }),

/***/ "../../node_modules/graceful-fs/clone.js":
/*!***********************************************!*\
  !*** ../../node_modules/graceful-fs/clone.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),

/***/ "../../node_modules/graceful-fs/graceful-fs.js":
/*!*****************************************************!*\
  !*** ../../node_modules/graceful-fs/graceful-fs.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var polyfills = __webpack_require__(/*! ./polyfills.js */ "../../node_modules/graceful-fs/polyfills.js")
var legacy = __webpack_require__(/*! ./legacy-streams.js */ "../../node_modules/graceful-fs/legacy-streams.js")
var clone = __webpack_require__(/*! ./clone.js */ "../../node_modules/graceful-fs/clone.js")

var util = __webpack_require__(/*! util */ "util")

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(/*! assert */ "assert").equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  var noReaddirOptionVersions = /^v[0-5]\./
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    var go$readdir = noReaddirOptionVersions.test(process.version)
      ? function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }
      : function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }

    return go$readdir(path, options, cb)

    function fs$readdirCallback (path, options, cb, startTime) {
      return function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([
            go$readdir,
            [path, options, cb],
            err,
            startTime || Date.now(),
            Date.now()
          ])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      }
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),

/***/ "../../node_modules/graceful-fs/legacy-streams.js":
/*!********************************************************!*\
  !*** ../../node_modules/graceful-fs/legacy-streams.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream)

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),

/***/ "../../node_modules/graceful-fs/polyfills.js":
/*!***************************************************!*\
  !*** ../../node_modules/graceful-fs/polyfills.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(/*! constants */ "constants")

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (fs.chmod && !fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (fs.chown && !fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = typeof fs.rename !== 'function' ? fs.rename
    : (function (fs$rename) {
      function rename (from, to, cb) {
        var start = Date.now()
        var backoff = 0;
        fs$rename(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM")
              && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er)
              })
            }, backoff)
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er)
        })
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)
      return rename
    })(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = typeof fs.read !== 'function' ? fs.read
  : (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else if (fs.futimes) {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),

/***/ "../../node_modules/is-fullwidth-code-point/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/is-fullwidth-code-point/index.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable yoda */
module.exports = x => {
	if (Number.isNaN(x)) {
		return false;
	}

	// code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (
		x >= 0x1100 && (
			x <= 0x115f ||  // Hangul Jamo
			x === 0x2329 || // LEFT-POINTING ANGLE BRACKET
			x === 0x232a || // RIGHT-POINTING ANGLE BRACKET
			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
			(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
			(0x3250 <= x && x <= 0x4dbf) ||
			// CJK Unified Ideographs .. Yi Radicals
			(0x4e00 <= x && x <= 0xa4c6) ||
			// Hangul Jamo Extended-A
			(0xa960 <= x && x <= 0xa97c) ||
			// Hangul Syllables
			(0xac00 <= x && x <= 0xd7a3) ||
			// CJK Compatibility Ideographs
			(0xf900 <= x && x <= 0xfaff) ||
			// Vertical Forms
			(0xfe10 <= x && x <= 0xfe19) ||
			// CJK Compatibility Forms .. Small Form Variants
			(0xfe30 <= x && x <= 0xfe6b) ||
			// Halfwidth and Fullwidth Forms
			(0xff01 <= x && x <= 0xff60) ||
			(0xffe0 <= x && x <= 0xffe6) ||
			// Kana Supplement
			(0x1b000 <= x && x <= 0x1b001) ||
			// Enclosed Ideographic Supplement
			(0x1f200 <= x && x <= 0x1f251) ||
			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
			(0x20000 <= x && x <= 0x3fffd)
		)
	) {
		return true;
	}

	return false;
};


/***/ }),

/***/ "../../node_modules/is-typedarray/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/is-typedarray/index.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}


/***/ }),

/***/ "../../node_modules/js-sha256/src/sha256.js":
/*!**************************************************!*\
  !*** ../../node_modules/js-sha256/src/sha256.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "../../node_modules/jsonfile/index.js":
/*!********************************************!*\
  !*** ../../node_modules/jsonfile/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _fs
try {
  _fs = __webpack_require__(/*! graceful-fs */ "../../node_modules/graceful-fs/graceful-fs.js")
} catch (_) {
  _fs = __webpack_require__(/*! fs */ "fs")
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === 'string') {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}

function readFileSync (file, options) {
  options = options || {}
  if (typeof options === 'string') {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  if ('throws' in options) {
    shouldThrow = options.throws
  }

  try {
    var content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces
  var EOL = '\n'
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces
    }
    if (options.EOL) {
      EOL = options.EOL
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var str = ''
  try {
    str = stringify(obj, options)
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null)
    return
  }

  fs.writeFile(file, str, options, callback)
}

function writeFileSync (file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  content = content.replace(/^\uFEFF/, '')
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
}

module.exports = jsonfile


/***/ }),

/***/ "../../node_modules/lockfile/lockfile.js":
/*!***********************************************!*\
  !*** ../../node_modules/lockfile/lockfile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")

var wx = 'wx'
if (process.version.match(/^v0\.[0-6]/)) {
  var c = __webpack_require__(/*! constants */ "constants")
  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL
}

var os = __webpack_require__(/*! os */ "os")
exports.filetime = 'ctime'
if (os.platform() == "win32") {
  exports.filetime = 'mtime'
}

var debug
var util = __webpack_require__(/*! util */ "util")
if (util.debuglog)
  debug = util.debuglog('LOCKFILE')
else if (/\blockfile\b/i.test(process.env.NODE_DEBUG))
  debug = function() {
    var msg = util.format.apply(util, arguments)
    console.error('LOCKFILE %d %s', process.pid, msg)
  }
else
  debug = function() {}

var locks = {}

function hasOwnProperty (obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop)
}

var onExit = __webpack_require__(/*! signal-exit */ "../../node_modules/signal-exit/index.js")
onExit(function () {
  debug('exit listener')
  // cleanup
  Object.keys(locks).forEach(exports.unlockSync)
})

// XXX https://github.com/joyent/node/issues/3555
// Remove when node 0.8 is deprecated.
if (/^v0\.[0-8]\./.test(process.version)) {
  debug('uncaughtException, version = %s', process.version)
  process.on('uncaughtException', function H (er) {
    debug('uncaughtException')
    var l = process.listeners('uncaughtException').filter(function (h) {
      return h !== H
    })
    if (!l.length) {
      // cleanup
      try { Object.keys(locks).forEach(exports.unlockSync) } catch (e) {}
      process.removeListener('uncaughtException', H)
      throw er
    }
  })
}

exports.unlock = function (path, cb) {
  debug('unlock', path)
  // best-effort.  unlocking an already-unlocked lock is a noop
  delete locks[path]
  fs.unlink(path, function (unlinkEr) { cb && cb() })
}

exports.unlockSync = function (path) {
  debug('unlockSync', path)
  // best-effort.  unlocking an already-unlocked lock is a noop
  try { fs.unlinkSync(path) } catch (er) {}
  delete locks[path]
}


// if the file can be opened in readonly mode, then it's there.
// if the error is something other than ENOENT, then it's not.
exports.check = function (path, opts, cb) {
  if (typeof opts === 'function') cb = opts, opts = {}
  debug('check', path, opts)
  fs.open(path, 'r', function (er, fd) {
    if (er) {
      if (er.code !== 'ENOENT') return cb(er)
      return cb(null, false)
    }

    if (!opts.stale) {
      return fs.close(fd, function (er) {
        return cb(er, true)
      })
    }

    fs.fstat(fd, function (er, st) {
      if (er) return fs.close(fd, function (er2) {
        return cb(er)
      })

      fs.close(fd, function (er) {
        var age = Date.now() - st[exports.filetime].getTime()
        return cb(er, age <= opts.stale)
      })
    })
  })
}

exports.checkSync = function (path, opts) {
  opts = opts || {}
  debug('checkSync', path, opts)
  if (opts.wait) {
    throw new Error('opts.wait not supported sync for obvious reasons')
  }

  try {
    var fd = fs.openSync(path, 'r')
  } catch (er) {
    if (er.code !== 'ENOENT') throw er
    return false
  }

  if (!opts.stale) {
    try { fs.closeSync(fd) } catch (er) {}
    return true
  }

  // file exists.  however, might be stale
  if (opts.stale) {
    try {
      var st = fs.fstatSync(fd)
    } finally {
      fs.closeSync(fd)
    }
    var age = Date.now() - st[exports.filetime].getTime()
    return (age <= opts.stale)
  }
}



var req = 1
exports.lock = function (path, opts, cb) {
  if (typeof opts === 'function') cb = opts, opts = {}
  opts.req = opts.req || req++
  debug('lock', path, opts)
  opts.start = opts.start || Date.now()

  if (typeof opts.retries === 'number' && opts.retries > 0) {
    debug('has retries', opts.retries)
    var retries = opts.retries
    opts.retries = 0
    cb = (function (orig) { return function cb (er, fd) {
      debug('retry-mutated callback')
      retries -= 1
      if (!er || retries < 0) return orig(er, fd)

      debug('lock retry', path, opts)

      if (opts.retryWait) setTimeout(retry, opts.retryWait)
      else retry()

      function retry () {
        opts.start = Date.now()
        debug('retrying', opts.start)
        exports.lock(path, opts, cb)
      }
    }})(cb)
  }

  // try to engage the lock.
  // if this succeeds, then we're in business.
  fs.open(path, wx, function (er, fd) {
    if (!er) {
      debug('locked', path, fd)
      locks[path] = fd
      return fs.close(fd, function () {
        return cb()
      })
    }

    debug('failed to acquire lock', er)

    // something other than "currently locked"
    // maybe eperm or something.
    if (er.code !== 'EEXIST') {
      debug('not EEXIST error', er)
      return cb(er)
    }

    // someone's got this one.  see if it's valid.
    if (!opts.stale) return notStale(er, path, opts, cb)

    return maybeStale(er, path, opts, false, cb)
  })
  debug('lock return')
}


// Staleness checking algorithm
// 1. acquire $lock, fail
// 2. stat $lock, find that it is stale
// 3. acquire $lock.STALE
// 4. stat $lock, assert that it is still stale
// 5. unlink $lock
// 6. link $lock.STALE $lock
// 7. unlink $lock.STALE
// On any failure, clean up whatever we've done, and raise the error.
function maybeStale (originalEr, path, opts, hasStaleLock, cb) {
  fs.stat(path, function (statEr, st) {
    if (statEr) {
      if (statEr.code === 'ENOENT') {
        // expired already!
        opts.stale = false
        debug('lock stale enoent retry', path, opts)
        exports.lock(path, opts, cb)
        return
      }
      return cb(statEr)
    }

    var age = Date.now() - st[exports.filetime].getTime()
    if (age <= opts.stale) return notStale(originalEr, path, opts, cb)

    debug('lock stale', path, opts)
    if (hasStaleLock) {
      exports.unlock(path, function (er) {
        if (er) return cb(er)
        debug('lock stale retry', path, opts)
        fs.link(path + '.STALE', path, function (er) {
          fs.unlink(path + '.STALE', function () {
            // best effort.  if the unlink fails, oh well.
            cb(er)
          })
        })
      })
    } else {
      debug('acquire .STALE file lock', opts)
      exports.lock(path + '.STALE', opts, function (er) {
        if (er) return cb(er)
        maybeStale(originalEr, path, opts, true, cb)
      })
    }
  })
}

function notStale (er, path, opts, cb) {
  debug('notStale', path, opts)

  // if we can't wait, then just call it a failure
  if (typeof opts.wait !== 'number' || opts.wait <= 0) {
    debug('notStale, wait is not a number')
    return cb(er)
  }

  // poll for some ms for the lock to clear
  var now = Date.now()
  var start = opts.start || now
  var end = start + opts.wait

  if (end <= now)
    return cb(er)

  debug('now=%d, wait until %d (delta=%d)', start, end, end-start)
  var wait = Math.min(end - start, opts.pollPeriod || 100)
  var timer = setTimeout(poll, wait)

  function poll () {
    debug('notStale, polling', path, opts)
    exports.lock(path, opts, cb)
  }
}

exports.lockSync = function (path, opts) {
  opts = opts || {}
  opts.req = opts.req || req++
  debug('lockSync', path, opts)
  if (opts.wait || opts.retryWait) {
    throw new Error('opts.wait not supported sync for obvious reasons')
  }

  try {
    var fd = fs.openSync(path, wx)
    locks[path] = fd
    try { fs.closeSync(fd) } catch (er) {}
    debug('locked sync!', path, fd)
    return
  } catch (er) {
    if (er.code !== 'EEXIST') return retryThrow(path, opts, er)

    if (opts.stale) {
      var st = fs.statSync(path)
      var ct = st[exports.filetime].getTime()
      if (!(ct % 1000) && (opts.stale % 1000)) {
        // probably don't have subsecond resolution.
        // round up the staleness indicator.
        // Yes, this will be wrong 1/1000 times on platforms
        // with subsecond stat precision, but that's acceptable
        // in exchange for not mistakenly removing locks on
        // most other systems.
        opts.stale = 1000 * Math.ceil(opts.stale / 1000)
      }
      var age = Date.now() - ct
      if (age > opts.stale) {
        debug('lockSync stale', path, opts, age)
        exports.unlockSync(path)
        return exports.lockSync(path, opts)
      }
    }

    // failed to lock!
    debug('failed to lock', path, opts, er)
    return retryThrow(path, opts, er)
  }
}

function retryThrow (path, opts, er) {
  if (typeof opts.retries === 'number' && opts.retries > 0) {
    var newRT = opts.retries - 1
    debug('retryThrow', path, opts, newRT)
    opts.retries = newRT
    return exports.lockSync(path, opts)
  }
  throw er
}



/***/ }),

/***/ "../../node_modules/ms/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ms/index.js ***!
  \**************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/tr46/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/tr46/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var punycode = __webpack_require__(/*! punycode */ "punycode");
var mappingTable = __webpack_require__(/*! ./lib/mappingTable.json */ "../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json");

var PROCESSING_OPTIONS = {
  TRANSITIONAL: 0,
  NONTRANSITIONAL: 1
};

function normalize(str) { // fix bug in v8
  return str.split('\u0000').map(function (s) { return s.normalize('NFC'); }).join('\u0000');
}

function findStatus(val) {
  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);

    var target = mappingTable[mid];
    if (target[0][0] <= val && target[0][1] >= val) {
      return target;
    } else if (target[0][0] > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function countSymbols(string) {
  return string
    // replace every surrogate pair with a BMP symbol
    .replace(regexAstralSymbols, '_')
    // then get the length
    .length;
}

function mapChars(domain_name, useSTD3, processing_option) {
  var hasError = false;
  var processed = "";

  var len = countSymbols(domain_name);
  for (var i = 0; i < len; ++i) {
    var codePoint = domain_name.codePointAt(i);
    var status = findStatus(codePoint);

    switch (status[1]) {
      case "disallowed":
        hasError = true;
        processed += String.fromCodePoint(codePoint);
        break;
      case "ignored":
        break;
      case "mapped":
        processed += String.fromCodePoint.apply(String, status[2]);
        break;
      case "deviation":
        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
          processed += String.fromCodePoint.apply(String, status[2]);
        } else {
          processed += String.fromCodePoint(codePoint);
        }
        break;
      case "valid":
        processed += String.fromCodePoint(codePoint);
        break;
      case "disallowed_STD3_mapped":
        if (useSTD3) {
          hasError = true;
          processed += String.fromCodePoint(codePoint);
        } else {
          processed += String.fromCodePoint.apply(String, status[2]);
        }
        break;
      case "disallowed_STD3_valid":
        if (useSTD3) {
          hasError = true;
        }

        processed += String.fromCodePoint(codePoint);
        break;
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;

function validateLabel(label, processing_option) {
  if (label.substr(0, 4) === "xn--") {
    label = punycode.toUnicode(label);
    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
  }

  var error = false;

  if (normalize(label) !== label ||
      (label[3] === "-" && label[4] === "-") ||
      label[0] === "-" || label[label.length - 1] === "-" ||
      label.indexOf(".") !== -1 ||
      label.search(combiningMarksRegex) === 0) {
    error = true;
  }

  var len = countSymbols(label);
  for (var i = 0; i < len; ++i) {
    var status = findStatus(label.codePointAt(i));
    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
         status[1] !== "valid" && status[1] !== "deviation")) {
      error = true;
      break;
    }
  }

  return {
    label: label,
    error: error
  };
}

function processing(domain_name, useSTD3, processing_option) {
  var result = mapChars(domain_name, useSTD3, processing_option);
  result.string = normalize(result.string);

  var labels = result.string.split(".");
  for (var i = 0; i < labels.length; ++i) {
    try {
      var validation = validateLabel(labels[i]);
      labels[i] = validation.label;
      result.error = result.error || validation.error;
    } catch(e) {
      result.error = true;
    }
  }

  return {
    string: labels.join("."),
    error: result.error
  };
}

module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
  var result = processing(domain_name, useSTD3, processing_option);
  var labels = result.string.split(".");
  labels = labels.map(function(l) {
    try {
      return punycode.toASCII(l);
    } catch(e) {
      result.error = true;
      return l;
    }
  });

  if (verifyDnsLength) {
    var total = labels.slice(0, labels.length - 1).join(".").length;
    if (total.length > 253 || total.length === 0) {
      result.error = true;
    }

    for (var i=0; i < labels.length; ++i) {
      if (labels.length > 63 || labels.length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) return null;
  return labels.join(".");
};

module.exports.toUnicode = function(domain_name, useSTD3) {
  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);

  return {
    domain: result.string,
    error: result.error
  };
};

module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;


/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const usm = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js");

exports.implementation = class URLImpl {
  constructor(constructorArgs) {
    const url = constructorArgs[0];
    const base = constructorArgs[1];

    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === "failure") {
        throw new TypeError("Invalid base URL");
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;

    // TODO: query stuff
  }

  get href() {
    return usm.serializeURL(this._url);
  }

  set href(v) {
    const parsedURL = usm.basicURLParse(v);
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;
  }

  get origin() {
    return usm.serializeURLOrigin(this._url);
  }

  get protocol() {
    return this._url.scheme + ":";
  }

  set protocol(v) {
    usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
  }

  get username() {
    return this._url.username;
  }

  set username(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setTheUsername(this._url, v);
  }

  get password() {
    return this._url.password;
  }

  set password(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setThePassword(this._url, v);
  }

  get host() {
    const url = this._url;

    if (url.host === null) {
      return "";
    }

    if (url.port === null) {
      return usm.serializeHost(url.host);
    }

    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
  }

  set host(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }

  get hostname() {
    if (this._url.host === null) {
      return "";
    }

    return usm.serializeHost(this._url.host);
  }

  set hostname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }

  get port() {
    if (this._url.port === null) {
      return "";
    }

    return usm.serializeInteger(this._url.port);
  }

  set port(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    if (v === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
    }
  }

  get pathname() {
    if (this._url.cannotBeABaseURL) {
      return this._url.path[0];
    }

    if (this._url.path.length === 0) {
      return "";
    }

    return "/" + this._url.path.join("/");
  }

  set pathname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    this._url.path = [];
    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
  }

  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }

    return "?" + this._url.query;
  }

  set search(v) {
    // TODO: query stuff

    const url = this._url;

    if (v === "") {
      url.query = null;
      return;
    }

    const input = v[0] === "?" ? v.substring(1) : v;
    url.query = "";
    usm.basicURLParse(input, { url, stateOverride: "query" });
  }

  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }

    return "#" + this._url.fragment;
  }

  set hash(v) {
    if (v === "") {
      this._url.fragment = null;
      return;
    }

    const input = v[0] === "#" ? v.substring(1) : v;
    this._url.fragment = "";
    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }

  toJSON() {
    return this.href;
  }
};


/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js":
/*!************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const conversions = __webpack_require__(/*! webidl-conversions */ "../../node_modules/webidl-conversions/lib/index.js");
const utils = __webpack_require__(/*! ./utils.js */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js");
const Impl = __webpack_require__(/*! .//URL-impl.js */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js");

const impl = utils.implSymbol;

function URL(url) {
  if (!this || this[impl] || !(this instanceof URL)) {
    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 2; ++i) {
    args[i] = arguments[i];
  }
  args[0] = conversions["USVString"](args[0]);
  if (args[1] !== undefined) {
  args[1] = conversions["USVString"](args[1]);
  }

  module.exports.setup(this, args);
}

URL.prototype.toJSON = function toJSON() {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 0; ++i) {
    args[i] = arguments[i];
  }
  return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
  get() {
    return this[impl].href;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].href = V;
  },
  enumerable: true,
  configurable: true
});

URL.prototype.toString = function () {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  return this.href;
};

Object.defineProperty(URL.prototype, "origin", {
  get() {
    return this[impl].origin;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "protocol", {
  get() {
    return this[impl].protocol;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].protocol = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "username", {
  get() {
    return this[impl].username;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].username = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "password", {
  get() {
    return this[impl].password;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].password = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "host", {
  get() {
    return this[impl].host;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].host = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hostname", {
  get() {
    return this[impl].hostname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hostname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "port", {
  get() {
    return this[impl].port;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].port = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "pathname", {
  get() {
    return this[impl].pathname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].pathname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "search", {
  get() {
    return this[impl].search;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].search = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hash", {
  get() {
    return this[impl].hash;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hash = V;
  },
  enumerable: true,
  configurable: true
});


module.exports = {
  is(obj) {
    return !!obj && obj[impl] instanceof Impl.implementation;
  },
  create(constructorArgs, privateData) {
    let obj = Object.create(URL.prototype);
    this.setup(obj, constructorArgs, privateData);
    return obj;
  },
  setup(obj, constructorArgs, privateData) {
    if (!privateData) privateData = {};
    privateData.wrapper = obj;

    obj[impl] = new Impl.implementation(constructorArgs, privateData);
    obj[impl][utils.wrapperSymbol] = obj;
  },
  interface: URL,
  expose: {
    Window: { URL: URL },
    Worker: { URL: URL }
  }
};



/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.URL = __webpack_require__(/*! ./URL */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js")["interface"];
exports.serializeURL = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeURL;
exports.serializeURLOrigin = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeURLOrigin;
exports.basicURLParse = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").basicURLParse;
exports.setTheUsername = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").setTheUsername;
exports.setThePassword = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").setThePassword;
exports.serializeHost = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeHost;
exports.serializeInteger = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").serializeInteger;
exports.parseURL = __webpack_require__(/*! ./url-state-machine */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js").parseURL;


/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const punycode = __webpack_require__(/*! punycode */ "punycode");
const tr46 = __webpack_require__(/*! tr46 */ "../../node_modules/node-fetch/node_modules/tr46/index.js");

const specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

const failure = Symbol("failure");

function countSymbols(str) {
  return punycode.ucs2.decode(str).length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isASCIIDigit(c) {
  return c >= 0x30 && c <= 0x39;
}

function isASCIIAlpha(c) {
  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
}

function isASCIIAlphanumeric(c) {
  return isASCIIAlpha(c) || isASCIIDigit(c);
}

function isASCIIHex(c) {
  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
}

function isSingleDot(buffer) {
  return buffer === "." || buffer.toLowerCase() === "%2e";
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}

function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}

function isWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}

function isNormalizedWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}

function containsForbiddenHostCodePoint(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function containsForbiddenHostCodePointExcludingPercent(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function isSpecialScheme(scheme) {
  return specialSchemes[scheme] !== undefined;
}

function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}

function defaultPort(scheme) {
  return specialSchemes[scheme];
}

function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = "0" + hex;
  }

  return "%" + hex;
}

function utf8PercentEncode(c) {
  const buf = new Buffer(c);

  let str = "";

  for (let i = 0; i < buf.length; ++i) {
    str += percentEncode(buf[i]);
  }

  return str;
}

function utf8PercentDecode(str) {
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i < input.length; ++i) {
    if (input[i] !== 37) {
      output.push(input[i]);
    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    } else {
      output.push(input[i]);
    }
  }
  return new Buffer(output).toString();
}

function isC0ControlPercentEncode(c) {
  return c <= 0x1F || c > 0x7E;
}

const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
function isPathPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}

const extraUserinfoPercentEncodeSet =
  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
function isUserinfoPercentEncode(c) {
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}

function percentEncodeChar(c, encodeSetPredicate) {
  const cStr = String.fromCodePoint(c);

  if (encodeSetPredicate(c)) {
    return utf8PercentEncode(cStr);
  }

  return cStr;
}

function parseIPv4Number(input) {
  let R = 10;

  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
    input = input.substring(2);
    R = 16;
  } else if (input.length >= 2 && input.charAt(0) === "0") {
    input = input.substring(1);
    R = 8;
  }

  if (input === "") {
    return 0;
  }

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length > 1) {
      parts.pop();
    }
  }

  if (parts.length > 4) {
    return input;
  }

  const numbers = [];
  for (const part of parts) {
    if (part === "") {
      return input;
    }
    const n = parseIPv4Number(part);
    if (n === failure) {
      return input;
    }

    numbers.push(n);
  }

  for (let i = 0; i < numbers.length - 1; ++i) {
    if (numbers[i] > 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = "";
  let n = address;

  for (let i = 1; i <= 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 4) {
      output = "." + output;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === 58) {
    if (input[pointer + 1] !== 58) {
      return failure;
    }

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }

  while (pointer < input.length) {
    if (pieceIndex === 8) {
      return failure;
    }

    if (input[pointer] === 58) {
      if (compress !== null) {
        return failure;
      }
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length < 4 && isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    if (input[pointer] === 46) {
      if (length === 0) {
        return failure;
      }

      pointer -= length;

      if (pieceIndex > 6) {
        return failure;
      }

      let numbersSeen = 0;

      while (input[pointer] !== undefined) {
        let ipv4Piece = null;

        if (numbersSeen > 0) {
          if (input[pointer] === 46 && numbersSeen < 4) {
            ++pointer;
          } else {
            return failure;
          }
        }

        if (!isASCIIDigit(input[pointer])) {
          return failure;
        }

        while (isASCIIDigit(input[pointer])) {
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) {
            ipv4Piece = number;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number;
          }
          if (ipv4Piece > 255) {
            return failure;
          }
          ++pointer;
        }

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }

      if (numbersSeen !== 4) {
        return failure;
      }

      break;
    } else if (input[pointer] === 58) {
      ++pointer;
      if (input[pointer] === undefined) {
        return failure;
      }
    } else if (input[pointer] !== undefined) {
      return failure;
    }

    address[pieceIndex] = value;
    ++pieceIndex;
  }

  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null && pieceIndex !== 8) {
    return failure;
  }

  return address;
}

function serializeIPv6(address) {
  let output = "";
  const seqResult = findLongestZeroSequence(address);
  const compress = seqResult.idx;
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
    if (ignore0 && address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }

    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    }

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) {
      output += ":";
    }
  }

  return output;
}

function parseHost(input, isSpecialArg) {
  if (input[0] === "[") {
    if (input[input.length - 1] !== "]") {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  if (!isSpecialArg) {
    return parseOpaqueHost(input);
  }

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
  if (asciiDomain === null) {
    return failure;
  }

  if (containsForbiddenHostCodePoint(asciiDomain)) {
    return failure;
  }

  const ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === "number" || ipv4Host === failure) {
    return ipv4Host;
  }

  return asciiDomain;
}

function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePointExcludingPercent(input)) {
    return failure;
  }

  let output = "";
  const decoded = punycode.ucs2.decode(input);
  for (let i = 0; i < decoded.length; ++i) {
    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
  }
  return output;
}

function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1; // only find elements > 1
  let currStart = null;
  let currLen = 0;

  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] !== 0) {
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }

      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i;
      }
      ++currLen;
    }
  }

  // if trailing zeros
  if (currLen > maxLen) {
    maxIdx = currStart;
    maxLen = currLen;
  }

  return {
    idx: maxIdx,
    len: maxLen
  };
}

function serializeHost(host) {
  if (typeof host === "number") {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return "[" + serializeIPv6(host) + "]";
  }

  return host;
}

function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}

function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/g, "");
}

function shortenPath(url) {
  const path = url.path;
  if (path.length === 0) {
    return;
  }
  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
    return;
  }

  path.pop();
}

function includesCredentials(url) {
  return url.username !== "" || url.password !== "";
}

function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}

function isNormalizedWindowsDriveLetter(string) {
  return /^[A-Za-z]:$/.test(string);
}

function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || "utf-8";
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) {
    this.url = {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      cannotBeABaseURL: false
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
  }

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) {
    this.parseError = true;
  }
  this.input = res;

  this.state = stateOverride || "scheme start";

  this.buffer = "";
  this.atFlag = false;
  this.arrFlag = false;
  this.passwordTokenSeenFlag = false;

  this.input = punycode.ucs2.decode(this.input);

  for (; this.pointer <= this.input.length; ++this.pointer) {
    const c = this.input[this.pointer];
    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this["parse " + this.state](c, cStr);
    if (!ret) {
      break; // terminate algorithm
    } else if (ret === failure) {
      this.failure = true;
      break;
    }
  }
}

URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
  if (isASCIIAlpha(c)) {
    this.buffer += cStr.toLowerCase();
    this.state = "scheme";
  } else if (!this.stateOverride) {
    this.state = "no scheme";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
    this.buffer += cStr.toLowerCase();
  } else if (c === 58) {
    if (this.stateOverride) {
      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
        return false;
      }

      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
        return false;
      }

      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
        return false;
      }

      if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
        return false;
      }
    }
    this.url.scheme = this.buffer;
    this.buffer = "";
    if (this.stateOverride) {
      return false;
    }
    if (this.url.scheme === "file") {
      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
        this.parseError = true;
      }
      this.state = "file";
    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
      this.state = "special relative or authority";
    } else if (isSpecial(this.url)) {
      this.state = "special authority slashes";
    } else if (this.input[this.pointer + 1] === 47) {
      this.state = "path or authority";
      ++this.pointer;
    } else {
      this.url.cannotBeABaseURL = true;
      this.url.path.push("");
      this.state = "cannot-be-a-base-URL path";
    }
  } else if (!this.stateOverride) {
    this.buffer = "";
    this.state = "no scheme";
    this.pointer = -1;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
    return failure;
  } else if (this.base.cannotBeABaseURL && c === 35) {
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.url.cannotBeABaseURL = true;
    this.state = "fragment";
  } else if (this.base.scheme === "file") {
    this.state = "file";
    --this.pointer;
  } else {
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
  if (c === 47) {
    this.state = "authority";
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
  this.url.scheme = this.base.scheme;
  if (isNaN(c)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
  } else if (c === 47) {
    this.state = "relative slash";
  } else if (c === 63) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.state = "fragment";
  } else if (isSpecial(this.url) && c === 92) {
    this.parseError = true;
    this.state = "relative slash";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
  if (isSpecial(this.url) && (c === 47 || c === 92)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "special authority ignore slashes";
  } else if (c === 47) {
    this.state = "authority";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "special authority ignore slashes";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
  if (c !== 47 && c !== 92) {
    this.state = "authority";
    --this.pointer;
  } else {
    this.parseError = true;
  }

  return true;
};

URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
  if (c === 64) {
    this.parseError = true;
    if (this.atFlag) {
      this.buffer = "%40" + this.buffer;
    }
    this.atFlag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer < len; ++pointer) {
      const codePoint = this.buffer.codePointAt(pointer);

      if (codePoint === 58 && !this.passwordTokenSeenFlag) {
        this.passwordTokenSeenFlag = true;
        continue;
      }
      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
      if (this.passwordTokenSeenFlag) {
        this.url.password += encodedCodePoints;
      } else {
        this.url.username += encodedCodePoints;
      }
    }
    this.buffer = "";
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    if (this.atFlag && this.buffer === "") {
      this.parseError = true;
      return failure;
    }
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = "";
    this.state = "host";
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse hostname"] =
URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
  if (this.stateOverride && this.url.scheme === "file") {
    --this.pointer;
    this.state = "file host";
  } else if (c === 58 && !this.arrFlag) {
    if (this.buffer === "") {
      this.parseError = true;
      return failure;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "port";
    if (this.stateOverride === "hostname") {
      return false;
    }
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    --this.pointer;
    if (isSpecial(this.url) && this.buffer === "") {
      this.parseError = true;
      return failure;
    } else if (this.stateOverride && this.buffer === "" &&
               (includesCredentials(this.url) || this.url.port !== null)) {
      this.parseError = true;
      return false;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "path start";
    if (this.stateOverride) {
      return false;
    }
  } else {
    if (c === 91) {
      this.arrFlag = true;
    } else if (c === 93) {
      this.arrFlag = false;
    }
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
  if (isASCIIDigit(c)) {
    this.buffer += cStr;
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92) ||
             this.stateOverride) {
    if (this.buffer !== "") {
      const port = parseInt(this.buffer);
      if (port > Math.pow(2, 16) - 1) {
        this.parseError = true;
        return failure;
      }
      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
      this.buffer = "";
    }
    if (this.stateOverride) {
      return false;
    }
    this.state = "path start";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

URLStateMachine.prototype["parse file"] = function parseFile(c) {
  this.url.scheme = "file";

  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file slash";
  } else if (this.base !== null && this.base.scheme === "file") {
    if (isNaN(c)) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 63) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        shortenPath(this.url);
      } else {
        this.parseError = true;
      }

      this.state = "path";
      --this.pointer;
    }
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file host";
  } else {
    if (this.base !== null && this.base.scheme === "file") {
      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
        this.url.path.push(this.base.path[0]);
      } else {
        this.url.host = this.base.host;
      }
    }
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
    --this.pointer;
    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
      this.parseError = true;
      this.state = "path";
    } else if (this.buffer === "") {
      this.url.host = "";
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
    } else {
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      if (host === "localhost") {
        host = "";
      }
      this.url.host = host;

      if (this.stateOverride) {
        return false;
      }

      this.buffer = "";
      this.state = "path start";
    }
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
  if (isSpecial(this.url)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "path";

    if (c !== 47 && c !== 92) {
      --this.pointer;
    }
  } else if (!this.stateOverride && c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (!this.stateOverride && c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else if (c !== undefined) {
    this.state = "path";
    if (c !== 47) {
      --this.pointer;
    }
  }

  return true;
};

URLStateMachine.prototype["parse path"] = function parsePath(c) {
  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
      (!this.stateOverride && (c === 63 || c === 35))) {
    if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
    }

    if (isDoubleDot(this.buffer)) {
      shortenPath(this.url);
      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      }
    } else if (isSingleDot(this.buffer) && c !== 47 &&
               !(isSpecial(this.url) && c === 92)) {
      this.url.path.push("");
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
        if (this.url.host !== "" && this.url.host !== null) {
          this.parseError = true;
          this.url.host = "";
        }
        this.buffer = this.buffer[0] + ":";
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = "";
    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
      while (this.url.path.length > 1 && this.url.path[0] === "") {
        this.parseError = true;
        this.url.path.shift();
      }
    }
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    }
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.

    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += percentEncodeChar(c, isPathPercentEncode);
  }

  return true;
};

URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
  if (c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) && c !== 37) {
      this.parseError = true;
    }

    if (c === 37 &&
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    if (!isNaN(c)) {
      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
    }
  }

  return true;
};

URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
  if (isNaN(c) || (!this.stateOverride && c === 35)) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }

    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
    for (let i = 0; i < buffer.length; ++i) {
      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) {
        this.url.query += percentEncode(buffer[i]);
      } else {
        this.url.query += String.fromCodePoint(buffer[i]);
      }
    }

    this.buffer = "";
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
  if (isNaN(c)) { // do nothing
  } else if (c === 0x0) {
    this.parseError = true;
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
  }

  return true;
};

function serializeURL(url, excludeFragment) {
  let output = url.scheme + ":";
  if (url.host !== null) {
    output += "//";

    if (url.username !== "" || url.password !== "") {
      output += url.username;
      if (url.password !== "") {
        output += ":" + url.password;
      }
      output += "@";
    }

    output += serializeHost(url.host);

    if (url.port !== null) {
      output += ":" + url.port;
    }
  } else if (url.host === null && url.scheme === "file") {
    output += "//";
  }

  if (url.cannotBeABaseURL) {
    output += url.path[0];
  } else {
    for (const string of url.path) {
      output += "/" + string;
    }
  }

  if (url.query !== null) {
    output += "?" + url.query;
  }

  if (!excludeFragment && url.fragment !== null) {
    output += "#" + url.fragment;
  }

  return output;
}

function serializeOrigin(tuple) {
  let result = tuple.scheme + "://";
  result += serializeHost(tuple.host);

  if (tuple.port !== null) {
    result += ":" + tuple.port;
  }

  return result;
}

module.exports.serializeURL = serializeURL;

module.exports.serializeURLOrigin = function (url) {
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) {
    case "blob":
      try {
        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
      } catch (e) {
        // serializing an opaque origin returns "null"
        return "null";
      }
    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case "file":
      // spec says "exercise to the reader", chrome says "file://"
      return "file://";
    default:
      // serializing an opaque origin returns "null"
      return "null";
  }
};

module.exports.basicURLParse = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return "failure";
  }

  return usm.url;
};

module.exports.setTheUsername = function (url, username) {
  url.username = "";
  const decoded = punycode.ucs2.decode(username);
  for (let i = 0; i < decoded.length; ++i) {
    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.setThePassword = function (url, password) {
  url.password = "";
  const decoded = punycode.ucs2.decode(password);
  for (let i = 0; i < decoded.length; ++i) {
    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.serializeInteger = function (integer) {
  return String(integer);
};

module.exports.parseURL = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  // We don't handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
};


/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


module.exports.mixin = function mixin(target, source) {
  const keys = Object.getOwnPropertyNames(source);
  for (let i = 0; i < keys.length; ++i) {
    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }
};

module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");

module.exports.wrapperForImpl = function (impl) {
  return impl[module.exports.wrapperSymbol];
};

module.exports.implForWrapper = function (wrapper) {
  return wrapper[module.exports.implSymbol];
};



/***/ }),

/***/ "../../node_modules/node-gyp-build/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/node-gyp-build/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")
var os = __webpack_require__(/*! os */ "os")

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : 'node'
var arch = os.arch()
var platform = os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.path(dir))
}

load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    (process.versions && process.versions.electron) ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', platform + '-' + arch)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags


/***/ }),

/***/ "../../node_modules/node-rsa/src/NodeRSA.js":
/*!**************************************************!*\
  !*** ../../node_modules/node-rsa/src/NodeRSA.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * RSA library for Node.js
 *
 * Author: rzcoder
 * License MIT
 */

var constants = __webpack_require__(/*! constants */ "constants");
var rsa = __webpack_require__(/*! ./libs/rsa.js */ "../../node_modules/node-rsa/src/libs/rsa.js");
var crypt = __webpack_require__(/*! crypto */ "crypto");
var ber = (__webpack_require__(/*! asn1 */ "../../node_modules/asn1/lib/index.js").Ber);
var _ = (__webpack_require__(/*! ./utils */ "../../node_modules/node-rsa/src/utils.js")._);
var utils = __webpack_require__(/*! ./utils */ "../../node_modules/node-rsa/src/utils.js");
var schemes = __webpack_require__(/*! ./schemes/schemes.js */ "../../node_modules/node-rsa/src/schemes/schemes.js");
var formats = __webpack_require__(/*! ./formats/formats.js */ "../../node_modules/node-rsa/src/formats/formats.js");

if (typeof constants.RSA_NO_PADDING === "undefined") {
    //patch for node v0.10.x, constants do not defined
    constants.RSA_NO_PADDING = 3;
}

module.exports = (function () {
    var SUPPORTED_HASH_ALGORITHMS = {
        node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],
        node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],
        iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],
        browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']
    };

    var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';
    var DEFAULT_SIGNING_SCHEME = 'pkcs1';

    var DEFAULT_EXPORT_FORMAT = 'private';
    var EXPORT_FORMAT_ALIASES = {
        'private': 'pkcs1-private-pem',
        'private-der': 'pkcs1-private-der',
        'public': 'pkcs8-public-pem',
        'public-der': 'pkcs8-public-der',
    };

    /**
     * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}
     * @constructor
     */
    function NodeRSA(key, format, options) {
        if (!(this instanceof NodeRSA)) {
            return new NodeRSA(key, format, options);
        }

        if (_.isObject(format)) {
            options = format;
            format = undefined;
        }

        this.$options = {
            signingScheme: DEFAULT_SIGNING_SCHEME,
            signingSchemeOptions: {
                hash: 'sha256',
                saltLength: null
            },
            encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,
            encryptionSchemeOptions: {
                hash: 'sha1',
                label: null
            },
            environment: utils.detectEnvironment(),
            rsaUtils: this
        };
        this.keyPair = new rsa.Key();
        this.$cache = {};

        if (Buffer.isBuffer(key) || _.isString(key)) {
            this.importKey(key, format);
        } else if (_.isObject(key)) {
            this.generateKeyPair(key.b, key.e);
        }

        this.setOptions(options);
    }

    /**
     * Set and validate options for key instance
     * @param options
     */
    NodeRSA.prototype.setOptions = function (options) {
        options = options || {};
        if (options.environment) {
            this.$options.environment = options.environment;
        }

        if (options.signingScheme) {
            if (_.isString(options.signingScheme)) {
                var signingScheme = options.signingScheme.toLowerCase().split('-');
                if (signingScheme.length == 1) {
                    if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {
                        this.$options.signingSchemeOptions = {
                            hash: signingScheme[0]
                        };
                        this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;
                    } else {
                        this.$options.signingScheme = signingScheme[0];
                        this.$options.signingSchemeOptions = {
                            hash: null
                        };
                    }
                } else {
                    this.$options.signingSchemeOptions = {
                        hash: signingScheme[1]
                    };
                    this.$options.signingScheme = signingScheme[0];
                }
            } else if (_.isObject(options.signingScheme)) {
                this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;
                this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');
            }

            if (!schemes.isSignature(this.$options.signingScheme)) {
                throw Error('Unsupported signing scheme');
            }

            if (this.$options.signingSchemeOptions.hash &&
                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {
                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');
            }
        }

        if (options.encryptionScheme) {
            if (_.isString(options.encryptionScheme)) {
                this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();
                this.$options.encryptionSchemeOptions = {};
            } else if (_.isObject(options.encryptionScheme)) {
                this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;
                this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');
            }

            if (!schemes.isEncryption(this.$options.encryptionScheme)) {
                throw Error('Unsupported encryption scheme');
            }

            if (this.$options.encryptionSchemeOptions.hash &&
                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {
                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');
            }
        }

        this.keyPair.setOptions(this.$options);
    };

    /**
     * Generate private/public keys pair
     *
     * @param bits {int} length key in bits. Default 2048.
     * @param exp {int} public exponent. Default 65537.
     * @returns {NodeRSA}
     */
    NodeRSA.prototype.generateKeyPair = function (bits, exp) {
        bits = bits || 2048;
        exp = exp || 65537;

        if (bits % 8 !== 0) {
            throw Error('Key size must be a multiple of 8.');
        }

        this.keyPair.generate(bits, exp.toString(16));
        this.$cache = {};
        return this;
    };

    /**
     * Importing key
     * @param keyData {string|buffer|Object}
     * @param format {string}
     */
    NodeRSA.prototype.importKey = function (keyData, format) {
        if (!keyData) {
            throw Error("Empty key given");
        }

        if (format) {
            format = EXPORT_FORMAT_ALIASES[format] || format;
        }

        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {
            throw Error("Key format must be specified");
        }
        
        this.$cache = {};
        
        return this;
    };

    /**
     * Exporting key
     * @param [format] {string}
     */
    NodeRSA.prototype.exportKey = function (format) {
        format = format || DEFAULT_EXPORT_FORMAT;
        format = EXPORT_FORMAT_ALIASES[format] || format;

        if (!this.$cache[format]) {
            this.$cache[format] = formats.detectAndExport(this.keyPair, format);
        }

        return this.$cache[format];
    };

    /**
     * Check if key pair contains private key
     */
    NodeRSA.prototype.isPrivate = function () {
        return this.keyPair.isPrivate();
    };

    /**
     * Check if key pair contains public key
     * @param [strict] {boolean} - public key only, return false if have private exponent
     */
    NodeRSA.prototype.isPublic = function (strict) {
        return this.keyPair.isPublic(strict);
    };

    /**
     * Check if key pair doesn't contains any data
     */
    NodeRSA.prototype.isEmpty = function (strict) {
        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);
    };

    /**
     * Encrypting data method with public key
     *
     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.
     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.
     * @returns {string|Buffer}
     */
    NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {
        return this.$$encryptKey(false, buffer, encoding, source_encoding);
    };

    /**
     * Decrypting data method with private key
     *
     * @param buffer {Buffer} - buffer for decrypting
     * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type
     * @returns {Buffer|object|string}
     */
    NodeRSA.prototype.decrypt = function (buffer, encoding) {
        return this.$$decryptKey(false, buffer, encoding);
    };

    /**
     * Encrypting data method with private key
     *
     * Parameters same as `encrypt` method
     */
    NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {
        return this.$$encryptKey(true, buffer, encoding, source_encoding);
    };

    /**
     * Decrypting data method with public key
     *
     * Parameters same as `decrypt` method
     */
    NodeRSA.prototype.decryptPublic = function (buffer, encoding) {
        return this.$$decryptKey(true, buffer, encoding);
    };

    /**
     * Encrypting data method with custom key
     */
    NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {
        try {
            var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);

            if (encoding == 'buffer' || !encoding) {
                return res;
            } else {
                return res.toString(encoding);
            }
        } catch (e) {
            throw Error('Error during encryption. Original error: ' + e);
        }
    };

    /**
     * Decrypting data method with custom key
     */
    NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {
        try {
            buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;
            var res = this.keyPair.decrypt(buffer, usePublic);

            if (res === null) {
                throw Error('Key decrypt method returns null.');
            }

            return this.$getDecryptedData(res, encoding);
        } catch (e) {
            throw Error('Error during decryption (probably incorrect key). Original error: ' + e);
        }
    };

    /**
     *  Signing data
     *
     * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.
     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.
     * @returns {string|Buffer}
     */
    NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {
        if (!this.isPrivate()) {
            throw Error("This is not private key");
        }

        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));

        if (encoding && encoding != 'buffer') {
            res = res.toString(encoding);
        }

        return res;
    };

    /**
     *  Verifying signed data
     *
     * @param buffer - signed data
     * @param signature
     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.
     * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.
     * @returns {*}
     */
    NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {
        if (!this.isPublic()) {
            throw Error("This is not public key");
        }
        signature_encoding = (!signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding);
        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);
    };

    /**
     * Returns key size in bits
     * @returns {int}
     */
    NodeRSA.prototype.getKeySize = function () {
        return this.keyPair.keySize;
    };

    /**
     * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme
     * @returns {int}
     */
    NodeRSA.prototype.getMaxMessageSize = function () {
        return this.keyPair.maxMessageLength;
    };

    /**
     * Preparing given data for encrypting/signing. Just make new/return Buffer object.
     *
     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.
     * @param encoding {string} - optional. Encoding for given string. Default utf8.
     * @returns {Buffer}
     */
    NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {
        if (_.isString(buffer) || _.isNumber(buffer)) {
            return Buffer.from('' + buffer, encoding || 'utf8');
        } else if (Buffer.isBuffer(buffer)) {
            return buffer;
        } else if (_.isObject(buffer)) {
            return Buffer.from(JSON.stringify(buffer));
        } else {
            throw Error("Unexpected data type");
        }
    };

    /**
     *
     * @param buffer {Buffer} - decrypted data.
     * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.
     * @returns {*}
     */
    NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {
        encoding = encoding || 'buffer';

        if (encoding == 'buffer') {
            return buffer;
        } else if (encoding == 'json') {
            return JSON.parse(buffer.toString());
        } else {
            return buffer.toString(encoding);
        }
    };

    return NodeRSA;
})();


/***/ }),

/***/ "../../node_modules/node-rsa/src/encryptEngines/encryptEngines.js":
/*!************************************************************************!*\
  !*** ../../node_modules/node-rsa/src/encryptEngines/encryptEngines.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var crypt = __webpack_require__(/*! crypto */ "crypto");

module.exports = {
    getEngine: function (keyPair, options) {
        var engine = __webpack_require__(/*! ./js.js */ "../../node_modules/node-rsa/src/encryptEngines/js.js");
        if (options.environment === 'node') {
            if (typeof crypt.publicEncrypt === 'function' && typeof crypt.privateDecrypt === 'function') {
                if (typeof crypt.privateEncrypt === 'function' && typeof crypt.publicDecrypt === 'function') {
                    engine = __webpack_require__(/*! ./io.js */ "../../node_modules/node-rsa/src/encryptEngines/io.js");
                } else {
                    engine = __webpack_require__(/*! ./node12.js */ "../../node_modules/node-rsa/src/encryptEngines/node12.js");
                }
            }
        }
        return engine(keyPair, options);
    }
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/encryptEngines/io.js":
/*!************************************************************!*\
  !*** ../../node_modules/node-rsa/src/encryptEngines/io.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var crypto = __webpack_require__(/*! crypto */ "crypto");
var constants = __webpack_require__(/*! constants */ "constants");
var schemes = __webpack_require__(/*! ../schemes/schemes.js */ "../../node_modules/node-rsa/src/schemes/schemes.js");

module.exports = function (keyPair, options) {
    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);

    return {
        encrypt: function (buffer, usePrivate) {
            var padding;
            if (usePrivate) {
                padding = constants.RSA_PKCS1_PADDING;
                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                    padding = options.encryptionSchemeOptions.padding;
                }
                return crypto.privateEncrypt({
                    key: options.rsaUtils.exportKey('private'),
                    padding: padding
                }, buffer);
            } else {
                padding = constants.RSA_PKCS1_OAEP_PADDING;
                if (options.encryptionScheme === 'pkcs1') {
                    padding = constants.RSA_PKCS1_PADDING;
                }
                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                    padding = options.encryptionSchemeOptions.padding;
                }

                var data = buffer;
                if (padding === constants.RSA_NO_PADDING) {
                    data = pkcs1Scheme.pkcs0pad(buffer);
                }

                return crypto.publicEncrypt({
                    key: options.rsaUtils.exportKey('public'),
                    padding: padding
                }, data);
            }
        },

        decrypt: function (buffer, usePublic) {
            var padding;
            if (usePublic) {
                padding = constants.RSA_PKCS1_PADDING;
                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                    padding = options.encryptionSchemeOptions.padding;
                }
                return crypto.publicDecrypt({
                    key: options.rsaUtils.exportKey('public'),
                    padding: padding
                }, buffer);
            } else {
                padding = constants.RSA_PKCS1_OAEP_PADDING;
                if (options.encryptionScheme === 'pkcs1') {
                    padding = constants.RSA_PKCS1_PADDING;
                }
                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                    padding = options.encryptionSchemeOptions.padding;
                }
                var res = crypto.privateDecrypt({
                    key: options.rsaUtils.exportKey('private'),
                    padding: padding
                }, buffer);

                if (padding === constants.RSA_NO_PADDING) {
                    return pkcs1Scheme.pkcs0unpad(res);
                }
                return res;
            }
        }
    };
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/encryptEngines/js.js":
/*!************************************************************!*\
  !*** ../../node_modules/node-rsa/src/encryptEngines/js.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BigInteger = __webpack_require__(/*! ../libs/jsbn.js */ "../../node_modules/node-rsa/src/libs/jsbn.js");
var schemes = __webpack_require__(/*! ../schemes/schemes.js */ "../../node_modules/node-rsa/src/schemes/schemes.js");

module.exports = function (keyPair, options) {
    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);

    return {
        encrypt: function (buffer, usePrivate) {
            var m, c;
            if (usePrivate) {
                /* Type 1: zeros padding for private key encrypt */
                m = new BigInteger(pkcs1Scheme.encPad(buffer, {type: 1}));
                c = keyPair.$doPrivate(m);
            } else {
                m = new BigInteger(keyPair.encryptionScheme.encPad(buffer));
                c = keyPair.$doPublic(m);
            }
            return c.toBuffer(keyPair.encryptedDataLength);
        },

        decrypt: function (buffer, usePublic) {
            var m, c = new BigInteger(buffer);

            if (usePublic) {
                m = keyPair.$doPublic(c);
                /* Type 1: zeros padding for private key decrypt */
                return pkcs1Scheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength), {type: 1});
            } else {
                m = keyPair.$doPrivate(c);
                return keyPair.encryptionScheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength));
            }
        }
    };
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/encryptEngines/node12.js":
/*!****************************************************************!*\
  !*** ../../node_modules/node-rsa/src/encryptEngines/node12.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var crypto = __webpack_require__(/*! crypto */ "crypto");
var constants = __webpack_require__(/*! constants */ "constants");
var schemes = __webpack_require__(/*! ../schemes/schemes.js */ "../../node_modules/node-rsa/src/schemes/schemes.js");

module.exports = function (keyPair, options) {
    var jsEngine = __webpack_require__(/*! ./js.js */ "../../node_modules/node-rsa/src/encryptEngines/js.js")(keyPair, options);
    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);

    return {
        encrypt: function (buffer, usePrivate) {
            if (usePrivate) {
                return jsEngine.encrypt(buffer, usePrivate);
            }
            var padding = constants.RSA_PKCS1_OAEP_PADDING;
            if (options.encryptionScheme === 'pkcs1') {
                padding = constants.RSA_PKCS1_PADDING;
            }
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                padding = options.encryptionSchemeOptions.padding;
            }

            var data = buffer;
            if (padding === constants.RSA_NO_PADDING) {
                data = pkcs1Scheme.pkcs0pad(buffer);
            }

            return crypto.publicEncrypt({
                key: options.rsaUtils.exportKey('public'),
                padding: padding
            }, data);
        },

        decrypt: function (buffer, usePublic) {
            if (usePublic) {
                return jsEngine.decrypt(buffer, usePublic);
            }
            var padding = constants.RSA_PKCS1_OAEP_PADDING;
            if (options.encryptionScheme === 'pkcs1') {
                padding = constants.RSA_PKCS1_PADDING;
            }
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
                padding = options.encryptionSchemeOptions.padding;
            }

            var res = crypto.privateDecrypt({
                key: options.rsaUtils.exportKey('private'),
                padding: padding
            }, buffer);

            if (padding === constants.RSA_NO_PADDING) {
                return pkcs1Scheme.pkcs0unpad(res);
            }
            return res;
        }
    };
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/formats/components.js":
/*!*************************************************************!*\
  !*** ../../node_modules/node-rsa/src/formats/components.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);
var utils = __webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js");

module.exports = {
    privateExport: function (key, options) {
        return {
            n: key.n.toBuffer(),
            e: key.e,
            d: key.d.toBuffer(),
            p: key.p.toBuffer(),
            q: key.q.toBuffer(),
            dmp1: key.dmp1.toBuffer(),
            dmq1: key.dmq1.toBuffer(),
            coeff: key.coeff.toBuffer()
        };
    },

    privateImport: function (key, data, options) {
        if (data.n && data.e && data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {
            key.setPrivate(
                data.n,
                data.e,
                data.d,
                data.p,
                data.q,
                data.dmp1,
                data.dmq1,
                data.coeff
            );
        } else {
            throw Error("Invalid key data");
        }
    },

    publicExport: function (key, options) {
        return {
            n: key.n.toBuffer(),
            e: key.e
        };
    },

    publicImport: function (key, data, options) {
        if (data.n && data.e) {
            key.setPublic(
                data.n,
                data.e
            );
        } else {
            throw Error("Invalid key data");
        }
    },

    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function (key, data) {
        if (data.n && data.e) {
            if (data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {
                module.exports.privateImport(key, data);
                return true;
            } else {
                module.exports.publicImport(key, data);
                return true;
            }
        }

        return false;
    }
};


/***/ }),

/***/ "../../node_modules/node-rsa/src/formats/formats.js":
/*!**********************************************************!*\
  !*** ../../node_modules/node-rsa/src/formats/formats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);

function formatParse(format) {
    format = format.split('-');
    var keyType = 'private';
    var keyOpt = {type: 'default'};

    for (var i = 1; i < format.length; i++) {
        if (format[i]) {
            switch (format[i]) {
                case 'public':
                    keyType = format[i];
                    break;
                case 'private':
                    keyType = format[i];
                    break;
                case 'pem':
                    keyOpt.type = format[i];
                    break;
                case 'der':
                    keyOpt.type = format[i];
                    break;
            }
        }
    }

    return {scheme: format[0], keyType: keyType, keyOpt: keyOpt};
}

module.exports = {
    pkcs1: __webpack_require__(/*! ./pkcs1 */ "../../node_modules/node-rsa/src/formats/pkcs1.js"),
    pkcs8: __webpack_require__(/*! ./pkcs8 */ "../../node_modules/node-rsa/src/formats/pkcs8.js"),
    components: __webpack_require__(/*! ./components */ "../../node_modules/node-rsa/src/formats/components.js"),

    isPrivateExport: function (format) {
        return module.exports[format] && typeof module.exports[format].privateExport === 'function';
    },

    isPrivateImport: function (format) {
        return module.exports[format] && typeof module.exports[format].privateImport === 'function';
    },

    isPublicExport: function (format) {
        return module.exports[format] && typeof module.exports[format].publicExport === 'function';
    },

    isPublicImport: function (format) {
        return module.exports[format] && typeof module.exports[format].publicImport === 'function';
    },

    detectAndImport: function (key, data, format) {
        if (format === undefined) {
            for (var scheme in module.exports) {
                if (typeof module.exports[scheme].autoImport === 'function' && module.exports[scheme].autoImport(key, data)) {
                    return true;
                }
            }
        } else if (format) {
            var fmt = formatParse(format);

            if (module.exports[fmt.scheme]) {
                if (fmt.keyType === 'private') {
                    module.exports[fmt.scheme].privateImport(key, data, fmt.keyOpt);
                } else {
                    module.exports[fmt.scheme].publicImport(key, data, fmt.keyOpt);
                }
            } else {
                throw Error('Unsupported key format');
            }
        }

        return false;
    },

    detectAndExport: function (key, format) {
        if (format) {
            var fmt = formatParse(format);

            if (module.exports[fmt.scheme]) {
                if (fmt.keyType === 'private') {
                    if (!key.isPrivate()) {
                        throw Error("This is not private key");
                    }
                    return module.exports[fmt.scheme].privateExport(key, fmt.keyOpt);
                } else {
                    if (!key.isPublic()) {
                        throw Error("This is not public key");
                    }
                    return module.exports[fmt.scheme].publicExport(key, fmt.keyOpt);
                }
            } else {
                throw Error('Unsupported key format');
            }
        }
    }
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/formats/pkcs1.js":
/*!********************************************************!*\
  !*** ../../node_modules/node-rsa/src/formats/pkcs1.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ber = (__webpack_require__(/*! asn1 */ "../../node_modules/asn1/lib/index.js").Ber);
var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);
var utils = __webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js");

const PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';
const PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';

const PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';
const PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';

module.exports = {
    privateExport: function (key, options) {
        options = options || {};

        var n = key.n.toBuffer();
        var d = key.d.toBuffer();
        var p = key.p.toBuffer();
        var q = key.q.toBuffer();
        var dmp1 = key.dmp1.toBuffer();
        var dmq1 = key.dmq1.toBuffer();
        var coeff = key.coeff.toBuffer();

        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic
        var writer = new ber.Writer({size: length});

        writer.startSequence();
        writer.writeInt(0);
        writer.writeBuffer(n, 2);
        writer.writeInt(key.e);
        writer.writeBuffer(d, 2);
        writer.writeBuffer(p, 2);
        writer.writeBuffer(q, 2);
        writer.writeBuffer(dmp1, 2);
        writer.writeBuffer(dmq1, 2);
        writer.writeBuffer(coeff, 2);
        writer.endSequence();

        if (options.type === 'der') {
            return writer.buffer;
        } else {
            return PRIVATE_OPENING_BOUNDARY + '\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\n' + PRIVATE_CLOSING_BOUNDARY;
        }
    },

    privateImport: function (key, data, options) {
        options = options || {};
        var buffer;

        if (options.type !== 'der') {
            if (Buffer.isBuffer(data)) {
                data = data.toString('utf8');
            }

            if (_.isString(data)) {
                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)
                    .replace(/\s+|\n\r|\n|\r$/gm, '');
                buffer = Buffer.from(pem, 'base64');
            } else {
                throw Error('Unsupported key format');
            }
        } else if (Buffer.isBuffer(data)) {
            buffer = data;
        } else {
            throw Error('Unsupported key format');
        }

        var reader = new ber.Reader(buffer);
        reader.readSequence();
        reader.readString(2, true); // just zero
        key.setPrivate(
            reader.readString(2, true),  // modulus
            reader.readString(2, true),  // publicExponent
            reader.readString(2, true),  // privateExponent
            reader.readString(2, true),  // prime1
            reader.readString(2, true),  // prime2
            reader.readString(2, true),  // exponent1 -- d mod (p1)
            reader.readString(2, true),  // exponent2 -- d mod (q-1)
            reader.readString(2, true)   // coefficient -- (inverse of q) mod p
        );
    },

    publicExport: function (key, options) {
        options = options || {};

        var n = key.n.toBuffer();
        var length = n.length + 512; // magic

        var bodyWriter = new ber.Writer({size: length});
        bodyWriter.startSequence();
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.endSequence();

        if (options.type === 'der') {
            return bodyWriter.buffer;
        } else {
            return PUBLIC_OPENING_BOUNDARY + '\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\n' + PUBLIC_CLOSING_BOUNDARY;
        }
    },

    publicImport: function (key, data, options) {
        options = options || {};
        var buffer;

        if (options.type !== 'der') {
            if (Buffer.isBuffer(data)) {
                data = data.toString('utf8');
            }

            if (_.isString(data)) {
                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)
                    .replace(/\s+|\n\r|\n|\r$/gm, '');
                buffer = Buffer.from(pem, 'base64');
            }
        } else if (Buffer.isBuffer(data)) {
            buffer = data;
        } else {
            throw Error('Unsupported key format');
        }

        var body = new ber.Reader(buffer);
        body.readSequence();
        key.setPublic(
            body.readString(0x02, true), // modulus
            body.readString(0x02, true)  // publicExponent
        );
    },

    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function (key, data) {
        // [\S\s]* matches zero or more of any character
        if (/^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(data)) {
            module.exports.privateImport(key, data);
            return true;
        }

        if (/^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(data)) {
            module.exports.publicImport(key, data);
            return true;
        }

        return false;
    }
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/formats/pkcs8.js":
/*!********************************************************!*\
  !*** ../../node_modules/node-rsa/src/formats/pkcs8.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ber = (__webpack_require__(/*! asn1 */ "../../node_modules/asn1/lib/index.js").Ber);
var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);
var PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';
var utils = __webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js");

const PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';
const PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';

const PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';
const PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';

module.exports = {
    privateExport: function (key, options) {
        options = options || {};

        var n = key.n.toBuffer();
        var d = key.d.toBuffer();
        var p = key.p.toBuffer();
        var q = key.q.toBuffer();
        var dmp1 = key.dmp1.toBuffer();
        var dmq1 = key.dmq1.toBuffer();
        var coeff = key.coeff.toBuffer();

        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic
        var bodyWriter = new ber.Writer({size: length});

        bodyWriter.startSequence();
        bodyWriter.writeInt(0);
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.writeBuffer(d, 2);
        bodyWriter.writeBuffer(p, 2);
        bodyWriter.writeBuffer(q, 2);
        bodyWriter.writeBuffer(dmp1, 2);
        bodyWriter.writeBuffer(dmq1, 2);
        bodyWriter.writeBuffer(coeff, 2);
        bodyWriter.endSequence();

        var writer = new ber.Writer({size: length});
        writer.startSequence();
        writer.writeInt(0);
        writer.startSequence();
        writer.writeOID(PUBLIC_RSA_OID);
        writer.writeNull();
        writer.endSequence();
        writer.writeBuffer(bodyWriter.buffer, 4);
        writer.endSequence();

        if (options.type === 'der') {
            return writer.buffer;
        } else {
            return PRIVATE_OPENING_BOUNDARY + '\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\n' + PRIVATE_CLOSING_BOUNDARY;
        }
    },

    privateImport: function (key, data, options) {
        options = options || {};
        var buffer;

        if (options.type !== 'der') {
            if (Buffer.isBuffer(data)) {
                data = data.toString('utf8');
            }

            if (_.isString(data)) {
                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)
                    .replace('-----END PRIVATE KEY-----', '')
                    .replace(/\s+|\n\r|\n|\r$/gm, '');
                buffer = Buffer.from(pem, 'base64');
            } else {
                throw Error('Unsupported key format');
            }
        } else if (Buffer.isBuffer(data)) {
            buffer = data;
        } else {
            throw Error('Unsupported key format');
        }

        var reader = new ber.Reader(buffer);
        reader.readSequence();
        reader.readInt(0);
        var header = new ber.Reader(reader.readString(0x30, true));

        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {
            throw Error('Invalid Public key format');
        }

        var body = new ber.Reader(reader.readString(0x04, true));
        body.readSequence();
        body.readString(2, true); // just zero
        key.setPrivate(
            body.readString(2, true),  // modulus
            body.readString(2, true),  // publicExponent
            body.readString(2, true),  // privateExponent
            body.readString(2, true),  // prime1
            body.readString(2, true),  // prime2
            body.readString(2, true),  // exponent1 -- d mod (p1)
            body.readString(2, true),  // exponent2 -- d mod (q-1)
            body.readString(2, true)   // coefficient -- (inverse of q) mod p
        );
    },

    publicExport: function (key, options) {
        options = options || {};

        var n = key.n.toBuffer();
        var length = n.length + 512; // magic

        var bodyWriter = new ber.Writer({size: length});
        bodyWriter.writeByte(0);
        bodyWriter.startSequence();
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.endSequence();

        var writer = new ber.Writer({size: length});
        writer.startSequence();
        writer.startSequence();
        writer.writeOID(PUBLIC_RSA_OID);
        writer.writeNull();
        writer.endSequence();
        writer.writeBuffer(bodyWriter.buffer, 3);
        writer.endSequence();

        if (options.type === 'der') {
            return writer.buffer;
        } else {
            return PUBLIC_OPENING_BOUNDARY + '\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\n' + PUBLIC_CLOSING_BOUNDARY;
        }
    },

    publicImport: function (key, data, options) {
        options = options || {};
        var buffer;

        if (options.type !== 'der') {
            if (Buffer.isBuffer(data)) {
                data = data.toString('utf8');
            }

            if (_.isString(data)) {
                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)
                    .replace(/\s+|\n\r|\n|\r$/gm, '');
                buffer = Buffer.from(pem, 'base64');
            }
        } else if (Buffer.isBuffer(data)) {
            buffer = data;
        } else {
            throw Error('Unsupported key format');
        }

        var reader = new ber.Reader(buffer);
        reader.readSequence();
        var header = new ber.Reader(reader.readString(0x30, true));

        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {
            throw Error('Invalid Public key format');
        }

        var body = new ber.Reader(reader.readString(0x03, true));
        body.readByte();
        body.readSequence();
        key.setPublic(
            body.readString(0x02, true), // modulus
            body.readString(0x02, true)  // publicExponent
        );
    },

    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function (key, data) {
        if (/^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(data)) {
            module.exports.privateImport(key, data);
            return true;
        }

        if (/^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(data)) {
            module.exports.publicImport(key, data);
            return true;
        }

        return false;
    }
};


/***/ }),

/***/ "../../node_modules/node-rsa/src/libs/jsbn.js":
/*!****************************************************!*\
  !*** ../../node_modules/node-rsa/src/libs/jsbn.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Basic JavaScript BN library - subset useful for RSA encryption.
 * 
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */

/*
 * Added Node.js Buffers support
 * 2014 rzcoder
 */

var crypt = __webpack_require__(/*! crypto */ "crypto");
var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);

// (public) Constructor
function BigInteger(a, b) {
    if (a != null) {
        if ("number" == typeof a) {
            this.fromNumber(a, b);
        } else if (Buffer.isBuffer(a)) {
            this.fromBuffer(a);
        } else if (b == null && "string" != typeof a) {
            this.fromByteArray(a);
        } else {
            this.fromString(a, b);
        }
    }
}

// return new, unset BigInteger
function nbi() {
    return new BigInteger(null);
}

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff, xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff, xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}

// We need to select the fastest one that works in this environment. 
//if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
//	BigInteger.prototype.am = am2;
//	dbits = 30;
//} else if (j_lm && (navigator.appName != "Netscape")) {
//	BigInteger.prototype.am = am1;
//	dbits = 26;
//} else { // Mozilla/Netscape seems to prefer am3
//	BigInteger.prototype.am = am3;
//	dbits = 28;
//}

// For node.js, we pick am3 with max dbits to 28.
BigInteger.prototype.am = am3;
dbits = 28;

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) {
    return BI_RM.charAt(n);
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + DV;
    else this.t = 0;
}

// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}

// (protected) set from string and radix
function bnpFromString(data, radix, unsigned) {
    var k;
    switch (radix) {
        case 2:
            k = 1;
            break;
        case 4:
            k = 2;
            break;
        case 8:
            k = 3;
            break;
        case 16:
            k = 4;
            break;
        case 32:
            k = 5;
            break;
        case 256:
            k = 8;
            break;
        default:
            this.fromRadix(data, radix);
            return;
    }

    this.t = 0;
    this.s = 0;

    var i = data.length;
    var mi = false;
    var sh = 0;

    while (--i >= 0) {
        var x = (k == 8) ? data[i] & 0xff : intAt(data, i);
        if (x < 0) {
            if (data.charAt(i) == "-") mi = true;
            continue;
        }
        mi = false;
        if (sh === 0)
            this[this.t++] = x;
        else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
            this[this.t++] = (x >> (this.DB - sh));
        }
        else
            this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
    }
    if ((!unsigned) && k == 8 && (data[0] & 0x80) != 0) {
        this.s = -1;
        if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) BigInteger.ZERO.subTo(this, this);
}

function bnpFromByteArray(a, unsigned) {
    this.fromString(a, 256, unsigned)
}

function bnpFromBuffer(a) {
    this.fromString(a, 256, true)
}

// (protected) clamp off excess high words
function bnpClamp() {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
        }
        while (i >= 0) {
            if (p < k) {
                d = (this[i] & ((1 << p) - 1)) << (k - p);
                d |= this[--i] >> (p += this.DB - k);
            }
            else {
                d = (this[i] >> (p -= k)) & km;
                if (p <= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
        }
    }
    return m ? r : "0";
}

// (public) -this
function bnNegate() {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
}

// (public) |this|
function bnAbs() {
    return (this.s < 0) ? this.negate() : this;
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
    return 0;
}

// returns bit length of the integer x
function nbits(x) {
    var r = 1, t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
    for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = (this[i] >> cbs) | c;
        c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
        r.t = 0;
        return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
    }
    if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += this.s;
    }
    else {
        c += this.s;
        while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
        }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
    }
    if (r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]);	// normalize modulus
    if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
    }
    else {
        pm.copyTo(y);
        pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 === 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
    var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);	// "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
            y.dlShiftTo(j, t);
            r.subTo(t, r);
            while (r[i] < --qd) r.subTo(t, r);
        }
    }
    if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r);	// Denormalize remainder
    if (ts < 0) BigInteger.ZERO.subTo(r, r);
}

// (public) this mod a
function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
    return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) {
    this.m = m;
}
function cConvert(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
}
function cRevert(x) {
    return x;
}
function cReduce(x) {
    x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}
function cSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) === 0) return 0;
    var y = x & 3;		// y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf;	// y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff;	// y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
}

// Montgomery reduction
function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
}

// xR mod m
function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
    return r;
}

// x/R mod m
function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
    while (x.t <= this.mt2)	// pad x so am has enough room later
        x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i] & 0x7fff;
        var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        // propagate carry
        while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
        }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() {
    return ((this.t > 0) ? (this[0] & 1) : this.s) === 0;
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
        else {
            var t = r;
            r = r2;
            r2 = t;
        }
    }
    return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e, z);
}

// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

//(public)
function bnClone() {
    var r = nbi();
    this.copyTo(r);
    return r;
}

//(public) return value as integer
function bnIntValue() {
    if (this.s < 0) {
        if (this.t == 1) return this[0] - this.DV;
        else if (this.t === 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t === 0) return 0;
// assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
}

//(public) return value as byte
function bnByteValue() {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
}

//(public) return value as short (assumes DB>=16)
function bnShortValue() {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
}

//(protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
}

//(public) 0 if this === 0, 1 if this > 0
function bnSigNum() {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
    if (b == null) b = 10;
    if (this.signum() === 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
}

//(protected) convert from radix string
function bnpFromRadix(s, b) {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() === 0) mi = true;
            continue;
        }
        w = b * w + x;
        if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
        }
    }
    if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
    }
    if (mi) BigInteger.ZERO.subTo(this, this);
}

//(protected) alternate constructor
function bnpFromNumber(a, b) {
    if ("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if (a < 2) this.fromInt(1);
        else {
            this.fromNumber(a);
            if (!this.testBit(a - 1))	// force MSB set
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0); // force odd
            while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
        }
    } else {
        // new BigInteger(int,RNG)
        var x = crypt.randomBytes((a >> 3) + 1)
        var t = a & 7;

        if (t > 0)
            x[0] &= ((1 << t) - 1);
        else
            x[0] = 0;

        this.fromByteArray(x);
    }
}

//(public) convert to bigendian byte array
function bnToByteArray() {
    var i = this.t, r = new Array();
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8, d, k = 0;
    if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | (this.s << (this.DB - p));
        while (i >= 0) {
            if (p < 8) {
                d = (this[i] & ((1 << p) - 1)) << (8 - p);
                d |= this[--i] >> (p += this.DB - 8);
            }
            else {
                d = (this[i] >> (p -= 8)) & 0xff;
                if (p <= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if ((d & 0x80) != 0) d |= -256;
            if (k === 0 && (this.s & 0x80) != (d & 0x80)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
        }
    }
    return r;
}

/**
 * return Buffer object
 * @param trim {boolean} slice buffer if first element == 0
 * @returns {Buffer}
 */
function bnToBuffer(trimOrSize) {
    var res = Buffer.from(this.toByteArray());
    if (trimOrSize === true && res[0] === 0) {
        res = res.slice(1);
    } else if (_.isNumber(trimOrSize)) {
        if (res.length > trimOrSize) {
            for (var i = 0; i < res.length - trimOrSize; i++) {
                if (res[i] !== 0) {
                    return null;
                }
            }
            return res.slice(res.length - trimOrSize);
        } else if (res.length < trimOrSize) {
            var padded = Buffer.alloc(trimOrSize);
            padded.fill(0, 0, trimOrSize - res.length);
            res.copy(padded, trimOrSize - res.length);
            return padded;
        }
    }
    return res;
}

function bnEquals(a) {
    return (this.compareTo(a) == 0);
}
function bnMin(a) {
    return (this.compareTo(a) < 0) ? this : a;
}
function bnMax(a) {
    return (this.compareTo(a) > 0) ? this : a;
}

//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
        r.t = this.t;
    }
    else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
        r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
}

//(public) this & a
function op_and(x, y) {
    return x & y;
}
function bnAnd(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
}

//(public) this | a
function op_or(x, y) {
    return x | y;
}
function bnOr(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
}

//(public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
function bnXor(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
}

//(public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
function bnAndNot(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
}

//(public) ~this
function bnNot() {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
}

//(public) this << n
function bnShiftLeft(n) {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
    return r;
}

//(public) this >> n
function bnShiftRight(n) {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
    return r;
}

//return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x === 0) return -1;
    var r = 0;
    if ((x & 0xffff) === 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) === 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) === 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) === 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) === 0) ++r;
    return r;
}

//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
    for (var i = 0; i < this.t; ++i)
        if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
}

//return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}

//(public) return number of set bits
function bnBitCount() {
    var r = 0, x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
}

//(public) true iff nth bit is set
function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
}

//(protected) this op (1<<n)
function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
}

//(public) this | (1<<n)
function bnSetBit(n) {
    return this.changeBit(n, op_or);
}

//(public) this & ~(1<<n)
function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
}

//(public) this ^ (1<<n)
function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
}

//(protected) r = this + a
function bnpAddTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
    }
    if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += this.s;
    }
    else {
        c += this.s;
        while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
}

//(public) this + a
function bnAdd(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
}

//(public) this - a
function bnSubtract(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
}

//(public) this * a
function bnMultiply(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
}

// (public) this^2
function bnSquare() {
    var r = nbi();
    this.squareTo(r);
    return r;
}

//(public) this / a
function bnDivide(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
}

//(public) this % a
function bnRemainder(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
}

//(public) [this/a,this%a]
function bnDivideAndRemainder(a) {
    var q = nbi(), r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
}

//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
}

//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
    if (n === 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t) this[this.t++] = 0;
        ++this[w];
    }
}

//A "null" reducer
function NullExp() {
}
function nNop(x) {
    return x;
}
function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
    x.squareTo(r);
}

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

//(public) this^e
function bnPow(e) {
    return this.exp(e, new NullExp());
}

//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
}

//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
}

//Barrett modular reduction
function Barrett(m) {
// setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
}

function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    }
}

function barrettRevert(x) {
    return x;
}

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}

//r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}

//r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

//(public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
    var i = e.bitLength(), k, r = nbv(1), z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8)
        z = new Classic(m);
    else if (m.isEven())
        z = new Barrett(m);
    else
        z = new Montgomery(m);

// precomputation
    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
            g[n] = nbi();
            z.mulTo(g2, g[n - 2], g[n]);
            n += 2;
        }
    }

    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
    i = nbits(e[j]) - 1;
    while (j >= 0) {
        if (i >= k1) w = (e[j] >> (i - k1)) & km;
        else {
            w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
            if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
        }

        n = k;
        while ((w & 1) === 0) {
            w >>= 1;
            --n;
        }
        if ((i -= n) < 0) {
            i += this.DB;
            --j;
        }
        if (is1) {	// ret == 1, don't bother squaring or multiplying it
            g[w].copyTo(r);
            is1 = false;
        }
        else {
            while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
            }
            if (n > 0) z.sqrTo(r, r2); else {
                t = r;
                r = r2;
                r2 = t;
            }
            z.mulTo(r2, g[w], r);
        }

        while (j >= 0 && (e[j] & (1 << i)) === 0) {
            z.sqrTo(r, r2);
            t = r;
            r = r2;
            r2 = t;
            if (--i < 0) {
                i = this.DB - 1;
                --j;
            }
        }
    }
    return z.revert(r);
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
    }
    var i = x.getLowestSetBit(), g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
    }
    while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
        }
        else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
        }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
}

//(protected) this % n, n < 2^26
function bnpModInt(n) {
    if (n <= 0) return 0;
    var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0)
        if (d === 0) r = this[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
}

//(public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() === 0) return BigInteger.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
        while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
                if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                }
                a.rShiftTo(1, a);
            }
            else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
        }
        while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
                if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                }
                c.rShiftTo(1, c);
            }
            else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
        }
        else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
        }
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d); else return d;
    if (d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
        return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j) if (m % lowprimes[i++] === 0) return false;
    }
    return x.millerRabin(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) === 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
        }
    }
    return true;
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.fromByteArray = bnpFromByteArray;
BigInteger.prototype.fromBuffer = bnpFromBuffer;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;


// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.toBuffer = bnToBuffer;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.int2char = int2char;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

//BigInteger interfaces not implemented in jsbn:

//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)

module.exports = BigInteger;

/***/ }),

/***/ "../../node_modules/node-rsa/src/libs/rsa.js":
/*!***************************************************!*\
  !*** ../../node_modules/node-rsa/src/libs/rsa.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*
 * RSA Encryption / Decryption with PKCS1 v2 Padding.
 * 
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */

/*
 * Node.js adaptation
 * long message support implementation
 * signing/verifying
 *
 * 2014 rzcoder
 */

var _ = (__webpack_require__(/*! ../utils */ "../../node_modules/node-rsa/src/utils.js")._);
var crypt = __webpack_require__(/*! crypto */ "crypto");
var BigInteger = __webpack_require__(/*! ./jsbn.js */ "../../node_modules/node-rsa/src/libs/jsbn.js");
var utils = __webpack_require__(/*! ../utils.js */ "../../node_modules/node-rsa/src/utils.js");
var schemes = __webpack_require__(/*! ../schemes/schemes.js */ "../../node_modules/node-rsa/src/schemes/schemes.js");
var encryptEngines = __webpack_require__(/*! ../encryptEngines/encryptEngines.js */ "../../node_modules/node-rsa/src/encryptEngines/encryptEngines.js");

exports.BigInteger = BigInteger;
module.exports.Key = (function () {
    /**
     * RSA key constructor
     *
     * n - modulus
     * e - publicExponent
     * d - privateExponent
     * p - prime1
     * q - prime2
     * dmp1 - exponent1 -- d mod (p1)
     * dmq1 - exponent2 -- d mod (q-1)
     * coeff - coefficient -- (inverse of q) mod p
     */
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }

    RSAKey.prototype.setOptions = function (options) {
        var signingSchemeProvider = schemes[options.signingScheme];
        var encryptionSchemeProvider = schemes[options.encryptionScheme];

        if (signingSchemeProvider === encryptionSchemeProvider) {
            this.signingScheme = this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
        } else {
            this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
            this.signingScheme = signingSchemeProvider.makeScheme(this, options);
        }

        this.encryptEngine = encryptEngines.getEngine(this, options);
    };

    /**
     * Generate a new random private key B bits long, using public expt E
     * @param B
     * @param E
     */
    RSAKey.prototype.generate = function (B, E) {
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        while (true) {
            while (true) {
                this.p = new BigInteger(B - qs, 1);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.p.isProbablePrime(10))
                    break;
            }
            while (true) {
                this.q = new BigInteger(qs, 1);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.q.isProbablePrime(10))
                    break;
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) === 0) {
                this.n = this.p.multiply(this.q);
                if (this.n.bitLength() < B) {
                    continue;
                }
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
        this.$$recalculateCache();
    };

    /**
     * Set the private key fields N, e, d and CRT params from buffers
     *
     * @param N
     * @param E
     * @param D
     * @param P
     * @param Q
     * @param DP
     * @param DQ
     * @param C
     */
    RSAKey.prototype.setPrivate = function (N, E, D, P, Q, DP, DQ, C) {
        if (N && E && D && N.length > 0 && (_.isNumber(E) || E.length > 0) && D.length > 0) {
            this.n = new BigInteger(N);
            this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);
            this.d = new BigInteger(D);

            if (P && Q && DP && DQ && C) {
                this.p = new BigInteger(P);
                this.q = new BigInteger(Q);
                this.dmp1 = new BigInteger(DP);
                this.dmq1 = new BigInteger(DQ);
                this.coeff = new BigInteger(C);
            } else {
                // TODO: re-calculate any missing CRT params
            }
            this.$$recalculateCache();
        } else {
            throw Error("Invalid RSA private key");
        }
    };

    /**
     * Set the public key fields N and e from hex strings
     * @param N
     * @param E
     */
    RSAKey.prototype.setPublic = function (N, E) {
        if (N && E && N.length > 0 && (_.isNumber(E) || E.length > 0)) {
            this.n = new BigInteger(N);
            this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);
            this.$$recalculateCache();
        } else {
            throw Error("Invalid RSA public key");
        }
    };

    /**
     * private
     * Perform raw private operation on "x": return x^d (mod n)
     *
     * @param x
     * @returns {*}
     */
    RSAKey.prototype.$doPrivate = function (x) {
        if (this.p || this.q) {
            return x.modPow(this.d, this.n);
        }

        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);

        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };

    /**
     * private
     * Perform raw public operation on "x": return x^e (mod n)
     *
     * @param x
     * @returns {*}
     */
    RSAKey.prototype.$doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };

    /**
     * Return the PKCS#1 RSA encryption of buffer
     * @param buffer {Buffer}
     * @returns {Buffer}
     */
    RSAKey.prototype.encrypt = function (buffer, usePrivate) {
        var buffers = [];
        var results = [];
        var bufferSize = buffer.length;
        var buffersCount = Math.ceil(bufferSize / this.maxMessageLength) || 1; // total buffers count for encrypt
        var dividedSize = Math.ceil(bufferSize / buffersCount || 1); // each buffer size

        if (buffersCount == 1) {
            buffers.push(buffer);
        } else {
            for (var bufNum = 0; bufNum < buffersCount; bufNum++) {
                buffers.push(buffer.slice(bufNum * dividedSize, (bufNum + 1) * dividedSize));
            }
        }

        for (var i = 0; i < buffers.length; i++) {
            results.push(this.encryptEngine.encrypt(buffers[i], usePrivate));
        }

        return Buffer.concat(results);
    };

    /**
     * Return the PKCS#1 RSA decryption of buffer
     * @param buffer {Buffer}
     * @returns {Buffer}
     */
    RSAKey.prototype.decrypt = function (buffer, usePublic) {
        if (buffer.length % this.encryptedDataLength > 0) {
            throw Error('Incorrect data or key');
        }

        var result = [];
        var offset = 0;
        var length = 0;
        var buffersCount = buffer.length / this.encryptedDataLength;

        for (var i = 0; i < buffersCount; i++) {
            offset = i * this.encryptedDataLength;
            length = offset + this.encryptedDataLength;
            result.push(this.encryptEngine.decrypt(buffer.slice(offset, Math.min(length, buffer.length)), usePublic));
        }

        return Buffer.concat(result);
    };

    RSAKey.prototype.sign = function (buffer) {
        return this.signingScheme.sign.apply(this.signingScheme, arguments);
    };

    RSAKey.prototype.verify = function (buffer, signature, signature_encoding) {
        return this.signingScheme.verify.apply(this.signingScheme, arguments);
    };

    /**
     * Check if key pair contains private key
     */
    RSAKey.prototype.isPrivate = function () {
        return this.n && this.e && this.d && true || false;
    };

    /**
     * Check if key pair contains public key
     * @param strict {boolean} - public key only, return false if have private exponent
     */
    RSAKey.prototype.isPublic = function (strict) {
        return this.n && this.e && !(strict && this.d) || false;
    };

    Object.defineProperty(RSAKey.prototype, 'keySize', {
        get: function () {
            return this.cache.keyBitLength;
        }
    });

    Object.defineProperty(RSAKey.prototype, 'encryptedDataLength', {
        get: function () {
            return this.cache.keyByteLength;
        }
    });

    Object.defineProperty(RSAKey.prototype, 'maxMessageLength', {
        get: function () {
            return this.encryptionScheme.maxMessageLength();
        }
    });

    /**
     * Caching key data
     */
    RSAKey.prototype.$$recalculateCache = function () {
        this.cache = this.cache || {};
        // Bit & byte length
        this.cache.keyBitLength = this.n.bitLength();
        this.cache.keyByteLength = (this.cache.keyBitLength + 6) >> 3;
    };

    return RSAKey;
})();



/***/ }),

/***/ "../../node_modules/node-rsa/src/schemes/oaep.js":
/*!*******************************************************!*\
  !*** ../../node_modules/node-rsa/src/schemes/oaep.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * PKCS_OAEP signature scheme
 */

var BigInteger = __webpack_require__(/*! ../libs/jsbn */ "../../node_modules/node-rsa/src/libs/jsbn.js");
var crypt = __webpack_require__(/*! crypto */ "crypto");

module.exports = {
    isEncryption: true,
    isSignature: false
};

module.exports.digestLength = {
    md4: 16,
    md5: 16,
    ripemd160: 20,
    rmd160: 20,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64
};

var DEFAULT_HASH_FUNCTION = 'sha1';

/*
 * OAEP Mask Generation Function 1
 * Generates a buffer full of pseudorandom bytes given seed and maskLength.
 * Giving the same seed, maskLength, and hashFunction will result in the same exact byte values in the buffer.
 *
 * https://tools.ietf.org/html/rfc3447#appendix-B.2.1
 *
 * Parameters:
 * seed			[Buffer]	The pseudo random seed for this function
 * maskLength	[int]		The length of the output
 * hashFunction	[String]	The hashing function to use. Will accept any valid crypto hash. Default "sha1"
 *		Supports "sha1" and "sha256".
 *		To add another algorythm the algorythem must be accepted by crypto.createHash, and then the length of the output of the hash function (the digest) must be added to the digestLength object below.
 *		Most RSA implementations will be expecting sha1
 */
module.exports.eme_oaep_mgf1 = function (seed, maskLength, hashFunction) {
    hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
    var hLen = module.exports.digestLength[hashFunction];
    var count = Math.ceil(maskLength / hLen);
    var T = Buffer.alloc(hLen * count);
    var c = Buffer.alloc(4);
    for (var i = 0; i < count; ++i) {
        var hash = crypt.createHash(hashFunction);
        hash.update(seed);
        c.writeUInt32BE(i, 0);
        hash.update(c);
        hash.digest().copy(T, i * hLen);
    }
    return T.slice(0, maskLength);
};

module.exports.makeScheme = function (key, options) {
    function Scheme(key, options) {
        this.key = key;
        this.options = options;
    }

    Scheme.prototype.maxMessageLength = function () {
        return this.key.encryptedDataLength - 2 * module.exports.digestLength[this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION] - 2;
    };

    /**
     * Pad input
     * alg: PKCS1_OAEP
     *
     * https://tools.ietf.org/html/rfc3447#section-7.1.1
     */
    Scheme.prototype.encPad = function (buffer) {
        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;
        var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);
        var emLen = this.key.encryptedDataLength;

        var hLen = module.exports.digestLength[hash];

        // Make sure we can put message into an encoded message of emLen bytes
        if (buffer.length > emLen - 2 * hLen - 2) {
            throw new Error("Message is too long to encode into an encoded message with a length of " + emLen + " bytes, increase" +
            "emLen to fix this error (minimum value for given parameters and options: " + (emLen - 2 * hLen - 2) + ")");
        }

        var lHash = crypt.createHash(hash);
        lHash.update(label);
        lHash = lHash.digest();

        var PS = Buffer.alloc(emLen - buffer.length - 2 * hLen - 1); // Padding "String"
        PS.fill(0); // Fill the buffer with octets of 0
        PS[PS.length - 1] = 1;

        var DB = Buffer.concat([lHash, PS, buffer]);
        var seed = crypt.randomBytes(hLen);

        // mask = dbMask
        var mask = mgf(seed, DB.length, hash);
        // XOR DB and dbMask together.
        for (var i = 0; i < DB.length; i++) {
            DB[i] ^= mask[i];
        }
        // DB = maskedDB

        // mask = seedMask
        mask = mgf(DB, hLen, hash);
        // XOR seed and seedMask together.
        for (i = 0; i < seed.length; i++) {
            seed[i] ^= mask[i];
        }
        // seed = maskedSeed

        var em = Buffer.alloc(1 + seed.length + DB.length);
        em[0] = 0;
        seed.copy(em, 1);
        DB.copy(em, 1 + seed.length);

        return em;
    };

    /**
     * Unpad input
     * alg: PKCS1_OAEP
     *
     * Note: This method works within the buffer given and modifies the values. It also returns a slice of the EM as the return Message.
     * If the implementation requires that the EM parameter be unmodified then the implementation should pass in a clone of the EM buffer.
     *
     * https://tools.ietf.org/html/rfc3447#section-7.1.2
     */
    Scheme.prototype.encUnPad = function (buffer) {
        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;
        var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);

        var hLen = module.exports.digestLength[hash];

        // Check to see if buffer is a properly encoded OAEP message
        if (buffer.length < 2 * hLen + 2) {
            throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");
        }

        var seed = buffer.slice(1, hLen + 1);	// seed = maskedSeed
        var DB = buffer.slice(1 + hLen);		// DB = maskedDB

        var mask = mgf(DB, hLen, hash); // seedMask
        // XOR maskedSeed and seedMask together to get the original seed.
        for (var i = 0; i < seed.length; i++) {
            seed[i] ^= mask[i];
        }

        mask = mgf(seed, DB.length, hash); // dbMask
        // XOR DB and dbMask together to get the original data block.
        for (i = 0; i < DB.length; i++) {
            DB[i] ^= mask[i];
        }

        var lHash = crypt.createHash(hash);
        lHash.update(label);
        lHash = lHash.digest();

        var lHashEM = DB.slice(0, hLen);
        if (lHashEM.toString("hex") != lHash.toString("hex")) {
            throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");
        }

        // Filter out padding
        i = hLen;
        while (DB[i++] === 0 && i < DB.length);
        if (DB[i - 1] != 1) {
            throw new Error("Error decoding message, there is no padding message separator byte");
        }

        return DB.slice(i); // Message
    };

    return new Scheme(key, options);
};


/***/ }),

/***/ "../../node_modules/node-rsa/src/schemes/pkcs1.js":
/*!********************************************************!*\
  !*** ../../node_modules/node-rsa/src/schemes/pkcs1.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * PKCS1 padding and signature scheme
 */

var BigInteger = __webpack_require__(/*! ../libs/jsbn */ "../../node_modules/node-rsa/src/libs/jsbn.js");
var crypt = __webpack_require__(/*! crypto */ "crypto");
var constants = __webpack_require__(/*! constants */ "constants");
var SIGN_INFO_HEAD = {
    md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
    md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
    sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
    sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
    sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
    sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
    sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
    ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),
    rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')
};

var SIGN_ALG_TO_HASH_ALIASES = {
    'ripemd160': 'rmd160'
};

var DEFAULT_HASH_FUNCTION = 'sha256';

module.exports = {
    isEncryption: true,
    isSignature: true
};

module.exports.makeScheme = function (key, options) {
    function Scheme(key, options) {
        this.key = key;
        this.options = options;
    }

    Scheme.prototype.maxMessageLength = function () {
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
            return this.key.encryptedDataLength;
        }
        return this.key.encryptedDataLength - 11;
    };

    /**
     * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from
     * alg: PKCS#1
     * @param buffer
     * @returns {Buffer}
     */
    Scheme.prototype.encPad = function (buffer, options) {
        options = options || {};
        var filled;
        if (buffer.length > this.key.maxMessageLength) {
            throw new Error("Message too long for RSA (n=" + this.key.encryptedDataLength + ", l=" + buffer.length + ")");
        }
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
            //RSA_NO_PADDING treated like JAVA left pad with zero character
            filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);
            filled.fill(0);
            return Buffer.concat([filled, buffer]);
        }

        /* Type 1: zeros padding for private key encrypt */
        if (options.type === 1) {
            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);
            filled.fill(0xff, 0, filled.length - 1);
            filled[0] = 1;
            filled[filled.length - 1] = 0;

            return Buffer.concat([filled, buffer]);
        } else {
            /* random padding for public key encrypt */
            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);
            filled[0] = 0;
            filled[1] = 2;
            var rand = crypt.randomBytes(filled.length - 3);
            for (var i = 0; i < rand.length; i++) {
                var r = rand[i];
                while (r === 0) { // non-zero only
                    r = crypt.randomBytes(1)[0];
                }
                filled[i + 2] = r;
            }
            filled[filled.length - 1] = 0;
            return Buffer.concat([filled, buffer]);
        }
    };

    /**
     * Unpad input Buffer and, if valid, return the Buffer object
     * alg: PKCS#1 (type 2, random)
     * @param buffer
     * @returns {Buffer}
     */
    Scheme.prototype.encUnPad = function (buffer, options) {
        options = options || {};
        var i = 0;

        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
            //RSA_NO_PADDING treated like JAVA left pad with zero character
            var unPad;
            if (typeof buffer.lastIndexOf == "function") { //patch for old node version
                unPad = buffer.slice(buffer.lastIndexOf('\0') + 1, buffer.length);
            } else {
                unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\0') + 1, buffer.length);
            }
            return unPad;
        }

        if (buffer.length < 4) {
            return null;
        }

        /* Type 1: zeros padding for private key decrypt */
        if (options.type === 1) {
            if (buffer[0] !== 0 || buffer[1] !== 1) {
                return null;
            }
            i = 3;
            while (buffer[i] !== 0) {
                if (buffer[i] != 0xFF || ++i >= buffer.length) {
                    return null;
                }
            }
        } else {
            /* random padding for public key decrypt */
            if (buffer[0] !== 0 || buffer[1] !== 2) {
                return null;
            }
            i = 3;
            while (buffer[i] !== 0) {
                if (++i >= buffer.length) {
                    return null;
                }
            }
        }
        return buffer.slice(i + 1, buffer.length);
    };

    Scheme.prototype.sign = function (buffer) {
        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        if (this.options.environment === 'browser') {
            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;

            var hasher = crypt.createHash(hashAlgorithm);
            hasher.update(buffer);
            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);
            var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);

            return res;
        } else {
            var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());
            signer.update(buffer);
            return signer.sign(this.options.rsaUtils.exportKey('private'));
        }
    };

    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
            //RSA_NO_PADDING has no verify data
            return false;
        }
        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        if (this.options.environment === 'browser') {
            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;

            if (signature_encoding) {
                signature = Buffer.from(signature, signature_encoding);
            }

            var hasher = crypt.createHash(hashAlgorithm);
            hasher.update(buffer);
            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);
            var m = this.key.$doPublic(new BigInteger(signature));

            return m.toBuffer().toString('hex') == hash.toString('hex');
        } else {
            var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());
            verifier.update(buffer);
            return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);
        }
    };

    /**
     * PKCS#1 zero pad input buffer to max data length
     * @param hashBuf
     * @param hashAlgorithm
     * @returns {*}
     */
    Scheme.prototype.pkcs0pad = function (buffer) {
        var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);
        filled.fill(0);
        return Buffer.concat([filled, buffer]);
    };

    Scheme.prototype.pkcs0unpad = function (buffer) {
        var unPad;
        if (typeof buffer.lastIndexOf == "function") { //patch for old node version
            unPad = buffer.slice(buffer.lastIndexOf('\0') + 1, buffer.length);
        } else {
            unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\0') + 1, buffer.length);
        }

        return unPad;
    };

    /**
     * PKCS#1 pad input buffer to max data length
     * @param hashBuf
     * @param hashAlgorithm
     * @returns {*}
     */
    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {
        var digest = SIGN_INFO_HEAD[hashAlgorithm];
        if (!digest) {
            throw Error('Unsupported hash algorithm');
        }

        var data = Buffer.concat([digest, hashBuf]);

        if (data.length + 10 > this.key.encryptedDataLength) {
            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');
        }

        var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);
        filled.fill(0xff, 0, filled.length - 1);
        filled[0] = 1;
        filled[filled.length - 1] = 0;

        var res = Buffer.concat([filled, data]);

        return res;
    };

    return new Scheme(key, options);
};




/***/ }),

/***/ "../../node_modules/node-rsa/src/schemes/pss.js":
/*!******************************************************!*\
  !*** ../../node_modules/node-rsa/src/schemes/pss.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * PSS signature scheme
 */

var BigInteger = __webpack_require__(/*! ../libs/jsbn */ "../../node_modules/node-rsa/src/libs/jsbn.js");
var crypt = __webpack_require__(/*! crypto */ "crypto");

module.exports = {
    isEncryption: false,
    isSignature: true
};

var DEFAULT_HASH_FUNCTION = 'sha1';
var DEFAULT_SALT_LENGTH = 20;

module.exports.makeScheme = function (key, options) {
    var OAEP = (__webpack_require__(/*! ./schemes */ "../../node_modules/node-rsa/src/schemes/schemes.js").pkcs1_oaep);

    /**
     * @param key
     * @param options
     * options    [Object]    An object that contains the following keys that specify certain options for encoding.
     *  └>signingSchemeOptions
     *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = "sha1")
     *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)
     *     └>sLen    [uint]        The length of the salt to generate. (default = 20)
     * @constructor
     */
    function Scheme(key, options) {
        this.key = key;
        this.options = options;
    }

    Scheme.prototype.sign = function (buffer) {
        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
        mHash.update(buffer);

        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);
        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);
    };

    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {
        if (signature_encoding) {
            signature = Buffer.from(signature, signature_encoding);
        }
        signature = new BigInteger(signature);

        var emLen = Math.ceil((this.key.keySize - 1) / 8);
        var m = this.key.$doPublic(signature).toBuffer(emLen);

        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
        mHash.update(buffer);

        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);
    };

    /*
     * https://tools.ietf.org/html/rfc3447#section-9.1.1
     *
     * mHash	[Buffer]	Hashed message to encode
     * emBits	[uint]		Maximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)
     * @returns {Buffer} The encoded message
     */
    Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {
        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;

        var hLen = OAEP.digestLength[hash];
        var emLen = Math.ceil(emBits / 8);

        if (emLen < hLen + sLen + 2) {
            throw new Error("Output length passed to emBits(" + emBits + ") is too small for the options " +
                "specified(" + hash + ", " + sLen + "). To fix this issue increase the value of emBits. (minimum size: " +
                (8 * hLen + 8 * sLen + 9) + ")"
            );
        }

        var salt = crypt.randomBytes(sLen);

        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);
        Mapostrophe.fill(0, 0, 8);
        mHash.copy(Mapostrophe, 8);
        salt.copy(Mapostrophe, 8 + mHash.length);

        var H = crypt.createHash(hash);
        H.update(Mapostrophe);
        H = H.digest();

        var PS = Buffer.alloc(emLen - salt.length - hLen - 2);
        PS.fill(0);

        var DB = Buffer.alloc(PS.length + 1 + salt.length);
        PS.copy(DB);
        DB[PS.length] = 0x01;
        salt.copy(DB, PS.length + 1);

        var dbMask = mgf(H, DB.length, hash);

        // XOR DB and dbMask together
        var maskedDB = Buffer.alloc(DB.length);
        for (var i = 0; i < dbMask.length; i++) {
            maskedDB[i] = DB[i] ^ dbMask[i];
        }

        var bits = 8 * emLen - emBits;
        var mask = 255 ^ (255 >> 8 - bits << 8 - bits);
        maskedDB[0] = maskedDB[0] & mask;

        var EM = Buffer.alloc(maskedDB.length + H.length + 1);
        maskedDB.copy(EM, 0);
        H.copy(EM, maskedDB.length);
        EM[EM.length - 1] = 0xbc;

        return EM;
    };

    /*
     * https://tools.ietf.org/html/rfc3447#section-9.1.2
     *
     * mHash	[Buffer]	Hashed message
     * EM		[Buffer]	Signature
     * emBits	[uint]		Length of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)
     * @returns {Boolean} True if signature(EM) matches message(M)
     */
    Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {
        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;

        var hLen = OAEP.digestLength[hash];
        var emLen = Math.ceil(emBits / 8);

        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {
            return false;
        }

        var DB = Buffer.alloc(emLen - hLen - 1);
        EM.copy(DB, 0, 0, emLen - hLen - 1);

        var mask = 0;
        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {
            mask |= 1 << (7 - i);
        }

        if ((DB[0] & mask) !== 0) {
            return false;
        }

        var H = EM.slice(emLen - hLen - 1, emLen - 1);
        var dbMask = mgf(H, DB.length, hash);

        // Unmask DB
        for (i = 0; i < DB.length; i++) {
            DB[i] ^= dbMask[i];
        }

        bits = 8 * emLen - emBits;
        mask = 255 ^ (255 >> 8 - bits << 8 - bits);
        DB[0] = DB[0] & mask;

        // Filter out padding
        for (i = 0; DB[i] === 0 && i < DB.length; i++);
        if (DB[i] != 1) {
            return false;
        }

        var salt = DB.slice(DB.length - sLen);

        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);
        Mapostrophe.fill(0, 0, 8);
        mHash.copy(Mapostrophe, 8);
        salt.copy(Mapostrophe, 8 + mHash.length);

        var Hapostrophe = crypt.createHash(hash);
        Hapostrophe.update(Mapostrophe);
        Hapostrophe = Hapostrophe.digest();

        return H.toString("hex") === Hapostrophe.toString("hex");
    };

    return new Scheme(key, options);
};


/***/ }),

/***/ "../../node_modules/node-rsa/src/schemes/schemes.js":
/*!**********************************************************!*\
  !*** ../../node_modules/node-rsa/src/schemes/schemes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    pkcs1: __webpack_require__(/*! ./pkcs1 */ "../../node_modules/node-rsa/src/schemes/pkcs1.js"),
    pkcs1_oaep: __webpack_require__(/*! ./oaep */ "../../node_modules/node-rsa/src/schemes/oaep.js"),
    pss: __webpack_require__(/*! ./pss */ "../../node_modules/node-rsa/src/schemes/pss.js"),

    /**
     * Check if scheme has padding methods
     * @param scheme {string}
     * @returns {Boolean}
     */
    isEncryption: function (scheme) {
        return module.exports[scheme] && module.exports[scheme].isEncryption;
    },

    /**
     * Check if scheme has sign/verify methods
     * @param scheme {string}
     * @returns {Boolean}
     */
    isSignature: function (scheme) {
        return module.exports[scheme] && module.exports[scheme].isSignature;
    }
};

/***/ }),

/***/ "../../node_modules/node-rsa/src/utils.js":
/*!************************************************!*\
  !*** ../../node_modules/node-rsa/src/utils.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Utils functions
 *
 */

var crypt = __webpack_require__(/*! crypto */ "crypto");

/**
 * Break string str each maxLen symbols
 * @param str
 * @param maxLen
 * @returns {string}
 */
module.exports.linebrk = function (str, maxLen) {
    var res = '';
    var i = 0;
    while (i + maxLen < str.length) {
        res += str.substring(i, i + maxLen) + "\n";
        i += maxLen;
    }
    return res + str.substring(i, str.length);
};

module.exports.detectEnvironment = function () {
    if (typeof(window) !== 'undefined' && window && !(process && process.title === 'node')) {
        return 'browser';
    }

    return 'node';
};

/**
 * Trying get a 32-bit unsigned integer from the partial buffer
 * @param buffer
 * @param offset
 * @returns {Number}
 */
module.exports.get32IntFromBuffer = function (buffer, offset) {
    offset = offset || 0;
    var size = 0;
    if ((size = buffer.length - offset) > 0) {
        if (size >= 4) {
            return buffer.readUIntBE(offset, size);
        } else {
            var res = 0;
            for (var i = offset + size, d = 0; i > offset; i--, d += 2) {
                res += buffer[i - 1] * Math.pow(16, d);
            }
            return res;
        }
    } else {
        return NaN;
    }
};

module.exports._ = {
    isObject: function (value) {
        var type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    },

    isString: function (value) {
        return typeof value == 'string' || value instanceof String;
    },

    isNumber: function (value) {
        return typeof value == 'number' || !isNaN(parseFloat(value)) && isFinite(value);
    },

    /**
     * Returns copy of `obj` without `removeProp` field.
     * @param obj
     * @param removeProp
     * @returns Object
     */
    omit: function (obj, removeProp) {
        var newObj = {};
        for (var prop in obj) {
            if (!obj.hasOwnProperty(prop) || prop === removeProp) {
                continue;
            }
            newObj[prop] = obj[prop];
        }

        return newObj;
    }
};

/**
 * Strips everything around the opening and closing lines, including the lines
 * themselves.
 */
module.exports.trimSurroundingText = function (data, opening, closing) {
    var trimStartIndex = 0;
    var trimEndIndex = data.length;

    var openingBoundaryIndex = data.indexOf(opening);
    if (openingBoundaryIndex >= 0) {
        trimStartIndex = openingBoundaryIndex + opening.length;
    }

    var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);
    if (closingBoundaryIndex >= 0) {
        trimEndIndex = closingBoundaryIndex;
    }

    return data.substring(trimStartIndex, trimEndIndex);
}

/***/ }),

/***/ "../../node_modules/p-limit/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/p-limit/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pTry = __webpack_require__(/*! p-try */ "../../node_modules/p-try/index.js");

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	const run = (fn, resolve, ...args) => {
		activeCount++;

		const result = pTry(fn, ...args);

		resolve(result);

		result.then(next, next);
	};

	const enqueue = (fn, resolve, ...args) => {
		if (activeCount < concurrency) {
			run(fn, resolve, ...args);
		} else {
			queue.push(run.bind(null, fn, resolve, ...args));
		}
	};

	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.length
		}
	});

	return generator;
};

module.exports = pLimit;
module.exports["default"] = pLimit;


/***/ }),

/***/ "../../node_modules/p-try/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/p-try/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


const pTry = (fn, ...arguments_) => new Promise(resolve => {
	resolve(fn(...arguments_));
});

module.exports = pTry;
// TODO: remove this in the next major version
module.exports["default"] = pTry;


/***/ }),

/***/ "../../node_modules/path-browserify/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/path-browserify/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "../../node_modules/path-exists/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/path-exists/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(/*! fs */ "fs");

module.exports = fp => new Promise(resolve => {
	fs.access(fp, err => {
		resolve(!err);
	});
});

module.exports.sync = fp => {
	try {
		fs.accessSync(fp);
		return true;
	} catch (err) {
		return false;
	}
};


/***/ }),

/***/ "../../node_modules/performance-ponyfill/node-ponyfill.js":
/*!****************************************************************!*\
  !*** ../../node_modules/performance-ponyfill/node-ponyfill.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { PerformanceObserver, performance } = __webpack_require__(/*! perf_hooks */ "perf_hooks");

const entriesList = [];
const observer = new PerformanceObserver((perfObserverList) => {
    entriesList.push(...perfObserverList.getEntries());
});

performance.getEntries = () => {
    return [...entriesList];
};

performance.getEntriesByName = (name, type) => {
    const result = entriesList.filter((entry) => {
        const isSameName = (entry.name === name);
        const isSameType = !type || (entry.type === type);

        return isSameName && isSameType;
    });

    return [...result];
};

performance.getEntriesByType = (type) => {
    const result = entriesList.filter((entry) => {
        return entry.type === type;
    });

    return [...result];
};

observer.observe({
    entryTypes: ['measure', 'mark'],
    buffered: false,
});

module.exports = { PerformanceObserver, performance };


/***/ }),

/***/ "../../node_modules/randombytes/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/randombytes/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! crypto */ "crypto").randomBytes


/***/ }),

/***/ "../../node_modules/require-directory/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/require-directory/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs"),
  join = (__webpack_require__(/*! path */ "path").join),
  resolve = (__webpack_require__(/*! path */ "path").resolve),
  dirname = (__webpack_require__(/*! path */ "path").dirname),
  defaultOptions = {
    extensions: ['js', 'json', 'coffee'],
    recurse: true,
    rename: function (name) {
      return name;
    },
    visit: function (obj) {
      return obj;
    }
  };

function checkFileInclusion(path, filename, options) {
  return (
    // verify file has valid extension
    (new RegExp('\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&

    // if options.include is a RegExp, evaluate it and make sure the path passes
    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&

    // if options.include is a function, evaluate it and make sure the path passes
    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&

    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&

    // if options.exclude is a function, evaluate it and make sure the path doesn't pass
    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))
  );
}

function requireDirectory(m, path, options) {
  var retval = {};

  // path is optional
  if (path && !options && typeof path !== 'string') {
    options = path;
    path = null;
  }

  // default options
  options = options || {};
  for (var prop in defaultOptions) {
    if (typeof options[prop] === 'undefined') {
      options[prop] = defaultOptions[prop];
    }
  }

  // if no path was passed in, assume the equivelant of __dirname from caller
  // otherwise, resolve path relative to the equivalent of __dirname
  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);

  // get the path of each file in specified directory, append to current tree node, recurse
  fs.readdirSync(path).forEach(function (filename) {
    var joined = join(path, filename),
      files,
      key,
      obj;

    if (fs.statSync(joined).isDirectory() && options.recurse) {
      // this node is a directory; recurse
      files = requireDirectory(m, joined, options);
      // exclude empty directories
      if (Object.keys(files).length) {
        retval[options.rename(filename, joined, filename)] = files;
      }
    } else {
      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
        // hash node key shouldn't include file extension
        key = filename.substring(0, filename.lastIndexOf('.'));
        obj = m.require(joined);
        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
      }
    }
  });

  return retval;
}

module.exports = requireDirectory;
module.exports.defaults = defaultOptions;


/***/ }),

/***/ "../../node_modules/require-main-filename/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/require-main-filename/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function (_require) {
  _require = _require || __webpack_require__("../../node_modules/require-main-filename sync recursive")
  var main = _require.main
  if (main && isIISNode(main)) return handleIISNode(main)
  else return main ? main.filename : process.cwd()
}

function isIISNode (main) {
  return /\\iisnode\\/.test(main.filename)
}

function handleIISNode (main) {
  if (!main.children.length) {
    return main.filename
  } else {
    return main.children[0].filename
  }
}


/***/ }),

/***/ "../../node_modules/require-main-filename sync recursive":
/*!******************************************************!*\
  !*** ../../node_modules/require-main-filename/ sync ***!
  \******************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/require-main-filename sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../node_modules/safer-buffer/safer.js":
/*!************************************************!*\
  !*** ../../node_modules/safer-buffer/safer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ "../../node_modules/set-blocking/index.js":
/*!************************************************!*\
  !*** ../../node_modules/set-blocking/index.js ***!
  \************************************************/
/***/ ((module) => {

module.exports = function (blocking) {
  [process.stdout, process.stderr].forEach(function (stream) {
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
      stream._handle.setBlocking(blocking)
    }
  })
}


/***/ }),

/***/ "../../node_modules/shimmer/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/shimmer/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


function isFunction (funktion) {
  return typeof funktion === 'function'
}

// Default to complaining loudly when things don't go according to plan.
var logger = console.error.bind(console)

// Sets a property on an object, preserving its enumerability.
// This function assumes that the property is already writable.
function defineProperty (obj, name, value) {
  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: enumerable,
    writable: true,
    value: value
  })
}

// Keep initialization idempotent.
function shimmer (options) {
  if (options && options.logger) {
    if (!isFunction(options.logger)) logger("new logger isn't a function, not replacing")
    else logger = options.logger
  }
}

function wrap (nodule, name, wrapper) {
  if (!nodule || !nodule[name]) {
    logger('no original function ' + name + ' to wrap')
    return
  }

  if (!wrapper) {
    logger('no wrapper function')
    logger((new Error()).stack)
    return
  }

  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
    logger('original object and wrapper must be functions')
    return
  }

  var original = nodule[name]
  var wrapped = wrapper(original, name)

  defineProperty(wrapped, '__original', original)
  defineProperty(wrapped, '__unwrap', function () {
    if (nodule[name] === wrapped) defineProperty(nodule, name, original)
  })
  defineProperty(wrapped, '__wrapped', true)

  defineProperty(nodule, name, wrapped)
  return wrapped
}

function massWrap (nodules, names, wrapper) {
  if (!nodules) {
    logger('must provide one or more modules to patch')
    logger((new Error()).stack)
    return
  } else if (!Array.isArray(nodules)) {
    nodules = [nodules]
  }

  if (!(names && Array.isArray(names))) {
    logger('must provide one or more functions to wrap on modules')
    return
  }

  nodules.forEach(function (nodule) {
    names.forEach(function (name) {
      wrap(nodule, name, wrapper)
    })
  })
}

function unwrap (nodule, name) {
  if (!nodule || !nodule[name]) {
    logger('no function to unwrap.')
    logger((new Error()).stack)
    return
  }

  if (!nodule[name].__unwrap) {
    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')
  } else {
    return nodule[name].__unwrap()
  }
}

function massUnwrap (nodules, names) {
  if (!nodules) {
    logger('must provide one or more modules to patch')
    logger((new Error()).stack)
    return
  } else if (!Array.isArray(nodules)) {
    nodules = [nodules]
  }

  if (!(names && Array.isArray(names))) {
    logger('must provide one or more functions to unwrap on modules')
    return
  }

  nodules.forEach(function (nodule) {
    names.forEach(function (name) {
      unwrap(nodule, name)
    })
  })
}

shimmer.wrap = wrap
shimmer.massWrap = massWrap
shimmer.unwrap = unwrap
shimmer.massUnwrap = massUnwrap

module.exports = shimmer


/***/ }),

/***/ "../../node_modules/signal-exit/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/signal-exit/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
var assert = __webpack_require__(/*! assert */ "assert")
var signals = __webpack_require__(/*! ./signals.js */ "../../node_modules/signal-exit/signals.js")
var isWin = /^win/i.test(process.platform)

var EE = __webpack_require__(/*! events */ "events")
/* istanbul ignore if */
if (typeof EE !== 'function') {
  EE = EE.EventEmitter
}

var emitter
if (process.__signal_exit_emitter__) {
  emitter = process.__signal_exit_emitter__
} else {
  emitter = process.__signal_exit_emitter__ = new EE()
  emitter.count = 0
  emitter.emitted = {}
}

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
}

module.exports = function (cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  if (loaded === false) {
    load()
  }

  var ev = 'exit'
  if (opts && opts.alwaysLast) {
    ev = 'afterexit'
  }

  var remove = function () {
    emitter.removeListener(ev, cb)
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) {
      unload()
    }
  }
  emitter.on(ev, cb)

  return remove
}

module.exports.unload = unload
function unload () {
  if (!loaded) {
    return
  }
  loaded = false

  signals.forEach(function (sig) {
    try {
      process.removeListener(sig, sigListeners[sig])
    } catch (er) {}
  })
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
}

function emit (event, code, signal) {
  if (emitter.emitted[event]) {
    return
  }
  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
}

// { <signal>: <listener fn>, ... }
var sigListeners = {}
signals.forEach(function (sig) {
  sigListeners[sig] = function listener () {
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig)
    if (listeners.length === emitter.count) {
      unload()
      emit('exit', null, sig)
      /* istanbul ignore next */
      emit('afterexit', null, sig)
      /* istanbul ignore next */
      if (isWin && sig === 'SIGHUP') {
        // "SIGHUP" throws an `ENOSYS` error on Windows,
        // so use a supported signal instead
        sig = 'SIGINT'
      }
      process.kill(process.pid, sig)
    }
  }
})

module.exports.signals = function () {
  return signals
}

module.exports.load = load

var loaded = false

function load () {
  if (loaded) {
    return
  }
  loaded = true

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1

  signals = signals.filter(function (sig) {
    try {
      process.on(sig, sigListeners[sig])
      return true
    } catch (er) {
      return false
    }
  })

  process.emit = processEmit
  process.reallyExit = processReallyExit
}

var originalProcessReallyExit = process.reallyExit
function processReallyExit (code) {
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null)
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode)
}

var originalProcessEmit = process.emit
function processEmit (ev, arg) {
  if (ev === 'exit') {
    if (arg !== undefined) {
      process.exitCode = arg
    }
    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    return ret
  } else {
    return originalProcessEmit.apply(this, arguments)
  }
}


/***/ }),

/***/ "../../node_modules/signal-exit/signals.js":
/*!*************************************************!*\
  !*** ../../node_modules/signal-exit/signals.js ***!
  \*************************************************/
/***/ ((module) => {

// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
  'SIGABRT',
  'SIGALRM',
  'SIGHUP',
  'SIGINT',
  'SIGTERM'
]

if (process.platform !== 'win32') {
  module.exports.push(
    'SIGVTALRM',
    'SIGXCPU',
    'SIGXFSZ',
    'SIGUSR2',
    'SIGTRAP',
    'SIGSYS',
    'SIGQUIT',
    'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  )
}

if (process.platform === 'linux') {
  module.exports.push(
    'SIGIO',
    'SIGPOLL',
    'SIGPWR',
    'SIGSTKFLT',
    'SIGUNUSED'
  )
}


/***/ }),

/***/ "../../node_modules/stack-chain/format.js":
/*!************************************************!*\
  !*** ../../node_modules/stack-chain/format.js ***!
  \************************************************/
/***/ ((module) => {

// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function FormatErrorString(error) {
  try {
    return Error.prototype.toString.call(error);
  } catch (e) {
    try {
      return "<error: " + e + ">";
    } catch (ee) {
      return "<error>";
    }
  }
}

module.exports = function FormatStackTrace(error, frames) {
  var lines = [];
  lines.push(FormatErrorString(error));
  for (var i = 0; i < frames.length; i++) {
    var frame = frames[i];
    var line;
    try {
      line = frame.toString();
    } catch (e) {
      try {
        line = "<error: " + e + ">";
      } catch (ee) {
        // Any code that reaches this point is seriously nasty!
        line = "<error>";
      }
    }
    lines.push("    at " + line);
  }
  return lines.join("\n");
};


/***/ }),

/***/ "../../node_modules/stack-chain/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/stack-chain/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// If a another copy (same version or not) of stack-chain exists it will result
// in wrong stack traces (most likely dublicate callSites).
if (global._stackChain) {
  // In case the version match, we can simply return the first initialized copy
  if (global._stackChain.version === (__webpack_require__(/*! ./package.json */ "../../node_modules/stack-chain/package.json").version)) {
    module.exports = global._stackChain;
  }
  // The version don't match, this is really bad. Lets just throw
  else {
    throw new Error('Conflicting version of stack-chain found');
  }
}
// Yay, no other stack-chain copy exists, yet :/
else {
  module.exports = global._stackChain = __webpack_require__(/*! ./stack-chain */ "../../node_modules/stack-chain/stack-chain.js");
}


/***/ }),

/***/ "../../node_modules/stack-chain/stack-chain.js":
/*!*****************************************************!*\
  !*** ../../node_modules/stack-chain/stack-chain.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


// use a already existing formater or fallback to the default v8 formater
var defaultFormater = __webpack_require__(/*! ./format.js */ "../../node_modules/stack-chain/format.js");

// public define API
function stackChain() {
  this.extend = new TraceModifier();
  this.filter = new TraceModifier();
  this.format = new StackFormater();
  this.version = (__webpack_require__(/*! ./package.json */ "../../node_modules/stack-chain/package.json").version);
}


var SHORTCIRCUIT_CALLSITE = false;
stackChain.prototype.callSite = function collectCallSites(options) {
  if (!options) options = {};

  // Get CallSites
  SHORTCIRCUIT_CALLSITE = true;
  var obj = {};
  Error.captureStackTrace(obj, collectCallSites);
  var callSites = obj.stack;
  SHORTCIRCUIT_CALLSITE = false;

  // Slice
  callSites = callSites.slice(options.slice || 0);

  // Modify CallSites
  if (options.extend) callSites = this.extend._modify(obj, callSites);
  if (options.filter) callSites = this.filter._modify(obj, callSites);

  // Done
  return callSites;
};

var chain = new stackChain();

function TraceModifier() {
  this._modifiers = [];
}

TraceModifier.prototype._modify = function (error, frames) {
  for (var i = 0, l = this._modifiers.length; i < l; i++) {
    frames = this._modifiers[i](error, frames);
  }

  return frames;
};

TraceModifier.prototype.attach = function (modifier) {
  this._modifiers.push(modifier);
};

TraceModifier.prototype.deattach = function (modifier) {
  var index = this._modifiers.indexOf(modifier);

  if (index === -1) return false;

  this._modifiers.splice(index, 1);
  return true;
};

function StackFormater() {
  this._formater = defaultFormater;
  this._previous = undefined;
}

StackFormater.prototype.replace = function (formater) {
  if (formater) {
    this._formater = formater;
  } else {
    this.restore();
  }
};

StackFormater.prototype.restore  = function () {
  this._formater = defaultFormater;
  this._previous = undefined;
};

StackFormater.prototype._backup = function () {
  this._previous = this._formater;
};

StackFormater.prototype._roolback = function () {
  if (this._previous === defaultFormater) {
    this.replace(undefined);
  } else {
    this.replace(this._previous);
  }

  this._previous = undefined;
};


//
// Set Error.prepareStackTrace thus allowing stack-chain
// to take control of the Error().stack formating.
//

// If there already is a custom stack formater, then set
// that as the stack-chain formater.
if (Error.prepareStackTrace) {
    chain.format.replace(Error.prepareStackTrace);
}

var SHORTCIRCUIT_FORMATER = false;
function prepareStackTrace(error, originalFrames) {
  if (SHORTCIRCUIT_CALLSITE) return originalFrames;
  if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);

  // Make a loss copy of originalFrames
  var frames = originalFrames.concat();

  // extend frames
  frames = chain.extend._modify(error, frames);

  // filter frames
  frames = chain.filter._modify(error, frames);

  // reduce frames to match Error.stackTraceLimit
  frames = frames.slice(0, Error.stackTraceLimit);

  // Set the callSite property
  // But only if it hasn't been explicitly set, otherwise
  // error.stack would have unintended side effects. Check also for
  // non-extensible/sealed objects, such as those from Google's Closure Library
  if (Object.isExtensible(error) &&
      (Object.getOwnPropertyDescriptor(error, "callSite") === undefined)) {
    error.callSite = {
      original: originalFrames,
      mutated: frames
    };
  }

  // format frames
  SHORTCIRCUIT_FORMATER = true;
  var format = chain.format._formater(error, frames);
  SHORTCIRCUIT_FORMATER = false;

  return format;
}

// Replace the v8 stack trace creator
Object.defineProperty(Error, 'prepareStackTrace', {
  'get': function () {
    return prepareStackTrace;
  },

  'set': function (formater) {
    // If formater is prepareStackTrace it means that someone ran
    // var old = Error.prepareStackTrace;
    // Error.prepareStackTrace = custom
    // new Error().stack
    // Error.prepareStackTrace = old;
    // The effect of this, should be that the old behaviour is restored.
    if (formater === prepareStackTrace) {
      chain.format._roolback();
    }
    // Error.prepareStackTrace was set, this means that someone is
    // trying to take control of the Error().stack format. Make
    // them belive they succeeded by setting them up as the stack-chain
    // formater.
    else {
      chain.format._backup();
      chain.format.replace(formater);
    }
  }
});

//
// Manage call site storeage
//
function callSiteGetter() {
  // calculate call site object
  this.stack;

  // return call site object
  return this.callSite;
}

Object.defineProperty(Error.prototype, 'callSite', {
  'get': callSiteGetter,

  'set': function (frames) {
    // In case callSite was set before [[getter]], just set
    // the value
    Object.defineProperty(this, 'callSite', {
        value: frames,
        writable: true,
        configurable: true
    });
  },

  configurable: true
});

module.exports = chain;


/***/ }),

/***/ "../../node_modules/sudo-prompt/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/sudo-prompt/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Node = {
  child: __webpack_require__(/*! child_process */ "child_process"),
  crypto: __webpack_require__(/*! crypto */ "crypto"),
  fs: __webpack_require__(/*! fs */ "fs"),
  os: __webpack_require__(/*! os */ "os"),
  path: __webpack_require__(/*! path */ "path"),
  process: process,
  util: __webpack_require__(/*! util */ "util")
};

function Attempt(instance, end) {
  var platform = Node.process.platform;
  if (platform === 'darwin') return Mac(instance, end);
  if (platform === 'linux') return Linux(instance, end);
  if (platform === 'win32') return Windows(instance, end);
  end(new Error('Platform not yet supported.'));
}

function EscapeDoubleQuotes(string) {
  if (typeof string !== 'string') throw new Error('Expected a string.');
  return string.replace(/"/g, '\\"');
}

function Exec() {
  if (arguments.length < 1 || arguments.length > 3) {
    throw new Error('Wrong number of arguments.');
  }
  var command = arguments[0];
  var options = {};
  var end = function() {};
  if (typeof command !== 'string') {
    throw new Error('Command should be a string.');
  }
  if (arguments.length === 2) {
    if (Node.util.isObject(arguments[1])) {
      options = arguments[1];
    } else if (Node.util.isFunction(arguments[1])) {
      end = arguments[1];
    } else {
      throw new Error('Expected options or callback.');
    }
  } else if (arguments.length === 3) {
    if (Node.util.isObject(arguments[1])) {
      options = arguments[1];
    } else {
      throw new Error('Expected options to be an object.');
    }
    if (Node.util.isFunction(arguments[2])) {
      end = arguments[2];
    } else {
      throw new Error('Expected callback to be a function.');
    }
  }
  if (/^sudo/i.test(command)) {
    return end(new Error('Command should not be prefixed with "sudo".'));
  }
  if (typeof options.name === 'undefined') {
    var title = Node.process.title;
    if (ValidName(title)) {
      options.name = title;
    } else {
      return end(new Error('process.title cannot be used as a valid name.'));
    }
  } else if (!ValidName(options.name)) {
    var error = '';
    error += 'options.name must be alphanumeric only ';
    error += '(spaces are allowed) and <= 70 characters.';
    return end(new Error(error));
  }
  if (typeof options.icns !== 'undefined') {
    if (typeof options.icns !== 'string') {
      return end(new Error('options.icns must be a string if provided.'));
    } else if (options.icns.trim().length === 0) {
      return end(new Error('options.icns must not be empty if provided.'));
    }
  }
  if (typeof options.env !== 'undefined') {
    if (typeof options.env !== 'object') {
      return end(new Error('options.env must be an object if provided.'));
    } else if (Object.keys(options.env).length === 0) {
      return end(new Error('options.env must not be empty if provided.'));
    } else {
      for (var key in options.env) {
        var value = options.env[key];
        if (typeof key !== 'string' || typeof value !== 'string') {
          return end(
            new Error('options.env environment variables must be strings.')
          );
        }
        // "Environment variable names used by the utilities in the Shell and
        // Utilities volume of IEEE Std 1003.1-2001 consist solely of uppercase
        // letters, digits, and the '_' (underscore) from the characters defined
        // in Portable Character Set and do not begin with a digit. Other
        // characters may be permitted by an implementation; applications shall
        // tolerate the presence of such names."
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
          return end(
            new Error(
              'options.env has an invalid environment variable name: ' +
              JSON.stringify(key)
            )
          );
        }
        if (/[\r\n]/.test(value)) {
          return end(
            new Error(
              'options.env has an invalid environment variable value: ' +
              JSON.stringify(value)
            )
          );
        }
      }
    }
  }
  var platform = Node.process.platform;
  if (platform !== 'darwin' && platform !== 'linux' && platform !== 'win32') {
    return end(new Error('Platform not yet supported.'));
  }
  var instance = {
    command: command,
    options: options,
    uuid: undefined,
    path: undefined
  };
  Attempt(instance, end);
}

function Linux(instance, end) {
  LinuxBinary(instance,
    function(error, binary) {
      if (error) return end(error);
      var command = [];
      // Preserve current working directory:
      command.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '";');
      // Export environment variables:
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        command.push('export ' + key + '="' + EscapeDoubleQuotes(value) + '";');
      }
      command.push('"' + EscapeDoubleQuotes(binary) + '"');
      if (/kdesudo/i.test(binary)) {
        command.push(
          '--comment',
          '"' + instance.options.name + ' wants to make changes. ' +
          'Enter your password to allow this."'
        );
        command.push('-d'); // Do not show the command to be run in the dialog.
        command.push('--');
      } else if (/pkexec/i.test(binary)) {
        command.push('--disable-internal-agent');
      }
      var magic = 'SUDOPROMPT\n';
      command.push(
        '/bin/bash -c "echo ' + EscapeDoubleQuotes(magic.trim()) + '; ' +
        EscapeDoubleQuotes(instance.command) +
        '"'
      );
      command = command.join(' ');
      Node.child.exec(command, { encoding: 'utf-8', maxBuffer: MAX_BUFFER },
        function(error, stdout, stderr) {
          // ISSUE 88:
          // We must distinguish between elevation errors and command errors.
          //
          // KDESUDO:
          // kdesudo provides no way to do this. We add a magic marker to know
          // if elevation succeeded. Any error thereafter is a command error.
          //
          // PKEXEC:
          // "Upon successful completion, the return value is the return value of
          // PROGRAM. If the calling process is not authorized or an
          // authorization could not be obtained through authentication or an
          // error occured, pkexec exits with a return value of 127. If the
          // authorization could not be obtained because the user dismissed the
          // authentication dialog, pkexec exits with a return value of 126."
          //
          // However, we do not rely on pkexec's return of 127 since our magic
          // marker is more reliable, and we already use it for kdesudo.
          var elevated = stdout && stdout.slice(0, magic.length) === magic;
          if (elevated) stdout = stdout.slice(magic.length);
          // Only normalize the error if it is definitely not a command error:
          // In other words, if we know that the command was never elevated.
          // We do not inspect error messages beyond NO_POLKIT_AGENT.
          // We cannot rely on English errors because of internationalization.
          if (error && !elevated) {
            if (/No authentication agent found/.test(stderr)) {
              error.message = NO_POLKIT_AGENT;
            } else {
              error.message = PERMISSION_DENIED;
            }
          }
          end(error, stdout, stderr);
        }
      );
    }
  );
}

function LinuxBinary(instance, end) {
  var index = 0;
  // We used to prefer gksudo over pkexec since it enabled a better prompt.
  // However, gksudo cannot run multiple commands concurrently.
  var paths = ['/usr/bin/kdesudo', '/usr/bin/pkexec'];
  function test() {
    if (index === paths.length) {
      return end(new Error('Unable to find pkexec or kdesudo.'));
    }
    var path = paths[index++];
    Node.fs.stat(path,
      function(error) {
        if (error) {
          if (error.code === 'ENOTDIR') return test();
          if (error.code === 'ENOENT') return test();
          end(error);
        } else {
          end(undefined, path);
        }
      }
    );
  }
  test();
}

function Mac(instance, callback) {
  var temp = Node.os.tmpdir();
  if (!temp) return callback(new Error('os.tmpdir() not defined.'));
  var user = Node.process.env.USER; // Applet shell scripts require $USER.
  if (!user) return callback(new Error('env[\'USER\'] not defined.'));
  UUID(instance,
    function(error, uuid) {
      if (error) return callback(error);
      instance.uuid = uuid;
      instance.path = Node.path.join(
        temp,
        instance.uuid,
        instance.options.name + '.app'
      );
      function end(error, stdout, stderr) {
        Remove(Node.path.dirname(instance.path),
          function(errorRemove) {
            if (error) return callback(error);
            if (errorRemove) return callback(errorRemove);
            callback(undefined, stdout, stderr);
          }
        );
      }
      MacApplet(instance,
        function(error, stdout, stderr) {
          if (error) return end(error, stdout, stderr);
          MacIcon(instance,
            function(error) {
              if (error) return end(error);
              MacPropertyList(instance,
                function(error, stdout, stderr) {
                  if (error) return end(error, stdout, stderr);
                  MacCommand(instance,
                    function(error) {
                      if (error) return end(error);
                      MacOpen(instance,
                        function(error, stdout, stderr) {
                          if (error) return end(error, stdout, stderr);
                          MacResult(instance, end);
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

function MacApplet(instance, end) {
  var parent = Node.path.dirname(instance.path);
  Node.fs.mkdir(parent,
    function(error) {
      if (error) return end(error);
      var zip = Node.path.join(parent, 'sudo-prompt-applet.zip');
      Node.fs.writeFile(zip, APPLET, 'base64',
        function(error) {
          if (error) return end(error);
          var command = [];
          command.push('/usr/bin/unzip');
          command.push('-o'); // Overwrite any existing applet.
          command.push('"' + EscapeDoubleQuotes(zip) + '"');
          command.push('-d "' + EscapeDoubleQuotes(instance.path) + '"');
          command = command.join(' ');
          Node.child.exec(command, { encoding: 'utf-8' }, end);
        }
      );
    }
  );
}

function MacCommand(instance, end) {
  var path = Node.path.join(
    instance.path,
    'Contents',
    'MacOS',
    'sudo-prompt-command'
  );
  var script = [];
  // Preserve current working directory:
  // We do this for commands that rely on relative paths.
  // This runs in a subshell and will not change the cwd of sudo-prompt-script.
  script.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '"');
  // Export environment variables:
  for (var key in instance.options.env) {
    var value = instance.options.env[key];
    script.push('export ' + key + '="' + EscapeDoubleQuotes(value) + '"');
  }
  script.push(instance.command);
  script = script.join('\n');
  Node.fs.writeFile(path, script, 'utf-8', end);
}

function MacIcon(instance, end) {
  if (!instance.options.icns) return end();
  Node.fs.readFile(instance.options.icns,
    function(error, buffer) {
      if (error) return end(error);
      var icns = Node.path.join(
        instance.path,
        'Contents',
        'Resources',
        'applet.icns'
      );
      Node.fs.writeFile(icns, buffer, end);
    }
  );
}

function MacOpen(instance, end) {
  // We must run the binary directly so that the cwd will apply.
  var binary = Node.path.join(instance.path, 'Contents', 'MacOS', 'applet');
  // We must set the cwd so that the AppleScript can find the shell scripts.
  var options = {
    cwd: Node.path.dirname(binary),
    encoding: 'utf-8'
  };
  // We use the relative path rather than the absolute path. The instance.path
  // may contain spaces which the cwd can handle, but which exec() cannot.
  Node.child.exec('./' + Node.path.basename(binary), options, end);
}

function MacPropertyList(instance, end) {
  // Value must be in single quotes (not double quotes) according to man entry.
  // e.g. defaults write com.companyname.appname "Default Color" '(255, 0, 0)'
  // The defaults command will be changed in an upcoming major release to only
  // operate on preferences domains. General plist manipulation utilities will
  // be folded into a different command-line program.
  var plist = Node.path.join(instance.path, 'Contents', 'Info.plist');
  var path = EscapeDoubleQuotes(plist);
  var key = EscapeDoubleQuotes('CFBundleName');
  var value = instance.options.name + ' Password Prompt';
  if (/'/.test(value)) {
    return end(new Error('Value should not contain single quotes.'));
  }
  var command = [];
  command.push('/usr/bin/defaults');
  command.push('write');
  command.push('"' + path + '"');
  command.push('"' + key + '"');
  command.push("'" + value + "'"); // We must use single quotes for value.
  command = command.join(' ');
  Node.child.exec(command, { encoding: 'utf-8' }, end);
}

function MacResult(instance, end) {
  var cwd = Node.path.join(instance.path, 'Contents', 'MacOS');
  Node.fs.readFile(Node.path.join(cwd, 'code'), 'utf-8',
    function(error, code) {
      if (error) {
        if (error.code === 'ENOENT') return end(new Error(PERMISSION_DENIED));
        end(error);
      } else {
        Node.fs.readFile(Node.path.join(cwd, 'stdout'), 'utf-8',
          function(error, stdout) {
            if (error) return end(error);
            Node.fs.readFile(Node.path.join(cwd, 'stderr'), 'utf-8',
              function(error, stderr) {
                if (error) return end(error);
                code = parseInt(code.trim(), 10); // Includes trailing newline.
                if (code === 0) {
                  end(undefined, stdout, stderr);
                } else {
                  error = new Error(
                    'Command failed: ' + instance.command + '\n' + stderr
                  );
                  error.code = code;
                  end(error, stdout, stderr);
                }
              }
            );
          }
        );
      }
    }
  );
}

function Remove(path, end) {
  if (typeof path !== 'string' || !path.trim()) {
    return end(new Error('Argument path not defined.'));
  }
  var command = [];
  if (Node.process.platform === 'win32') {
    if (/"/.test(path)) {
      return end(new Error('Argument path cannot contain double-quotes.'));
    }
    command.push('rmdir /s /q "' + path + '"');
  } else {
    command.push('/bin/rm');
    command.push('-rf');
    command.push('"' + EscapeDoubleQuotes(Node.path.normalize(path)) + '"');
  }
  command = command.join(' ');
  Node.child.exec(command, { encoding: 'utf-8' }, end);
}

function UUID(instance, end) {
  Node.crypto.randomBytes(256,
    function(error, random) {
      if (error) random = Date.now() + '' + Math.random();
      var hash = Node.crypto.createHash('SHA256');
      hash.update('sudo-prompt-3');
      hash.update(instance.options.name);
      hash.update(instance.command);
      hash.update(random);
      var uuid = hash.digest('hex').slice(-32);
      if (!uuid || typeof uuid !== 'string' || uuid.length !== 32) {
        // This is critical to ensure we don't remove the wrong temp directory.
        return end(new Error('Expected a valid UUID.'));
      }
      end(undefined, uuid);
    }
  );
}

function ValidName(string) {
  // We use 70 characters as a limit to side-step any issues with Unicode
  // normalization form causing a 255 character string to exceed the fs limit.
  if (!/^[a-z0-9 ]+$/i.test(string)) return false;
  if (string.trim().length === 0) return false;
  if (string.length > 70) return false;
  return true;
}

function Windows(instance, callback) {
  var temp = Node.os.tmpdir();
  if (!temp) return callback(new Error('os.tmpdir() not defined.'));
  UUID(instance,
    function(error, uuid) {
      if (error) return callback(error);
      instance.uuid = uuid;
      instance.path = Node.path.join(temp, instance.uuid);
      if (/"/.test(instance.path)) {
        // We expect double quotes to be reserved on Windows.
        // Even so, we test for this and abort if they are present.
        return callback(
          new Error('instance.path cannot contain double-quotes.')
        );
      }
      instance.pathElevate = Node.path.join(instance.path, 'elevate.vbs');
      instance.pathExecute = Node.path.join(instance.path, 'execute.bat');
      instance.pathCommand = Node.path.join(instance.path, 'command.bat');
      instance.pathStdout = Node.path.join(instance.path, 'stdout');
      instance.pathStderr = Node.path.join(instance.path, 'stderr');
      instance.pathStatus = Node.path.join(instance.path, 'status');
      Node.fs.mkdir(instance.path,
        function(error) {
          if (error) return callback(error);
          function end(error, stdout, stderr) {
            Remove(instance.path,
              function(errorRemove) {
                if (error) return callback(error);
                if (errorRemove) return callback(errorRemove);
                callback(undefined, stdout, stderr);
              }
            );
          }
          WindowsWriteExecuteScript(instance,
            function(error) {
              if (error) return end(error);
              WindowsWriteCommandScript(instance,
                function(error) {
                  if (error) return end(error);
                  WindowsElevate(instance,
                    function(error, stdout, stderr) {
                      if (error) return end(error, stdout, stderr);
                      WindowsWaitForStatus(instance,
                        function(error) {
                          if (error) return end(error);
                          WindowsResult(instance, end);
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

function WindowsElevate(instance, end) {
  // We used to use this for executing elevate.vbs:
  // var command = 'cscript.exe //NoLogo "' + instance.pathElevate + '"';
  var command = [];
  command.push('powershell.exe');
  command.push('Start-Process');
  command.push('-FilePath');
  // Escape characters for cmd using double quotes:
  // Escape characters for PowerShell using single quotes:
  // Escape single quotes for PowerShell using backtick:
  // See: https://ss64.com/ps/syntax-esc.html
  command.push('"\'' + instance.pathExecute.replace(/'/g, "`'") + '\'"');
  command.push('-WindowStyle hidden');
  command.push('-Verb runAs');
  command = command.join(' ');
  var child = Node.child.exec(command, { encoding: 'utf-8' },
    function(error, stdout, stderr) {
      // We used to return PERMISSION_DENIED only for error messages containing
      // the string 'canceled by the user'. However, Windows internationalizes
      // error messages (issue 96) so now we must assume all errors here are
      // permission errors. This seems reasonable, given that we already run the
      // user's command in a subshell.
      if (error) return end(new Error(PERMISSION_DENIED), stdout, stderr);
      end();
    }
  );
  child.stdin.end(); // Otherwise PowerShell waits indefinitely on Windows 7.
}

function WindowsResult(instance, end) {
  Node.fs.readFile(instance.pathStatus, 'utf-8',
    function(error, code) {
      if (error) return end(error);
      Node.fs.readFile(instance.pathStdout, 'utf-8',
        function(error, stdout) {
          if (error) return end(error);
          Node.fs.readFile(instance.pathStderr, 'utf-8',
            function(error, stderr) {
              if (error) return end(error);
              code = parseInt(code.trim(), 10);
              if (code === 0) {
                end(undefined, stdout, stderr);
              } else {
                error = new Error(
                  'Command failed: ' + instance.command + '\r\n' + stderr
                );
                error.code = code;
                end(error, stdout, stderr);
              }
            }
          );
        }
      );
    }
  );
}

function WindowsWaitForStatus(instance, end) {
  // VBScript cannot wait for the elevated process to finish so we have to poll.
  // VBScript cannot return error code if user does not grant permission.
  // PowerShell can be used to elevate and wait on Windows 10.
  // PowerShell can be used to elevate on Windows 7 but it cannot wait.
  // powershell.exe Start-Process cmd.exe -Verb runAs -Wait
  Node.fs.stat(instance.pathStatus,
    function(error, stats) {
      if ((error && error.code === 'ENOENT') || stats.size < 2) {
        // Retry if file does not exist or is not finished writing.
        // We expect a file size of 2. That should cover at least "0\r".
        // We use a 1 second timeout to keep a light footprint for long-lived
        // sudo-prompt processes.
        setTimeout(
          function() {
            // If administrator has no password and user clicks Yes, then
            // PowerShell returns no error and execute (and command) never runs.
            // We check that command output has been redirected to stdout file:
            Node.fs.stat(instance.pathStdout,
              function(error) {
                if (error) return end(new Error(PERMISSION_DENIED));
                WindowsWaitForStatus(instance, end);
              }
            );
          },
          1000
        );
      } else if (error) {
        end(error);
      } else {
        end();
      }
    }
  );
}

function WindowsWriteCommandScript(instance, end) {
  var cwd = Node.process.cwd();
  if (/"/.test(cwd)) {
    // We expect double quotes to be reserved on Windows.
    // Even so, we test for this and abort if they are present.
    return end(new Error('process.cwd() cannot contain double-quotes.'));
  }
  var script = [];
  script.push('@echo off');
  // Set code page to UTF-8:
  script.push('chcp 65001>nul');
  // Preserve current working directory:
  // We pass /d as an option in case the cwd is on another drive (issue 70).
  script.push('cd /d "' + cwd + '"');
  // Export environment variables:
  for (var key in instance.options.env) {
    // "The characters <, >, |, &, ^ are special command shell characters, and
    // they must be preceded by the escape character (^) or enclosed in
    // quotation marks. If you use quotation marks to enclose a string that
    // contains one of the special characters, the quotation marks are set as
    // part of the environment variable value."
    // In other words, Windows assigns everything that follows the equals sign
    // to the value of the variable, whereas Unix systems ignore double quotes.
    var value = instance.options.env[key];
    script.push('set ' + key + '=' + value.replace(/([<>\\|&^])/g, '^$1'));
  }
  script.push(instance.command);
  script = script.join('\r\n');
  Node.fs.writeFile(instance.pathCommand, script, 'utf-8', end);
}

function WindowsWriteElevateScript(instance, end) {
  // We do not use VBScript to elevate since it does not return an error if
  // the user does not grant permission. This is here for reference.
  // var script = [];
  // script.push('Set objShell = CreateObject("Shell.Application")');
  // script.push(
  // 'objShell.ShellExecute "' + instance.pathExecute + '", "", "", "runas", 0'
  // );
  // script = script.join('\r\n');
  // Node.fs.writeFile(instance.pathElevate, script, 'utf-8', end);
}

function WindowsWriteExecuteScript(instance, end) {
  var script = [];
  script.push('@echo off');
  script.push(
    'call "' + instance.pathCommand + '"' +
    ' > "' + instance.pathStdout + '" 2> "' + instance.pathStderr + '"'
  );
  script.push('(echo %ERRORLEVEL%) > "' + instance.pathStatus + '"');
  script = script.join('\r\n');
  Node.fs.writeFile(instance.pathExecute, script, 'utf-8', end);
}

module.exports.exec = Exec;

// We used to expect that applet.app would be included with this module.
// This could not be copied when sudo-prompt was packaged within an asar file.
// We now store applet.app as a zip file in base64 within index.js instead.
// To recreate: "zip -r ../applet.zip Contents" (with applet.app as CWD).
// The zip file must not include applet.app as the root directory so that we
// can extract it directly to the target app directory.
var APPLET = 'UEsDBAoAAAAAAO1YcEcAAAAAAAAAAAAAAAAJABwAQ29udGVudHMvVVQJAAPNnElWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACgeXBHlHaGqKEBAAC+AwAAEwAcAENvbnRlbnRzL0luZm8ucGxpc3RVVAkAA1zWSVYtkRBXdXgLAAEE9QEAAAQUAAAAfZNRb5swFIWfl1/BeA9OpSmqJkqVBCJFop1VyKQ9Ta59S6wa27NNCfv1M0naJWTsEXO+c8+9vo7v97UI3sBYruRdeBPNwgAkVYzL6i7cluvpbXifTOLP6bdV+QNngRbcugBvl/lmFYRThBZaC0AoLdMA55uiDLwHQtljGIQ75/RXhNq2jUiviqiqe6FF2CgNxnW5N5t6IGKOhb7M0f0ijj9lnLpk8il+hS5ZrZeNZAIWQqj2ge+B5YoSwX8T5xEbo17ktc40gIZQCm8glK5BuieovP5Dbp3xHSeZrHyCXYxO3wM+2wNtHHkWMAQP/bkxbkOVXPMxKuK0Dz6CMh+Wv3AwQ9gPM7INU1NtVK3Ha8sXlfoB+m6J6b4fRzv0mkezMf6R1Fe5MbG2VYYF+L+lMaGvpIKy01cOC4zzMazYKeNOQYuDYkjfjMcteCWJa8w/Zi2ugubFA5e8buqisw7qU81ltzB0xx3QC5/TFh7J/e385/zL+7+/wWbR/LwIOl/dvHiCXw03YFfEPJ9dwsWu5sV2kwnod3QoeLeL0eGdJJM/UEsDBAoAAAAAAHSBjkgAAAAAAAAAAAAAAAAPABwAQ29udGVudHMvTWFjT1MvVVQJAAMbpQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACABVHBdH7Dk4KTIIAADIYQAAFQAcAENvbnRlbnRzL01hY09TL2FwcGxldFVUCQADMiPZVVOlD1d1eAsAAQT1AQAABBQAAADtnG9sHEcVwGfti7M1/rONLNVtXHqpzsipis+pHOSWFOzEm25at3XrJI2ozbK+W/suuds79vaSuCKSpaOIxRy1+NSPRPAhlWj7AVRaQCWpTRz+CEo+RSKCCho4K67kVhUyAeV4b3fWt17fXZqKFgHvp8zO3/dmdmfPmtl5L7+8/uPXGWMNELZCaGRMgmjHIlxaBCibdcoGsewCljGCIAiCIAiCIAiCIP7r+M21d67zjb/zEaAdwr1bGHuWMQH2/2wAgqqODj0kf0F+8nGfoFRbJ8p9U0C5g/KRgwEZqZLGfrfwwJx+LP2kVWkelD9zJ2NfBr1nWt2xrhNisxWZ3Ex6MpNSc1Z+soqOO+5i7JMYt7vj9BC5jiZXBwirCT2V1c0qOgZAxwMYt9cbRyxnmUljusa9mKBjGON2tgG/PlXNGyeSRlxNGlOZKjpeBR0KxsFx+MB7VJy5GB46OOSrCLPKfEjrH3/gFry+4zOpuH8sm+VF5srW6ltVjZQ3HVnL3KRDDLsflMSADpyDyjuR0urp6AAdHRgHdOD9iOs6Ypl0OmPUupeecOW19OsQAmn3tzBy4LFH5OED3jz0MbYouM8D460BOdTXCaEF6tsgLkF8GeJPQBj16Rb4PTf5xl2NH4J8a5Vy1N3F3OcZzefMaCo5GeVTuJ2P4cUf/aH5qbbP73/utpfeevdbLzwfYfy+Q80woGan/1E+ljo/703g77IaOJY479t5rqFLDag9OjaTs/R0dCQ5aWrmTHS/qaX1ExnzWC66L2PqY7p5PBnTc71TXnn0sG7mkhkjFx3a0IL30e/rQxB+EXL68J4BBLe73r298DySk5tlGPtJY1BmOhZTc727PBH2Ke+ZhF35nTyP80oQBEEQBPFRcJTZVwpvrxZWpLmJkN0VKT4q2iORUGFBOPfnBuFX9nhELOG67f1D9pWxpw4XVrrmTklz+ZY5Wfwurm/t3ffi9cE+uM41vYbbj2fP5kNXt9sXiopwVRj6xhPlr160mttfuVi4Fs2vXv2rfc5u7UeZfxQ+y4pPh/JrpyUUBjmrofzmadGXKf0eui7KK/ZwJLQUiuRAe+mLUFQ+tFKUV3npd7AU9ytz8iqIiXYoUnoBsqdxDbXk3CXcRov9lYhoW5EQjBxb4NoSY9iQsvn5+QSuusrduAybL3eHIIIbLqyIS9CHlY3loB8rldVKuLfyOsE1+a6zhUVxYsFp3Amqz8tr7Lz8dza1JF8TmC3/syivYVtcfxcWOycWQDvuLcrdnc61y7mGnWsErgmsXDbK5TKkscnypJvGhsuH3TQ2X37YTaPQ8ucw7W6t1LR2TFfjekqb0SGTiedTOmz0klZSSyWf0U01pqVSufXGmThsjs20OpU3Yrjuxbnu4u+GP8b1LO6PcX2L4Q6+v8Q07u9aQFLy71Ckt54TIfjfNdzfDkMYhTAOIXHXh39vCYIgCIIgCIIgCIL4z3Nm+84/Ci1Nn8b0ryHsgbBX1rbgOXD7LZJzNtrC0/gFqYOn8csQ/GONguQchPXzcvy+9CBzvk84HxkO+tJH3bRz5Fb0pb/nS3/fl/6BL/2aL43faLzz3Wbmju8W5p6pttaoR9THjgyZ0zEeH2eqqmbNzLShpXVIpxOqflKP5S1dTehaXDeZqhvHk2bGYOo+LZXal0lnM4ZuWMPJXFazYgmmPp7VjWF9SsunrPVa1HpMn0lPm2r8hGZO3aea+nQyZ+mmmtNjFp5i4oG0lTChE+eDj2pm8lbSgDFoln4yCRp00zQyEDmZtBZLbGxnanHzgWh092d29e/uv+/f+DIQBEEQBEEQBEEQ/7P81rX/FxoZm/Xs/5UmtP8PO/W3M9fGvKoPAEfYXLQJ1HOpmk+AJx80OOb5m/URGG9z9c378rVs9F15tPXP1dS3wvVtC+Q9/H4DFX21fQcY9zvo9eXrj6++D0Af1zfqy9eyx3f16QnVMayufr+zXN+sL99YRx/O69er+RdIgXkNxJv9DfBTDIxLPa6Zudr6enz5euO6ke9Bj7TRzr0noK+JbczfyA9hgOvr9OX98t57XNFX3ydhlOsL+2T8+oK/ucrvNOCfEHbbXhAqeebLB/0V7oYp7+Pt8PsZWnl1+urRpAn7SUCcYBX/hkth95kd2cFYllX3bxB4+xCrzcCO6v4PbXzo1fwbEM/H4ds/f/nCgZH+8k+j0vNPv7Jlz7qPQ1PFx+FVPoZ76ozj42K87YP9/cT7xuf9UfpSeP0MsJvzp0A8/4g3w+78ef4R+F4QBEEQBPH/w1Gm2FeUwturytwpUSnmJfta4Q3h3J8aFeE9xf7d1ZBSOCcqhftZ/m+YKuG6wV4qaQzdGED0Z2jJ/zpa9ZcegjIF7fkVaIBrt11nJxYOOepXpPPyKjsvvytOLcnvCWxJfh87V+xTa0rx1Kpj0a8UFqWJhXL3fgHt9xXn+rCz7Bop3rkTEkNj5e7bIZ7HNRZb/ku5XE6g58HyZUzdj6mLjh1/Pbt7XMt5dvfvtLl1Fbv7BtbhrtyEPW6V038H1yE88yQTTkqC1LJVnIeaCNe7dr3sEPEe6lCb9LWGfa3efvNG8pe5fF8NeW8g3n7jCI+/xOOEVH19KvF9oudHH2n/YOtYgiAIgiAIgiAIgiA+fm69mx3aO8bYtkHn/xlwDq8nkwaavz9h9swzc+DWwRrm71A5CJVVjeChTtk26Fqwu0fxQjUL+9vqHVV/KC53OUd+bJxVfBkw7/gzCO5pr3dOK/g+WUQDeZlV/A2QRwJ5THjn1/xcd9BfhlT1KbgpVwLn+W2amGr2//8CUEsDBBQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABwAQ29udGVudHMvTWFjT1Mvc3Vkby1wcm9tcHQtc2NyaXB0VVQJAAOJkBBXipAQV3V4CwABBPUBAAAEFAAAAI1SO08cMRDu91cMHIKGxUB5xSGEUqTlFKWMvPYca+EXnjGXy6/PeNcg0qVay+PvObs5U5OLatI0DxvYIwNVm4BdQGIdMhxSkauJ8K1i7FOjvSdwB2A+/WJnXpEJdEGwjvTk0W6HhTW8WldgzKDedVF2Ug2tLn7svz3DDpTFdxWr93C/u7wbVKWyoDhVM/8XZAOPOXvcm+IyXxGcizeaUca0XJ1D0CfQnlEysE2VwbuII0br4gvdCMF37m9IoC39+oxTO2EpS8oZJdtRS0aIKY5/sCQoyLVEMMki6Ghl0BGN9SeuICkPIctXDHDDSB9oGEQi1yZWUAda8EZnIcR/eIOOVao+9TrbkpYFjLmkkHk0KYSGvdt12/e71cP6Hs2c4OJBemtsYusplVX+GLHQ7DKkQ098/ZF38dLEpRCeNUMlMW90BIseeQkWtuu2qKmIyDHCuqFuo1N11Ud/1Cf6CHb7Sfxld2ATklQoUGEDActfZ5326WU74G/HcDv8BVBLAwQKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAcAENvbnRlbnRzL1BrZ0luZm9VVAkAA82cSVYqkRBXdXgLAAEE9QEAAAQUAAAAQVBQTGFwbHRQSwMECgAAAAAAm3lwRwAAAAAAAAAAAAAAABMAHABDb250ZW50cy9SZXNvdXJjZXMvVVQJAANW1klWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACAeXBHfrnysfYGAAAf3AAAHgAcAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUCQADH9ZJVnGlD1d1eAsAAQT1AQAABBQAAADt3Xk81Hkcx/Hvb5yVo5bGsVlKbcpRRqFlGZGS5JikRBIdI0OZttMZloqiYwrVjD1UqJaUokTRubG72bZVjqR1VZNjp2XEGo9H+9gt+9h/9tHx8H7N4/fw5MHjYeaPz+P7+P7x/bL9griEPNBm+001J0S+ZbvL/NmKwzWHE0IUHebYuRFCEckjL9v/xSvk2EpCpBXZtrYuDra2Oi4hwSvZgSsIMU9MdPdePcZd1aqQu0p3fDkrcFrs+mPWihMU9y6clp5XEFFdbRrEczCtGtfkL3pWfvBGublJ4ct051kuocYtaaqll/IjdfR+V75vlTdl//AJVZU6elZ5f0S7NO3MaE2xMElhF+TUrHgW2nFYeGTrs/OrhDJN5zMX8ZJVKXrqSUM1Rj03bnf85/pJMXECNdl0D1ctfe/j82imziM2nllSa3t5q8+vP1f38k/k22uN1lmnvfz0b8dGxO+mnh91v7WB2tKdrG3d4vmJaHlTvjGzdMqWcw/9frnCtQpPZK9sMKi/Ey/jzgqIPzBy9/dlf9griI2/u+sjcApozWx6/NXytC+qBTlrhb69fE7J6tgOzpWjFSl8qxihr5dYf/qExoeupY6Ze/j2PfL1azhhZ8fU3eelJY+ylk16UJN6KmOU0M4r+75cZhH/mxNndowNb4wx7TCoN4yvMGu8ySq5l5W5t+xQyYbS/Ome7e0W0sXbC5aktl0LEXNYR9obH7dMT721dbNdT/eFzXNEYSH8GU+bQ5s6YniGcj3fHtgXPbo0Oj4i3d5G1Fjfm/Ng7kgpjQDNxw4RRnu+Vloy5ZE3J6OpwlFBzaxS25He2h3lJuizO70zJPLUYtks14RE5yrD8y2tXa5l5Wqh/NBY06yoiCLF08Nk9A5Ojbs43GmR1Ch/PaZsLf3e6uPRSrIM1ROqGjt80leqfdxYbNn+WV7K7ZKiy/t6r1/3ie46V5432T/Oahs9V7NnVzb9zoq2rFgvPxXrcAMzmvWnGjof/RpdsZThIEpex6DGbd5h6STaOyZXxV/YfW9u4KyllmZ3X15IMHHLSJtVPSOvULCsz2TyPC/WL9kGSme/1L01SSzjfbHnqk+OV7OBmevZeo3DBR7lXT5drT0MkX5PwDd1EQ0ebfkh1zy/L8ydd+VJ4CLuRndNjuwj+vMfU8q2l2l1rGtr8FC2D+fdSGk81eltuTjYSMk++4BMd0DXQo35iXbZndGdcXkGFyeG6b28evF22M2w22HlYSXetGSLW4cfFT00WqvN9bkqCujQ9KzdSt+snr+qmbcme+5Y3cDRn9BDLps+dPVltE9UkPeb6XovineiVUznTznyuZaSn/ZvR8VeRUYLqe3iHFqnU6+7+4LmtfsmaS0MdjIvslFJGG/rn7DPdMGLcx4d6eP2Oz92Y49kWbBUjudU2ijHnc7YIODQxD1aPx8PynVr+cmvJoy2+M5nQa2Kt0dvdPxp73LNU6aTeaktTfHH1L+8Pm/XalZcFcfzYxlhTefuzjRGobLKEqPZh8QKxUXWbU/ERvW78ghvTGTUNd0g9YqbcjUy5h0xVbn3S7SS54SOqKt88UR0qZuxKfxlZfODUm52o2HkGTOLw5dqhevvWjH7ssiqxAhKwA91d1nWG9w/GJIc7GwWbKKe/mAsGRqXBb87P10jH8/0LY6kpGQV1KcuAwAAeCt4LiVFWRJKs4DJ6p9GxGHWfLuTM5dt61/pzCCE7vLmSodGJM/ASqdzU2U3VjpY6WClg5XOICudUaI3VjocuWCsdAAAAAAAAAAAAAAAAD5o1Gmr054TSoqWxPvnfrLxVEIc29/cT5YmkmdgPzlCSz8a+8nYT8Z+MvaTB9lPZpJX+8lRktFyRdDF0m6IdcF2MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8ddD8G5oJkUuQnAXwnvxLAAAAADDkEFURRckVE6rIv+Tb1078MiZEetubJ34RHckzcOIXd8uWTpz4hRO/cOIXTvwa5MQvoidZ5S8a9h8nfl1QVhipQ6jyyWeuvTaBGP3D5fwgE4gpeQYmUCZ7XQ0mECYQJhAm0GATyOfVmYOU4sAdNi+cOUpm/9cdNv2Di8kkFN3mYOtrg8sE14xicGFwYXDhmlEAAD5w/Os1o8bTcM0oVjpY6WClg2tGAQAAAAAAAAAAAAAAgL/wb9eMBpow+r817yN/fwnJf33P5g78nWofEZNXD3u95GdSkh3o135/aL2i3vl/gHf/7t59oDlnDSHS8gQhNGQL8uWs6P+iwPYLDuIOzARqyM+E9QOfA3PIfw4IIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhND70J9QSwMEFAAAAAgA7VhwR/dYplZAAAAAagEAAB4AHABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAkAA82cSVZTpQ9XdXgLAAEE9QEAAAQUAAAAY2BgZGBgYFQBEiDsxjDygJQDPlkmEIEaRpJAQg8kLAMML8bi5OIqIFuouKA4A0jLMTD8/w+S5AdrB7PlBIAEAFBLAwQKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1VUCQADzZxJVi2REFd1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAHABDb250ZW50cy9SZXNvdXJjZXMvZGVzY3JpcHRpb24ucnRmZC9UWFQucnRmVVQJAAPNnElWU6UPV3V4CwABBPUBAAAEFAAAACWJOw6AIBAFe08DCBVX2QbWhZgQ1vCpCHcXtHkzkzegtCDB5Xp/g0+UyihARnb70kL/UbvffYpjQODcmk9zKXListxCoUsZA7EQ5S0+dVq085gvUEsDBAoAAAAAAIeBjkgAAAAAAAAAAAAAAAAbABwAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQJAAM9pQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACAAJgI5ICl5liTUBAADMAQAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUCQADcaIPV1OlD1d1eAsAAQT1AQAABBQAAAB9UMtOAkEQrNldd9dhH3Dz6NGYiPIJHjTxLCZeF9iDcXEJC0RvfoI/4sEfIvoHPEQEhbIHvOok01U16emu7vOkaF2dXu7XqrUTcyMATkxCwYKthCAUbmciAQ8O11yFcGBfbF/4jR24WmCvWjwUeXqfNutn13XyEeYYHkqKam+kghdJGfUCvwIfB6jiGAX6aCHHETroCrYFe6IKNEXfGOXChc0v7HKpBRzdSFrtELvbumKVC80F/FIjzwe9bj91uZRuXJuwAiLjNi7DlsxPaJSUAMrCFOeac3GfpINennQ6d/0sA4z7JxzKiVCCV+YHAs74LuuIONUi//4RIoC63czrIbYQS3PFicWJcTMTv1JHmocmROLJ45gjzfHvXJqjf7ZZ4RT+61uaBbDipGh2ZanBcjh8/gFQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAACQAYAAAAAAAAABAA7UEAAAAAQ29udGVudHMvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAoHlwR5R2hqihAQAAvgMAABMAGAAAAAAAAQAAAKSBQwAAAENvbnRlbnRzL0luZm8ucGxpc3RVVAUAA1zWSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAAB0gY5IAAAAAAAAAAAAAAAADwAYAAAAAAAAABAA7UExAgAAQ29udGVudHMvTWFjT1MvVVQFAAMbpQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAVRwXR+w5OCkyCAAAyGEAABUAGAAAAAAAAAAAAO2BegIAAENvbnRlbnRzL01hY09TL2FwcGxldFVUBQADMiPZVXV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABgAAAAAAAEAAADtgfsKAABDb250ZW50cy9NYWNPUy9zdWRvLXByb21wdC1zY3JpcHRVVAUAA4mQEFd1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAYAAAAAAABAAAApIHTDAAAQ29udGVudHMvUGtnSW5mb1VUBQADzZxJVnV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAJt5cEcAAAAAAAAAAAAAAAATABgAAAAAAAAAEADtQSUNAABDb250ZW50cy9SZXNvdXJjZXMvVVQFAANW1klWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAgHlwR3658rH2BgAAH9wAAB4AGAAAAAAAAAAAAKSBcg0AAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUBQADH9ZJVnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAO1YcEf3WKZWQAAAAGoBAAAeABgAAAAAAAAAAACkgcAUAABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAYAAAAAAAAABAA7UFYFQAAQ29udGVudHMvUmVzb3VyY2VzL2Rlc2NyaXB0aW9uLnJ0ZmQvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAGAAAAAAAAQAAAKSBthUAAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1RYVC5ydGZVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACHgY5IAAAAAAAAAAAAAAAAGwAYAAAAAAAAABAA7UFuFgAAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQFAAM9pQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgACYCOSApeZYk1AQAAzAEAACQAGAAAAAAAAAAAAKSBwxYAAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUBQADcaIPV3V4CwABBPUBAAAEFAAAAFBLBQYAAAAADQANANwEAABWGAAAAAA=';

var PERMISSION_DENIED = 'User did not grant permission.';
var NO_POLKIT_AGENT = 'No polkit authentication agent found.';

// See issue 66:
var MAX_BUFFER = 134217728;


/***/ }),

/***/ "../../node_modules/supports-color/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/supports-color/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "../../node_modules/supports-color/node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if ('GITHUB_ACTIONS' in env) {
		return 1;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "../../node_modules/supports-color/node_modules/has-flag/index.js":
/*!************************************************************************!*\
  !*** ../../node_modules/supports-color/node_modules/has-flag/index.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "../../node_modules/typedarray-to-buffer/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/typedarray-to-buffer/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = (__webpack_require__(/*! is-typedarray */ "../../node_modules/is-typedarray/index.js").strict)

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}


/***/ }),

/***/ "../../node_modules/universalify/index.js":
/*!************************************************!*\
  !*** ../../node_modules/universalify/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res)
        }
        arguments.length++
        fn.apply(this, arguments)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else fn.apply(this, arguments).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}


/***/ }),

/***/ "../../node_modules/utf-8-validate/fallback.js":
/*!*****************************************************!*\
  !*** ../../node_modules/utf-8-validate/fallback.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0  // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;


/***/ }),

/***/ "../../node_modules/utf-8-validate/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/utf-8-validate/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "../../node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "../../node_modules/utf-8-validate/fallback.js");
}


/***/ }),

/***/ "../../node_modules/uuid/index.js":
/*!****************************************!*\
  !*** ../../node_modules/uuid/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var v1 = __webpack_require__(/*! ./v1 */ "../../node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "../../node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "../../node_modules/uuid/lib/bytesToUuid.js":
/*!**************************************************!*\
  !*** ../../node_modules/uuid/lib/bytesToUuid.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../../node_modules/uuid/lib/rng.js":
/*!******************************************!*\
  !*** ../../node_modules/uuid/lib/rng.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "../../node_modules/uuid/v1.js":
/*!*************************************!*\
  !*** ../../node_modules/uuid/v1.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../../node_modules/uuid/v4.js":
/*!*************************************!*\
  !*** ../../node_modules/uuid/v4.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../../node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../../node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/cancellation.js":
/*!*************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/cancellation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/is.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this._emitter = undefined;
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        this.cancel();
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/events.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/events.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
Emitter._noop = function () { };
exports.Emitter = Emitter;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/is.js":
/*!***************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/is.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/linkedMap.js":
/*!**********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/linkedMap.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/main.js":
/*!*****************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/main.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="./thenable.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../../node_modules/vscode-jsonrpc/lib/messages.js");
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../../node_modules/vscode-jsonrpc/lib/messageReader.js");
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../../node_modules/vscode-jsonrpc/lib/messageWriter.js");
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/events.js");
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../../node_modules/vscode-jsonrpc/lib/cancellation.js");
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../../node_modules/vscode-jsonrpc/lib/linkedMap.js");
__export(__webpack_require__(/*! ./pipeSupport */ "../../node_modules/vscode-jsonrpc/lib/pipeSupport.js"));
__export(__webpack_require__(/*! ./socketSupport */ "../../node_modules/vscode-jsonrpc/lib/socketSupport.js"));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    ;
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            console.log("inspect");
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/messageReader.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/messageReader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/is.js");
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't recevied the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/messageWriter.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/messageWriter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! ./events */ "../../node_modules/vscode-jsonrpc/lib/events.js");
const Is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/is.js");
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/messages.js":
/*!*********************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/messages.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is = __webpack_require__(/*! ./is */ "../../node_modules/vscode-jsonrpc/lib/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/pipeSupport.js":
/*!************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/pipeSupport.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __webpack_require__(/*! path */ "path");
const os_1 = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../../node_modules/vscode-jsonrpc/lib/messageReader.js");
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../../node_modules/vscode-jsonrpc/lib/messageWriter.js");
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),

/***/ "../../node_modules/vscode-jsonrpc/lib/socketSupport.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vscode-jsonrpc/lib/socketSupport.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __webpack_require__(/*! net */ "net");
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../../node_modules/vscode-jsonrpc/lib/messageReader.js");
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../../node_modules/vscode-jsonrpc/lib/messageWriter.js");
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const port_forwarder_1 = __webpack_require__(/*! @vs/port-forwarder */ "../dist/src/index.js");
const vso_workspace_hub_util_1 = __webpack_require__(/*! @vs/vso-workspace-hub-util */ "../../workspace/hub-util/dist/src/index.js");
const argv = (0, vso_workspace_hub_util_1.getServerArgOptions)()
    .option('workspaceId', {
    description: 'Workspace Id',
    alias: 'w',
    type: 'string'
})
    .argv;
class PortAgentServer {
    constructor(traceSource) {
        if (!argv.workspaceId) {
            traceSource.error(`workspace id needs to be defined`);
            process.exit(2);
        }
        const connectionHub = (0, port_forwarder_1.initWorkspaceHubConnectionHub)(traceSource);
        this.sudoPortForwarderService = new port_forwarder_1.SudoPortForwarderService(traceSource, argv.workspaceId, connectionHub);
    }
    accept(socket) {
        const messageReader = new rpc.StreamMessageReader(socket);
        const messageWriter = new rpc.StreamMessageWriter(socket);
        const rpcConnection = this.sudoPortForwarderService.acceptStream({
            reader: messageReader,
            writer: messageWriter
        });
        return Promise.resolve(rpcConnection);
    }
    dispose() {
        return this.sudoPortForwarderService.disconnectAsync();
    }
}
const options = Object.assign({
    name: 'port-forwarder',
    processName: 'CodespacePortForwarder',
    logTmpDirectory: port_forwarder_1.LOGS_DIRECTORY,
    isAdmin: true,
}, (0, vso_workspace_hub_util_1.getServerArgOptions)().argv);
(0, vso_workspace_hub_util_1.startServer)(options, (keepAliveCallback, traceSource) => new PortAgentServer(traceSource))
    .then((traceSource) => {
    traceSource.info('succeeded..');
})
    .catch(err => {
    // Deal with the fact the chain failed
    console.error(`failed err:${err}`);
});


/***/ }),

/***/ "../../node_modules/webidl-conversions/lib/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/webidl-conversions/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function makeException(ErrorType, message, opts = {}) {
    if (opts.globals) {
        ErrorType = opts.globals[ErrorType.name];
    }
    return new ErrorType(`${opts.context ? opts.context : "Value"} ${message}.`);
}

function toNumber(value, opts = {}) {
    if (!opts.globals) {
        return +value;
    }
    if (typeof value === "bigint") {
        throw opts.globals.TypeError("Cannot convert a BigInt value to a number");
    }
    return opts.globals.Number(value);
}

function type(V) {
    if (V === null) {
        return "Null";
    }
    switch (typeof V) {
        case "undefined":
            return "Undefined";
        case "boolean":
            return "Boolean";
        case "number":
            return "Number";
        case "string":
            return "String";
        case "symbol":
            return "Symbol";
        case "bigint":
            return "BigInt";
        case "object":
            // Falls through
        case "function":
            // Falls through
        default:
            // Per ES spec, typeof returns an implemention-defined value that is not any of the existing ones for
            // uncallable non-standard exotic objects. Yet Type() which the Web IDL spec depends on returns Object for
            // such cases. So treat the default case as an object.
            return "Object";
    }
}

// Round x to the nearest integer, choosing the even integer if it lies halfway between two.
function evenRound(x) {
    // There are four cases for numbers with fractional part being .5:
    //
    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example
    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0
    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2
    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0
    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2
    // (where n is a non-negative integer)
    //
    // Branch here for cases 1 and 4
    if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||
        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {
        return censorNegativeZero(Math.floor(x));
    }

    return censorNegativeZero(Math.round(x));
}

function integerPart(n) {
    return censorNegativeZero(Math.trunc(n));
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

function modulo(x, y) {
    // https://tc39.github.io/ecma262/#eqn-modulo
    // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos
    const signMightNotMatch = x % y;
    if (sign(y) !== sign(signMightNotMatch)) {
        return signMightNotMatch + y;
    }
    return signMightNotMatch;
}

function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
}

function createIntegerConversion(bitLength, typeOpts) {
    const isSigned = !typeOpts.unsigned;

    let lowerBound;
    let upperBound;
    if (bitLength === 64) {
        upperBound = Number.MAX_SAFE_INTEGER;
        lowerBound = !isSigned ? 0 : Number.MIN_SAFE_INTEGER;
    } else if (!isSigned) {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
    } else {
        lowerBound = -Math.pow(2, bitLength - 1);
        upperBound = Math.pow(2, bitLength - 1) - 1;
    }

    const twoToTheBitLength = Math.pow(2, bitLength);
    const twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);

    return (V, opts = {}) => {
        let x = toNumber(V, opts);
        x = censorNegativeZero(x);

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw makeException(TypeError, "is not a finite number", opts);
            }

            x = integerPart(x);

            if (x < lowerBound || x > upperBound) {
                throw makeException(TypeError,
                    `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, opts);
            }

            return x;
        }

        if (!Number.isNaN(x) && opts.clamp) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            x = evenRound(x);
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }
        x = integerPart(x);

        // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if
        // possible. Hopefully it's an optimization for the non-64-bitLength cases too.
        if (x >= lowerBound && x <= upperBound) {
            return x;
        }

        // These will not work great for bitLength of 64, but oh well. See the README for more details.
        x = modulo(x, twoToTheBitLength);
        if (isSigned && x >= twoToOneLessThanTheBitLength) {
            return x - twoToTheBitLength;
        }
        return x;
    };
}

function createLongLongConversion(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;

    return (V, opts = {}) => {
        if (opts === undefined) {
            opts = {};
        }

        let x = toNumber(V, opts);
        x = censorNegativeZero(x);

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw makeException(TypeError, "is not a finite number", opts);
            }

            x = integerPart(x);

            if (x < lowerBound || x > upperBound) {
                throw makeException(TypeError,
                    `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, opts);
            }

            return x;
        }

        if (!Number.isNaN(x) && opts.clamp) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            x = evenRound(x);
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }

        let xBigInt = BigInt(integerPart(x));
        xBigInt = asBigIntN(bitLength, xBigInt);
        return Number(xBigInt);
    };
}

exports.any = V => {
    return V;
};

exports["void"] = function () {
    return undefined;
};

exports.boolean = function (val) {
    return !!val;
};

exports.byte = createIntegerConversion(8, { unsigned: false });
exports.octet = createIntegerConversion(8, { unsigned: true });

exports.short = createIntegerConversion(16, { unsigned: false });
exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });

exports.long = createIntegerConversion(32, { unsigned: false });
exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });

exports["long long"] = createLongLongConversion(64, { unsigned: false });
exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });

exports.double = (V, opts) => {
    const x = toNumber(V, opts);

    if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", opts);
    }

    return x;
};

exports["unrestricted double"] = (V, opts) => {
    const x = toNumber(V, opts);

    return x;
};

exports.float = (V, opts) => {
    const x = toNumber(V, opts);

    if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", opts);
    }

    if (Object.is(x, -0)) {
        return x;
    }

    const y = Math.fround(x);

    if (!Number.isFinite(y)) {
        throw makeException(TypeError, "is outside the range of a single-precision floating-point value", opts);
    }

    return y;
};

exports["unrestricted float"] = (V, opts) => {
    const x = toNumber(V, opts);

    if (isNaN(x)) {
        return x;
    }

    if (Object.is(x, -0)) {
        return x;
    }

    return Math.fround(x);
};

exports.DOMString = function (V, opts = {}) {
    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }

    if (typeof V === "symbol") {
        throw makeException(TypeError, "is a symbol, which cannot be converted to a string", opts);
    }

    const StringCtor = opts.globals ? opts.globals.String : String;
    return StringCtor(V);
};

exports.ByteString = (V, opts) => {
    const x = exports.DOMString(V, opts);
    let c;
    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
        if (c > 255) {
            throw makeException(TypeError, "is not a valid ByteString", opts);
        }
    }

    return x;
};

exports.USVString = (V, opts) => {
    const S = exports.DOMString(V, opts);
    const n = S.length;
    const U = [];
    for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else if (i === n - 1) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            const d = S.charCodeAt(i + 1);
            if (0xDC00 <= d && d <= 0xDFFF) {
                const a = c & 0x3FF;
                const b = d & 0x3FF;
                U.push(String.fromCodePoint((2 << 15) + ((2 << 9) * a) + b));
                ++i;
            } else {
                U.push(String.fromCodePoint(0xFFFD));
            }
        }
    }

    return U.join("");
};

exports.object = (V, opts) => {
    if (type(V) !== "Object") {
        throw makeException(TypeError, "is not an object", opts);
    }

    return V;
};

// Not exported, but used in Function and VoidFunction.

// Neither Function nor VoidFunction is defined with [TreatNonObjectAsNull], so
// handling for that is omitted.
function convertCallbackFunction(V, opts) {
    if (typeof V !== "function") {
        throw makeException(TypeError, "is not a function", opts);
    }
    return V;
}

const abByteLengthGetter =
    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
const sabByteLengthGetter =
    Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get;

function isNonSharedArrayBuffer(V) {
    try {
        // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.
        // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)
        abByteLengthGetter.call(V);

        return true;
    } catch {
        return false;
    }
}

function isSharedArrayBuffer(V) {
    try {
        sabByteLengthGetter.call(V);
        return true;
    } catch {
        return false;
    }
}

function isArrayBufferDetached(V) {
    try {
        // eslint-disable-next-line no-new
        new Uint8Array(V);
        return false;
    } catch {
        return true;
    }
}

exports.ArrayBuffer = (V, opts = {}) => {
    if (!isNonSharedArrayBuffer(V)) {
        if (opts.allowShared && !isSharedArrayBuffer(V)) {
            throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", opts);
        }
        throw makeException(TypeError, "is not an ArrayBuffer", opts);
    }
    if (isArrayBufferDetached(V)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", opts);
    }

    return V;
};

const dvByteLengthGetter =
    Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
exports.DataView = (V, opts = {}) => {
    try {
        dvByteLengthGetter.call(V);
    } catch (e) {
        throw makeException(TypeError, "is not a DataView", opts);
    }

    if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {
        throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", opts);
    }
    if (isArrayBufferDetached(V.buffer)) {
        throw makeException(TypeError, "is backed by a detached ArrayBuffer", opts);
    }

    return V;
};

// Returns the unforgeable `TypedArray` constructor name or `undefined`,
// if the `this` value isn't a valid `TypedArray` object.
//
// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag
const typedArrayNameGetter = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(Uint8Array).prototype,
    Symbol.toStringTag
).get;
[
    Int8Array, Int16Array, Int32Array, Uint8Array,
    Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array
].forEach(func => {
    const name = func.name;
    const article = /^[AEIOU]/.test(name) ? "an" : "a";
    exports[name] = (V, opts = {}) => {
        if (!ArrayBuffer.isView(V) || typedArrayNameGetter.call(V) !== name) {
            throw makeException(TypeError, `is not ${article} ${name} object`, opts);
        }
        if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {
            throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", opts);
        }
        if (isArrayBufferDetached(V.buffer)) {
            throw makeException(TypeError, "is a view on a detached ArrayBuffer", opts);
        }

        return V;
    };
});

// Common definitions

exports.ArrayBufferView = (V, opts = {}) => {
    if (!ArrayBuffer.isView(V)) {
        throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", opts);
    }

    if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", opts);
    }

    if (isArrayBufferDetached(V.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", opts);
    }
    return V;
};

exports.BufferSource = (V, opts = {}) => {
    if (ArrayBuffer.isView(V)) {
        if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {
            throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", opts);
        }

        if (isArrayBufferDetached(V.buffer)) {
            throw makeException(TypeError, "is a view on a detached ArrayBuffer", opts);
        }
        return V;
    }

    if (!opts.allowShared && !isNonSharedArrayBuffer(V)) {
        throw makeException(TypeError, "is not an ArrayBuffer or a view on one", opts);
    }
    if (opts.allowShared && !isSharedArrayBuffer(V) && !isNonSharedArrayBuffer(V)) {
        throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBufer, or a view on one", opts);
    }
    if (isArrayBufferDetached(V)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", opts);
    }

    return V;
};

exports.DOMTimeStamp = exports["unsigned long long"];

exports.Function = convertCallbackFunction;

exports.VoidFunction = convertCallbackFunction;


/***/ }),

/***/ "../../node_modules/websocket/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/websocket/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/websocket */ "../../node_modules/websocket/lib/websocket.js");

/***/ }),

/***/ "../../node_modules/websocket/lib/Deprecation.js":
/*!*******************************************************!*\
  !*** ../../node_modules/websocket/lib/Deprecation.js ***!
  \*******************************************************/
/***/ ((module) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var Deprecation = {
    disableWarnings: false,

    deprecationWarningMap: {

    },

    warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);
            this.deprecationWarningMap[deprecationName] = false;
        }
    }
};

module.exports = Deprecation;


/***/ }),

/***/ "../../node_modules/websocket/lib/W3CWebSocket.js":
/*!********************************************************!*\
  !*** ../../node_modules/websocket/lib/W3CWebSocket.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ "../../node_modules/websocket/lib/WebSocketClient.js");
var toBuffer = __webpack_require__(/*! typedarray-to-buffer */ "../../node_modules/typedarray-to-buffer/index.js");
var yaeti = __webpack_require__(/*! yaeti */ "../../node_modules/yaeti/index.js");


const CONNECTING = 0;
const OPEN = 1;
const CLOSING = 2;
const CLOSED = 3;


module.exports = W3CWebSocket;


function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
    // Make this an EventTarget.
    yaeti.EventTarget.call(this);

    // Sanitize clientConfig.
    clientConfig = clientConfig || {};
    clientConfig.assembleFragments = true;  // Required in the W3C API.

    var self = this;

    this._url = url;
    this._readyState = CONNECTING;
    this._protocol = undefined;
    this._extensions = '';
    this._bufferedAmount = 0;  // Hack, always 0.
    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.

    // The WebSocketConnection instance.
    this._connection = undefined;

    // WebSocketClient instance.
    this._client = new WebSocketClient(clientConfig);

    this._client.on('connect', function(connection) {
        onConnect.call(self, connection);
    });

    this._client.on('connectFailed', function() {
        onConnectFailed.call(self);
    });

    this._client.connect(url, protocols, origin, headers, requestOptions);
}


// Expose W3C read only attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    url:            { get: function() { return this._url;            } },
    readyState:     { get: function() { return this._readyState;     } },
    protocol:       { get: function() { return this._protocol;       } },
    extensions:     { get: function() { return this._extensions;     } },
    bufferedAmount: { get: function() { return this._bufferedAmount; } }
});


// Expose W3C write/read attributes.
Object.defineProperties(W3CWebSocket.prototype, {
    binaryType: {
        get: function() {
            return this._binaryType;
        },
        set: function(type) {
            // TODO: Just 'arraybuffer' supported.
            if (type !== 'arraybuffer') {
                throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
            }
            this._binaryType = type;
        }
    }
});


// Expose W3C readyState constants into the WebSocket instance as W3C states.
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() { return property[1]; }
    });
});

// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,
// but there are so many libs relying on them).
[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {
    Object.defineProperty(W3CWebSocket, property[0], {
        get: function() { return property[1]; }
    });
});


W3CWebSocket.prototype.send = function(data) {
    if (this._readyState !== OPEN) {
        throw new Error('cannot call send() while not connected');
    }

    // Text.
    if (typeof data === 'string' || data instanceof String) {
        this._connection.sendUTF(data);
    }
    // Binary.
    else {
        // Node Buffer.
        if (data instanceof Buffer) {
            this._connection.sendBytes(data);
        }
        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.
        else if (data.byteLength || data.byteLength === 0) {
            data = toBuffer(data);
            this._connection.sendBytes(data);
        }
        else {
            throw new Error('unknown binary data:', data);
        }
    }
};


W3CWebSocket.prototype.close = function(code, reason) {
    switch(this._readyState) {
        case CONNECTING:
            // NOTE: We don't have the WebSocketConnection instance yet so no
            // way to close the TCP connection.
            // Artificially invoke the onConnectFailed event.
            onConnectFailed.call(this);
            // And close if it connects after a while.
            this._client.on('connect', function(connection) {
                if (code) {
                    connection.close(code, reason);
                } else {
                    connection.close();
                }
            });
            break;
        case OPEN:
            this._readyState = CLOSING;
            if (code) {
                this._connection.close(code, reason);
            } else {
                this._connection.close();
            }
            break;
        case CLOSING:
        case CLOSED:
            break;
    }
};


/**
 * Private API.
 */


function createCloseEvent(code, reason) {
    var event = new yaeti.Event('close');

    event.code = code;
    event.reason = reason;
    event.wasClean = (typeof code === 'undefined' || code === 1000);

    return event;
}


function createMessageEvent(data) {
    var event = new yaeti.Event('message');

    event.data = data;

    return event;
}


function onConnect(connection) {
    var self = this;

    this._readyState = OPEN;
    this._connection = connection;
    this._protocol = connection.protocol;
    this._extensions = connection.extensions;

    this._connection.on('close', function(code, reason) {
        onClose.call(self, code, reason);
    });

    this._connection.on('message', function(msg) {
        onMessage.call(self, msg);
    });

    this.dispatchEvent(new yaeti.Event('open'));
}


function onConnectFailed() {
    destroy.call(this);
    this._readyState = CLOSED;

    try {
        this.dispatchEvent(new yaeti.Event('error'));
    } finally {
        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));
    }
}


function onClose(code, reason) {
    destroy.call(this);
    this._readyState = CLOSED;

    this.dispatchEvent(createCloseEvent(code, reason || ''));
}


function onMessage(message) {
    if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
    }
    else if (message.binaryData) {
        // Must convert from Node Buffer to ArrayBuffer.
        // TODO: or to a Blob (which does not exist in Node!).
        if (this.binaryType === 'arraybuffer') {
            var buffer = message.binaryData;
            var arraybuffer = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(arraybuffer);
            for (var i=0, len=buffer.length; i<len; ++i) {
                view[i] = buffer[i];
            }
            this.dispatchEvent(createMessageEvent(arraybuffer));
        }
    }
}


function destroy() {
    this._client.removeAllListeners();
    if (this._connection) {
        this._connection.removeAllListeners();
    }
}


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketClient.js":
/*!***********************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketClient.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var utils = __webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js");
var extend = utils.extend;
var util = __webpack_require__(/*! util */ "util");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var url = __webpack_require__(/*! url */ "url");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ "../../node_modules/websocket/lib/WebSocketConnection.js");
var bufferAllocUnsafe = utils.bufferAllocUnsafe;

var protocolSeparators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];

var excludedTlsOptions = ['hostname','port','method','path','headers'];

function WebSocketClient(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    // TODO: Implement extensions

    this.config = {
        // 1MiB max frame size.
        maxReceivedFrameSize: 0x100000,

        // 8MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x800000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // Which version of the protocol to use for this session.  This
        // option will be removed once the protocol is finalized by the IETF
        // It is only available to ease the transition through the
        // intermediate draft protocol versions.
        // At present, it only affects the name of the Origin header.
        webSocketVersion: 13,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000,

        // Options to pass to https.connect if connecting via TLS
        tlsOptions: {}
    };

    if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        }
        else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
    }

    this._req = null;
    
    switch (this.config.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');
    }
}

util.inherits(WebSocketClient, EventEmitter);

WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
    var self = this;
    
    if (typeof(protocols) === 'string') {
        if (protocols.length > 0) {
            protocols = [protocols];
        }
        else {
            protocols = [];
        }
    }
    if (!(protocols instanceof Array)) {
        protocols = [];
    }
    this.protocols = protocols;
    this.origin = origin;

    if (typeof(requestUrl) === 'string') {
        this.url = url.parse(requestUrl);
    }
    else {
        this.url = requestUrl; // in case an already parsed url is passed in.
    }
    if (!this.url.protocol) {
        throw new Error('You must specify a full WebSocket URL, including protocol.');
    }
    if (!this.url.host) {
        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');
    }

    this.secure = (this.url.protocol === 'wss:');

    // validate protocol characters:
    this.protocols.forEach(function(protocol) {
        for (var i=0; i < protocol.length; i ++) {
            var charCode = protocol.charCodeAt(i);
            var character = protocol.charAt(i);
            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {
                throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
            }
        }
    });

    var defaultPorts = {
        'ws:': '80',
        'wss:': '443'
    };

    if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
    }

    var nonce = bufferAllocUnsafe(16);
    for (var i=0; i < 16; i++) {
        nonce[i] = Math.round(Math.random()*0xFF);
    }
    this.base64nonce = nonce.toString('base64');

    var hostHeaderValue = this.url.hostname;
    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||
        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {
        hostHeaderValue += (':' + this.url.port);
    }

    var reqHeaders = {};
    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {
      // Allow for additional headers to be provided when connecting via HTTPS
      extend(reqHeaders, this.config.tlsOptions.headers);
    }
    if (headers) {
      // Explicitly provided headers take priority over any from tlsOptions
      extend(reqHeaders, headers);
    }
    extend(reqHeaders, {
        'Upgrade': 'websocket',
        'Connection': 'Upgrade',
        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),
        'Sec-WebSocket-Key': this.base64nonce,
        'Host': reqHeaders.Host || hostHeaderValue
    });

    if (this.protocols.length > 0) {
        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');
    }
    if (this.origin) {
        if (this.config.webSocketVersion === 13) {
            reqHeaders['Origin'] = this.origin;
        }
        else if (this.config.webSocketVersion === 8) {
            reqHeaders['Sec-WebSocket-Origin'] = this.origin;
        }
    }

    // TODO: Implement extensions

    var pathAndQuery;
    // Ensure it begins with '/'.
    if (this.url.pathname) {
        pathAndQuery = this.url.path;
    }
    else if (this.url.path) {
        pathAndQuery = '/' + this.url.path;
    }
    else {
        pathAndQuery = '/';
    }

    function handleRequestError(error) {
        self._req = null;
        self.emit('connectFailed', error);
    }

    var requestOptions = {
        agent: false
    };
    if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
    }
    // These options are always overridden by the library.  The user is not
    // allowed to specify these directly.
    extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: 'GET',
        path: pathAndQuery,
        headers: reqHeaders
    });
    if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
                requestOptions[key] = tlsOptions[key];
            }
        }
    }

    var req = this._req = (this.secure ? https : http).request(requestOptions);
    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {
        self._req = null;
        req.removeListener('error', handleRequestError);
        self.socket = socket;
        self.response = response;
        self.firstDataChunk = head;
        self.validateHandshake();
    });
    req.on('error', handleRequestError);

    req.on('response', function(response) {
        self._req = null;
        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {
            self.emit('httpResponse', response, self);
            if (response.socket) {
                response.socket.end();
            }
        }
        else {
            var headerDumpParts = [];
            for (var headerName in response.headers) {
                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);
            }
            self.failHandshake(
                'Server responded with a non-101 status: ' +
                response.statusCode + ' ' + response.statusMessage +
                '\nResponse Headers Follow:\n' +
                headerDumpParts.join('\n') + '\n'
            );
        }
    });
    req.end();
};

WebSocketClient.prototype.validateHandshake = function() {
    var headers = this.response.headers;

    if (this.protocols.length > 0) {
        this.protocol = headers['sec-websocket-protocol'];
        if (this.protocol) {
            if (this.protocols.indexOf(this.protocol) === -1) {
                this.failHandshake('Server did not respond with a requested protocol.');
                return;
            }
        }
        else {
            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');
            return;
        }
    }

    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {
        this.failHandshake('Expected a Connection: Upgrade header from the server');
        return;
    }

    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {
        this.failHandshake('Expected an Upgrade: websocket header from the server');
        return;
    }

    var sha1 = crypto.createHash('sha1');
    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var expectedKey = sha1.digest('base64');

    if (!headers['sec-websocket-accept']) {
        this.failHandshake('Expected Sec-WebSocket-Accept header from server');
        return;
    }

    if (headers['sec-websocket-accept'] !== expectedKey) {
        this.failHandshake('Sec-WebSocket-Accept header from server didn\'t match expected value of ' + expectedKey);
        return;
    }

    // TODO: Support extensions

    this.succeedHandshake();
};

WebSocketClient.prototype.failHandshake = function(errorDescription) {
    if (this.socket && this.socket.writable) {
        this.socket.end();
    }
    this.emit('connectFailed', new Error(errorDescription));
};

WebSocketClient.prototype.succeedHandshake = function() {
    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);

    connection.webSocketVersion = this.config.webSocketVersion;
    connection._addSocketEventListeners();

    this.emit('connect', connection);
    if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
    }
    this.firstDataChunk = null;
};

WebSocketClient.prototype.abort = function() {
    if (this._req) {
        this._req.abort();
    }
};

module.exports = WebSocketClient;


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketConnection.js":
/*!***************************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketConnection.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __webpack_require__(/*! util */ "util");
var utils = __webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ "../../node_modules/websocket/lib/WebSocketFrame.js");
var BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ "../../node_modules/websocket/vendor/FastBufferList.js");
var isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "../../node_modules/utf-8-validate/index.js");
var bufferAllocUnsafe = utils.bufferAllocUnsafe;
var bufferFromString = utils.bufferFromString;

// Connected, fully-open, ready to send and receive frames
const STATE_OPEN = 'open';
// Received a close frame from the remote peer
const STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';
// Sent close frame to remote peer.  No further data can be sent.
const STATE_ENDING = 'ending';
// Connection is fully closed.  No further data can be sent or received.
const STATE_CLOSED = 'closed';

var setImmediateImpl = ('setImmediate' in global) ?
                            global.setImmediate.bind(global) :
                            process.nextTick.bind(process);

var idCounter = 0;

function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);
    this._debug('constructor');
    
    if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
    }
    
    // Superclass Constructor
    EventEmitter.call(this);

    this._pingListenerCount = 0;
    this.on('newListener', function(ev) {
        if (ev === 'ping'){
            this._pingListenerCount++;
        }
      }).on('removeListener', function(ev) {
        if (ev === 'ping') {
            this._pingListenerCount--;
        }
    });

    this.config = config;
    this.socket = socket;
    this.protocol = protocol;
    this.extensions = extensions;
    this.remoteAddress = socket.remoteAddress;
    this.closeReasonCode = -1;
    this.closeDescription = null;
    this.closeEventEmitted = false;

    // We have to mask outgoing packets if we're acting as a WebSocket client.
    this.maskOutgoingPackets = maskOutgoingPackets;

    // We re-use the same buffers for the mask and frame header for all frames
    // received on each connection to avoid a small memory allocation for each
    // frame.
    this.maskBytes = bufferAllocUnsafe(4);
    this.frameHeader = bufferAllocUnsafe(10);

    // the BufferList will handle the data streaming in
    this.bufferList = new BufferList();

    // Prepare for receiving first frame
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    this.fragmentationSize = 0; // data received so far...
    this.frameQueue = [];
    
    // Various bits of connection state
    this.connected = true;
    this.state = STATE_OPEN;
    this.waitingForCloseResponse = false;
    // Received TCP FIN, socket's readable stream is finished.
    this.receivedEnd = false;

    this.closeTimeout = this.config.closeTimeout;
    this.assembleFragments = this.config.assembleFragments;
    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;

    this.outputBufferFull = false;
    this.inputPaused = false;
    this.receivedDataHandler = this.processReceivedData.bind(this);
    this._closeTimerHandler = this.handleCloseTimer.bind(this);

    // Disable nagle algorithm?
    this.socket.setNoDelay(this.config.disableNagleAlgorithm);

    // Make sure there is no socket inactivity timeout
    this.socket.setTimeout(0);

    if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof(this.config.keepaliveInterval) !== 'number') {
            throw new Error('keepaliveInterval must be specified and numeric ' +
                            'if keepalive is true.');
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();

        if (this.config.dropConnectionOnKeepaliveTimeout) {
            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {
                throw new Error('keepaliveGracePeriod  must be specified and ' +
                                'numeric if dropConnectionOnKeepaliveTimeout ' +
                                'is true.');
            }
            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
    }
    else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!('setKeepAlive' in this.socket)) {
            throw new Error('Unable to use native keepalive: unsupported by ' +
                            'this version of Node.');
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
    }
    
    // The HTTP Client seems to subscribe to socket error events
    // and re-dispatch them in such a way that doesn't make sense
    // for users of our client, so we want to make sure nobody
    // else is listening for error events on the socket besides us.
    this.socket.removeAllListeners('error');
}

WebSocketConnection.CLOSE_REASON_NORMAL = 1000;
WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
WebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.
WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire
WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire

WebSocketConnection.CLOSE_DESCRIPTIONS = {
    1000: 'Normal connection closure',
    1001: 'Remote peer is going away',
    1002: 'Protocol error',
    1003: 'Unprocessable input',
    1004: 'Reserved',
    1005: 'Reason not provided',
    1006: 'Abnormal closure, no further detail available',
    1007: 'Invalid data received',
    1008: 'Policy violation',
    1009: 'Message too big',
    1010: 'Extension requested by client is required',
    1011: 'Internal Server Error',
    1015: 'TLS Handshake Failed'
};

function validateCloseReason(code) {
    if (code < 1000) {
        // Status codes in the range 0-999 are not used
        return false;
    }
    if (code >= 1000 && code <= 2999) {
        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only
        // a few codes are defined, all others are currently illegal.
        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
    }
    if (code >= 3000 && code <= 3999) {
        // Reserved for use by libraries, frameworks, and applications.
        // Should be registered with IANA.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 4000 && code <= 4999) {
        // Reserved for private use.  Interpretation of these codes is
        // undefined by the WebSocket protocol.
        return true;
    }
    if (code >= 5000) {
        return false;
    }
}

util.inherits(WebSocketConnection, EventEmitter);

WebSocketConnection.prototype._addSocketEventListeners = function() {
    this.socket.on('error', this.handleSocketError.bind(this));
    this.socket.on('end', this.handleSocketEnd.bind(this));
    this.socket.on('close', this.handleSocketClose.bind(this));
    this.socket.on('drain', this.handleSocketDrain.bind(this));
    this.socket.on('pause', this.handleSocketPause.bind(this));
    this.socket.on('resume', this.handleSocketResume.bind(this));
    this.socket.on('data', this.handleSocketData.bind(this));
};

// set or reset the keepalive timer when data is received.
WebSocketConnection.prototype.setKeepaliveTimer = function() {
    this._debug('setKeepaliveTimer');
    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
};

WebSocketConnection.prototype.clearKeepaliveTimer = function() {
    if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
    }
};

// No data has been received within config.keepaliveTimeout ms.
WebSocketConnection.prototype.handleKeepaliveTimer = function() {
    this._debug('handleKeepaliveTimer');
    this._keepaliveTimeoutID = null;
    this.ping();

    // If we are configured to drop connections if the client doesn't respond
    // then set the grace period timer.
    if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
    }
    else {
        // Otherwise reset the keepalive timer to send the next ping.
        this.setKeepaliveTimer();
    }
};

WebSocketConnection.prototype.setGracePeriodTimer = function() {
    this._debug('setGracePeriodTimer');
    this.clearGracePeriodTimer();
    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
};

WebSocketConnection.prototype.clearGracePeriodTimer = function() {
    if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
    }
};

WebSocketConnection.prototype.handleGracePeriodTimer = function() {
    this._debug('handleGracePeriodTimer');
    // If this is called, the client has not responded and is assumed dead.
    this._gracePeriodTimeoutID = null;
    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);
};

WebSocketConnection.prototype.handleSocketData = function(data) {
    this._debug('handleSocketData');
    // Reset the keepalive timer when receiving data of any kind.
    this.setKeepaliveTimer();

    // Add received data to our bufferList, which efficiently holds received
    // data chunks in a linked list of Buffer objects.
    this.bufferList.write(data);

    this.processReceivedData();
};

WebSocketConnection.prototype.processReceivedData = function() {
    this._debug('processReceivedData');
    // If we're not connected, we should ignore any data remaining on the buffer.
    if (!this.connected) { return; }

    // Receiving/parsing is expected to be halted when paused.
    if (this.inputPaused) { return; }

    var frame = this.currentFrame;

    // WebSocketFrame.prototype.addData returns true if all data necessary to
    // parse the frame was available.  It returns false if we are waiting for
    // more data to come in on the wire.
    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }

    var self = this;

    // Handle possible parsing errors
    if (frame.protocolError) {
        // Something bad happened.. get rid of this client.
        this._debug('-- protocol error');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
    }
    else if (frame.frameTooLarge) {
        this._debug('-- frame too large');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
    }

    // For now since we don't support extensions, all RSV bits are illegal
    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug('-- illegal rsv flag');
        process.nextTick(function() {
            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unsupported usage of rsv bits without negotiated extension.');
        });
        return;
    }

    if (!this.assembleFragments) {
        this._debug('-- emitting frame');
        process.nextTick(function() { self.emit('frame', frame); });
    }

    process.nextTick(function() { self.processFrame(frame); });
    
    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);

    // If there's data remaining, schedule additional processing, but yield
    // for now so that other connections have a chance to have their data
    // processed.  We use setImmediate here instead of process.nextTick to
    // explicitly indicate that we wish for other I/O to be handled first.
    if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
    }
};

WebSocketConnection.prototype.handleSocketError = function(error) {
    this._debug('handleSocketError: %j', error);
    if (this.state === STATE_CLOSED) {
		// See https://github.com/theturtle32/WebSocket-Node/issues/288
        this._debug('  --- Socket \'error\' after \'close\'');
        return;
    }
    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;
    this.connected = false;
    this.state = STATE_CLOSED;
    this.fragmentationSize = 0;
    if (utils.eventEmitterListenerCount(this, 'error') > 0) {
        this.emit('error', error);
    }
    this.socket.destroy();
    this._debug.printOutput();
};

WebSocketConnection.prototype.handleSocketEnd = function() {
    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);
    this.receivedEnd = true;
    if (this.state === STATE_CLOSED) {
        // When using the TLS module, sometimes the socket will emit 'end'
        // after it emits 'close'.  I don't think that's correct behavior,
        // but we should deal with it gracefully by ignoring it.
        this._debug('  --- Socket \'end\' after \'close\'');
        return;
    }
    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&
        this.state !== STATE_ENDING) {
      this._debug('  --- UNEXPECTED socket end.');
      this.socket.end();
    }
};

WebSocketConnection.prototype.handleSocketClose = function(hadError) {
    this._debug('handleSocketClose: received socket close');
    this.socketHadError = hadError;
    this.connected = false;
    this.state = STATE_CLOSED;
    // If closeReasonCode is still set to -1 at this point then we must
    // not have received a close frame!!
    if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = 'Connection dropped by remote peer.';
    }
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();
    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('-- Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
};

WebSocketConnection.prototype.handleSocketDrain = function() {
    this._debug('handleSocketDrain: socket drain event');
    this.outputBufferFull = false;
    this.emit('drain');
};

WebSocketConnection.prototype.handleSocketPause = function() {
    this._debug('handleSocketPause: socket pause event');
    this.inputPaused = true;
    this.emit('pause');
};

WebSocketConnection.prototype.handleSocketResume = function() {
    this._debug('handleSocketResume: socket resume event');
    this.inputPaused = false;
    this.emit('resume');
    this.processReceivedData();
};

WebSocketConnection.prototype.pause = function() {
    this._debug('pause: pause requested');
    this.socket.pause();
};

WebSocketConnection.prototype.resume = function() {
    this._debug('resume: resume requested');
    this.socket.resume();
};

WebSocketConnection.prototype.close = function(reasonCode, description) {
    if (this.connected) {
        this._debug('close: Initating clean WebSocket close sequence.');
        if ('number' !== typeof reasonCode) {
            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
            throw new Error('Close code ' + reasonCode + ' is not valid.');
        }
        if ('string' !== typeof description) {
            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
    }
};

WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
    this._debug('drop');
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
    }

    if (typeof(description) !== 'string') {
        // If no description is provided, try to look one up based on the
        // specified reasonCode.
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
    }

    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',
        skipCloseFrame, reasonCode, description
    );

    this.closeReasonCode = reasonCode;
    this.closeDescription = description;
    this.frameQueue = [];
    this.fragmentationSize = 0;
    if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
    }
    this.connected = false;
    this.state = STATE_CLOSED;
    this.clearCloseTimer();
    this.clearKeepaliveTimer();
    this.clearGracePeriodTimer();

    if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug('Emitting WebSocketConnection close event');
        this.emit('close', this.closeReasonCode, this.closeDescription);
    }
    
    this._debug('Drop: destroying socket');
    this.socket.destroy();
};

WebSocketConnection.prototype.setCloseTimer = function() {
    this._debug('setCloseTimer');
    this.clearCloseTimer();
    this._debug('Setting close timer');
    this.waitingForCloseResponse = true;
    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
};

WebSocketConnection.prototype.clearCloseTimer = function() {
    this._debug('clearCloseTimer');
    if (this.closeTimer) {
        this._debug('Clearing close timer');
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
    }
};

WebSocketConnection.prototype.handleCloseTimer = function() {
    this._debug('handleCloseTimer');
    this.closeTimer = null;
    if (this.waitingForCloseResponse) {
        this._debug('Close response not received from client.  Forcing socket end.');
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
    }
};

WebSocketConnection.prototype.processFrame = function(frame) {
    this._debug('processFrame');
    this._debug(' -- frame: %s', frame);
    
    // Any non-control opcode besides 0x00 (continuation) received in the
    // middle of a fragmented message is illegal.
    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {
        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +
          'received in middle of fragmented message.');
        return;
    }

    switch(frame.opcode) {
        case 0x02: // WebSocketFrame.BINARY_FRAME
            this._debug('-- Binary Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'binary',
                        binaryData: frame.binaryPayload
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x01: // WebSocketFrame.TEXT_FRAME
            this._debug('-- Text Frame');
            if (this.assembleFragments) {
                if (frame.fin) {
                    if (!isValidUTF8(frame.binaryPayload)) {
                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                          'Invalid UTF-8 Data Received');
                        return;
                    }
                    // Complete single-frame message received
                    this._debug('---- Emitting \'message\' event');
                    this.emit('message', {
                        type: 'utf8',
                        utf8Data: frame.binaryPayload.toString('utf8')
                    });
                }
                else {
                    // beginning of a fragmented message
                    this.frameQueue.push(frame);
                    this.fragmentationSize = frame.length;
                }
            }
            break;
        case 0x00: // WebSocketFrame.CONTINUATION
            this._debug('-- Continuation Frame');
            if (this.assembleFragments) {
                if (this.frameQueue.length === 0) {
                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                      'Unexpected Continuation Frame');
                    return;
                }

                this.fragmentationSize += frame.length;

                if (this.fragmentationSize > this.maxReceivedMessageSize) {
                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,
                      'Maximum message size exceeded.');
                    return;
                }

                this.frameQueue.push(frame);

                if (frame.fin) {
                    // end of fragmented message, so we process the whole
                    // message now.  We also have to decode the utf-8 data
                    // for text frames after combining all the fragments.
                    var bytesCopied = 0;
                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
                    var opcode = this.frameQueue[0].opcode;
                    this.frameQueue.forEach(function (currentFrame) {
                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                        bytesCopied += currentFrame.binaryPayload.length;
                    });
                    this.frameQueue = [];
                    this.fragmentationSize = 0;

                    switch (opcode) {
                        case 0x02: // WebSocketOpcode.BINARY_FRAME
                            this.emit('message', {
                                type: 'binary',
                                binaryData: binaryPayload
                            });
                            break;
                        case 0x01: // WebSocketOpcode.TEXT_FRAME
                            if (!isValidUTF8(binaryPayload)) {
                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                                  'Invalid UTF-8 Data Received');
                                return;
                            }
                            this.emit('message', {
                                type: 'utf8',
                                utf8Data: binaryPayload.toString('utf8')
                            });
                            break;
                        default:
                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));
                            return;
                    }
                }
            }
            break;
        case 0x09: // WebSocketFrame.PING
            this._debug('-- Ping Frame');

            if (this._pingListenerCount > 0) {
                // logic to emit the ping frame: this is only done when a listener is known to exist
                // Expose a function allowing the user to override the default ping() behavior
                var cancelled = false;
                var cancel = function() { 
                  cancelled = true; 
                };
                this.emit('ping', cancel, frame.binaryPayload);

                // Only send a pong if the client did not indicate that he would like to cancel
                if (!cancelled) {
                    this.pong(frame.binaryPayload);
                }
            }
            else {
                this.pong(frame.binaryPayload);
            }

            break;
        case 0x0A: // WebSocketFrame.PONG
            this._debug('-- Pong Frame');
            this.emit('pong', frame.binaryPayload);
            break;
        case 0x08: // WebSocketFrame.CONNECTION_CLOSE
            this._debug('-- Close Frame');
            if (this.waitingForCloseResponse) {
                // Got response to our request to close the connection.
                // Close is complete, so we just hang up.
                this._debug('---- Got close response from peer.  Completing closing handshake.');
                this.clearCloseTimer();
                this.waitingForCloseResponse = false;
                this.state = STATE_CLOSED;
                this.socket.end();
                return;
            }
            
            this._debug('---- Closing handshake initiated by peer.');
            // Got request from other party to close connection.
            // Send back acknowledgement and then hang up.
            this.state = STATE_PEER_REQUESTED_CLOSE;
            var respondCloseReasonCode;

            // Make sure the close reason provided is legal according to
            // the protocol spec.  Providing no close status is legal.
            // WebSocketFrame sets closeStatus to -1 by default, so if it
            // is still -1, then no status was provided.
            if (frame.invalidCloseFrameLength) {
                this.closeReasonCode = 1005; // 1005 = No reason provided.
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
            }
            else {
                this.closeReasonCode = frame.closeStatus;
                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
            }
            
            // If there is a textual description in the close frame, extract it.
            if (frame.binaryPayload.length > 1) {
                if (!isValidUTF8(frame.binaryPayload)) {
                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,
                      'Invalid UTF-8 Data Received');
                    return;
                }
                this.closeDescription = frame.binaryPayload.toString('utf8');
            }
            else {
                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
            }
            this._debug(
                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',
                this.remoteAddress, this.closeReasonCode,
                this.closeDescription, frame.length
            );
            this._debug('------ responding to remote peer\'s close request.');
            this.sendCloseFrame(respondCloseReasonCode, null);
            this.connected = false;
            break;
        default:
            this._debug('-- Unrecognized Opcode %d', frame.opcode);
            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,
              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));
            break;
    }
};

WebSocketConnection.prototype.send = function(data, cb) {
    this._debug('send');
    if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
    }
    else if (typeof(data['toString']) === 'function') {
        this.sendUTF(data, cb);
    }
    else {
        throw new Error('Data provided must either be a Node Buffer or implement toString()');
    }
};

WebSocketConnection.prototype.sendUTF = function(data, cb) {
    data = bufferFromString(data.toString(), 'utf8');
    this._debug('sendUTF: %d bytes', data.length);
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.sendBytes = function(data, cb) {
    this._debug('sendBytes');
    if (!Buffer.isBuffer(data)) {
        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');
    }
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME
    frame.binaryPayload = data;
    this.fragmentAndSend(frame, cb);
};

WebSocketConnection.prototype.ping = function(data) {
    this._debug('ping');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x09; // WebSocketOpcode.PING
    frame.fin = true;
    if (data) {
        if (!Buffer.isBuffer(data)) {
            data = bufferFromString(data.toString(), 'utf8');
        }
        if (data.length > 125) {
            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');
            data = data.slice(0,124);
        }
        frame.binaryPayload = data;
    }
    this.sendFrame(frame);
};

// Pong frames have to echo back the contents of the data portion of the
// ping frame exactly, byte for byte.
WebSocketConnection.prototype.pong = function(binaryPayload) {
    this._debug('pong');
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.opcode = 0x0A; // WebSocketOpcode.PONG
    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');
        binaryPayload = binaryPayload.slice(0,124);
    }
    frame.binaryPayload = binaryPayload;
    frame.fin = true;
    this.sendFrame(frame);
};

WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
    this._debug('fragmentAndSend');
    if (frame.opcode > 0x07) {
        throw new Error('You cannot fragment control frames.');
    }

    var threshold = this.config.fragmentationThreshold;
    var length = frame.binaryPayload.length;

    // Send immediately if fragmentation is disabled or the message is not
    // larger than the fragmentation threshold.
    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
    }
    
    var numFragments = Math.ceil(length / threshold);
    var sentFragments = 0;
    var sentCallback = function fragmentSentCallback(err) {
        if (err) {
            if (typeof cb === 'function') {
                // pass only the first error
                cb(err);
                cb = null;
            }
            return;
        }
        ++sentFragments;
        if ((sentFragments === numFragments) && (typeof cb === 'function')) {
            cb();
        }
    };
    for (var i=1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        
        // continuation opcode except for first frame.
        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;
        
        // fin set on last frame only
        currentFrame.fin = (i === numFragments);
        
        // length is likely to be shorter on the last fragment
        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;
        var sliceStart = threshold * (i-1);
        
        // Slice the right portion of the original payload
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        
        this.sendFrame(currentFrame, sentCallback);
    }
};

WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
    if (typeof(reasonCode) !== 'number') {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
    }
    
    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);
    
    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }
    
    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
    frame.fin = true;
    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE
    frame.closeStatus = reasonCode;
    if (typeof(description) === 'string') {
        frame.binaryPayload = bufferFromString(description, 'utf8');
    }
    
    this.sendFrame(frame, cb);
    this.socket.end();
};

WebSocketConnection.prototype.sendFrame = function(frame, cb) {
    this._debug('sendFrame');
    frame.mask = this.maskOutgoingPackets;
    var flushed = this.socket.write(frame.toBuffer(), cb);
    this.outputBufferFull = !flushed;
    return flushed;
};

module.exports = WebSocketConnection;



function instrumentSocketForDebugging(connection, socket) {
    /* jshint loopfunc: true */
    if (!connection._debug.enabled) { return; }
    
    var originalSocketEmit = socket.emit;
    socket.emit = function(event) {
        connection._debug('||| Socket Event  \'%s\'', event);
        originalSocketEmit.apply(this, arguments);
    };
    
    for (var key in socket) {
        if ('function' !== typeof(socket[key])) { continue; }
        if (['emit'].indexOf(key) !== -1) { continue; }
        (function(key) {
            var original = socket[key];
            if (key === 'on') {
                socket[key] = function proxyMethod__EventEmitter__On() {
                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);
                    return original.apply(this, arguments);
                };
                return;
            }
            socket[key] = function proxyMethod() {
                connection._debug('||| Socket method called:  %s', key);
                return original.apply(this, arguments);
            };
        })(key);
    }
}


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketFrame.js":
/*!**********************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketFrame.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var bufferUtil = __webpack_require__(/*! bufferutil */ "../../node_modules/bufferutil/index.js");
var bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js").bufferAllocUnsafe);

const DECODE_HEADER = 1;
const WAITING_FOR_16_BIT_LENGTH = 2;
const WAITING_FOR_64_BIT_LENGTH = 3;
const WAITING_FOR_MASK_KEY = 4;
const WAITING_FOR_PAYLOAD = 5;
const COMPLETE = 6;

// WebSocketConnection will pass shared buffer objects for maskBytes and
// frameHeader into the constructor to avoid tons of small memory allocations
// for each frame we have to parse.  This is only used for parsing frames
// we receive off the wire.
function WebSocketFrame(maskBytes, frameHeader, config) {
    this.maskBytes = maskBytes;
    this.frameHeader = frameHeader;
    this.config = config;
    this.maxReceivedFrameSize = config.maxReceivedFrameSize;
    this.protocolError = false;
    this.frameTooLarge = false;
    this.invalidCloseFrameLength = false;
    this.parseState = DECODE_HEADER;
    this.closeStatus = -1;
}

WebSocketFrame.prototype.addData = function(bufferList) {
    if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 0, 0, 2);
            bufferList.advance(2);
            var firstByte = this.frameHeader[0];
            var secondByte = this.frameHeader[1];

            this.fin     = Boolean(firstByte  & 0x80);
            this.rsv1    = Boolean(firstByte  & 0x40);
            this.rsv2    = Boolean(firstByte  & 0x20);
            this.rsv3    = Boolean(firstByte  & 0x10);
            this.mask    = Boolean(secondByte & 0x80);

            this.opcode  = firstByte  & 0x0F;
            this.length = secondByte & 0x7F;

            // Control frame sanity check
            if (this.opcode >= 0x08) {
                if (this.length > 125) {
                    this.protocolError = true;
                    this.dropReason = 'Illegal control frame longer than 125 bytes.';
                    return true;
                }
                if (!this.fin) {
                    this.protocolError = true;
                    this.dropReason = 'Control frames must not be fragmented.';
                    return true;
                }
            }

            if (this.length === 126) {
                this.parseState = WAITING_FOR_16_BIT_LENGTH;
            }
            else if (this.length === 127) {
                this.parseState = WAITING_FOR_64_BIT_LENGTH;
            }
            else {
                this.parseState = WAITING_FOR_MASK_KEY;
            }
        }
    }
    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
            bufferList.joinInto(this.frameHeader, 2, 0, 2);
            bufferList.advance(2);
            this.length = this.frameHeader.readUInt16BE(2);
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }
    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
            bufferList.joinInto(this.frameHeader, 2, 0, 8);
            bufferList.advance(8);
            var lengthPair = [
              this.frameHeader.readUInt32BE(2),
              this.frameHeader.readUInt32BE(2+4)
            ];

            if (lengthPair[0] !== 0) {
                this.protocolError = true;
                this.dropReason = 'Unsupported 64-bit length frame received';
                return true;
            }
            this.length = lengthPair[1];
            this.parseState = WAITING_FOR_MASK_KEY;
        }
    }

    if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
            if (bufferList.length >= 4) {
                bufferList.joinInto(this.maskBytes, 0, 0, 4);
                bufferList.advance(4);
                this.parseState = WAITING_FOR_PAYLOAD;
            }
        }
        else {
            this.parseState = WAITING_FOR_PAYLOAD;
        }
    }

    if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
            this.frameTooLarge = true;
            this.dropReason = 'Frame size of ' + this.length.toString(10) +
                              ' bytes exceeds maximum accepted frame size';
            return true;
        }

        if (this.length === 0) {
            this.binaryPayload = bufferAllocUnsafe(0);
            this.parseState = COMPLETE;
            return true;
        }
        if (bufferList.length >= this.length) {
            this.binaryPayload = bufferList.take(this.length);
            bufferList.advance(this.length);
            if (this.mask) {
                bufferUtil.unmask(this.binaryPayload, this.maskBytes);
                // xor(this.binaryPayload, this.maskBytes, 0);
            }

            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE
                if (this.length === 1) {
                    // Invalid length for a close frame.  Must be zero or at least two.
                    this.binaryPayload = bufferAllocUnsafe(0);
                    this.invalidCloseFrameLength = true;
                }
                if (this.length >= 2) {
                    this.closeStatus = this.binaryPayload.readUInt16BE(0);
                    this.binaryPayload = this.binaryPayload.slice(2);
                }
            }

            this.parseState = COMPLETE;
            return true;
        }
    }
    return false;
};

WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
    if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
    }
    return false;
};

WebSocketFrame.prototype.toBuffer = function(nullMask) {
    var maskKey;
    var headerLength = 2;
    var data;
    var outputPos;
    var firstByte = 0x00;
    var secondByte = 0x00;

    if (this.fin) {
        firstByte |= 0x80;
    }
    if (this.rsv1) {
        firstByte |= 0x40;
    }
    if (this.rsv2) {
        firstByte |= 0x20;
    }
    if (this.rsv3) {
        firstByte |= 0x10;
    }
    if (this.mask) {
        secondByte |= 0x80;
    }

    firstByte |= (this.opcode & 0x0F);

    // the close frame is a special case because the close reason is
    // prepended to the payload data.
    if (this.opcode === 0x08) {
        this.length = 2;
        if (this.binaryPayload) {
            this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
            this.binaryPayload.copy(data, 2);
        }
    }
    else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
    }
    else {
        this.length = 0;
    }

    if (this.length <= 125) {
        // encode the length directly into the two-byte frame header
        secondByte |= (this.length & 0x7F);
    }
    else if (this.length > 125 && this.length <= 0xFFFF) {
        // Use 16-bit length
        secondByte |= 126;
        headerLength += 2;
    }
    else if (this.length > 0xFFFF) {
        // Use 64-bit length
        secondByte |= 127;
        headerLength += 8;
    }

    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));

    // write the frame header
    output[0] = firstByte;
    output[1] = secondByte;

    outputPos = 2;

    if (this.length > 125 && this.length <= 0xFFFF) {
        // write 16-bit length
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
    }
    else if (this.length > 0xFFFF) {
        // write 64-bit length
        output.writeUInt32BE(0x00000000, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
    }

    if (this.mask) {
        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);
        this.maskBytes.writeUInt32BE(maskKey, 0);

        // write the mask key
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;

        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
    }
    else if (data) {
        data.copy(output, outputPos);
    }

    return output;
};

WebSocketFrame.prototype.toString = function() {
    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;
};


module.exports = WebSocketFrame;


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketRequest.js":
/*!************************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketRequest.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var crypto = __webpack_require__(/*! crypto */ "crypto");
var util = __webpack_require__(/*! util */ "util");
var url = __webpack_require__(/*! url */ "url");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ "../../node_modules/websocket/lib/WebSocketConnection.js");

var headerValueSplitRegExp = /,\s*/;
var headerParamSplitRegExp = /;\s*/;
var headerSanitizeRegExp = /[\r\n]/g;
var xForwardedForSeparatorRegExp = /,\s*/;
var separators = [
    '(', ')', '<', '>', '@',
    ',', ';', ':', '\\', '\"',
    '/', '[', ']', '?', '=',
    '{', '}', ' ', String.fromCharCode(9)
];
var controlChars = [String.fromCharCode(127) /* DEL */];
for (var i=0; i < 31; i ++) {
    /* US-ASCII Control Characters */
    controlChars.push(String.fromCharCode(i));
}

var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;

var cookieSeparatorRegEx = /[;,] */;

var httpStatusDescriptions = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    406: 'Not Acceptable',
    407: 'Proxy Authorization Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Long',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    426: 'Upgrade Required',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported'
};

function WebSocketRequest(socket, httpRequest, serverConfig) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.socket = socket;
    this.httpRequest = httpRequest;
    this.resource = httpRequest.url;
    this.remoteAddress = socket.remoteAddress;
    this.remoteAddresses = [this.remoteAddress];
    this.serverConfig = serverConfig;

    // Watch for the underlying TCP socket closing before we call accept
    this._socketIsClosing = false;
    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
    this.socket.on('end', this._socketCloseHandler);
    this.socket.on('close', this._socketCloseHandler);

    this._resolved = false;
}

util.inherits(WebSocketRequest, EventEmitter);

WebSocketRequest.prototype.readHandshake = function() {
    var self = this;
    var request = this.httpRequest;

    // Decode URL
    this.resourceURL = url.parse(this.resource, true);

    this.host = request.headers['host'];
    if (!this.host) {
        throw new Error('Client must provide a Host header.');
    }

    this.key = request.headers['sec-websocket-key'];
    if (!this.key) {
        throw new Error('Client must provide a value for Sec-WebSocket-Key.');
    }

    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);

    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error('Client must provide a value for Sec-WebSocket-Version.');
    }

    switch (this.webSocketVersion) {
        case 8:
        case 13:
            break;
        default:
            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +
                              'Only versions 8 and 13 are supported.');
            e.httpCode = 426;
            e.headers = {
                'Sec-WebSocket-Version': '13'
            };
            throw e;
    }

    if (this.webSocketVersion === 13) {
        this.origin = request.headers['origin'];
    }
    else if (this.webSocketVersion === 8) {
        this.origin = request.headers['sec-websocket-origin'];
    }

    // Protocol is optional.
    var protocolString = request.headers['sec-websocket-protocol'];
    this.protocolFullCaseMap = {};
    this.requestedProtocols = [];
    if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
            var lcProtocol = protocol.toLocaleLowerCase();
            self.requestedProtocols.push(lcProtocol);
            self.protocolFullCaseMap[lcProtocol] = protocol;
        });
    }

    if (!this.serverConfig.ignoreXForwardedFor &&
        request.headers['x-forwarded-for']) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers['x-forwarded-for']
            .split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
    }

    // Extensions are optional.
    if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers['sec-websocket-extensions'];
        this.requestedExtensions = this.parseExtensions(extensionsString);
    } else {
        this.requestedExtensions = [];
    }

    // Cookies are optional
    if (this.serverConfig.parseCookies) {
        var cookieString = request.headers['cookie'];
        this.cookies = this.parseCookies(cookieString);
    } else {
        this.cookies = [];
    }
};

WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
    if (!extensionsString || extensionsString.length === 0) {
        return [];
    }
    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
    extensions.forEach(function(extension, index, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index, array) {
            var arr = rawParam.split('=');
            var obj = {
                name: arr[0],
                value: arr[1]
            };
            array.splice(index, 1, obj);
        });
        var obj = {
            name: extensionName,
            params: extensionParams
        };
        array.splice(index, 1, obj);
    });
    return extensions;
};

// This function adapted from node-cookie
// https://github.com/shtylman/node-cookie
WebSocketRequest.prototype.parseCookies = function(str) {
    // Sanity Check
    if (!str || typeof(str) !== 'string') {
        return [];
    }

    var cookies = [];
    var pairs = str.split(cookieSeparatorRegEx);

    pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=');
        if (eq_idx === -1) {
            cookies.push({
                name: pair,
                value: null
            });
            return;
        }

        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' === val[0]) {
            val = val.slice(1, -1);
        }

        cookies.push({
            name: key,
            value: decodeURIComponent(val)
        });
    });

    return cookies;
};

WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
    this._verifyResolution();

    // TODO: Handle extensions

    var protocolFullCase;

    if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof(protocolFullCase) === 'undefined') {
            protocolFullCase = acceptedProtocol;
        }
    }
    else {
        protocolFullCase = acceptedProtocol;
    }
    this.protocolFullCaseMap = null;

    // Create key validation hash
    var sha1 = crypto.createHash('sha1');
    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    var acceptKey = sha1.digest('base64');

    var response = 'HTTP/1.1 101 Switching Protocols\r\n' +
                   'Upgrade: websocket\r\n' +
                   'Connection: Upgrade\r\n' +
                   'Sec-WebSocket-Accept: ' + acceptKey + '\r\n';

    if (protocolFullCase) {
        // validate protocol
        for (var i=0; i < protocolFullCase.length; i++) {
            var charCode = protocolFullCase.charCodeAt(i);
            var character = protocolFullCase.charAt(i);
            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {
                this.reject(500);
                throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
            }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
            this.reject(500);
            throw new Error('Specified protocol was not requested by the client.');
        }

        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');
        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\r\n';
    }
    this.requestedProtocols = null;

    if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');
        if (this.webSocketVersion === 13) {
            response += 'Origin: ' + allowedOrigin + '\r\n';
        }
        else if (this.webSocketVersion === 8) {
            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\r\n';
        }
    }

    if (cookies) {
        if (!Array.isArray(cookies)) {
            this.reject(500);
            throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
            if (!cookie.name || !cookie.value) {
                this.reject(500);
                throw new Error('Each cookie to set must at least provide a "name" and "value"');
            }

            // Make sure there are no \r\n sequences inserted
            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');
            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');

            if (seenCookies[cookie.name]) {
                this.reject(500);
                throw new Error('You may not specify the same cookie name twice.');
            }
            seenCookies[cookie.name] = true;

            // token (RFC 2616, Section 2.2)
            var invalidChar = cookie.name.match(cookieNameValidateRegEx);
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');
            }

            // RFC 6265, Section 4.1.1
            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
            } else {
                invalidChar = cookie.value.match(cookieValueValidateRegEx);
            }
            if (invalidChar) {
                this.reject(500);
                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');
            }

            var cookieParts = [cookie.name + '=' + cookie.value];

            // RFC 6265, Section 4.1.1
            // 'Path=' path-value | <any CHAR except CTLs or ';'>
            if(cookie.path){
                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');
                }
                cookieParts.push('Path=' + cookie.path);
            }

            // RFC 6265, Section 4.1.2.3
            // 'Domain=' subdomain
            if (cookie.domain) {
                if (typeof(cookie.domain) !== 'string') {
                    this.reject(500);
                    throw new Error('Domain must be specified and must be a string.');
                }
                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
                if (invalidChar) {
                    this.reject(500);
                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');
                }
                cookieParts.push('Domain=' + cookie.domain.toLowerCase());
            }

            // RFC 6265, Section 4.1.1
            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch
            if (cookie.expires) {
                if (!(cookie.expires instanceof Date)){
                    this.reject(500);
                    throw new Error('Value supplied for cookie "expires" must be a vaild date object');
                }
                cookieParts.push('Expires=' + cookie.expires.toGMTString());
            }

            // RFC 6265, Section 4.1.1
            //'Max-Age=' non-zero-digit *DIGIT
            if (cookie.maxage) {
                var maxage = cookie.maxage;
                if (typeof(maxage) === 'string') {
                    maxage = parseInt(maxage, 10);
                }
                if (isNaN(maxage) || maxage <= 0 ) {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
                }
                maxage = Math.round(maxage);
                cookieParts.push('Max-Age=' + maxage.toString(10));
            }

            // RFC 6265, Section 4.1.1
            //'Secure;'
            if (cookie.secure) {
                if (typeof(cookie.secure) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "secure" must be of type boolean');
                }
                cookieParts.push('Secure');
            }

            // RFC 6265, Section 4.1.1
            //'HttpOnly;'
            if (cookie.httponly) {
                if (typeof(cookie.httponly) !== 'boolean') {
                    this.reject(500);
                    throw new Error('Value supplied for cookie "httponly" must be of type boolean');
                }
                cookieParts.push('HttpOnly');
            }

            response += ('Set-Cookie: ' + cookieParts.join(';') + '\r\n');
        }.bind(this));
    }

    // TODO: handle negotiated extensions
    // if (negotiatedExtensions) {
    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\r\n';
    // }

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    response += '\r\n';

    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
    connection.webSocketVersion = this.webSocketVersion;
    connection.remoteAddress = this.remoteAddress;
    connection.remoteAddresses = this.remoteAddresses;

    var self = this;

    if (this._socketIsClosing) {
        // Handle case when the client hangs up before we get a chance to
        // accept the connection and send our side of the opening handshake.
        cleanupFailedConnection(connection);
    }
    else {
        this.socket.write(response, 'ascii', function(error) {
            if (error) {
                cleanupFailedConnection(connection);
                return;
            }

            self._removeSocketCloseListeners();
            connection._addSocketEventListeners();
        });
    }

    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
    this._verifyResolution();

    // Mark the request resolved now so that the user can't call accept or
    // reject a second time.
    this._resolved = true;
    this.emit('requestResolved', this);

    if (typeof(status) !== 'number') {
        status = 403;
    }
    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\r\n' +
                   'Connection: close\r\n';
    if (reason) {
        reason = reason.replace(headerSanitizeRegExp, '');
        response += 'X-WebSocket-Reject-Reason: ' + reason + '\r\n';
    }

    if (extraHeaders) {
        for (var key in extraHeaders) {
            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');
            var sanitizedKey = key.replace(headerSanitizeRegExp, '');
            response += (sanitizedKey + ': ' + sanitizedValue + '\r\n');
        }
    }

    response += '\r\n';
    this.socket.end(response, 'ascii');

    this.emit('requestRejected', this);
};

WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
    this._socketIsClosing = true;
    this._removeSocketCloseListeners();
};

WebSocketRequest.prototype._removeSocketCloseListeners = function() {
    this.socket.removeListener('end', this._socketCloseHandler);
    this.socket.removeListener('close', this._socketCloseHandler);
};

WebSocketRequest.prototype._verifyResolution = function() {
    if (this._resolved) {
        throw new Error('WebSocketRequest may only be accepted or rejected one time.');
    }
};

function cleanupFailedConnection(connection) {
    // Since we have to return a connection object even if the socket is
    // already dead in order not to break the API, we schedule a 'close'
    // event on the connection object to occur immediately.
    process.nextTick(function() {
        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006
        // Third param: Skip sending the close frame to a dead socket
        connection.drop(1006, 'TCP connection lost before handshake completed.', true);
    });
}

module.exports = WebSocketRequest;


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketRouter.js":
/*!***********************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketRouter.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js").extend);
var util = __webpack_require__(/*! util */ "util");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ "../../node_modules/websocket/lib/WebSocketRouterRequest.js");

function WebSocketRouter(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.config = {
        // The WebSocketServer instance to attach to.
        server: null
    };
    if (config) {
        extend(this.config, config);
    }
    this.handlers = [];

    this._requestHandler = this.handleRequest.bind(this);
    if (this.config.server) {
        this.attachServer(this.config.server);
    }
}

util.inherits(WebSocketRouter, EventEmitter);

WebSocketRouter.prototype.attachServer = function(server) {
    if (server) {
        this.server = server;
        this.server.on('request', this._requestHandler);
    }
    else {
        throw new Error('You must specify a WebSocketServer instance to attach to.');
    }
};

WebSocketRouter.prototype.detachServer = function() {
    if (this.server) {
        this.server.removeListener('request', this._requestHandler);
        this.server = null;
    }
    else {
        throw new Error('Cannot detach from server: not attached.');
    }
};

WebSocketRouter.prototype.mount = function(path, protocol, callback) {
    if (!path) {
        throw new Error('You must specify a path for this handler.');
    }
    if (!protocol) {
        protocol = '____no_protocol____';
    }
    if (!callback) {
        throw new Error('You must specify a callback for this handler.');
    }

    path = this.pathToRegExp(path);
    if (!(path instanceof RegExp)) {
        throw new Error('Path must be specified as either a string or a RegExp.');
    }
    var pathString = path.toString();

    // normalize protocol to lower-case
    protocol = protocol.toLocaleLowerCase();

    if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error('You may only mount one handler per path/protocol combination.');
    }

    this.handlers.push({
        'path': path,
        'pathString': pathString,
        'protocol': protocol,
        'callback': callback
    });
};
WebSocketRouter.prototype.unmount = function(path, protocol) {
    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);
    if (index !== -1) {
        this.handlers.splice(index, 1);
    }
    else {
        throw new Error('Unable to find a route matching the specified path and protocol.');
    }
};

WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
    protocol = protocol.toLocaleLowerCase();
    for (var i=0, len=this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
            return i;
        }
    }
    return -1;
};

WebSocketRouter.prototype.pathToRegExp = function(path) {
    if (typeof(path) === 'string') {
        if (path === '*') {
            path = /^.*$/;
        }
        else {
            path = path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            path = new RegExp('^' + path + '$');
        }
    }
    return path;
};

WebSocketRouter.prototype.handleRequest = function(request) {
    var requestedProtocols = request.requestedProtocols;
    if (requestedProtocols.length === 0) {
        requestedProtocols = ['____no_protocol____'];
    }

    // Find a handler with the first requested protocol first
    for (var i=0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();

        // find the first handler that can process this request
        for (var j=0, len=this.handlers.length; j < len; j++) {
            var handler = this.handlers[j];
            if (handler.path.test(request.resourceURL.pathname)) {
                if (requestedProtocol === handler.protocol ||
                    handler.protocol === '*')
                {
                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
                    handler.callback(routerRequest);
                    return;
                }
            }
        }
    }

    // If we get here we were unable to find a suitable handler.
    request.reject(404, 'No handler is available for the given request.');
};

module.exports = WebSocketRouter;


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!******************************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var util = __webpack_require__(/*! util */ "util");
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);

function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
    // Superclass Constructor
    EventEmitter.call(this);

    this.webSocketRequest = webSocketRequest;
    if (resolvedProtocol === '____no_protocol____') {
        this.protocol = null;
    }
    else {
        this.protocol = resolvedProtocol;
    }
    this.origin = webSocketRequest.origin;
    this.resource = webSocketRequest.resource;
    this.resourceURL = webSocketRequest.resourceURL;
    this.httpRequest = webSocketRequest.httpRequest;
    this.remoteAddress = webSocketRequest.remoteAddress;
    this.webSocketVersion = webSocketRequest.webSocketVersion;
    this.requestedExtensions = webSocketRequest.requestedExtensions;
    this.cookies = webSocketRequest.cookies;
}

util.inherits(WebSocketRouterRequest, EventEmitter);

WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
    this.emit('requestAccepted', connection);
    return connection;
};

WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
    this.webSocketRequest.reject(status, reason, extraHeaders);
    this.emit('requestRejected', this);
};

module.exports = WebSocketRouterRequest;


/***/ }),

/***/ "../../node_modules/websocket/lib/WebSocketServer.js":
/*!***********************************************************!*\
  !*** ../../node_modules/websocket/lib/WebSocketServer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/************************************************************************
 *  Copyright 2010-2015 Brian McKelvey.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ***********************************************************************/

var extend = (__webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js").extend);
var utils = __webpack_require__(/*! ./utils */ "../../node_modules/websocket/lib/utils.js");
var util = __webpack_require__(/*! util */ "util");
var debug = __webpack_require__(/*! debug */ "../../node_modules/websocket/node_modules/debug/src/index.js")('websocket:server');
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ "../../node_modules/websocket/lib/WebSocketRequest.js");

var WebSocketServer = function WebSocketServer(config) {
    // Superclass Constructor
    EventEmitter.call(this);

    this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
    };
    this.connections = [];
    this.pendingRequests = [];
    if (config) {
        this.mount(config);
    }
};

util.inherits(WebSocketServer, EventEmitter);

WebSocketServer.prototype.mount = function(config) {
    this.config = {
        // The http server instance to attach to.  Required.
        httpServer: null,

        // 64KiB max frame size.
        maxReceivedFrameSize: 0x10000,

        // 1MiB max message size, only applicable if
        // assembleFragments is true
        maxReceivedMessageSize: 0x100000,

        // Outgoing messages larger than fragmentationThreshold will be
        // split into multiple fragments.
        fragmentOutgoingMessages: true,

        // Outgoing frames are fragmented if they exceed this threshold.
        // Default is 16KiB
        fragmentationThreshold: 0x4000,

        // If true, the server will automatically send a ping to all
        // clients every 'keepaliveInterval' milliseconds.  The timer is
        // reset on any received data from the client.
        keepalive: true,

        // The interval to send keepalive pings to connected clients if the
        // connection is idle.  Any received data will reset the counter.
        keepaliveInterval: 20000,

        // If true, the server will consider any connection that has not
        // received any data within the amount of time specified by
        // 'keepaliveGracePeriod' after a keepalive ping has been sent to
        // be dead, and will drop the connection.
        // Ignored if keepalive is false.
        dropConnectionOnKeepaliveTimeout: true,

        // The amount of time to wait after sending a keepalive ping before
        // closing the connection if the connected peer does not respond.
        // Ignored if keepalive is false.
        keepaliveGracePeriod: 10000,

        // Whether to use native TCP keep-alive instead of WebSockets ping
        // and pong packets.  Native TCP keep-alive sends smaller packets
        // on the wire and so uses bandwidth more efficiently.  This may
        // be more important when talking to mobile devices.
        // If this value is set to true, then these values will be ignored:
        //   keepaliveGracePeriod
        //   dropConnectionOnKeepaliveTimeout
        useNativeKeepalive: false,

        // If true, fragmented messages will be automatically assembled
        // and the full message will be emitted via a 'message' event.
        // If false, each frame will be emitted via a 'frame' event and
        // the application will be responsible for aggregating multiple
        // fragmented frames.  Single-frame messages will emit a 'message'
        // event in addition to the 'frame' event.
        // Most users will want to leave this set to 'true'
        assembleFragments: true,

        // If this is true, websocket connections will be accepted
        // regardless of the path and protocol specified by the client.
        // The protocol accepted will be the first that was requested
        // by the client.  Clients from any origin will be accepted.
        // This should only be used in the simplest of cases.  You should
        // probably leave this set to 'false' and inspect the request
        // object to make sure it's acceptable before accepting it.
        autoAcceptConnections: false,

        // Whether or not the X-Forwarded-For header should be respected.
        // It's important to set this to 'true' when accepting connections
        // from untrusted clients, as a malicious client could spoof its
        // IP address by simply setting this header.  It's meant to be added
        // by a trusted proxy or other intermediary within your own
        // infrastructure.
        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For
        ignoreXForwardedFor: false,

        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies
        parseCookies: true,

        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions
        parseExtensions: true,

        // The Nagle Algorithm makes more efficient use of network resources
        // by introducing a small delay before sending small packets so that
        // multiple messages can be batched together before going onto the
        // wire.  This however comes at the cost of latency, so the default
        // is to disable it.  If you don't need low latency and are streaming
        // lots of small messages, you can change this to 'false'
        disableNagleAlgorithm: true,

        // The number of milliseconds to wait after sending a close frame
        // for an acknowledgement to come back before giving up and just
        // closing the socket.
        closeTimeout: 5000
    };
    extend(this.config, config);

    if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
            this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
            httpServer.on('upgrade', upgradeHandler);
        });
    }
    else {
        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');
    }
};

WebSocketServer.prototype.unmount = function() {
    var upgradeHandler = this._handlers.upgrade;
    this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener('upgrade', upgradeHandler);
    });
};

WebSocketServer.prototype.closeAllConnections = function() {
    this.connections.forEach(function(connection) {
        connection.close();
    });
    this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503); // HTTP 503 Service Unavailable
        });
    });
};

WebSocketServer.prototype.broadcast = function(data) {
    if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
    }
    else if (typeof(data.toString) === 'function') {
        this.broadcastUTF(data);
    }
};

WebSocketServer.prototype.broadcastUTF = function(utfData) {
    this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
    });
};

WebSocketServer.prototype.broadcastBytes = function(binaryData) {
    this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
    });
};

WebSocketServer.prototype.shutDown = function() {
    this.unmount();
    this.closeAllConnections();
};

WebSocketServer.prototype.handleUpgrade = function(request, socket) {
    var self = this;
    var wsRequest = new WebSocketRequest(socket, request, this.config);
    try {
        wsRequest.readHandshake();
    }
    catch(e) {
        wsRequest.reject(
            e.httpCode ? e.httpCode : 400,
            e.message,
            e.headers
        );
        debug('Invalid handshake: %s', e.message);
        this.emit('upgradeError', e);
        return;
    }

    this.pendingRequests.push(wsRequest);

    wsRequest.once('requestAccepted', this._handlers.requestAccepted);
    wsRequest.once('requestResolved', this._handlers.requestResolved);
    socket.once('close', function () {
        self._handlers.requestResolved(wsRequest);
    });

    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {
        this.emit('request', wsRequest);
    }
    else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
    }
    else {
        wsRequest.reject(404, 'No handler is configured to accept the connection.');
    }
};

WebSocketServer.prototype.handleRequestAccepted = function(connection) {
    var self = this;
    connection.once('close', function(closeReason, description) {
        self.handleConnectionClose(connection, closeReason, description);
    });
    this.connections.push(connection);
    this.emit('connect', connection);
};

WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
    var index = this.connections.indexOf(connection);
    if (index !== -1) {
        this.connections.splice(index, 1);
    }
    this.emit('close', connection, closeReason, description);
};

WebSocketServer.prototype.handleRequestResolved = function(request) {
    var index = this.pendingRequests.indexOf(request);
    if (index !== -1) { this.pendingRequests.splice(index, 1); }
};

module.exports = WebSocketServer;


/***/ }),

/***/ "../../node_modules/websocket/lib/utils.js":
/*!*************************************************!*\
  !*** ../../node_modules/websocket/lib/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var noop = exports.noop = function(){};

exports.extend = function extend(dest, source) {
    for (var prop in source) {
        dest[prop] = source[prop];
    }
};

exports.eventEmitterListenerCount =
    (__webpack_require__(/*! events */ "events").EventEmitter.listenerCount) ||
    function(emitter, type) { return emitter.listeners(type).length; };

exports.bufferAllocUnsafe = Buffer.allocUnsafe ?
    Buffer.allocUnsafe :
    function oldBufferAllocUnsafe(size) { return new Buffer(size); };

exports.bufferFromString = Buffer.from ?
    Buffer.from :
    function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };

exports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
    var logFunction = __webpack_require__(/*! debug */ "../../node_modules/websocket/node_modules/debug/src/index.js")(identifier);
    if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
    }
    logFunction.printOutput = noop;
    return logFunction;
};

function BufferingLogger(identifier, uniqueID, logFunction) {
    this.logFunction = logFunction;
    this.identifier = identifier;
    this.uniqueID = uniqueID;
    this.buffer = [];
}

BufferingLogger.prototype.log = function() {
  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);
  return this;
};

BufferingLogger.prototype.clear = function() {
  this.buffer = [];
  return this;
};

BufferingLogger.prototype.printOutput = function(logFunction) {
    if (!logFunction) { logFunction = this.logFunction; }
    var uniqueID = this.uniqueID;
    this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== (void 0) && formatString !== null) {
            formatString = '%s - %s - ' + formatString.toString();
            args.splice(0, 1, formatString, date, uniqueID);
            logFunction.apply(global, args);
        }
    });
};


/***/ }),

/***/ "../../node_modules/websocket/lib/version.js":
/*!***************************************************!*\
  !*** ../../node_modules/websocket/lib/version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ../package.json */ "../../node_modules/websocket/package.json").version;


/***/ }),

/***/ "../../node_modules/websocket/lib/websocket.js":
/*!*****************************************************!*\
  !*** ../../node_modules/websocket/lib/websocket.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    'server'       : __webpack_require__(/*! ./WebSocketServer */ "../../node_modules/websocket/lib/WebSocketServer.js"),
    'client'       : __webpack_require__(/*! ./WebSocketClient */ "../../node_modules/websocket/lib/WebSocketClient.js"),
    'router'       : __webpack_require__(/*! ./WebSocketRouter */ "../../node_modules/websocket/lib/WebSocketRouter.js"),
    'frame'        : __webpack_require__(/*! ./WebSocketFrame */ "../../node_modules/websocket/lib/WebSocketFrame.js"),
    'request'      : __webpack_require__(/*! ./WebSocketRequest */ "../../node_modules/websocket/lib/WebSocketRequest.js"),
    'connection'   : __webpack_require__(/*! ./WebSocketConnection */ "../../node_modules/websocket/lib/WebSocketConnection.js"),
    'w3cwebsocket' : __webpack_require__(/*! ./W3CWebSocket */ "../../node_modules/websocket/lib/W3CWebSocket.js"),
    'deprecation'  : __webpack_require__(/*! ./Deprecation */ "../../node_modules/websocket/lib/Deprecation.js"),
    'version'      : __webpack_require__(/*! ./version */ "../../node_modules/websocket/lib/version.js")
};


/***/ }),

/***/ "../../node_modules/websocket/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/websocket/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "../../node_modules/websocket/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "../../node_modules/websocket/node_modules/debug/src/debug.js":
/*!********************************************************************!*\
  !*** ../../node_modules/websocket/node_modules/debug/src/debug.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "../../node_modules/websocket/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "../../node_modules/websocket/node_modules/debug/src/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/websocket/node_modules/debug/src/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./browser.js */ "../../node_modules/websocket/node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__(/*! ./node.js */ "../../node_modules/websocket/node_modules/debug/src/node.js");
}


/***/ }),

/***/ "../../node_modules/websocket/node_modules/debug/src/node.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/websocket/node_modules/debug/src/node.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(/*! tty */ "tty");
var util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "../../node_modules/websocket/node_modules/debug/src/debug.js");
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = __webpack_require__(/*! fs */ "fs");
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = __webpack_require__(/*! net */ "net");
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),

/***/ "../../node_modules/websocket/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/websocket/node_modules/ms/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "../../node_modules/websocket/vendor/FastBufferList.js":
/*!*************************************************************!*\
  !*** ../../node_modules/websocket/vendor/FastBufferList.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// This file was copied from https://github.com/substack/node-bufferlist
// and modified to be able to copy bytes from the bufferlist directly into
// a pre-existing fixed-size buffer without an additional memory allocation.

// bufferlist.js
// Treat a linked list of buffers as a single variable-size buffer.
var Buffer = (__webpack_require__(/*! buffer */ "buffer").Buffer);
var EventEmitter = (__webpack_require__(/*! events */ "events").EventEmitter);
var bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ "../../node_modules/websocket/lib/utils.js").bufferAllocUnsafe);

module.exports = BufferList;
module.exports.BufferList = BufferList; // backwards compatibility

function BufferList(opts) {
    if (!(this instanceof BufferList)) return new BufferList(opts);
    EventEmitter.call(this);
    var self = this;
    
    if (typeof(opts) == 'undefined') opts = {};
    
    // default encoding to use for take(). Leaving as 'undefined'
    // makes take() return a Buffer instead.
    self.encoding = opts.encoding;
    
    var head = { next : null, buffer : null };
    var last = { next : null, buffer : null };
    
    // length can get negative when advanced past the end
    // and this is the desired behavior
    var length = 0;
    self.__defineGetter__('length', function () {
        return length;
    });
    
    // keep an offset of the head to decide when to head = head.next
    var offset = 0;
    
    // Write to the bufferlist. Emits 'write'. Always returns true.
    self.write = function (buf) {
        if (!head.buffer) {
            head.buffer = buf;
            last = head;
        }
        else {
            last.next = { next : null, buffer : buf };
            last = last.next;
        }
        length += buf.length;
        self.emit('write', buf);
        return true;
    };
    
    self.end = function (buf) {
        if (Buffer.isBuffer(buf)) self.write(buf);
    };
    
    // Push buffers to the end of the linked list. (deprecated)
    // Return this (self).
    self.push = function () {
        var args = [].concat.apply([], arguments);
        args.forEach(self.write);
        return self;
    };
    
    // For each buffer, perform some action.
    // If fn's result is a true value, cut out early.
    // Returns this (self).
    self.forEach = function (fn) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        
        if (head.buffer.length - offset <= 0) return self;
        var firstBuf = head.buffer.slice(offset);
        
        var b = { buffer : firstBuf, next : head.next };
        
        while (b && b.buffer) {
            var r = fn(b.buffer);
            if (r) break;
            b = b.next;
        }
        
        return self;
    };
    
    // Create a single Buffer out of all the chunks or some subset specified by
    // start and one-past the end (like slice) in bytes.
    self.join = function (start, end) {
        if (!head.buffer) return bufferAllocUnsafe(0);
        if (start == undefined) start = 0;
        if (end == undefined) end = self.length;
        
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self.forEach(function (buffer) {
            if (start < (ix + buffer.length) && ix < end) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(0, ix - start),
                    Math.max(0, start - ix),
                    Math.min(buffer.length, end - ix)
                );
            }
            ix += buffer.length;
            if (ix > end) return true; // stop processing past end
        });
        
        return big;
    };
    
    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer) return new bufferAllocUnsafe(0);
        if (sourceStart == undefined) sourceStart = 0;
        if (sourceEnd == undefined) sourceEnd = self.length;
        
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
            throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self.forEach(function (buffer) {
            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {
                // at least partially contained in the range
                buffer.copy(
                    big,
                    Math.max(targetStart, targetStart + ix - sourceStart),
                    Math.max(0, sourceStart - ix),
                    Math.min(buffer.length, sourceEnd - ix)
                );
            }
            ix += buffer.length;
            if (ix > sourceEnd) return true; // stop processing past end
        });
        
        return big;
    };
    
    // Advance the buffer stream by n bytes.
    // If n the aggregate advance offset passes the end of the buffer list,
    // operations such as .take() will return empty strings until enough data is
    // pushed.
    // Returns this (self).
    self.advance = function (n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
            offset -= head.buffer.length;
            head = head.next
                ? head.next
                : { buffer : null, next : null }
            ;
        }
        if (head.buffer === null) last = { next : null, buffer : null };
        self.emit('advance', n);
        return self;
    };
    
    // Take n bytes from the start of the buffers.
    // Returns a string.
    // If there are less than n bytes in all the buffers or n is undefined,
    // returns the entire concatenated buffer string.
    self.take = function (n, encoding) {
        if (n == undefined) n = self.length;
        else if (typeof n !== 'number') {
            encoding = n;
            n = self.length;
        }
        var b = head;
        if (!encoding) encoding = self.encoding;
        if (encoding) {
            var acc = '';
            self.forEach(function (buffer) {
                if (n <= 0) return true;
                acc += buffer.toString(
                    encoding, 0, Math.min(n,buffer.length)
                );
                n -= buffer.length;
            });
            return acc;
        } else {
            // If no 'encoding' is specified, then return a Buffer.
            return self.join(0, n);
        }
    };
    
    // The entire concatenated buffer as a string.
    self.toString = function () {
        return self.take('binary');
    };
}
(__webpack_require__(/*! util */ "util").inherits)(BufferList, EventEmitter);


/***/ }),

/***/ "../../node_modules/which-module/index.js":
/*!************************************************!*\
  !*** ../../node_modules/which-module/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = function whichModule (exported) {
  for (var i = 0, files = Object.keys(__webpack_require__.c), mod; i < files.length; i++) {
    mod = __webpack_require__.c[files[i]]
    if (mod.exports === exported) return mod
  }
  return null
}


/***/ }),

/***/ "../../node_modules/y18n/index.js":
/*!****************************************!*\
  !*** ../../node_modules/y18n/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")
var util = __webpack_require__(/*! util */ "util")

function Y18N (opts) {
  // configurable options.
  opts = opts || {}
  this.directory = opts.directory || './locales'
  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true
  this.locale = opts.locale || 'en'
  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true

  // internal stuff.
  this.cache = Object.create(null)
  this.writeQueue = []
}

Y18N.prototype.__ = function () {
  if (typeof arguments[0] !== 'string') {
    return this._taggedLiteral.apply(this, arguments)
  }
  var args = Array.prototype.slice.call(arguments)
  var str = args.shift()
  var cb = function () {} // start with noop.

  if (typeof args[args.length - 1] === 'function') cb = args.pop()
  cb = cb || function () {} // noop.

  if (!this.cache[this.locale]) this._readLocaleFile()

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][str] && this.updateFiles) {
    this.cache[this.locale][str] = str

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb])
  } else {
    cb()
  }

  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))
}

Y18N.prototype._taggedLiteral = function (parts) {
  var args = arguments
  var str = ''
  parts.forEach(function (part, i) {
    var arg = args[i + 1]
    str += part
    if (typeof arg !== 'undefined') {
      str += '%s'
    }
  })
  return this.__.apply(null, [str].concat([].slice.call(arguments, 1)))
}

Y18N.prototype._enqueueWrite = function (work) {
  this.writeQueue.push(work)
  if (this.writeQueue.length === 1) this._processWriteQueue()
}

Y18N.prototype._processWriteQueue = function () {
  var _this = this
  var work = this.writeQueue[0]

  // destructure the enqueued work.
  var directory = work[0]
  var locale = work[1]
  var cb = work[2]

  var languageFile = this._resolveLocaleFile(directory, locale)
  var serializedLocale = JSON.stringify(this.cache[locale], null, 2)

  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
    _this.writeQueue.shift()
    if (_this.writeQueue.length > 0) _this._processWriteQueue()
    cb(err)
  })
}

Y18N.prototype._readLocaleFile = function () {
  var localeLookup = {}
  var languageFile = this._resolveLocaleFile(this.directory, this.locale)

  try {
    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))
  } catch (err) {
    if (err instanceof SyntaxError) {
      err.message = 'syntax error in ' + languageFile
    }

    if (err.code === 'ENOENT') localeLookup = {}
    else throw err
  }

  this.cache[this.locale] = localeLookup
}

Y18N.prototype._resolveLocaleFile = function (directory, locale) {
  var file = path.resolve(directory, './', locale + '.json')
  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
    // attempt fallback to language only
    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')
    if (this._fileExistsSync(languageFile)) file = languageFile
  }
  return file
}

// this only exists because fs.existsSync() "will be deprecated"
// see https://nodejs.org/api/fs.html#fs_fs_existssync_path
Y18N.prototype._fileExistsSync = function (file) {
  try {
    return fs.statSync(file).isFile()
  } catch (err) {
    return false
  }
}

Y18N.prototype.__n = function () {
  var args = Array.prototype.slice.call(arguments)
  var singular = args.shift()
  var plural = args.shift()
  var quantity = args.shift()

  var cb = function () {} // start with noop.
  if (typeof args[args.length - 1] === 'function') cb = args.pop()

  if (!this.cache[this.locale]) this._readLocaleFile()

  var str = quantity === 1 ? singular : plural
  if (this.cache[this.locale][singular]) {
    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']
  }

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][singular] && this.updateFiles) {
    this.cache[this.locale][singular] = {
      one: singular,
      other: plural
    }

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb])
  } else {
    cb()
  }

  // if a %d placeholder is provided, add quantity
  // to the arguments expanded by util.format.
  var values = [str]
  if (~str.indexOf('%d')) values.push(quantity)

  return util.format.apply(util, values.concat(args))
}

Y18N.prototype.setLocale = function (locale) {
  this.locale = locale
}

Y18N.prototype.getLocale = function () {
  return this.locale
}

Y18N.prototype.updateLocale = function (obj) {
  if (!this.cache[this.locale]) this._readLocaleFile()

  for (var key in obj) {
    this.cache[this.locale][key] = obj[key]
  }
}

module.exports = function (opts) {
  var y18n = new Y18N(opts)

  // bind all functions to y18n, so that
  // they can be used in isolation.
  for (var key in y18n) {
    if (typeof y18n[key] === 'function') {
      y18n[key] = y18n[key].bind(y18n)
    }
  }

  return y18n
}


/***/ }),

/***/ "../../node_modules/yaeti/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/yaeti/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
	EventTarget : __webpack_require__(/*! ./lib/EventTarget */ "../../node_modules/yaeti/lib/EventTarget.js"),
	Event       : __webpack_require__(/*! ./lib/Event */ "../../node_modules/yaeti/lib/Event.js")
};


/***/ }),

/***/ "../../node_modules/yaeti/lib/Event.js":
/*!*********************************************!*\
  !*** ../../node_modules/yaeti/lib/Event.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Expose the Event class.
 */
module.exports = _Event;


function _Event(type) {
	this.type = type;
	this.isTrusted = false;

	// Set a flag indicating this is not a DOM Event object
	this._yaeti = true;
}


/***/ }),

/***/ "../../node_modules/yaeti/lib/EventTarget.js":
/*!***************************************************!*\
  !*** ../../node_modules/yaeti/lib/EventTarget.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Expose the _EventTarget class.
 */
module.exports = _EventTarget;

function _EventTarget() {
	// Do nothing if called for a native EventTarget object..
	if (typeof this.addEventListener === 'function') {
		return;
	}

	this._listeners = {};

	this.addEventListener = _addEventListener;
	this.removeEventListener = _removeEventListener;
	this.dispatchEvent = _dispatchEvent;
}

Object.defineProperties(_EventTarget.prototype, {
	listeners: {
		get: function () {
			return this._listeners;
		}
	}
});

function _addEventListener(type, newListener) {
	var
		listenersType,
		i, listener;

	if (!type || !newListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		this._listeners[type] = listenersType = [];
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === newListener) {
			return;
		}
	}

	listenersType.push(newListener);
}

function _removeEventListener(type, oldListener) {
	var
		listenersType,
		i, listener;

	if (!type || !oldListener) {
		return;
	}

	listenersType = this._listeners[type];
	if (listenersType === undefined) {
		return;
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (listener === oldListener) {
			listenersType.splice(i, 1);
			break;
		}
	}

	if (listenersType.length === 0) {
		delete this._listeners[type];
	}
}

function _dispatchEvent(event) {
	var
		type,
		listenersType,
		dummyListener,
		stopImmediatePropagation = false,
		i, listener;

	if (!event || typeof event.type !== 'string') {
		throw new Error('`event` must have a valid `type` property');
	}

	// Do some stuff to emulate DOM Event behavior (just if this is not a
	// DOM Event object)
	if (event._yaeti) {
		event.target = this;
		event.cancelable = true;
	}

	// Attempt to override the stopImmediatePropagation() method
	try {
		event.stopImmediatePropagation = function () {
			stopImmediatePropagation = true;
		};
	} catch (error) {}

	type = event.type;
	listenersType = (this._listeners[type] || []);

	dummyListener = this['on' + type];
	if (typeof dummyListener === 'function') {
		dummyListener.call(this, event);
	}

	for (i = 0; !!(listener = listenersType[i]); i++) {
		if (stopImmediatePropagation) {
			break;
		}

		listener.call(this, event);
	}

	return !event.defaultPrevented;
}


/***/ }),

/***/ "../../node_modules/yargs/index.js":
/*!*****************************************!*\
  !*** ../../node_modules/yargs/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// classic singleton yargs API, to use yargs
// without running as a singleton do:
// require('yargs/yargs')(process.argv.slice(2))
const yargs = __webpack_require__(/*! ./yargs */ "../../node_modules/yargs/yargs.js")

Argv(process.argv.slice(2))

module.exports = Argv

function Argv (processArgs, cwd) {
  const argv = yargs(processArgs, cwd, __webpack_require__("../../node_modules/yargs sync recursive"))
  singletonify(argv)
  return argv
}

/*  Hack an instance of Argv with process.argv into Argv
    so people can do
    require('yargs')(['--beeble=1','-z','zizzle']).argv
    to parse a list of args and
    require('yargs').argv
    to get a parsed version of process.argv.
*/
function singletonify (inst) {
  Object.keys(inst).forEach((key) => {
    if (key === 'argv') {
      Argv.__defineGetter__(key, inst.__lookupGetter__(key))
    } else {
      Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]
    }
  })
}


/***/ }),

/***/ "../../node_modules/yargs/lib/apply-extends.js":
/*!*****************************************************!*\
  !*** ../../node_modules/yargs/lib/apply-extends.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! fs */ "fs")
const path = __webpack_require__(/*! path */ "path")
const YError = __webpack_require__(/*! ./yerror */ "../../node_modules/yargs/lib/yerror.js")

let previouslyVisitedConfigs = []

function checkForCircularExtends (cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`)
  }
}

function getPathToDefaultConfig (cwd, pathToExtend) {
  return path.resolve(cwd, pathToExtend)
}

function applyExtends (config, cwd) {
  let defaultConfig = {}

  if (config.hasOwnProperty('extends')) {
    if (typeof config.extends !== 'string') return defaultConfig
    const isPath = /\.json|\..*rc$/.test(config.extends)
    let pathToDefault = null
    if (!isPath) {
      try {
        pathToDefault = /*require.resolve*/(__webpack_require__("../../node_modules/yargs/lib sync recursive").resolve(config.extends))
      } catch (err) {
        // most likely this simply isn't a module.
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends)
    }
    // maybe the module uses key for some other reason,
    // err on side of caution.
    if (!pathToDefault && !isPath) return config

    checkForCircularExtends(pathToDefault)

    previouslyVisitedConfigs.push(pathToDefault)

    defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : __webpack_require__("../../node_modules/yargs/lib sync recursive")(config.extends)
    delete config.extends
    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault))
  }

  previouslyVisitedConfigs = []

  return Object.assign({}, defaultConfig, config)
}

module.exports = applyExtends


/***/ }),

/***/ "../../node_modules/yargs/lib/argsert.js":
/*!***********************************************!*\
  !*** ../../node_modules/yargs/lib/argsert.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// hoisted due to circular dependency on command.
module.exports = argsert
const command = __webpack_require__(/*! ./command */ "../../node_modules/yargs/lib/command.js")()
const YError = __webpack_require__(/*! ./yerror */ "../../node_modules/yargs/lib/yerror.js")

const positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']
function argsert (expected, callerArguments, length) {
  // TODO: should this eventually raise an exception.
  try {
    // preface the argument description with "cmd", so
    // that we can run it through yargs' command parser.
    let position = 0
    let parsed = { demanded: [], optional: [] }
    if (typeof expected === 'object') {
      length = callerArguments
      callerArguments = expected
    } else {
      parsed = command.parseCommand(`cmd ${expected}`)
    }
    const args = [].slice.call(callerArguments)

    while (args.length && args[args.length - 1] === undefined) args.pop()
    length = length || args.length

    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`)
    }

    const totalCommands = parsed.demanded.length + parsed.optional.length
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`)
    }

    parsed.demanded.forEach((demanded) => {
      const arg = args.shift()
      const observedType = guessType(arg)
      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*')
      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false)
      position += 1
    })

    parsed.optional.forEach((optional) => {
      if (args.length === 0) return
      const arg = args.shift()
      const observedType = guessType(arg)
      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*')
      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true)
      position += 1
    })
  } catch (err) {
    console.warn(err.stack)
  }
}

function guessType (arg) {
  if (Array.isArray(arg)) {
    return 'array'
  } else if (arg === null) {
    return 'null'
  }
  return typeof arg
}

function argumentTypeError (observedType, allowedTypes, position, optional) {
  throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`)
}


/***/ }),

/***/ "../../node_modules/yargs/lib/command.js":
/*!***********************************************!*\
  !*** ../../node_modules/yargs/lib/command.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const inspect = (__webpack_require__(/*! util */ "util").inspect)
const isPromise = __webpack_require__(/*! ./is-promise */ "../../node_modules/yargs/lib/is-promise.js")
const { applyMiddleware, commandMiddlewareFactory } = __webpack_require__(/*! ./middleware */ "../../node_modules/yargs/lib/middleware.js")
const path = __webpack_require__(/*! path */ "path")
const Parser = __webpack_require__(/*! yargs-parser */ "../../node_modules/yargs/node_modules/yargs-parser/index.js")

const DEFAULT_MARKER = /(^\*)|(^\$0)/

// handles parsing positional arguments,
// and populating argv with said positional
// arguments.
module.exports = function command (yargs, usage, validation, globalMiddleware) {
  const self = {}
  let handlers = {}
  let aliasMap = {}
  let defaultCommand
  globalMiddleware = globalMiddleware || []

  self.addHandler = function addHandler (cmd, description, builder, handler, commandMiddleware) {
    let aliases = []
    const middlewares = commandMiddlewareFactory(commandMiddleware)
    handler = handler || (() => {})

    if (Array.isArray(cmd)) {
      aliases = cmd.slice(1)
      cmd = cmd[0]
    } else if (typeof cmd === 'object') {
      let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)
      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)
      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares)
      return
    }

    // allow a module to be provided instead of separate builder and handler
    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {
      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares)
      return
    }

    // parse positionals out of cmd string
    const parsedCommand = self.parseCommand(cmd)

    // remove positional args from aliases only
    aliases = aliases.map(alias => self.parseCommand(alias).cmd)

    // check for default and filter out '*''
    let isDefault = false
    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
      if (DEFAULT_MARKER.test(c)) {
        isDefault = true
        return false
      }
      return true
    })

    // standardize on $0 for default command.
    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0')

    // shift cmd and aliases after filtering out '*'
    if (isDefault) {
      parsedCommand.cmd = parsedAliases[0]
      aliases = parsedAliases.slice(1)
      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)
    }

    // populate aliasMap
    aliases.forEach((alias) => {
      aliasMap[alias] = parsedCommand.cmd
    })

    if (description !== false) {
      usage.command(cmd, description, isDefault, aliases)
    }

    handlers[parsedCommand.cmd] = {
      original: cmd,
      description: description,
      handler,
      builder: builder || {},
      middlewares: middlewares || [],
      demanded: parsedCommand.demanded,
      optional: parsedCommand.optional
    }

    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]
  }

  self.addDirectory = function addDirectory (dir, context, req, callerFile, opts) {
    opts = opts || {}
    // disable recursion to support nested directories of subcommands
    if (typeof opts.recurse !== 'boolean') opts.recurse = false
    // exclude 'json', 'coffee' from require-directory defaults
    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']
    // allow consumer to define their own visitor function
    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o
    // call addHandler via visitor function
    opts.visit = function visit (obj, joined, filename) {
      const visited = parentVisit(obj, joined, filename)
      // allow consumer to skip modules with their own visitor
      if (visited) {
        // check for cyclic reference
        // each command file path should only be seen once per execution
        if (~context.files.indexOf(joined)) return visited
        // keep track of visited files in context.files
        context.files.push(joined)
        self.addHandler(visited)
      }
      return visited
    }
    __webpack_require__(/*! require-directory */ "../../node_modules/require-directory/index.js")({ require: req, filename: callerFile }, dir, opts)
  }

  // lookup module object from require()d command and derive name
  // if module was not require()d and no name given, throw error
  function moduleName (obj) {
    const mod = __webpack_require__(/*! which-module */ "../../node_modules/which-module/index.js")(obj)
    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`)
    return commandFromFilename(mod.filename)
  }

  // derive command name from filename
  function commandFromFilename (filename) {
    return path.basename(filename, path.extname(filename))
  }

  function extractDesc (obj) {
    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {
      test = obj[keys[i]]
      if (typeof test === 'string' || typeof test === 'boolean') return test
    }
    return false
  }

  self.parseCommand = function parseCommand (cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ')
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/)
    const bregex = /\.*[\][<>]/g
    const parsedCommand = {
      cmd: (splitCommand.shift()).replace(bregex, ''),
      demanded: [],
      optional: []
    }
    splitCommand.forEach((cmd, i) => {
      let variadic = false
      cmd = cmd.replace(/\s/g, '')
      if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true
      if (/^\[/.test(cmd)) {
        parsedCommand.optional.push({
          cmd: cmd.replace(bregex, '').split('|'),
          variadic
        })
      } else {
        parsedCommand.demanded.push({
          cmd: cmd.replace(bregex, '').split('|'),
          variadic
        })
      }
    })
    return parsedCommand
  }

  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap))

  self.getCommandHandlers = () => handlers

  self.hasDefaultCommand = () => !!defaultCommand

  self.runCommand = function runCommand (command, yargs, parsed, commandIndex) {
    let aliases = parsed.aliases
    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand
    const currentContext = yargs.getContext()
    let numFiles = currentContext.files.length
    const parentCommands = currentContext.commands.slice()

    // what does yargs look like after the buidler is run?
    let innerArgv = parsed.argv
    let innerYargs = null
    let positionalMap = {}
    if (command) {
      currentContext.commands.push(command)
      currentContext.fullCommands.push(commandHandler.original)
    }
    if (typeof commandHandler.builder === 'function') {
      // a function can be provided, which builds
      // up a yargs chain and possibly returns it.
      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))
      // if the builder function did not yet parse argv with reset yargs
      // and did not explicitly set a usage() string, then apply the
      // original command string as usage() for consistent behavior with
      // options object below.
      if (yargs.parsed === false) {
        if (shouldUpdateUsage(yargs)) {
          yargs.getUsageInstance().usage(
            usageFromParentCommandsCommandHandler(parentCommands, commandHandler),
            commandHandler.description
          )
        }
        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)
      } else {
        innerArgv = yargs.parsed.argv
      }

      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases
      else aliases = yargs.parsed.aliases
    } else if (typeof commandHandler.builder === 'object') {
      // as a short hand, an object can instead be provided, specifying
      // the options that a command takes.
      innerYargs = yargs.reset(parsed.aliases)
      if (shouldUpdateUsage(innerYargs)) {
        innerYargs.getUsageInstance().usage(
          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),
          commandHandler.description
        )
      }
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, commandHandler.builder[key])
      })
      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)
      aliases = innerYargs.parsed.aliases
    }

    if (!yargs._hasOutput()) {
      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)
    }

    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || [])
    applyMiddleware(innerArgv, yargs, middlewares, true)

    // we apply validation post-hoc, so that custom
    // checks get passed populated positional arguments.
    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)

    if (commandHandler.handler && !yargs._hasOutput()) {
      yargs._setHasOutput()

      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false)

      const handlerResult = isPromise(innerArgv)
        ? innerArgv.then(argv => commandHandler.handler(argv))
        : commandHandler.handler(innerArgv)

      if (isPromise(handlerResult)) {
        handlerResult.catch(error =>
          yargs.getUsageInstance().fail(null, error)
        )
      }
    }

    if (command) {
      currentContext.commands.pop()
      currentContext.fullCommands.pop()
    }
    numFiles = currentContext.files.length - numFiles
    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)

    return innerArgv
  }

  function shouldUpdateUsage (yargs) {
    return !yargs.getUsageInstance().getUsageDisabled() &&
      yargs.getUsageInstance().getUsage().length === 0
  }

  function usageFromParentCommandsCommandHandler (parentCommands, commandHandler) {
    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original
    const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c) })
    pc.push(c)
    return `$0 ${pc.join(' ')}`
  }

  self.runDefaultBuilderOn = function (yargs) {
    if (shouldUpdateUsage(yargs)) {
      // build the root-level command string from the default string.
      const commandString = DEFAULT_MARKER.test(defaultCommand.original)
        ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ')
      yargs.getUsageInstance().usage(
        commandString,
        defaultCommand.description
      )
    }
    const builder = defaultCommand.builder
    if (typeof builder === 'function') {
      builder(yargs)
    } else {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key])
      })
    }
  }

  // transcribe all positional arguments "command <foo> <bar> [apple]"
  // onto argv.
  function populatePositionals (commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length) // nuke the current commands
    const demanded = commandHandler.demanded.slice(0)
    const optional = commandHandler.optional.slice(0)
    const positionalMap = {}

    validation.positionalCount(demanded.length, argv._.length)

    while (demanded.length) {
      const demand = demanded.shift()
      populatePositional(demand, argv, positionalMap)
    }

    while (optional.length) {
      const maybe = optional.shift()
      populatePositional(maybe, argv, positionalMap)
    }

    argv._ = context.commands.concat(argv._)

    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original))

    return positionalMap
  }

  function populatePositional (positional, argv, positionalMap, parseOptions) {
    const cmd = positional.cmd[0]
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String)
    } else {
      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())]
    }
  }

  // we run yargs-parser against the positional arguments
  // applying the same parsing logic used for flags.
  function postProcessPositionals (argv, positionalMap, parseOptions) {
    // combine the parsing hints we've inferred from the command
    // string with explicitly configured parsing hints.
    const options = Object.assign({}, yargs.getOptions())
    options.default = Object.assign(parseOptions.default, options.default)
    options.alias = Object.assign(parseOptions.alias, options.alias)
    options.array = options.array.concat(parseOptions.array)
    delete options.config //  don't load config when processing positionals.

    const unparsed = []
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value) => {
        unparsed.push(`--${key}`)
        unparsed.push(value)
      })
    })

    // short-circuit parse.
    if (!unparsed.length) return

    const parsed = Parser.detailed(unparsed, options)

    if (parsed.error) {
      yargs.getUsageInstance().fail(parsed.error.message, parsed.error)
    } else {
      // only copy over positional keys (don't overwrite
      // flag arguments that were already parsed).
      const positionalKeys = Object.keys(positionalMap)
      Object.keys(positionalMap).forEach((key) => {
        [].push.apply(positionalKeys, parsed.aliases[key])
      })

      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.indexOf(key) !== -1) {
          // any new aliases need to be placed in positionalMap, which
          // is used for validation.
          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key]
          argv[key] = parsed.argv[key]
        }
      })
    }
  }

  self.cmdToParseOptions = function (cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {}
    }

    const parsed = self.parseCommand(cmdString)
    parsed.demanded.forEach((d) => {
      const cmds = d.cmd.slice(0)
      const cmd = cmds.shift()
      if (d.variadic) {
        parseOptions.array.push(cmd)
        parseOptions.default[cmd] = []
      }
      cmds.forEach((c) => {
        parseOptions.alias[cmd] = c
      })
      parseOptions.demand[cmd] = true
    })

    parsed.optional.forEach((o) => {
      const cmds = o.cmd.slice(0)
      const cmd = cmds.shift()
      if (o.variadic) {
        parseOptions.array.push(cmd)
        parseOptions.default[cmd] = []
      }
      cmds.forEach((c) => {
        parseOptions.alias[cmd] = c
      })
    })

    return parseOptions
  }

  self.reset = () => {
    handlers = {}
    aliasMap = {}
    defaultCommand = undefined
    return self
  }

  // used by yargs.parse() to freeze
  // the state of commands such that
  // we can apply .parse() multiple times
  // with the same yargs instance.
  let frozen
  self.freeze = () => {
    frozen = {}
    frozen.handlers = handlers
    frozen.aliasMap = aliasMap
    frozen.defaultCommand = defaultCommand
  }
  self.unfreeze = () => {
    handlers = frozen.handlers
    aliasMap = frozen.aliasMap
    defaultCommand = frozen.defaultCommand
    frozen = undefined
  }

  return self
}


/***/ }),

/***/ "../../node_modules/yargs/lib/completion-templates.js":
/*!************************************************************!*\
  !*** ../../node_modules/yargs/lib/completion-templates.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.completionShTemplate =
`###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`

exports.completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`


/***/ }),

/***/ "../../node_modules/yargs/lib/completion.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/completion.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path")

// add bash completions to your
//  yargs-powered applications.
module.exports = function completion (yargs, usage, command) {
  const self = {
    completionKey: 'get-yargs-completions'
  }

  const zshShell = process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1
  // get a list of completion commands.
  // 'args' is the array of strings from the line to be completed
  self.getCompletion = function getCompletion (args, done) {
    const completions = []
    const current = args.length ? args[args.length - 1] : ''
    const argv = yargs.parse(args, true)
    const aliases = yargs.parsed.aliases
    const parentCommands = yargs.getContext().commands

    // a custom completion function can be provided
    // to completion().
    if (completionFunction) {
      if (completionFunction.length < 3) {
        const result = completionFunction(current, argv)

        // promise based completion function.
        if (typeof result.then === 'function') {
          return result.then((list) => {
            process.nextTick(() => { done(list) })
          }).catch((err) => {
            process.nextTick(() => { throw err })
          })
        }

        // synchronous completion function.
        return done(result)
      } else {
        // asynchronous completion function
        return completionFunction(current, argv, (completions) => {
          done(completions)
        })
      }
    }

    const handlers = command.getCommandHandlers()
    for (let i = 0, ii = args.length; i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder
        if (typeof builder === 'function') {
          const y = yargs.reset()
          builder(y)
          return y.argv
        }
      }
    }

    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
      usage.getCommands().forEach((usageCommand) => {
        const commandName = command.parseCommand(usageCommand[0]).cmd
        if (args.indexOf(commandName) === -1) {
          if (!zshShell) {
            completions.push(commandName)
          } else {
            const desc = usageCommand[1] || ''
            completions.push(commandName.replace(/:/g, '\\:') + ':' + desc)
          }
        }
      })
    }

    if (current.match(/^-/) || (current === '' && completions.length === 0)) {
      const descs = usage.getDescriptions()
      Object.keys(yargs.getOptions().key).forEach((key) => {
        // If the key and its aliases aren't in 'args', add the key to 'completions'
        const keyAndAliases = [key].concat(aliases[key] || [])
        const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1)
        if (notInArgs) {
          if (!zshShell) {
            completions.push(`--${key}`)
          } else {
            const desc = descs[key] || ''
            completions.push(`--${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '')}`)
          }
        }
      })
    }

    done(completions)
  }

  // generate the completion script to add to your .bashrc.
  self.generateCompletionScript = function generateCompletionScript ($0, cmd) {
    const templates = __webpack_require__(/*! ./completion-templates */ "../../node_modules/yargs/lib/completion-templates.js")
    let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate
    const name = path.basename($0)

    // add ./to applications not yet installed as bin.
    if ($0.match(/\.js$/)) $0 = `./${$0}`

    script = script.replace(/{{app_name}}/g, name)
    script = script.replace(/{{completion_command}}/g, cmd)
    return script.replace(/{{app_path}}/g, $0)
  }

  // register a function to perform your own custom
  // completions., this function can be either
  // synchrnous or asynchronous.
  let completionFunction = null
  self.registerFunction = (fn) => {
    completionFunction = fn
  }

  return self
}


/***/ }),

/***/ "../../node_modules/yargs/lib/decamelize.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/decamelize.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


module.exports = (text, separator) => {
  separator = typeof separator === 'undefined' ? '_' : separator

  return text
    .replace(/([a-z\d])([A-Z])/g, `$1${separator}$2`)
    .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, `$1${separator}$2`)
    .toLowerCase()
}


/***/ }),

/***/ "../../node_modules/yargs/lib/is-promise.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/is-promise.js ***!
  \**************************************************/
/***/ ((module) => {

module.exports = function isPromise (maybePromise) {
  return maybePromise instanceof Promise
}


/***/ }),

/***/ "../../node_modules/yargs/lib/levenshtein.js":
/*!***************************************************!*\
  !*** ../../node_modules/yargs/lib/levenshtein.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
/*
Copyright (c) 2011 Andrei Mackenzie

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// levenshtein distance algorithm, pulled from Andrei Mackenzie's MIT licensed.
// gist, which can be found here: https://gist.github.com/andrei-m/982927

// Compute the edit distance between the two given strings
module.exports = function levenshtein (a, b) {
  if (a.length === 0) return b.length
  if (b.length === 0) return a.length

  const matrix = []

  // increment along the first column of each row
  let i
  for (i = 0; i <= b.length; i++) {
    matrix[i] = [i]
  }

  // increment each column in the first row
  let j
  for (j = 0; j <= a.length; j++) {
    matrix[0][j] = j
  }

  // Fill in the rest of the matrix
  for (i = 1; i <= b.length; i++) {
    for (j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1]
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
          Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)) // deletion
      }
    }
  }

  return matrix[b.length][a.length]
}


/***/ }),

/***/ "../../node_modules/yargs/lib/middleware.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/middleware.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// hoisted due to circular dependency on command.
module.exports = {
  applyMiddleware,
  commandMiddlewareFactory,
  globalMiddlewareFactory
}
const isPromise = __webpack_require__(/*! ./is-promise */ "../../node_modules/yargs/lib/is-promise.js")
const argsert = __webpack_require__(/*! ./argsert */ "../../node_modules/yargs/lib/argsert.js")

function globalMiddlewareFactory (globalMiddleware, context) {
  return function (callback, applyBeforeValidation = false) {
    argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length)
    if (Array.isArray(callback)) {
      for (let i = 0; i < callback.length; i++) {
        if (typeof callback[i] !== 'function') {
          throw Error('middleware must be a function')
        }
        callback[i].applyBeforeValidation = applyBeforeValidation
      }
      Array.prototype.push.apply(globalMiddleware, callback)
    } else if (typeof callback === 'function') {
      callback.applyBeforeValidation = applyBeforeValidation
      globalMiddleware.push(callback)
    }
    return context
  }
}

function commandMiddlewareFactory (commandMiddleware) {
  if (!commandMiddleware) return []
  return commandMiddleware.map(middleware => {
    middleware.applyBeforeValidation = false
    return middleware
  })
}

function applyMiddleware (argv, yargs, middlewares, beforeValidation) {
  const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true')
  return middlewares
    .reduce((accumulation, middleware) => {
      if (middleware.applyBeforeValidation !== beforeValidation &&
          !isPromise(accumulation)) {
        return accumulation
      }

      if (isPromise(accumulation)) {
        return accumulation
          .then(initialObj =>
            Promise.all([initialObj, middleware(initialObj, yargs)])
          )
          .then(([initialObj, middlewareObj]) =>
            Object.assign(initialObj, middlewareObj)
          )
      } else {
        const result = middleware(argv, yargs)
        if (beforeValidation && isPromise(result)) throw beforeValidationError

        return isPromise(result)
          ? result.then(middlewareObj => Object.assign(accumulation, middlewareObj))
          : Object.assign(accumulation, result)
      }
    }, argv)
}


/***/ }),

/***/ "../../node_modules/yargs/lib/obj-filter.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/obj-filter.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";

module.exports = function objFilter (original, filter) {
  const obj = {}
  filter = filter || ((k, v) => true)
  Object.keys(original || {}).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key]
    }
  })
  return obj
}


/***/ }),

/***/ "../../node_modules/yargs/lib/usage.js":
/*!*********************************************!*\
  !*** ../../node_modules/yargs/lib/usage.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// this file handles outputting usage instructions,
// failures, etc. keeps logging in one place.
const decamelize = __webpack_require__(/*! ./decamelize */ "../../node_modules/yargs/lib/decamelize.js")
const stringWidth = __webpack_require__(/*! string-width */ "../../node_modules/yargs/node_modules/string-width/index.js")
const objFilter = __webpack_require__(/*! ./obj-filter */ "../../node_modules/yargs/lib/obj-filter.js")
const path = __webpack_require__(/*! path */ "path")
const setBlocking = __webpack_require__(/*! set-blocking */ "../../node_modules/set-blocking/index.js")
const YError = __webpack_require__(/*! ./yerror */ "../../node_modules/yargs/lib/yerror.js")

module.exports = function usage (yargs, y18n) {
  const __ = y18n.__
  const self = {}

  // methods for ouputting/building failure message.
  const fails = []
  self.failFn = function failFn (f) {
    fails.push(f)
  }

  let failMessage = null
  let showHelpOnFail = true
  self.showHelpOnFail = function showHelpOnFailFn (enabled, message) {
    if (typeof enabled === 'string') {
      message = enabled
      enabled = true
    } else if (typeof enabled === 'undefined') {
      enabled = true
    }
    failMessage = message
    showHelpOnFail = enabled
    return self
  }

  let failureOutput = false
  self.fail = function fail (msg, err) {
    const logger = yargs._getLoggerInstance()

    if (fails.length) {
      for (let i = fails.length - 1; i >= 0; --i) {
        fails[i](msg, err, self)
      }
    } else {
      if (yargs.getExitProcess()) setBlocking(true)

      // don't output failure message more than once
      if (!failureOutput) {
        failureOutput = true
        if (showHelpOnFail) {
          yargs.showHelp('error')
          logger.error()
        }
        if (msg || err) logger.error(msg || err)
        if (failMessage) {
          if (msg || err) logger.error('')
          logger.error(failMessage)
        }
      }

      err = err || new YError(msg)
      if (yargs.getExitProcess()) {
        return yargs.exit(1)
      } else if (yargs._hasParseCallback()) {
        return yargs.exit(1, err)
      } else {
        throw err
      }
    }
  }

  // methods for ouputting/building help (usage) message.
  let usages = []
  let usageDisabled = false
  self.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true
      usages = []
      return
    }
    usageDisabled = false
    usages.push([msg, description || ''])
    return self
  }
  self.getUsage = () => {
    return usages
  }
  self.getUsageDisabled = () => {
    return usageDisabled
  }

  self.getPositionalGroupName = () => {
    return __('Positionals:')
  }

  let examples = []
  self.example = (cmd, description) => {
    examples.push([cmd, description || ''])
  }

  let commands = []
  self.command = function command (cmd, description, isDefault, aliases) {
    // the last default wins, so cancel out any previously set default
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false
        return cmdArray
      })
    }
    commands.push([cmd, description || '', isDefault, aliases])
  }
  self.getCommands = () => commands

  let descriptions = {}
  self.describe = function describe (key, desc) {
    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self.describe(k, key[k])
      })
    } else {
      descriptions[key] = desc
    }
  }
  self.getDescriptions = () => descriptions

  let epilog
  self.epilog = (msg) => {
    epilog = msg
  }

  let wrapSet = false
  let wrap
  self.wrap = (cols) => {
    wrapSet = true
    wrap = cols
  }

  function getWrap () {
    if (!wrapSet) {
      wrap = windowWidth()
      wrapSet = true
    }

    return wrap
  }

  const deferY18nLookupPrefix = '__yargsString__:'
  self.deferY18nLookup = str => deferY18nLookupPrefix + str

  const defaultGroup = 'Options:'
  self.help = function help () {
    normalizeAliases()

    // handle old demanded API
    const base$0 = path.basename(yargs.$0)
    const demandedOptions = yargs.getDemandedOptions()
    const demandedCommands = yargs.getDemandedCommands()
    const groups = yargs.getGroups()
    const options = yargs.getOptions()

    let keys = []
    keys = keys.concat(Object.keys(descriptions))
    keys = keys.concat(Object.keys(demandedOptions))
    keys = keys.concat(Object.keys(demandedCommands))
    keys = keys.concat(Object.keys(options.default))
    keys = keys.filter(filterHiddenOptions)
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== '_') acc[key] = true
      return acc
    }, {}))

    const theWrap = getWrap()
    const ui = __webpack_require__(/*! cliui */ "../../node_modules/yargs/node_modules/cliui/index.js")({
      width: theWrap,
      wrap: !!theWrap
    })

    // the usage string.
    if (!usageDisabled) {
      if (usages.length) {
        // user-defined usage.
        usages.forEach((usage) => {
          ui.div(`${usage[0].replace(/\$0/g, base$0)}`)
          if (usage[1]) {
            ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] })
          }
        })
        ui.div()
      } else if (commands.length) {
        let u = null
        // demonstrate how commands are used.
        if (demandedCommands._) {
          u = `${base$0} <${__('command')}>\n`
        } else {
          u = `${base$0} [${__('command')}]\n`
        }
        ui.div(`${u}`)
      }
    }

    // your application's commands, i.e., non-option
    // arguments populated in '_'.
    if (commands.length) {
      ui.div(__('Commands:'))

      const context = yargs.getContext()
      const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : ''

      if (yargs.getParserConfiguration()['sort-commands'] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]))
      }

      commands.forEach((command) => {
        const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\$0 ?/, '')}` // drop $0 from default commands.
        ui.span(
          {
            text: commandString,
            padding: [0, 2, 0, 2],
            width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
          },
          { text: command[1] }
        )
        const hints = []
        if (command[2]) hints.push(`[${__('default:').slice(0, -1)}]`) // TODO hacking around i18n here
        if (command[3] && command[3].length) {
          hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`)
        }
        if (hints.length) {
          ui.div({ text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right' })
        } else {
          ui.div()
        }
      })

      ui.div()
    }

    // perform some cleanup on the keys array, making it
    // only include top-level keys not their aliases.
    const aliasKeys = (Object.keys(options.alias) || [])
      .concat(Object.keys(yargs.parsed.newAliases) || [])

    keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1))

    // populate 'Options:' group with any keys that have not
    // explicitly had a group set.
    if (!groups[defaultGroup]) groups[defaultGroup] = []
    addUngroupedKeys(keys, options.alias, groups)

    // display 'Options:' table along with any custom tables:
    Object.keys(groups).forEach((groupName) => {
      if (!groups[groupName].length) return

      // if we've grouped the key 'f', but 'f' aliases 'foobar',
      // normalizedKeys should contain only 'foobar'.
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (~aliasKeys.indexOf(key)) return key
        for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey
        }
        return key
      })

      if (normalizedKeys.length < 1) return

      ui.div(__(groupName))

      // actually generate the switches string --foo, -f, --bar.
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [ key ].concat(options.alias[key] || [])
          .map(sw => {
            // for the special positional group don't
            // add '--' or '-' prefix.
            if (groupName === self.getPositionalGroupName()) return sw
            else return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')

        return acc
      }, {})

      normalizedKeys.forEach((key) => {
        const kswitch = switches[key]
        let desc = descriptions[key] || ''
        let type = null

        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))

        if (~options.boolean.indexOf(key)) type = `[${__('boolean')}]`
        if (~options.count.indexOf(key)) type = `[${__('count')}]`
        if (~options.string.indexOf(key)) type = `[${__('string')}]`
        if (~options.normalize.indexOf(key)) type = `[${__('string')}]`
        if (~options.array.indexOf(key)) type = `[${__('array')}]`
        if (~options.number.indexOf(key)) type = `[${__('number')}]`

        const extra = [
          type,
          (key in demandedOptions) ? `[${__('required')}]` : null,
          options.choices && options.choices[key] ? `[${__('choices:')} ${
            self.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(' ')

        ui.span(
          { text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 },
          desc
        )

        if (extra) ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' })
        else ui.div()
      })

      ui.div()
    })

    // describe some common use-cases for your application.
    if (examples.length) {
      ui.div(__('Examples:'))

      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0)
      })

      examples.forEach((example) => {
        if (example[1] === '') {
          ui.div(
            {
              text: example[0],
              padding: [0, 2, 0, 2]
            }
          )
        } else {
          ui.div(
            {
              text: example[0],
              padding: [0, 2, 0, 2],
              width: maxWidth(examples, theWrap) + 4
            }, {
              text: example[1]
            }
          )
        }
      })

      ui.div()
    }

    // the usage string.
    if (epilog) {
      const e = epilog.replace(/\$0/g, base$0)
      ui.div(`${e}\n`)
    }

    // Remove the trailing white spaces
    return ui.toString().replace(/\s*$/, '')
  }

  // return the maximum width of a string
  // in the left-hand column of a table.
  function maxWidth (table, theWrap, modifier) {
    let width = 0

    // table might be of the form [leftColumn],
    // or {key: leftColumn}
    if (!Array.isArray(table)) {
      table = Object.keys(table).map(key => [table[key]])
    }

    table.forEach((v) => {
      width = Math.max(
        stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]),
        width
      )
    })

    // if we've enabled 'wrap' we should limit
    // the max-width of the left-column.
    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10))

    return width
  }

  // make sure any options set for aliases,
  // are copied to the keys being aliased.
  function normalizeAliases () {
    // handle old demanded API
    const demandedOptions = yargs.getDemandedOptions()
    const options = yargs.getOptions()

    ;(Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        // copy descriptions.
        if (descriptions[alias]) self.describe(key, descriptions[alias])
        // copy demanded.
        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias])
        // type messages.
        if (~options.boolean.indexOf(alias)) yargs.boolean(key)
        if (~options.count.indexOf(alias)) yargs.count(key)
        if (~options.string.indexOf(alias)) yargs.string(key)
        if (~options.normalize.indexOf(alias)) yargs.normalize(key)
        if (~options.array.indexOf(alias)) yargs.array(key)
        if (~options.number.indexOf(alias)) yargs.number(key)
      })
    })
  }

  // given a set of keys, place any keys that are
  // ungrouped under the 'Options:' grouping.
  function addUngroupedKeys (keys, aliases, groups) {
    let groupedKeys = []
    let toCheck = null
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group])
    })

    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key])
      if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key)
      }
    })
    return groupedKeys
  }

  function filterHiddenOptions (key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt]
  }

  self.showHelp = (level) => {
    const logger = yargs._getLoggerInstance()
    if (!level) level = 'error'
    const emit = typeof level === 'function' ? level : logger[level]
    emit(self.help())
  }

  self.functionDescription = (fn) => {
    const description = fn.name ? decamelize(fn.name, '-') : __('generated-value')
    return ['(', description, ')'].join('')
  }

  self.stringifiedValues = function stringifiedValues (values, separator) {
    let string = ''
    const sep = separator || ', '
    const array = [].concat(values)

    if (!values || !array.length) return string

    array.forEach((value) => {
      if (string.length) string += sep
      string += JSON.stringify(value)
    })

    return string
  }

  // format the default-value-string displayed in
  // the right-hand column.
  function defaultString (value, defaultDescription) {
    let string = `[${__('default:')} `

    if (value === undefined && !defaultDescription) return null

    if (defaultDescription) {
      string += defaultDescription
    } else {
      switch (typeof value) {
        case 'string':
          string += `"${value}"`
          break
        case 'object':
          string += JSON.stringify(value)
          break
        default:
          string += value
      }
    }

    return `${string}]`
  }

  // guess the width of the console window, max-width 80.
  function windowWidth () {
    const maxWidth = 80
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
      return Math.min(maxWidth, process.stdout.columns)
    } else {
      return maxWidth
    }
  }

  // logic for displaying application version.
  let version = null
  self.version = (ver) => {
    version = ver
  }

  self.showVersion = () => {
    const logger = yargs._getLoggerInstance()
    logger.log(version)
  }

  self.reset = function reset (localLookup) {
    // do not reset wrap here
    // do not reset fails here
    failMessage = null
    failureOutput = false
    usages = []
    usageDisabled = false
    epilog = undefined
    examples = []
    commands = []
    descriptions = objFilter(descriptions, (k, v) => !localLookup[k])
    return self
  }

  let frozen
  self.freeze = function freeze () {
    frozen = {}
    frozen.failMessage = failMessage
    frozen.failureOutput = failureOutput
    frozen.usages = usages
    frozen.usageDisabled = usageDisabled
    frozen.epilog = epilog
    frozen.examples = examples
    frozen.commands = commands
    frozen.descriptions = descriptions
  }
  self.unfreeze = function unfreeze () {
    failMessage = frozen.failMessage
    failureOutput = frozen.failureOutput
    usages = frozen.usages
    usageDisabled = frozen.usageDisabled
    epilog = frozen.epilog
    examples = frozen.examples
    commands = frozen.commands
    descriptions = frozen.descriptions
    frozen = undefined
  }

  return self
}


/***/ }),

/***/ "../../node_modules/yargs/lib/validation.js":
/*!**************************************************!*\
  !*** ../../node_modules/yargs/lib/validation.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const argsert = __webpack_require__(/*! ./argsert */ "../../node_modules/yargs/lib/argsert.js")
const objFilter = __webpack_require__(/*! ./obj-filter */ "../../node_modules/yargs/lib/obj-filter.js")
const specialKeys = ['$0', '--', '_']

// validation-type-stuff, missing params,
// bad implications, custom checks.
module.exports = function validation (yargs, usage, y18n) {
  const __ = y18n.__
  const __n = y18n.__n
  const self = {}

  // validate appropriate # of non-option
  // arguments were provided, i.e., '_'.
  self.nonOptionCount = function nonOptionCount (argv) {
    const demandedCommands = yargs.getDemandedCommands()
    // don't count currently executing commands
    const _s = argv._.length - yargs.getContext().commands.length

    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage.fail(
            // replace $0 with observed, $1 with expected.
            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s).replace(/\$1/, demandedCommands._.min) : null
          )
        } else {
          usage.fail(
            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)
          )
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage.fail(
            // replace $0 with observed, $1 with expected.
            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s).replace(/\$1/, demandedCommands._.max) : null
          )
        } else {
          usage.fail(
            __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)
          )
        }
      }
    }
  }

  // validate the appropriate # of <required>
  // positional arguments were provided:
  self.positionalCount = function positionalCount (required, observed) {
    if (observed < required) {
      usage.fail(
        __('Not enough non-option arguments: got %s, need at least %s', observed, required)
      )
    }
  }

  // make sure all the required arguments are present.
  self.requiredArguments = function requiredArguments (argv) {
    const demandedOptions = yargs.getDemandedOptions()
    let missing = null

    Object.keys(demandedOptions).forEach((key) => {
      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {
        missing = missing || {}
        missing[key] = demandedOptions[key]
      }
    })

    if (missing) {
      const customMsgs = []
      Object.keys(missing).forEach((key) => {
        const msg = missing[key]
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg)
        }
      })

      const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : ''

      usage.fail(__n(
        'Missing required argument: %s',
        'Missing required arguments: %s',
        Object.keys(missing).length,
        Object.keys(missing).join(', ') + customMsg
      ))
    }
  }

  // check for unknown arguments (strict-mode).
  self.unknownArguments = function unknownArguments (argv, aliases, positionalMap) {
    const commandKeys = yargs.getCommandInstance().getCommands()
    const unknown = []
    const currentContext = yargs.getContext()

    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 &&
        !positionalMap.hasOwnProperty(key) &&
        !yargs._getParseContext().hasOwnProperty(key) &&
        !aliases.hasOwnProperty(key)
      ) {
        unknown.push(key)
      }
    })

    if (commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (commandKeys.indexOf(key) === -1) {
          unknown.push(key)
        }
      })
    }

    if (unknown.length > 0) {
      usage.fail(__n(
        'Unknown argument: %s',
        'Unknown arguments: %s',
        unknown.length,
        unknown.join(', ')
      ))
    }
  }

  // validate arguments limited to enumerated choices
  self.limitedChoices = function limitedChoices (argv) {
    const options = yargs.getOptions()
    const invalid = {}

    if (!Object.keys(options.choices).length) return

    Object.keys(argv).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 &&
        options.choices.hasOwnProperty(key)) {
        [].concat(argv[key]).forEach((value) => {
          // TODO case-insensitive configurability
          if (options.choices[key].indexOf(value) === -1 &&
              value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value)
          }
        })
      }
    })

    const invalidKeys = Object.keys(invalid)

    if (!invalidKeys.length) return

    let msg = __('Invalid values:')
    invalidKeys.forEach((key) => {
      msg += `\n  ${__(
        'Argument: %s, Given: %s, Choices: %s',
        key,
        usage.stringifiedValues(invalid[key]),
        usage.stringifiedValues(options.choices[key])
      )}`
    })
    usage.fail(msg)
  }

  // custom checks, added using the `check` option on yargs.
  let checks = []
  self.check = function check (f, global) {
    checks.push({
      func: f,
      global
    })
  }

  self.customChecks = function customChecks (argv, aliases) {
    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {
      const func = f.func
      let result = null
      try {
        result = func(argv, aliases)
      } catch (err) {
        usage.fail(err.message ? err.message : err, err)
        continue
      }

      if (!result) {
        usage.fail(__('Argument check failed: %s', func.toString()))
      } else if (typeof result === 'string' || result instanceof Error) {
        usage.fail(result.toString(), result)
      }
    }
  }

  // check implications, argument foo implies => argument bar.
  let implied = {}
  self.implies = function implies (key, value) {
    argsert('<string|object> [array|number|string]', [key, value], arguments.length)

    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self.implies(k, key[k])
      })
    } else {
      yargs.global(key)
      if (!implied[key]) {
        implied[key] = []
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self.implies(key, i))
      } else {
        implied[key].push(value)
      }
    }
  }
  self.getImplied = function getImplied () {
    return implied
  }

  self.implications = function implications (argv) {
    const implyFail = []

    Object.keys(implied).forEach((key) => {
      const origKey = key
      ;(implied[key] || []).forEach((value) => {
        let num
        let key = origKey
        const origValue = value

        // convert string '1' to number 1
        num = Number(key)
        key = isNaN(num) ? key : num

        if (typeof key === 'number') {
          // check length of argv._
          key = argv._.length >= key
        } else if (key.match(/^--no-.+/)) {
          // check if key doesn't exist
          key = key.match(/^--no-(.+)/)[1]
          key = !argv[key]
        } else {
          // check if key exists
          key = argv[key]
        }

        num = Number(value)
        value = isNaN(num) ? value : num

        if (typeof value === 'number') {
          value = argv._.length >= value
        } else if (value.match(/^--no-.+/)) {
          value = value.match(/^--no-(.+)/)[1]
          value = !argv[value]
        } else {
          value = argv[value]
        }
        if (key && !value) {
          implyFail.push(` ${origKey} -> ${origValue}`)
        }
      })
    })

    if (implyFail.length) {
      let msg = `${__('Implications failed:')}\n`

      implyFail.forEach((value) => {
        msg += (value)
      })

      usage.fail(msg)
    }
  }

  let conflicting = {}
  self.conflicts = function conflicts (key, value) {
    argsert('<string|object> [array|string]', [key, value], arguments.length)

    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self.conflicts(k, key[k])
      })
    } else {
      yargs.global(key)
      if (!conflicting[key]) {
        conflicting[key] = []
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self.conflicts(key, i))
      } else {
        conflicting[key].push(value)
      }
    }
  }
  self.getConflicting = () => conflicting

  self.conflicting = function conflictingFn (argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value) => {
          // we default keys to 'undefined' that have been configured, we should not
          // apply conflicting check unless they are a value other than 'undefined'.
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value))
          }
        })
      }
    })
  }

  self.recommendCommands = function recommendCommands (cmd, potentialCommands) {
    const distance = __webpack_require__(/*! ./levenshtein */ "../../node_modules/yargs/lib/levenshtein.js")
    const threshold = 3 // if it takes more than three edits, let's move on.
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length)

    let recommended = null
    let bestDistance = Infinity
    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
      const d = distance(cmd, candidate)
      if (d <= threshold && d < bestDistance) {
        bestDistance = d
        recommended = candidate
      }
    }
    if (recommended) usage.fail(__('Did you mean %s?', recommended))
  }

  self.reset = function reset (localLookup) {
    implied = objFilter(implied, (k, v) => !localLookup[k])
    conflicting = objFilter(conflicting, (k, v) => !localLookup[k])
    checks = checks.filter(c => c.global)
    return self
  }

  let frozen
  self.freeze = function freeze () {
    frozen = {}
    frozen.implied = implied
    frozen.checks = checks
    frozen.conflicting = conflicting
  }
  self.unfreeze = function unfreeze () {
    implied = frozen.implied
    checks = frozen.checks
    conflicting = frozen.conflicting
    frozen = undefined
  }

  return self
}


/***/ }),

/***/ "../../node_modules/yargs/lib/yerror.js":
/*!**********************************************!*\
  !*** ../../node_modules/yargs/lib/yerror.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

function YError (msg) {
  this.name = 'YError'
  this.message = msg || 'yargs error'
  Error.captureStackTrace(this, YError)
}

YError.prototype = Object.create(Error.prototype)
YError.prototype.constructor = YError

module.exports = YError


/***/ }),

/***/ "../../node_modules/yargs/lib sync recursive":
/*!******************************************!*\
  !*** ../../node_modules/yargs/lib/ sync ***!
  \******************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/yargs/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../node_modules/yargs/node_modules/ansi-styles/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/ansi-styles/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);

const colorConvert = __webpack_require__(/*! color-convert */ "../../node_modules/yargs/node_modules/color-convert/index.js");

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),

/***/ "../../node_modules/yargs/node_modules/cliui/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/cliui/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var stringWidth = __webpack_require__(/*! string-width */ "../../node_modules/yargs/node_modules/string-width/index.js")
var stripAnsi = __webpack_require__(/*! strip-ansi */ "../../node_modules/yargs/node_modules/strip-ansi/index.js")
var wrap = __webpack_require__(/*! wrap-ansi */ "../../node_modules/yargs/node_modules/wrap-ansi/index.js")
var align = {
  right: alignRight,
  center: alignCenter
}
var top = 0
var right = 1
var bottom = 2
var left = 3

function UI (opts) {
  this.width = opts.width
  this.wrap = opts.wrap
  this.rows = []
}

UI.prototype.span = function () {
  var cols = this.div.apply(this, arguments)
  cols.span = true
}

UI.prototype.resetOutput = function () {
  this.rows = []
}

UI.prototype.div = function () {
  if (arguments.length === 0) this.div('')
  if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
    return this._applyLayoutDSL(arguments[0])
  }

  var cols = []

  for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
    if (typeof arg === 'string') cols.push(this._colFromString(arg))
    else cols.push(arg)
  }

  this.rows.push(cols)
  return cols
}

UI.prototype._shouldApplyLayoutDSL = function () {
  return arguments.length === 1 && typeof arguments[0] === 'string' &&
    /[\t\n]/.test(arguments[0])
}

UI.prototype._applyLayoutDSL = function (str) {
  var _this = this
  var rows = str.split('\n')
  var leftColumnWidth = 0

  // simple heuristic for layout, make sure the
  // second column lines up along the left-hand.
  // don't allow the first column to take up more
  // than 50% of the screen.
  rows.forEach(function (row) {
    var columns = row.split('\t')
    if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
      leftColumnWidth = Math.min(
        Math.floor(_this.width * 0.5),
        stringWidth(columns[0])
      )
    }
  })

  // generate a table:
  //  replacing ' ' with padding calculations.
  //  using the algorithmically generated width.
  rows.forEach(function (row) {
    var columns = row.split('\t')
    _this.div.apply(_this, columns.map(function (r, i) {
      return {
        text: r.trim(),
        padding: _this._measurePadding(r),
        width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
      }
    }))
  })

  return this.rows[this.rows.length - 1]
}

UI.prototype._colFromString = function (str) {
  return {
    text: str,
    padding: this._measurePadding(str)
  }
}

UI.prototype._measurePadding = function (str) {
  // measure padding without ansi escape codes
  var noAnsi = stripAnsi(str)
  return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length]
}

UI.prototype.toString = function () {
  var _this = this
  var lines = []

  _this.rows.forEach(function (row, i) {
    _this.rowToString(row, lines)
  })

  // don't display any lines with the
  // hidden flag set.
  lines = lines.filter(function (line) {
    return !line.hidden
  })

  return lines.map(function (line) {
    return line.text
  }).join('\n')
}

UI.prototype.rowToString = function (row, lines) {
  var _this = this
  var padding
  var rrows = this._rasterize(row)
  var str = ''
  var ts
  var width
  var wrapWidth

  rrows.forEach(function (rrow, r) {
    str = ''
    rrow.forEach(function (col, c) {
      ts = '' // temporary string used during alignment/padding.
      width = row[c].width // the width with padding.
      wrapWidth = _this._negatePadding(row[c]) // the width without padding.

      ts += col

      for (var i = 0; i < wrapWidth - stringWidth(col); i++) {
        ts += ' '
      }

      // align the string within its column.
      if (row[c].align && row[c].align !== 'left' && _this.wrap) {
        ts = align[row[c].align](ts, wrapWidth)
        if (stringWidth(ts) < wrapWidth) ts += new Array(width - stringWidth(ts)).join(' ')
      }

      // apply border and padding to string.
      padding = row[c].padding || [0, 0, 0, 0]
      if (padding[left]) str += new Array(padding[left] + 1).join(' ')
      str += addBorder(row[c], ts, '| ')
      str += ts
      str += addBorder(row[c], ts, ' |')
      if (padding[right]) str += new Array(padding[right] + 1).join(' ')

      // if prior row is span, try to render the
      // current row on the prior line.
      if (r === 0 && lines.length > 0) {
        str = _this._renderInline(str, lines[lines.length - 1])
      }
    })

    // remove trailing whitespace.
    lines.push({
      text: str.replace(/ +$/, ''),
      span: row.span
    })
  })

  return lines
}

function addBorder (col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) return ''
    else if (ts.trim().length) return style
    else return '  '
  }
  return ''
}

// if the full 'source' can render in
// the target line, do so.
UI.prototype._renderInline = function (source, previousLine) {
  var leadingWhitespace = source.match(/^ */)[0].length
  var target = previousLine.text
  var targetTextWidth = stringWidth(target.trimRight())

  if (!previousLine.span) return source

  // if we're not applying wrapping logic,
  // just always append to the span.
  if (!this.wrap) {
    previousLine.hidden = true
    return target + source
  }

  if (leadingWhitespace < targetTextWidth) return source

  previousLine.hidden = true

  return target.trimRight() + new Array(leadingWhitespace - targetTextWidth + 1).join(' ') + source.trimLeft()
}

UI.prototype._rasterize = function (row) {
  var _this = this
  var i
  var rrow
  var rrows = []
  var widths = this._columnWidths(row)
  var wrapped

  // word wrap all columns, and create
  // a data-structure that is easy to rasterize.
  row.forEach(function (col, c) {
    // leave room for left and right padding.
    col.width = widths[c]
    if (_this.wrap) wrapped = wrap(col.text, _this._negatePadding(col), { hard: true }).split('\n')
    else wrapped = col.text.split('\n')

    if (col.border) {
      wrapped.unshift('.' + new Array(_this._negatePadding(col) + 3).join('-') + '.')
      wrapped.push("'" + new Array(_this._negatePadding(col) + 3).join('-') + "'")
    }

    // add top and bottom padding.
    if (col.padding) {
      for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
      for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
    }

    wrapped.forEach(function (str, r) {
      if (!rrows[r]) rrows.push([])

      rrow = rrows[r]

      for (var i = 0; i < c; i++) {
        if (rrow[i] === undefined) rrow.push('')
      }
      rrow.push(str)
    })
  })

  return rrows
}

UI.prototype._negatePadding = function (col) {
  var wrapWidth = col.width
  if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
  if (col.border) wrapWidth -= 4
  return wrapWidth
}

UI.prototype._columnWidths = function (row) {
  var _this = this
  var widths = []
  var unset = row.length
  var unsetWidth
  var remainingWidth = this.width

  // column widths can be set in config.
  row.forEach(function (col, i) {
    if (col.width) {
      unset--
      widths[i] = col.width
      remainingWidth -= col.width
    } else {
      widths[i] = undefined
    }
  })

  // any unset widths should be calculated.
  if (unset) unsetWidth = Math.floor(remainingWidth / unset)
  widths.forEach(function (w, i) {
    if (!_this.wrap) widths[i] = row[i].width || stringWidth(row[i].text)
    else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
  })

  return widths
}

// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth (col) {
  var padding = col.padding || []
  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)
  if (col.border) minWidth += 4
  return minWidth
}

function getWindowWidth () {
  if (typeof process === 'object' && process.stdout && process.stdout.columns) return process.stdout.columns
}

function alignRight (str, width) {
  str = str.trim()
  var padding = ''
  var strWidth = stringWidth(str)

  if (strWidth < width) {
    padding = new Array(width - strWidth + 1).join(' ')
  }

  return padding + str
}

function alignCenter (str, width) {
  str = str.trim()
  var padding = ''
  var strWidth = stringWidth(str.trim())

  if (strWidth < width) {
    padding = new Array(parseInt((width - strWidth) / 2, 10) + 1).join(' ')
  }

  return padding + str
}

module.exports = function (opts) {
  opts = opts || {}

  return new UI({
    width: (opts || {}).width || getWindowWidth() || 80,
    wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
  })
}


/***/ }),

/***/ "../../node_modules/yargs/node_modules/color-convert/conversions.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/color-convert/conversions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
var cssKeywords = __webpack_require__(/*! color-name */ "../../node_modules/yargs/node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/color-convert/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/color-convert/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var conversions = __webpack_require__(/*! ./conversions */ "../../node_modules/yargs/node_modules/color-convert/conversions.js");
var route = __webpack_require__(/*! ./route */ "../../node_modules/yargs/node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "../../node_modules/yargs/node_modules/color-convert/route.js":
/*!********************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/color-convert/route.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var conversions = __webpack_require__(/*! ./conversions */ "../../node_modules/yargs/node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "../../node_modules/yargs/node_modules/color-name/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/color-name/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/emoji-regex/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/emoji-regex/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4(?:\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74)\uDB40\uDC7F|\u200D\u2620\uFE0F)|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3]))|\uD83D\uDC69\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83D\uDC69\u200D[\u2695\u2696\u2708])\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC68(?:\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDB0-\uDDB3])|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF9]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF9]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDD1-\uDDDD])/g;
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/find-up/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/find-up/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const locatePath = __webpack_require__(/*! locate-path */ "../../node_modules/yargs/node_modules/locate-path/index.js");

module.exports = (filename, opts = {}) => {
	const startDir = path.resolve(opts.cwd || '');
	const {root} = path.parse(startDir);

	const filenames = [].concat(filename);

	return new Promise(resolve => {
		(function find(dir) {
			locatePath(filenames, {cwd: dir}).then(file => {
				if (file) {
					resolve(path.join(dir, file));
				} else if (dir === root) {
					resolve(null);
				} else {
					find(path.dirname(dir));
				}
			});
		})(startDir);
	});
};

module.exports.sync = (filename, opts = {}) => {
	let dir = path.resolve(opts.cwd || '');
	const {root} = path.parse(dir);

	const filenames = [].concat(filename);

	// eslint-disable-next-line no-constant-condition
	while (true) {
		const file = locatePath.sync(filenames, {cwd: dir});

		if (file) {
			return path.join(dir, file);
		}

		if (dir === root) {
			return null;
		}

		dir = path.dirname(dir);
	}
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/locate-path/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/locate-path/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(/*! path */ "path");
const pathExists = __webpack_require__(/*! path-exists */ "../../node_modules/path-exists/index.js");
const pLocate = __webpack_require__(/*! p-locate */ "../../node_modules/yargs/node_modules/p-locate/index.js");

module.exports = (iterable, options) => {
	options = Object.assign({
		cwd: process.cwd()
	}, options);

	return pLocate(iterable, el => pathExists(path.resolve(options.cwd, el)), options);
};

module.exports.sync = (iterable, options) => {
	options = Object.assign({
		cwd: process.cwd()
	}, options);

	for (const el of iterable) {
		if (pathExists.sync(path.resolve(options.cwd, el))) {
			return el;
		}
	}
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/p-locate/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/p-locate/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pLimit = __webpack_require__(/*! p-limit */ "../../node_modules/p-limit/index.js");

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// The input can also be a promise, so we `Promise.resolve()` it
const testElement = (el, tester) => Promise.resolve(el).then(tester);

// The input can also be a promise, so we `Promise.all()` them both
const finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));

module.exports = (iterable, tester, opts) => {
	opts = Object.assign({
		concurrency: Infinity,
		preserveOrder: true
	}, opts);

	const limit = pLimit(opts.concurrency);

	// Start all the promises concurrently with optional limit
	const items = [...iterable].map(el => [el, limit(testElement, el, tester)]);

	// Check the promises either serially or concurrently
	const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);

	return Promise.all(items.map(el => checkLimit(finder, el)))
		.then(() => {})
		.catch(err => err instanceof EndError ? err.value : Promise.reject(err));
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/string-width/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/string-width/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stripAnsi = __webpack_require__(/*! strip-ansi */ "../../node_modules/yargs/node_modules/strip-ansi/index.js");
const isFullwidthCodePoint = __webpack_require__(/*! is-fullwidth-code-point */ "../../node_modules/is-fullwidth-code-point/index.js");
const emojiRegex = __webpack_require__(/*! emoji-regex */ "../../node_modules/yargs/node_modules/emoji-regex/index.js")();

module.exports = input => {
	input = input.replace(emojiRegex, '  ');

	if (typeof input !== 'string' || input.length === 0) {
		return 0;
	}

	input = stripAnsi(input);

	let width = 0;

	for (let i = 0; i < input.length; i++) {
		const code = input.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/strip-ansi/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/strip-ansi/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiRegex = __webpack_require__(/*! ansi-regex */ "../../node_modules/ansi-regex/index.js");

const stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

module.exports = stripAnsi;
module.exports["default"] = stripAnsi;


/***/ }),

/***/ "../../node_modules/yargs/node_modules/wrap-ansi/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/wrap-ansi/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stringWidth = __webpack_require__(/*! string-width */ "../../node_modules/yargs/node_modules/string-width/index.js");
const stripAnsi = __webpack_require__(/*! strip-ansi */ "../../node_modules/yargs/node_modules/strip-ansi/index.js");
const ansiStyles = __webpack_require__(/*! ansi-styles */ "../../node_modules/yargs/node_modules/ansi-styles/index.js");

const ESCAPES = new Set([
	'\u001B',
	'\u009B'
]);

const END_CODE = 39;

const wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let insideEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			insideEscape = true;
		} else if (insideEscape && character === 'm') {
			insideEscape = false;
			continue;
		}

		if (insideEscape) {
			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = str => {
	const words = str.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return str;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked
// in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more
// than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let pre = '';
	let ret = '';
	let escapeCode;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
		}

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is
		// never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows.push('');
		}

		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}

		rows[rows.length - 1] += word;
	}

	if (options.trim !== false) {
		rows = rows.map(stringVisibleTrimSpacesRight);
	}

	pre = rows.join('\n');

	for (const [index, character] of [...pre].entries()) {
		ret += character;

		if (ESCAPES.has(character)) {
			const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
			escapeCode = code === END_CODE ? null : code;
		}

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (escapeCode && code) {
			if (pre[index + 1] === '\n') {
				ret += wrapAnsi(code);
			} else if (character === '\n') {
				ret += wrapAnsi(escapeCode);
			}
		}
	}

	return ret;
};

// For each newline, invoke the method separately
module.exports = (string, columns, options) => {
	return String(string)
		.normalize()
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
};


/***/ }),

/***/ "../../node_modules/yargs/node_modules/yargs-parser/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/yargs-parser/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var camelCase = __webpack_require__(/*! camelcase */ "../../node_modules/camelcase/index.js")
var decamelize = __webpack_require__(/*! decamelize */ "../../node_modules/decamelize/index.js")
var path = __webpack_require__(/*! path */ "path")
var tokenizeArgString = __webpack_require__(/*! ./lib/tokenize-arg-string */ "../../node_modules/yargs/node_modules/yargs-parser/lib/tokenize-arg-string.js")
var util = __webpack_require__(/*! util */ "util")

function parse (args, opts) {
  if (!opts) opts = {}
  // allow a string argument to be passed in rather
  // than an argv array.
  args = tokenizeArgString(args)

  // aliases might have transitive relationships, normalize this.
  var aliases = combineAliases(opts.alias || {})
  var configuration = Object.assign({
    'short-option-groups': true,
    'camel-case-expansion': true,
    'dot-notation': true,
    'parse-numbers': true,
    'boolean-negation': true,
    'negation-prefix': 'no-',
    'duplicate-arguments-array': true,
    'flatten-duplicate-arrays': true,
    'populate--': false,
    'combine-arrays': false,
    'set-placeholder-key': false,
    'halt-at-non-option': false,
    'strip-aliased': false,
    'strip-dashed': false
  }, opts.configuration)
  var defaults = opts.default || {}
  var configObjects = opts.configObjects || []
  var envPrefix = opts.envPrefix
  var notFlagsOption = configuration['populate--']
  var notFlagsArgv = notFlagsOption ? '--' : '_'
  var newAliases = {}
  // allow a i18n handler to be passed in, default to a fake one (util.format).
  var __ = opts.__ || util.format
  var error = null
  var flags = {
    aliases: {},
    arrays: {},
    bools: {},
    strings: {},
    numbers: {},
    counts: {},
    normalize: {},
    configs: {},
    defaulted: {},
    nargs: {},
    coercions: {},
    keys: []
  }
  var negative = /^-[0-9]+(\.[0-9]+)?/
  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')

  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {
    var key = opt.key || opt

    // assign to flags[bools|strings|numbers]
    const assignment = Object.keys(opt).map(function (key) {
      return ({
        boolean: 'bools',
        string: 'strings',
        number: 'numbers'
      })[key]
    }).filter(Boolean).pop()

    // assign key to be coerced
    if (assignment) {
      flags[assignment][key] = true
    }

    flags.arrays[key] = true
    flags.keys.push(key)
  })

  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {
    flags.bools[key] = true
    flags.keys.push(key)
  })

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
    flags.strings[key] = true
    flags.keys.push(key)
  })

  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {
    flags.numbers[key] = true
    flags.keys.push(key)
  })

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
    flags.counts[key] = true
    flags.keys.push(key)
  })

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
    flags.normalize[key] = true
    flags.keys.push(key)
  })

  Object.keys(opts.narg || {}).forEach(function (k) {
    flags.nargs[k] = opts.narg[k]
    flags.keys.push(k)
  })

  Object.keys(opts.coerce || {}).forEach(function (k) {
    flags.coercions[k] = opts.coerce[k]
    flags.keys.push(k)
  })

  if (Array.isArray(opts.config) || typeof opts.config === 'string') {
    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
      flags.configs[key] = true
    })
  } else {
    Object.keys(opts.config || {}).forEach(function (k) {
      flags.configs[k] = opts.config[k]
    })
  }

  // create a lookup table that takes into account all
  // combinations of aliases: {f: ['foo'], foo: ['f']}
  extendAliases(opts.key, aliases, opts.default, flags.arrays)

  // apply default values to all aliases.
  Object.keys(defaults).forEach(function (key) {
    (flags.aliases[key] || []).forEach(function (alias) {
      defaults[alias] = defaults[key]
    })
  })

  var argv = { _: [] }

  Object.keys(flags.bools).forEach(function (key) {
    if (Object.prototype.hasOwnProperty.call(defaults, key)) {
      setArg(key, defaults[key])
      setDefaulted(key)
    }
  })

  var notFlags = []

  for (var i = 0; i < args.length; i++) {
    var arg = args[i]
    var broken
    var key
    var letters
    var m
    var next
    var value

    // -- separated by =
    if (arg.match(/^--.+=/) || (
      !configuration['short-option-groups'] && arg.match(/^-.+=/)
    )) {
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--?([^=]+)=([\s\S]*)$/)

      // nargs format = '--f=monkey washing cat'
      if (checkAllAliases(m[1], flags.nargs)) {
        args.splice(i + 1, 0, m[2])
        i = eatNargs(i, m[1], args)
      // arrays format = '--f=a b c'
      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
        args.splice(i + 1, 0, m[2])
        i = eatArray(i, m[1], args)
      } else {
        setArg(m[1], m[2])
      }
    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
      key = arg.match(negatedBoolean)[1]
      setArg(key, false)

    // -- seperated by space.
    } else if (arg.match(/^--.+/) || (
      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)
    )) {
      key = arg.match(/^--?(.+)/)[1]

      // nargs format = '--foo a b c'
      if (checkAllAliases(key, flags.nargs)) {
        i = eatNargs(i, key, args)
      // array format = '--foo a b c'
      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
        i = eatArray(i, key, args)
      } else {
        next = flags.nargs[key] === 0 ? undefined : args[i + 1]

        if (next !== undefined && (!next.match(/^-/) ||
          next.match(negative)) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) {
          setArg(key, next)
          i++
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next)
          i++
        } else {
          setArg(key, defaultValue(key))
        }
      }

    // dot-notation flag seperated by '='.
    } else if (arg.match(/^-.\..+=/)) {
      m = arg.match(/^-([^=]+)=([\s\S]*)$/)
      setArg(m[1], m[2])

    // dot-notation flag seperated by space.
    } else if (arg.match(/^-.\..+/)) {
      next = args[i + 1]
      key = arg.match(/^-(.\..+)/)[1]

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) {
        setArg(key, next)
        i++
      } else {
        setArg(key, defaultValue(key))
      }
    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
      letters = arg.slice(1, -1).split('')
      broken = false

      for (var j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2)

        if (letters[j + 1] && letters[j + 1] === '=') {
          value = arg.slice(j + 3)
          key = letters[j]

          // nargs format = '-f=monkey washing cat'
          if (checkAllAliases(key, flags.nargs)) {
            args.splice(i + 1, 0, value)
            i = eatNargs(i, key, args)
          // array format = '-f=a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, 0, value)
            i = eatArray(i, key, args)
          } else {
            setArg(key, value)
          }

          broken = true
          break
        }

        if (next === '-') {
          setArg(letters[j], next)
          continue
        }

        // current letter is an alphabetic character and next value is a number
        if (/[A-Za-z]/.test(letters[j]) &&
          /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next)
          broken = true
          break
        }

        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], next)
          broken = true
          break
        } else {
          setArg(letters[j], defaultValue(letters[j]))
        }
      }

      key = arg.slice(-1)[0]

      if (!broken && key !== '-') {
        // nargs format = '-f a b c'
        if (checkAllAliases(key, flags.nargs)) {
          i = eatNargs(i, key, args)
        // array format = '-f a b c'
        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
          i = eatArray(i, key, args)
        } else {
          next = args[i + 1]

          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
            next.match(negative)) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultValue(key))
          }
        }
      }
    } else if (arg === '--') {
      notFlags = args.slice(i + 1)
      break
    } else if (configuration['halt-at-non-option']) {
      notFlags = args.slice(i)
      break
    } else {
      argv._.push(maybeCoerceNumber('_', arg))
    }
  }

  // order of precedence:
  // 1. command line arg
  // 2. value from env var
  // 3. value from config file
  // 4. value from config objects
  // 5. configured default value
  applyEnvVars(argv, true) // special case: check env vars that point to config file
  applyEnvVars(argv, false)
  setConfig(argv)
  setConfigObjects()
  applyDefaultsAndAliases(argv, flags.aliases, defaults)
  applyCoercions(argv)
  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)

  // for any counts either not in args or without an explicit default, set to 0
  Object.keys(flags.counts).forEach(function (key) {
    if (!hasKey(argv, key.split('.'))) setArg(key, 0)
  })

  // '--' defaults to undefined.
  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []
  notFlags.forEach(function (key) {
    argv[notFlagsArgv].push(key)
  })

  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
      delete argv[key]
    })
  }

  if (configuration['strip-aliased']) {
    // XXX Switch to [].concat(...Object.values(aliases)) once node.js 6 is dropped
    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
      if (configuration['camel-case-expansion']) {
        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]
      }

      delete argv[alias]
    })
  }

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args) {
    var ii
    const toEat = checkAllAliases(key, flags.nargs)

    // nargs will not consume flag arguments, e.g., -abc, --foo,
    // and terminates when one is observed.
    var available = 0
    for (ii = i + 1; ii < args.length; ii++) {
      if (!args[ii].match(/^-[^0-9]/)) available++
      else break
    }

    if (available < toEat) error = Error(__('Not enough arguments following: %s', key))

    const consumed = Math.min(available, toEat)
    for (ii = i + 1; ii < (consumed + i + 1); ii++) {
      setArg(key, args[ii])
    }

    return (i + consumed)
  }

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args) {
    var start = i + 1
    var argsToSet = []
    var multipleArrayFlag = i > 0
    for (var ii = i + 1; ii < args.length; ii++) {
      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {
        if (ii === start) {
          setArg(key, defaultForType('array'))
        }
        multipleArrayFlag = true
        break
      }
      i = ii
      argsToSet.push(args[ii])
    }
    if (multipleArrayFlag) {
      setArg(key, argsToSet.map(function (arg) {
        return processValue(key, arg)
      }))
    } else {
      argsToSet.forEach(function (arg) {
        setArg(key, arg)
      })
    }

    return i
  }

  function setArg (key, val) {
    unsetDefaulted(key)

    if (/-/.test(key) && configuration['camel-case-expansion']) {
      var alias = key.split('.').map(function (prop) {
        return camelCase(prop)
      }).join('.')
      addNewAlias(key, alias)
    }

    var value = processValue(key, val)

    var splitKey = key.split('.')
    setKey(argv, splitKey, value)

    // handle populating aliases of the full key
    if (flags.aliases[key] && flags.aliases[key].forEach) {
      flags.aliases[key].forEach(function (x) {
        x = x.split('.')
        setKey(argv, x, value)
      })
    }

    // handle populating aliases of the first element of the dot-notation key
    if (splitKey.length > 1 && configuration['dot-notation']) {
      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {
        x = x.split('.')

        // expand alias with nested objects in key
        var a = [].concat(splitKey)
        a.shift() // nuke the old key.
        x = x.concat(a)

        setKey(argv, x, value)
      })
    }

    // Set normalize getter and setter when key is in 'normalize' but isn't an array
    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
      var keys = [key].concat(flags.aliases[key] || [])
      keys.forEach(function (key) {
        argv.__defineSetter__(key, function (v) {
          val = path.normalize(v)
        })

        argv.__defineGetter__(key, function () {
          return typeof val === 'string' ? path.normalize(val) : val
        })
      })
    }
  }

  function addNewAlias (key, alias) {
    if (!(flags.aliases[key] && flags.aliases[key].length)) {
      flags.aliases[key] = [alias]
      newAliases[alias] = true
    }
    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
      addNewAlias(alias, key)
    }
  }

  function processValue (key, val) {
    // strings may be quoted, clean this up as we assign values.
    if (typeof val === 'string' &&
      (val[0] === "'" || val[0] === '"') &&
      val[val.length - 1] === val[0]
    ) {
      val = val.substring(1, val.length - 1)
    }

    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
      if (typeof val === 'string') val = val === 'true'
    }

    var value = maybeCoerceNumber(key, val)

    // increment a count given as arg (either no value or value parsed as boolean)
    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
      value = increment
    }

    // Set normalized value when key is in 'normalize' and in 'arrays'
    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
      if (Array.isArray(val)) value = val.map(path.normalize)
      else value = path.normalize(val)
    }
    return value
  }

  function maybeCoerceNumber (key, value) {
    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {
      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (
        Number.isSafeInteger(Math.floor(value))
      )
      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)
    }
    return value
  }

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) {
    var configLookup = {}

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)

    Object.keys(flags.configs).forEach(function (configKey) {
      var configPath = argv[configKey] || configLookup[configKey]
      if (configPath) {
        try {
          var config = null
          var resolvedConfigPath = path.resolve(process.cwd(), configPath)

          if (typeof flags.configs[configKey] === 'function') {
            try {
              config = flags.configs[configKey](resolvedConfigPath)
            } catch (e) {
              config = e
            }
            if (config instanceof Error) {
              error = config
              return
            }
          } else {
            config = __webpack_require__("../../node_modules/yargs/node_modules/yargs-parser sync recursive")(resolvedConfigPath)
          }

          setConfigObject(config)
        } catch (ex) {
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
        }
      }
    })
  }

  // set args from config object.
  // it recursively checks nested objects.
  function setConfigObject (config, prev) {
    Object.keys(config).forEach(function (key) {
      var value = config[key]
      var fullKey = prev ? prev + '.' + key : key

      // if the value is an inner object and we have dot-notation
      // enabled, treat inner objects in config the same as
      // heavily nested dot notations (foo.bar.apple).
      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
        // if the value is an object but not an array, check nested object
        setConfigObject(value, fullKey)
      } else {
        // setting arguments via CLI takes precedence over
        // values within the config file.
        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey]) || (flags.arrays[fullKey] && configuration['combine-arrays'])) {
          setArg(fullKey, value)
        }
      }
    })
  }

  // set all config objects passed in opts
  function setConfigObjects () {
    if (typeof configObjects === 'undefined') return
    configObjects.forEach(function (configObject) {
      setConfigObject(configObject)
    })
  }

  function applyEnvVars (argv, configOnly) {
    if (typeof envPrefix === 'undefined') return

    var prefix = typeof envPrefix === 'string' ? envPrefix : ''
    Object.keys(process.env).forEach(function (envVar) {
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
        // get array of nested keys and convert them to camel case
        var keys = envVar.split('__').map(function (key, i) {
          if (i === 0) {
            key = key.substring(prefix.length)
          }
          return camelCase(key)
        })

        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {
          setArg(keys.join('.'), process.env[envVar])
        }
      }
    })
  }

  function applyCoercions (argv) {
    var coerce
    var applied = {}
    Object.keys(argv).forEach(function (key) {
      if (!applied.hasOwnProperty(key)) { // If we haven't already coerced this option via one of its aliases
        coerce = checkAllAliases(key, flags.coercions)
        if (typeof coerce === 'function') {
          try {
            var value = coerce(argv[key])
            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {
              applied[ali] = argv[ali] = value
            })
          } catch (err) {
            error = err
          }
        }
      }
    })
  }

  function setPlaceholderKeys (argv) {
    flags.keys.forEach((key) => {
      // don't set placeholder keys for dot notation options 'foo.bar'.
      if (~key.indexOf('.')) return
      if (typeof argv[key] === 'undefined') argv[key] = undefined
    })
    return argv
  }

  function applyDefaultsAndAliases (obj, aliases, defaults) {
    Object.keys(defaults).forEach(function (key) {
      if (!hasKey(obj, key.split('.'))) {
        setKey(obj, key.split('.'), defaults[key])

        ;(aliases[key] || []).forEach(function (x) {
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key])
        })
      }
    })
  }

  function hasKey (obj, keys) {
    var o = obj

    if (!configuration['dot-notation']) keys = [keys.join('.')]

    keys.slice(0, -1).forEach(function (key) {
      o = (o[key] || {})
    })

    var key = keys[keys.length - 1]

    if (typeof o !== 'object') return false
    else return key in o
  }

  function setKey (obj, keys, value) {
    var o = obj

    if (!configuration['dot-notation']) keys = [keys.join('.')]

    keys.slice(0, -1).forEach(function (key, index) {
      // TODO(bcoe): in the next major version of yargs, switch to
      // Object.create(null) for dot notation:
      key = sanitizeKey(key)

      if (typeof o === 'object' && o[key] === undefined) {
        o[key] = {}
      }

      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
        // ensure that o[key] is an array, and that the last item is an empty object.
        if (Array.isArray(o[key])) {
          o[key].push({})
        } else {
          o[key] = [o[key], {}]
        }

        // we want to update the empty object at the end of the o[key] array, so set o to that object
        o = o[key][o[key].length - 1]
      } else {
        o = o[key]
      }
    })

    // TODO(bcoe): in the next major version of yargs, switch to
    // Object.create(null) for dot notation:
    const key = sanitizeKey(keys[keys.length - 1])

    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)
    const isValueArray = Array.isArray(value)
    let duplicate = configuration['duplicate-arguments-array']

    // nargs has higher priority than duplicate
    if (!duplicate && checkAllAliases(key, flags.nargs)) {
      duplicate = true
      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
        o[key] = undefined
      }
    }

    if (value === increment) {
      o[key] = increment(o[key])
    } else if (Array.isArray(o[key])) {
      if (duplicate && isTypeArray && isValueArray) {
        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])
      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
        o[key] = value
      } else {
        o[key] = o[key].concat([value])
      }
    } else if (o[key] === undefined && isTypeArray) {
      o[key] = isValueArray ? value : [value]
    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {
      o[key] = [ o[key], value ]
    } else {
      o[key] = value
    }
  }

  // extend the aliases list with inferred aliases.
  function extendAliases (...args) {
    args.forEach(function (obj) {
      Object.keys(obj || {}).forEach(function (key) {
        // short-circuit if we've already added a key
        // to the aliases array, for example it might
        // exist in both 'opts.default' and 'opts.key'.
        if (flags.aliases[key]) return

        flags.aliases[key] = [].concat(aliases[key] || [])
        // For "--option-name", also set argv.optionName
        flags.aliases[key].concat(key).forEach(function (x) {
          if (/-/.test(x) && configuration['camel-case-expansion']) {
            var c = camelCase(x)
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c)
              newAliases[c] = true
            }
          }
        })
        // For "--optionName", also set argv['option-name']
        flags.aliases[key].concat(key).forEach(function (x) {
          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
            var c = decamelize(x, '-')
            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
              flags.aliases[key].push(c)
              newAliases[c] = true
            }
          }
        })
        flags.aliases[key].forEach(function (x) {
          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
            return x !== y
          }))
        })
      })
    })
  }

  // check if a flag is set for any of a key's aliases.
  function checkAllAliases (key, flag) {
    var isSet = false
    var toCheck = [].concat(flags.aliases[key] || [], key)

    toCheck.forEach(function (key) {
      if (flag[key]) isSet = flag[key]
    })

    return isSet
  }

  function setDefaulted (key) {
    [].concat(flags.aliases[key] || [], key).forEach(function (k) {
      flags.defaulted[k] = true
    })
  }

  function unsetDefaulted (key) {
    [].concat(flags.aliases[key] || [], key).forEach(function (k) {
      delete flags.defaulted[k]
    })
  }

  // make a best effor to pick a default value
  // for an option based on name and type.
  function defaultValue (key) {
    if (!checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts) &&
        `${key}` in defaults) {
      return defaults[key]
    } else {
      return defaultForType(guessType(key))
    }
  }

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) {
    var def = {
      boolean: true,
      string: '',
      number: undefined,
      array: []
    }

    return def[type]
  }

  // given a flag, enforce a default type.
  function guessType (key) {
    var type = 'boolean'

    if (checkAllAliases(key, flags.strings)) type = 'string'
    else if (checkAllAliases(key, flags.numbers)) type = 'number'
    else if (checkAllAliases(key, flags.arrays)) type = 'array'

    return type
  }

  function isNumber (x) {
    if (x === null || x === undefined) return false
    // if loaded from config, may already be a number.
    if (typeof x === 'number') return true
    // hexadecimal.
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    // don't treat 0123 as a number; as it drops the leading '0'.
    if (x.length > 1 && x[0] === '0') return false
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  }

  function isUndefined (num) {
    return num === undefined
  }

  return {
    argv: argv,
    error: error,
    aliases: flags.aliases,
    newAliases: newAliases,
    configuration: configuration
  }
}

// if any aliases reference each other, we should
// merge them together.
function combineAliases (aliases) {
  var aliasArrays = []
  var change = true
  var combined = {}

  // turn alias lookup hash {key: ['alias1', 'alias2']} into
  // a simple array ['key', 'alias1', 'alias2']
  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push(
      [].concat(aliases[key], key)
    )
  })

  // combine arrays until zero changes are
  // made in an iteration.
  while (change) {
    change = false
    for (var i = 0; i < aliasArrays.length; i++) {
      for (var ii = i + 1; ii < aliasArrays.length; ii++) {
        var intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1
        })

        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])
          aliasArrays.splice(ii, 1)
          change = true
          break
        }
      }
    }
  }

  // map arrays back to the hash-lookup (de-dupe while
  // we're at it).
  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self) {
      return self.indexOf(v) === i
    })
    combined[aliasArray.pop()] = aliasArray
  })

  return combined
}

// this function should only be called when a count is given as an arg
// it is NOT called to set a default value
// thus we can start the count at 1 instead of 0
function increment (orig) {
  return orig !== undefined ? orig + 1 : 1
}

function Parser (args, opts) {
  var result = parse(args.slice(), opts)

  return result.argv
}

// parse arguments and return detailed
// meta information, aliases, etc.
Parser.detailed = function (args, opts) {
  return parse(args.slice(), opts)
}

// TODO(bcoe): in the next major version of yargs, switch to
// Object.create(null) for dot notation:
function sanitizeKey (key) {
  if (key === '__proto__') return '___proto___'
  return key
}

module.exports = Parser


/***/ }),

/***/ "../../node_modules/yargs/node_modules/yargs-parser/lib/tokenize-arg-string.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/yargs-parser/lib/tokenize-arg-string.js ***!
  \*************************************************************************************/
/***/ ((module) => {

// take an un-split argv string and tokenize it.
module.exports = function (argString) {
  if (Array.isArray(argString)) {
    return argString.map(e => typeof e !== 'string' ? e + '' : e)
  }

  argString = argString.trim()

  var i = 0
  var prevC = null
  var c = null
  var opening = null
  var args = []

  for (var ii = 0; ii < argString.length; ii++) {
    prevC = c
    c = argString.charAt(ii)

    // split on spaces unless we're in quotes.
    if (c === ' ' && !opening) {
      if (!(prevC === ' ')) {
        i++
      }
      continue
    }

    // don't split the string if we're in matching
    // opening or closing single and double quotes.
    if (c === opening) {
      opening = null
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c
    }

    if (!args[i]) args[i] = ''
    args[i] += c
  }

  return args
}


/***/ }),

/***/ "../../node_modules/yargs/node_modules/yargs-parser sync recursive":
/*!****************************************************************!*\
  !*** ../../node_modules/yargs/node_modules/yargs-parser/ sync ***!
  \****************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/yargs/node_modules/yargs-parser sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../node_modules/yargs/yargs.js":
/*!*****************************************!*\
  !*** ../../node_modules/yargs/yargs.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

const argsert = __webpack_require__(/*! ./lib/argsert */ "../../node_modules/yargs/lib/argsert.js")
const fs = __webpack_require__(/*! fs */ "fs")
const Command = __webpack_require__(/*! ./lib/command */ "../../node_modules/yargs/lib/command.js")
const Completion = __webpack_require__(/*! ./lib/completion */ "../../node_modules/yargs/lib/completion.js")
const Parser = __webpack_require__(/*! yargs-parser */ "../../node_modules/yargs/node_modules/yargs-parser/index.js")
const path = __webpack_require__(/*! path */ "path")
const Usage = __webpack_require__(/*! ./lib/usage */ "../../node_modules/yargs/lib/usage.js")
const Validation = __webpack_require__(/*! ./lib/validation */ "../../node_modules/yargs/lib/validation.js")
const Y18n = __webpack_require__(/*! y18n */ "../../node_modules/y18n/index.js")
const objFilter = __webpack_require__(/*! ./lib/obj-filter */ "../../node_modules/yargs/lib/obj-filter.js")
const setBlocking = __webpack_require__(/*! set-blocking */ "../../node_modules/set-blocking/index.js")
const applyExtends = __webpack_require__(/*! ./lib/apply-extends */ "../../node_modules/yargs/lib/apply-extends.js")
const { globalMiddlewareFactory } = __webpack_require__(/*! ./lib/middleware */ "../../node_modules/yargs/lib/middleware.js")
const YError = __webpack_require__(/*! ./lib/yerror */ "../../node_modules/yargs/lib/yerror.js")

exports = module.exports = Yargs
function Yargs (processArgs, cwd, parentRequire) {
  processArgs = processArgs || [] // handle calling yargs().

  const self = {}
  let command = null
  let completion = null
  let groups = {}
  let globalMiddleware = []
  let output = ''
  let preservedGroups = {}
  let usage = null
  let validation = null

  const y18n = Y18n({
    directory: path.resolve(__dirname, './locales'),
    updateFiles: false
  })

  self.middleware = globalMiddlewareFactory(globalMiddleware, self)

  if (!cwd) cwd = process.cwd()

  self.scriptName = function scriptName (scriptName) {
    self.$0 = scriptName
    return self
  }

  // ignore the node bin, specify this in your
  // bin file with #!/usr/bin/env node
  if (/\b(node|iojs|electron)(\.exe)?$/.test(process.argv[0])) {
    self.$0 = process.argv.slice(1, 2)
  } else {
    self.$0 = process.argv.slice(0, 1)
  }

  self.$0 = self.$0
    .map((x, i) => {
      const b = rebase(cwd, x)
      return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x
    })
    .join(' ').trim()

  if (process.env._ !== undefined && process.argv[1] === process.env._) {
    self.$0 = process.env._.replace(
      `${path.dirname(process.execPath)}/`, ''
    )
  }

  // use context object to keep track of resets, subcommand execution, etc
  // submodules should modify and check the state of context as necessary
  const context = { resets: -1, commands: [], fullCommands: [], files: [] }
  self.getContext = () => context

  // puts yargs back into an initial state. any keys
  // that have been set to "global" will not be reset
  // by this action.
  let options
  self.resetOptions = self.reset = function resetOptions (aliases) {
    context.resets++
    aliases = aliases || {}
    options = options || {}
    // put yargs back into an initial state, this
    // logic is used to build a nested command
    // hierarchy.
    const tmpOptions = {}
    tmpOptions.local = options.local ? options.local : []
    tmpOptions.configObjects = options.configObjects ? options.configObjects : []

    // if a key has been explicitly set as local,
    // we should reset it before passing options to command.
    const localLookup = {}
    tmpOptions.local.forEach((l) => {
      localLookup[l] = true
      ;(aliases[l] || []).forEach((a) => {
        localLookup[a] = true
      })
    })

    // preserve all groups not set to local.
    preservedGroups = Object.keys(groups).reduce((acc, groupName) => {
      const keys = groups[groupName].filter(key => !(key in localLookup))
      if (keys.length > 0) {
        acc[groupName] = keys
      }
      return acc
    }, {})
    // groups can now be reset
    groups = {}

    const arrayOptions = [
      'array', 'boolean', 'string', 'skipValidation',
      'count', 'normalize', 'number',
      'hiddenOptions'
    ]

    const objectOptions = [
      'narg', 'key', 'alias', 'default', 'defaultDescription',
      'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'
    ]

    arrayOptions.forEach((k) => {
      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k])
    })

    objectOptions.forEach((k) => {
      tmpOptions[k] = objFilter(options[k], (k, v) => !localLookup[k])
    })

    tmpOptions.envPrefix = options.envPrefix
    options = tmpOptions

    // if this is the first time being executed, create
    // instances of all our helpers -- otherwise just reset.
    usage = usage ? usage.reset(localLookup) : Usage(self, y18n)
    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n)
    command = command ? command.reset() : Command(self, usage, validation, globalMiddleware)
    if (!completion) completion = Completion(self, usage, command)

    completionCommand = null
    output = ''
    exitError = null
    hasOutput = false
    self.parsed = false

    return self
  }
  self.resetOptions()

  // temporary hack: allow "freezing" of reset-able state for parse(msg, cb)
  let frozen
  function freeze () {
    frozen = {}
    frozen.options = options
    frozen.configObjects = options.configObjects.slice(0)
    frozen.exitProcess = exitProcess
    frozen.groups = groups
    usage.freeze()
    validation.freeze()
    command.freeze()
    frozen.strict = strict
    frozen.completionCommand = completionCommand
    frozen.output = output
    frozen.exitError = exitError
    frozen.hasOutput = hasOutput
    frozen.parsed = self.parsed
  }
  function unfreeze () {
    options = frozen.options
    options.configObjects = frozen.configObjects
    exitProcess = frozen.exitProcess
    groups = frozen.groups
    output = frozen.output
    exitError = frozen.exitError
    hasOutput = frozen.hasOutput
    self.parsed = frozen.parsed
    usage.unfreeze()
    validation.unfreeze()
    command.unfreeze()
    strict = frozen.strict
    completionCommand = frozen.completionCommand
    parseFn = null
    parseContext = null
    frozen = undefined
  }

  self.boolean = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('boolean', keys)
    return self
  }

  self.array = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('array', keys)
    return self
  }

  self.number = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('number', keys)
    return self
  }

  self.normalize = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('normalize', keys)
    return self
  }

  self.count = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('count', keys)
    return self
  }

  self.string = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('string', keys)
    return self
  }

  self.requiresArg = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintObject(self.nargs, false, 'narg', keys, 1)
    return self
  }

  self.skipValidation = function (keys) {
    argsert('<array|string>', [keys], arguments.length)
    populateParserHintArray('skipValidation', keys)
    return self
  }

  function populateParserHintArray (type, keys, value) {
    keys = [].concat(keys)
    keys.forEach((key) => {
      key = sanitizeKey(key)
      options[type].push(key)
    })
  }

  self.nargs = function (key, value) {
    argsert('<string|object|array> [number]', [key, value], arguments.length)
    populateParserHintObject(self.nargs, false, 'narg', key, value)
    return self
  }

  self.choices = function (key, value) {
    argsert('<object|string|array> [string|array]', [key, value], arguments.length)
    populateParserHintObject(self.choices, true, 'choices', key, value)
    return self
  }

  self.alias = function (key, value) {
    argsert('<object|string|array> [string|array]', [key, value], arguments.length)
    populateParserHintObject(self.alias, true, 'alias', key, value)
    return self
  }

  // TODO: actually deprecate self.defaults.
  self.default = self.defaults = function (key, value, defaultDescription) {
    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length)
    if (defaultDescription) options.defaultDescription[key] = defaultDescription
    if (typeof value === 'function') {
      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)
      value = value.call()
    }
    populateParserHintObject(self.default, false, 'default', key, value)
    return self
  }

  self.describe = function (key, desc) {
    argsert('<object|string|array> [string]', [key, desc], arguments.length)
    populateParserHintObject(self.describe, false, 'key', key, true)
    usage.describe(key, desc)
    return self
  }

  self.demandOption = function (keys, msg) {
    argsert('<object|string|array> [string]', [keys, msg], arguments.length)
    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg)
    return self
  }

  self.coerce = function (keys, value) {
    argsert('<object|string|array> [function]', [keys, value], arguments.length)
    populateParserHintObject(self.coerce, false, 'coerce', keys, value)
    return self
  }

  function populateParserHintObject (builder, isArray, type, key, value) {
    if (Array.isArray(key)) {
      const temp = Object.create(null)
      // an array of keys with one value ['x', 'y', 'z'], function parse () {}
      key.forEach((k) => {
        temp[k] = value
      })
      builder(temp)
    } else if (typeof key === 'object') {
      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}
      Object.keys(key).forEach((k) => {
        builder(k, key[k])
      })
    } else {
      key = sanitizeKey(key)
      // a single key value pair 'x', parse() {}
      if (isArray) {
        options[type][key] = (options[type][key] || []).concat(value)
      } else {
        options[type][key] = value
      }
    }
  }

  // TODO(bcoe): in future major versions move more objects towards
  // Object.create(null):
  function sanitizeKey (key) {
    if (key === '__proto__') return '___proto___'
    return key
  }

  function deleteFromParserHintObject (optionKey) {
    // delete from all parsing hints:
    // boolean, array, key, alias, etc.
    Object.keys(options).forEach((hintKey) => {
      const hint = options[hintKey]
      if (Array.isArray(hint)) {
        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1)
      } else if (typeof hint === 'object') {
        delete hint[optionKey]
      }
    })
    // now delete the description from usage.js.
    delete usage.getDescriptions()[optionKey]
  }

  self.config = function config (key, msg, parseFn) {
    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length)
    // allow a config object to be provided directly.
    if (typeof key === 'object') {
      key = applyExtends(key, cwd)
      options.configObjects = (options.configObjects || []).concat(key)
      return self
    }

    // allow for a custom parsing function.
    if (typeof msg === 'function') {
      parseFn = msg
      msg = null
    }

    key = key || 'config'
    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))
    ;(Array.isArray(key) ? key : [key]).forEach((k) => {
      options.config[k] = parseFn || true
    })

    return self
  }

  self.example = function (cmd, description) {
    argsert('<string> [string]', [cmd, description], arguments.length)
    usage.example(cmd, description)
    return self
  }

  self.command = function (cmd, description, builder, handler, middlewares) {
    argsert('<string|array|object> [string|boolean] [function|object] [function] [array]', [cmd, description, builder, handler, middlewares], arguments.length)
    command.addHandler(cmd, description, builder, handler, middlewares)
    return self
  }

  self.commandDir = function (dir, opts) {
    argsert('<string> [object]', [dir, opts], arguments.length)
    const req = parentRequire || __webpack_require__("../../node_modules/yargs sync recursive")
    command.addDirectory(dir, self.getContext(), req, __webpack_require__(/*! get-caller-file */ "../../node_modules/get-caller-file/index.js")(), opts)
    return self
  }

  // TODO: deprecate self.demand in favor of
  // .demandCommand() .demandOption().
  self.demand = self.required = self.require = function demand (keys, max, msg) {
    // you can optionally provide a 'max' key,
    // which will raise an exception if too many '_'
    // options are provided.
    if (Array.isArray(max)) {
      max.forEach((key) => {
        self.demandOption(key, msg)
      })
      max = Infinity
    } else if (typeof max !== 'number') {
      msg = max
      max = Infinity
    }

    if (typeof keys === 'number') {
      self.demandCommand(keys, max, msg, msg)
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        self.demandOption(key, msg)
      })
    } else {
      if (typeof msg === 'string') {
        self.demandOption(keys, msg)
      } else if (msg === true || typeof msg === 'undefined') {
        self.demandOption(keys)
      }
    }

    return self
  }

  self.demandCommand = function demandCommand (min, max, minMsg, maxMsg) {
    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length)

    if (typeof min === 'undefined') min = 1

    if (typeof max !== 'number') {
      minMsg = max
      max = Infinity
    }

    self.global('_', false)

    options.demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg
    }

    return self
  }

  self.getDemandedOptions = () => {
    argsert([], 0)
    return options.demandedOptions
  }

  self.getDemandedCommands = () => {
    argsert([], 0)
    return options.demandedCommands
  }

  self.implies = function (key, value) {
    argsert('<string|object> [number|string|array]', [key, value], arguments.length)
    validation.implies(key, value)
    return self
  }

  self.conflicts = function (key1, key2) {
    argsert('<string|object> [string|array]', [key1, key2], arguments.length)
    validation.conflicts(key1, key2)
    return self
  }

  self.usage = function (msg, description, builder, handler) {
    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length)

    if (description !== undefined) {
      // .usage() can be used as an alias for defining
      // a default command.
      if ((msg || '').match(/^\$0( |$)/)) {
        return self.command(msg, description, builder, handler)
      } else {
        throw new YError('.usage() description must start with $0 if being used as alias for .command()')
      }
    } else {
      usage.usage(msg)
      return self
    }
  }

  self.epilogue = self.epilog = function (msg) {
    argsert('<string>', [msg], arguments.length)
    usage.epilog(msg)
    return self
  }

  self.fail = function (f) {
    argsert('<function>', [f], arguments.length)
    usage.failFn(f)
    return self
  }

  self.check = function (f, _global) {
    argsert('<function> [boolean]', [f, _global], arguments.length)
    validation.check(f, _global !== false)
    return self
  }

  self.global = function global (globals, global) {
    argsert('<string|array> [boolean]', [globals, global], arguments.length)
    globals = [].concat(globals)
    if (global !== false) {
      options.local = options.local.filter(l => globals.indexOf(l) === -1)
    } else {
      globals.forEach((g) => {
        if (options.local.indexOf(g) === -1) options.local.push(g)
      })
    }
    return self
  }

  self.pkgConf = function pkgConf (key, rootPath) {
    argsert('<string> [string]', [key, rootPath], arguments.length)
    let conf = null
    // prefer cwd to require-main-filename in this method
    // since we're looking for e.g. "nyc" config in nyc consumer
    // rather than "yargs" config in nyc (where nyc is the main filename)
    const obj = pkgUp(rootPath || cwd)

    // If an object exists in the key, add it to options.configObjects
    if (obj[key] && typeof obj[key] === 'object') {
      conf = applyExtends(obj[key], rootPath || cwd)
      options.configObjects = (options.configObjects || []).concat(conf)
    }

    return self
  }

  const pkgs = {}
  function pkgUp (rootPath) {
    const npath = rootPath || '*'
    if (pkgs[npath]) return pkgs[npath]
    const findUp = __webpack_require__(/*! find-up */ "../../node_modules/yargs/node_modules/find-up/index.js")

    let obj = {}
    try {
      let startDir = rootPath || __webpack_require__(/*! require-main-filename */ "../../node_modules/require-main-filename/index.js")(parentRequire || __webpack_require__("../../node_modules/yargs sync recursive"))

      // When called in an environment that lacks require.main.filename, such as a jest test runner,
      // startDir is already process.cwd(), and should not be shortened.
      // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.
      if (!rootPath && path.extname(startDir)) {
        startDir = path.dirname(startDir)
      }

      const pkgJsonPath = findUp.sync('package.json', {
        cwd: startDir
      })
      obj = JSON.parse(fs.readFileSync(pkgJsonPath))
    } catch (noop) {}

    pkgs[npath] = obj || {}
    return pkgs[npath]
  }

  let parseFn = null
  let parseContext = null
  self.parse = function parse (args, shortCircuit, _parseFn) {
    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length)
    if (typeof args === 'undefined') {
      return self._parseArgs(processArgs)
    }

    // a context object can optionally be provided, this allows
    // additional information to be passed to a command handler.
    if (typeof shortCircuit === 'object') {
      parseContext = shortCircuit
      shortCircuit = _parseFn
    }

    // by providing a function as a second argument to
    // parse you can capture output that would otherwise
    // default to printing to stdout/stderr.
    if (typeof shortCircuit === 'function') {
      parseFn = shortCircuit
      shortCircuit = null
    }
    // completion short-circuits the parsing process,
    // skipping validation, etc.
    if (!shortCircuit) processArgs = args

    freeze()
    if (parseFn) exitProcess = false

    const parsed = self._parseArgs(args, shortCircuit)
    if (parseFn) parseFn(exitError, parsed, output)
    unfreeze()

    return parsed
  }

  self._getParseContext = () => parseContext || {}

  self._hasParseCallback = () => !!parseFn

  self.option = self.options = function option (key, opt) {
    argsert('<string|object> [object]', [key, opt], arguments.length)
    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self.options(k, key[k])
      })
    } else {
      if (typeof opt !== 'object') {
        opt = {}
      }

      options.key[key] = true // track manually set keys.

      if (opt.alias) self.alias(key, opt.alias)

      const demand = opt.demand || opt.required || opt.require

      // deprecated, use 'demandOption' instead
      if (demand) {
        self.demand(key, demand)
      }

      if (opt.demandOption) {
        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined)
      }

      if ('conflicts' in opt) {
        self.conflicts(key, opt.conflicts)
      }

      if ('default' in opt) {
        self.default(key, opt.default)
      }

      if ('implies' in opt) {
        self.implies(key, opt.implies)
      }

      if ('nargs' in opt) {
        self.nargs(key, opt.nargs)
      }

      if (opt.config) {
        self.config(key, opt.configParser)
      }

      if (opt.normalize) {
        self.normalize(key)
      }

      if ('choices' in opt) {
        self.choices(key, opt.choices)
      }

      if ('coerce' in opt) {
        self.coerce(key, opt.coerce)
      }

      if ('group' in opt) {
        self.group(key, opt.group)
      }

      if (opt.boolean || opt.type === 'boolean') {
        self.boolean(key)
        if (opt.alias) self.boolean(opt.alias)
      }

      if (opt.array || opt.type === 'array') {
        self.array(key)
        if (opt.alias) self.array(opt.alias)
      }

      if (opt.number || opt.type === 'number') {
        self.number(key)
        if (opt.alias) self.number(opt.alias)
      }

      if (opt.string || opt.type === 'string') {
        self.string(key)
        if (opt.alias) self.string(opt.alias)
      }

      if (opt.count || opt.type === 'count') {
        self.count(key)
      }

      if (typeof opt.global === 'boolean') {
        self.global(key, opt.global)
      }

      if (opt.defaultDescription) {
        options.defaultDescription[key] = opt.defaultDescription
      }

      if (opt.skipValidation) {
        self.skipValidation(key)
      }

      const desc = opt.describe || opt.description || opt.desc
      self.describe(key, desc)
      if (opt.hidden) {
        self.hide(key)
      }

      if (opt.requiresArg) {
        self.requiresArg(key)
      }
    }

    return self
  }
  self.getOptions = () => options

  self.positional = function (key, opts) {
    argsert('<string> <object>', [key, opts], arguments.length)
    if (context.resets === 0) {
      throw new YError(".positional() can only be called in a command's builder function")
    }

    // .positional() only supports a subset of the configuration
    // options available to .option().
    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',
      'choices', 'conflicts', 'coerce', 'type', 'describe',
      'desc', 'description', 'alias']
    opts = objFilter(opts, (k, v) => {
      let accept = supportedOpts.indexOf(k) !== -1
      // type can be one of string|number|boolean.
      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false
      return accept
    })

    // copy over any settings that can be inferred from the command string.
    const fullCommand = context.fullCommands[context.fullCommands.length - 1]
    const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {
      array: [],
      alias: {},
      default: {},
      demand: {}
    }
    Object.keys(parseOptions).forEach((pk) => {
      if (Array.isArray(parseOptions[pk])) {
        if (parseOptions[pk].indexOf(key) !== -1) opts[pk] = true
      } else {
        if (parseOptions[pk][key] && !(pk in opts)) opts[pk] = parseOptions[pk][key]
      }
    })
    self.group(key, usage.getPositionalGroupName())
    return self.option(key, opts)
  }

  self.group = function group (opts, groupName) {
    argsert('<string|array> <string>', [opts, groupName], arguments.length)
    const existing = preservedGroups[groupName] || groups[groupName]
    if (preservedGroups[groupName]) {
      // we now only need to track this group name in groups.
      delete preservedGroups[groupName]
    }

    const seen = {}
    groups[groupName] = (existing || []).concat(opts).filter((key) => {
      if (seen[key]) return false
      return (seen[key] = true)
    })
    return self
  }
  // combine explicit and preserved groups. explicit groups should be first
  self.getGroups = () => Object.assign({}, groups, preservedGroups)

  // as long as options.envPrefix is not undefined,
  // parser will apply env vars matching prefix to argv
  self.env = function (prefix) {
    argsert('[string|boolean]', [prefix], arguments.length)
    if (prefix === false) options.envPrefix = undefined
    else options.envPrefix = prefix || ''
    return self
  }

  self.wrap = function (cols) {
    argsert('<number|null|undefined>', [cols], arguments.length)
    usage.wrap(cols)
    return self
  }

  let strict = false
  self.strict = function (enabled) {
    argsert('[boolean]', [enabled], arguments.length)
    strict = enabled !== false
    return self
  }
  self.getStrict = () => strict

  let parserConfig = {}
  self.parserConfiguration = function parserConfiguration (config) {
    argsert('<object>', [config], arguments.length)
    parserConfig = config
    return self
  }
  self.getParserConfiguration = () => parserConfig

  self.showHelp = function (level) {
    argsert('[string|function]', [level], arguments.length)
    if (!self.parsed) self._parseArgs(processArgs) // run parser, if it has not already been executed.
    if (command.hasDefaultCommand()) {
      context.resets++ // override the restriction on top-level positoinals.
      command.runDefaultBuilderOn(self, true)
    }
    usage.showHelp(level)
    return self
  }

  let versionOpt = null
  self.version = function version (opt, msg, ver) {
    const defaultVersionOpt = 'version'
    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length)

    // nuke the key previously configured
    // to return version #.
    if (versionOpt) {
      deleteFromParserHintObject(versionOpt)
      usage.version(undefined)
      versionOpt = null
    }

    if (arguments.length === 0) {
      ver = guessVersion()
      opt = defaultVersionOpt
    } else if (arguments.length === 1) {
      if (opt === false) { // disable default 'version' key.
        return self
      }
      ver = opt
      opt = defaultVersionOpt
    } else if (arguments.length === 2) {
      ver = msg
      msg = null
    }

    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt
    msg = msg || usage.deferY18nLookup('Show version number')

    usage.version(ver || undefined)
    self.boolean(versionOpt)
    self.describe(versionOpt, msg)
    return self
  }

  function guessVersion () {
    const obj = pkgUp()

    return obj.version || 'unknown'
  }

  let helpOpt = null
  self.addHelpOpt = self.help = function addHelpOpt (opt, msg) {
    const defaultHelpOpt = 'help'
    argsert('[string|boolean] [string]', [opt, msg], arguments.length)

    // nuke the key previously configured
    // to return help.
    if (helpOpt) {
      deleteFromParserHintObject(helpOpt)
      helpOpt = null
    }

    if (arguments.length === 1) {
      if (opt === false) return self
    }

    // use arguments, fallback to defaults for opt and msg
    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt
    self.boolean(helpOpt)
    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'))
    return self
  }

  const defaultShowHiddenOpt = 'show-hidden'
  options.showHiddenOpt = defaultShowHiddenOpt
  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt (opt, msg) {
    argsert('[string|boolean] [string]', [opt, msg], arguments.length)

    if (arguments.length === 1) {
      if (opt === false) return self
    }

    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt
    self.boolean(showHiddenOpt)
    self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'))
    options.showHiddenOpt = showHiddenOpt
    return self
  }

  self.hide = function hide (key) {
    argsert('<string|object>', [key], arguments.length)
    options.hiddenOptions.push(key)
    return self
  }

  self.showHelpOnFail = function showHelpOnFail (enabled, message) {
    argsert('[boolean|string] [string]', [enabled, message], arguments.length)
    usage.showHelpOnFail(enabled, message)
    return self
  }

  var exitProcess = true
  self.exitProcess = function (enabled) {
    argsert('[boolean]', [enabled], arguments.length)
    if (typeof enabled !== 'boolean') {
      enabled = true
    }
    exitProcess = enabled
    return self
  }
  self.getExitProcess = () => exitProcess

  var completionCommand = null
  self.completion = function (cmd, desc, fn) {
    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length)

    // a function to execute when generating
    // completions can be provided as the second
    // or third argument to completion.
    if (typeof desc === 'function') {
      fn = desc
      desc = null
    }

    // register the completion command.
    completionCommand = cmd || 'completion'
    if (!desc && desc !== false) {
      desc = 'generate completion script'
    }
    self.command(completionCommand, desc)

    // a function can be provided
    if (fn) completion.registerFunction(fn)

    return self
  }

  self.showCompletionScript = function ($0) {
    argsert('[string]', [$0], arguments.length)
    $0 = $0 || self.$0
    _logger.log(completion.generateCompletionScript($0, completionCommand))
    return self
  }

  self.getCompletion = function (args, done) {
    argsert('<array> <function>', [args, done], arguments.length)
    completion.getCompletion(args, done)
  }

  self.locale = function (locale) {
    argsert('[string]', [locale], arguments.length)
    if (arguments.length === 0) {
      guessLocale()
      return y18n.getLocale()
    }
    detectLocale = false
    y18n.setLocale(locale)
    return self
  }

  self.updateStrings = self.updateLocale = function (obj) {
    argsert('<object>', [obj], arguments.length)
    detectLocale = false
    y18n.updateLocale(obj)
    return self
  }

  let detectLocale = true
  self.detectLocale = function (detect) {
    argsert('<boolean>', [detect], arguments.length)
    detectLocale = detect
    return self
  }
  self.getDetectLocale = () => detectLocale

  var hasOutput = false
  var exitError = null
  // maybe exit, always capture
  // context about why we wanted to exit.
  self.exit = (code, err) => {
    hasOutput = true
    exitError = err
    if (exitProcess) process.exit(code)
  }

  // we use a custom logger that buffers output,
  // so that we can print to non-CLIs, e.g., chat-bots.
  const _logger = {
    log () {
      const args = []
      for (let i = 0; i < arguments.length; i++) args.push(arguments[i])
      if (!self._hasParseCallback()) console.log.apply(console, args)
      hasOutput = true
      if (output.length) output += '\n'
      output += args.join(' ')
    },
    error () {
      const args = []
      for (let i = 0; i < arguments.length; i++) args.push(arguments[i])
      if (!self._hasParseCallback()) console.error.apply(console, args)
      hasOutput = true
      if (output.length) output += '\n'
      output += args.join(' ')
    }
  }
  self._getLoggerInstance = () => _logger
  // has yargs output an error our help
  // message in the current execution context.
  self._hasOutput = () => hasOutput

  self._setHasOutput = () => {
    hasOutput = true
  }

  let recommendCommands
  self.recommendCommands = function (recommend) {
    argsert('[boolean]', [recommend], arguments.length)
    recommendCommands = typeof recommend === 'boolean' ? recommend : true
    return self
  }

  self.getUsageInstance = () => usage

  self.getValidationInstance = () => validation

  self.getCommandInstance = () => command

  self.terminalWidth = () => {
    argsert([], 0)
    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null
  }

  Object.defineProperty(self, 'argv', {
    get: () => self._parseArgs(processArgs),
    enumerable: true
  })

  self._parseArgs = function parseArgs (args, shortCircuit, _skipValidation, commandIndex) {
    let skipValidation = !!_skipValidation
    args = args || processArgs

    options.__ = y18n.__
    options.configuration = self.getParserConfiguration()

    // Deprecated
    let pkgConfig = pkgUp()['yargs']
    if (pkgConfig) {
      console.warn('Configuring yargs through package.json is deprecated and will be removed in the next major release, please use the JS API instead.')
      options.configuration = Object.assign({}, pkgConfig, options.configuration)
    }

    const parsed = Parser.detailed(args, options)
    let argv = parsed.argv
    if (parseContext) argv = Object.assign({}, argv, parseContext)
    const aliases = parsed.aliases

    argv.$0 = self.$0
    self.parsed = parsed

    try {
      guessLocale() // guess locale lazily, so that it can be turned off in chain.

      // while building up the argv object, there
      // are two passes through the parser. If completion
      // is being performed short-circuit on the first pass.
      if (shortCircuit) {
        return argv
      }

      // if there's a handler associated with a
      // command defer processing to it.
      if (helpOpt) {
        // consider any multi-char helpOpt alias as a valid help command
        // unless all helpOpt aliases are single-char
        // note that parsed.aliases is a normalized bidirectional map :)
        const helpCmds = [helpOpt]
          .concat(aliases[helpOpt] || [])
          .filter(k => k.length > 1)
        // check if help should trigger and strip it from _.
        if (~helpCmds.indexOf(argv._[argv._.length - 1])) {
          argv._.pop()
          argv[helpOpt] = true
        }
      }

      const handlerKeys = command.getCommands()
      const requestCompletions = completion.completionKey in argv
      const skipRecommendation = argv[helpOpt] || requestCompletions
      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0')

      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand
          for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {
            cmd = String(argv._[i])
            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {
              // commands are executed using a recursive algorithm that executes
              // the deepest command first; we keep track of the position in the
              // argv._ array that is currently being executed.
              return command.runCommand(cmd, self, parsed, i + 1)
            } else if (!firstUnknownCommand && cmd !== completionCommand) {
              firstUnknownCommand = cmd
              break
            }
          }

          // run the default command, if defined
          if (command.hasDefaultCommand() && !skipDefaultCommand) {
            return command.runCommand(null, self, parsed)
          }

          // recommend a command if recommendCommands() has
          // been enabled, and no commands were found to execute
          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {
            validation.recommendCommands(firstUnknownCommand, handlerKeys)
          }
        }

        // generate a completion script for adding to ~/.bashrc.
        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {
          if (exitProcess) setBlocking(true)
          self.showCompletionScript()
          self.exit(0)
        }
      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {
        return command.runCommand(null, self, parsed)
      }

      // we must run completions first, a user might
      // want to complete the --help or --version option.
      if (requestCompletions) {
        if (exitProcess) setBlocking(true)

        // we allow for asynchronous completions,
        // e.g., loading in a list of commands from an API.
        const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1)
        completion.getCompletion(completionArgs, (completions) => {
          ;(completions || []).forEach((completion) => {
            _logger.log(completion)
          })

          self.exit(0)
        })
        return argv
      }

      // Handle 'help' and 'version' options
      // if we haven't already output help!
      if (!hasOutput) {
        Object.keys(argv).forEach((key) => {
          if (key === helpOpt && argv[key]) {
            if (exitProcess) setBlocking(true)

            skipValidation = true
            self.showHelp('log')
            self.exit(0)
          } else if (key === versionOpt && argv[key]) {
            if (exitProcess) setBlocking(true)

            skipValidation = true
            usage.showVersion()
            self.exit(0)
          }
        })
      }

      // Check if any of the options to skip validation were provided
      if (!skipValidation && options.skipValidation.length > 0) {
        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true)
      }

      // If the help or version options where used and exitProcess is false,
      // or if explicitly skipped, we won't run validations.
      if (!skipValidation) {
        if (parsed.error) throw new YError(parsed.error.message)

        // if we're executed via bash completion, don't
        // bother with validation.
        if (!requestCompletions) {
          self._runValidation(argv, aliases, {}, parsed.error)
        }
      }
    } catch (err) {
      if (err instanceof YError) usage.fail(err.message, err)
      else throw err
    }

    return argv
  }

  self._runValidation = function runValidation (argv, aliases, positionalMap, parseErrors) {
    if (parseErrors) throw new YError(parseErrors.message || parseErrors)
    validation.nonOptionCount(argv)
    validation.requiredArguments(argv)
    if (strict) validation.unknownArguments(argv, aliases, positionalMap)
    validation.customChecks(argv, aliases)
    validation.limitedChoices(argv)
    validation.implications(argv)
    validation.conflicting(argv)
  }

  function guessLocale () {
    if (!detectLocale) return

    try {
      const { env } = process
      const locale = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE || 'en_US'
      self.locale(locale.replace(/[.:].*/, ''))
    } catch (err) {
      // if we explode looking up locale just noop
      // we'll keep using the default language 'en'.
    }
  }

  // an app should almost always have --version and --help,
  // if you *really* want to disable this use .help(false)/.version(false).
  self.help()
  self.version()

  return self
}

// rebase an absolute path to a relative one with respect to a base directory
// exported for tests
exports.rebase = rebase
function rebase (base, dir) {
  return path.relative(base, dir)
}


/***/ }),

/***/ "../../node_modules/yargs sync recursive":
/*!**************************************!*\
  !*** ../../node_modules/yargs/ sync ***!
  \**************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../../node_modules/yargs sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../../performance/dist/src/Performance.js":
/*!*************************************************!*\
  !*** ../../performance/dist/src/Performance.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOrCreatePerformance = exports.initializePerformanceInstance = exports.Performance = void 0;
const performance_ponyfill_1 = __webpack_require__(/*! performance-ponyfill */ "../../node_modules/performance-ponyfill/node-ponyfill.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const WaterfallNode_1 = __webpack_require__(/*! ./WaterfallNode */ "../../performance/dist/src/WaterfallNode.js");
const PerformanceBlocks_1 = __webpack_require__(/*! ./PerformanceBlocks */ "../../performance/dist/src/PerformanceBlocks.js");
/**
 * Main performance measurement class. Meant do be used recusively,
 * e.g. every `createGroup` mathod call will return the instance of
 * the same class which is linked to the parent. This allows to create
 * callstack-like performance trees or waterfalls.
 */
class Performance {
    constructor(name, groupId, pathString = 'start') {
        this.name = name;
        this.groupId = groupId;
        this.pathString = pathString;
        this.groups = [];
        this.onAnyEventEmitter = new vscode_jsonrpc_1.Emitter();
        this.onAnyEvent = this.onAnyEventEmitter.event;
        /**
         * Create the child subgroup of the current group.
         * All the performance groups must have the reference to the top-level performance
         * class, since searching for any of the group/event ids should be possible from any
         * of the performance groups.
         */
        this.createGroup = (groupName, groupdId = Performance.groupCount++) => {
            const pathString = `${this.pathString}.${groupName}.${this.groupId}`;
            const newGroup = new Performance(groupName, groupdId, pathString);
            newGroup.setMainPerformance(this.main);
            newGroup.onAnyEvent((e) => {
                this.onAnyEventEmitter.fire(e);
            });
            this.groups.push(newGroup);
            return newGroup;
        };
        /**
         * Marks `start` or `end` point of a code block that need to be measured
         * in between. see `blocks.markBlock` method note for man example.
         */
        this.markBlock = (blockOptions) => {
            this.blocks.markBlock(blockOptions);
            return this;
        };
        /**
         * Marks `start` point of a code block that need to be measured
         * in between. see `blocks.markBlock` method note for man example.
         */
        this.markBlockStart = (blockOptions, ignoreExistingBlock = false) => {
            try {
                this.blocks.markBlockStart(blockOptions);
            }
            catch (e) {
                if (!ignoreExistingBlock) {
                    throw e;
                }
            }
            return this;
        };
        /**
         * Marks `end` point of a code block that need to be measured
         * in between. see `blocks.markBlock` method note for man example.
         */
        this.markBlockEnd = (blockOptions, ignoreExistingBlock = false) => {
            try {
                this.blocks.markBlockEnd(blockOptions);
            }
            catch (e) {
                if (!ignoreExistingBlock) {
                    throw e;
                }
            }
            return this;
        };
        /**
         * Convenience method for the `markBlock` method. Instead of calling
         * the `markBlock` twice, the `measure` can wrap the code block of interest
         * into an asynchronous function hence be called only once.
         */
        this.measure = (options, callback) => __awaiter(this, void 0, void 0, function* () {
            return yield this.blocks.measure(options, callback);
        });
        /**
         * Sync version of the `measure`.
         */
        this.measureSync = (options, callback) => {
            return this.blocks.measureSync(options, callback);
        };
        /**
         * Get waterfall of all the nested performance blocks, starting from the main
         * "start" root node that is initialized as singleton when app starts.
         */
        this.getWaterfall = () => {
            performance_ponyfill_1.performance.measure(this.pathString, this.pathString);
            const [measure] = performance_ponyfill_1.performance.getEntriesByName(this.pathString);
            const node = new WaterfallNode_1.WaterfallNode(this.groupId, this.name, this.pathString, measure, this.blocks.measures(), this.groups);
            return node;
        };
        /**
         * Get a measurement of a specific block by `id`.
         */
        this.getBlockMeasure = (id, waterfall) => {
            waterfall = waterfall !== null && waterfall !== void 0 ? waterfall : this.main.getWaterfall();
            if (waterfall.id === id) {
                return waterfall;
            }
            for (let group of waterfall.groups) {
                const result = this.getBlockMeasure(id, group);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        this.getBlock = (id) => {
            return this.blocks.getBlock(id);
        };
        /**
         * Get block `startTime` by block `id` or `null` if block is not found.
         */
        this.getBlockStartTime = (id) => {
            const block = this.main.getBlockMeasure(id);
            ;
            if (!block) {
                return null;
            }
            const { measure } = block;
            return measure.startTime;
        };
        /**
         * Get block `endTime` by block `id` or `null` if block is not found.
         */
        this.getBlockEndTime = (id) => {
            const block = this.main.getBlockMeasure(id);
            ;
            if (!block) {
                return null;
            }
            const { measure } = block;
            return measure.startTime + measure.duration;
        };
        /**
         * Get block `durationTime` by block `id` or `null` if block is not found.
         */
        this.getBlockDurationTime = (id) => {
            const block = this.main.getBlockMeasure(id);
            ;
            if (!block) {
                return null;
            }
            const { measure } = block;
            return measure.duration;
        };
        this.blocks = new PerformanceBlocks_1.PerformanceBlocks(pathString);
        performance_ponyfill_1.performance.mark(pathString);
        // set self as "main" performance initialy
        this.mainPerformanceReference = this;
        this.blocks.onAnyEvent((e) => {
            this.onAnyEventEmitter.fire(e);
        });
    }
    setMainPerformance(performance) {
        this.mainPerformanceReference = performance;
    }
    get main() {
        if (!this.mainPerformanceReference) {
            throw new Error('No main performance found.');
        }
        return this.mainPerformanceReference;
    }
    /**
     * Subscribe to `start` or `end` events of a block by `id`.
     */
    onEvent(options, callback) {
        this.blocks.onEvent(options, (opts) => {
            const { id, type } = opts;
            if (type === 'start') {
                callback(opts);
                return this;
            }
            const node = this.getBlockMeasure(id);
            if (!node) {
                throw new Error(`Cannot find "${id}" block.`);
            }
            callback(opts, node);
        });
        return this;
    }
    /**
     * Subscribe to `start` or `end` events of a block by `id`.
     */
    onMeasure(options, callback) {
        this.blocks.onEvent(options, (opts) => {
            const { id, type } = opts;
            if (type === 'start') {
                callback(opts);
                return this;
            }
            const node = this.getBlockMeasure(id);
            if (!node) {
                throw new Error(`Cannot find "${id}" block.`);
            }
            callback(opts, node);
        });
        return this;
    }
}
exports.Performance = Performance;
Performance.groupCount = 0;
/**
 * Function to initialize the main performance singleton class, meant to be
 * called on the app startup.a
 */
const initializePerformanceInstance = (groupdId, PerformanceClass = Performance) => {
    const codespacePerformance = new PerformanceClass('start', groupdId);
    codespacePerformance.setMainPerformance(codespacePerformance);
    return codespacePerformance;
};
exports.initializePerformanceInstance = initializePerformanceInstance;
/**
 * Get or create an instance of Performance for the group ID (default is 'extension:start').
 * Throws an error if group ID is empty or undefined, or performance has already been initialized with a different group ID.
 *
 * @param groupId Group id, by default it is 'extension:start'
 * @returns Created or existing instance of Performance with the given group ID.
 */
exports.getOrCreatePerformance = (0, vscs_utils_1.onlyOnce)((groupId) => (0, exports.initializePerformanceInstance)(groupId), 'extension:start');
//# sourceMappingURL=Performance.js.map

/***/ }),

/***/ "../../performance/dist/src/PerformanceBlocks.js":
/*!*******************************************************!*\
  !*** ../../performance/dist/src/PerformanceBlocks.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceBlocks = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const performance_ponyfill_1 = __webpack_require__(/*! performance-ponyfill */ "../../node_modules/performance-ponyfill/node-ponyfill.js");
/**
 * Utility class to abstract methods around mesuaring performance blocks.
 */
class PerformanceBlocks {
    /**
     * The `pathString` param used to define a full path of a block in
     * the nested blocks tree. Hence the path includes the paths of all
     * parents of the current block in the nested tree.
     */
    constructor(pathString) {
        this.pathString = pathString;
        this.blocks = {};
        /**
         * Events for any block `start`/`end` event.
         */
        this.onAnyEventEmitter = new vscode_jsonrpc_1.Emitter();
        this.onAnyEvent = this.onAnyEventEmitter.event;
        /**
         * Mark a `start` or `end` of a code block to measure. Must include
         * a name and can include `id` in case the block measurements need to
         * be retrieved later.
         *
         * Example:
         *
         * ```typescript
         * performanceBlocks.markBlock({ name: 'fetching info', type: 'start' });
         * // .. do some work
         * performanceBlocks.markBlock({ name: 'fetching info', type: 'end' });
         * ```
         * If id is not defined, name for the `start` and `end` should be equal.
         * Each `start` or `end` block with the same `name`/`id` expected to be
         * called once.
         */
        this.markBlock = (blockOptions) => {
            const { id, name, type } = blockOptions;
            // get unique block id
            const blockPath = `${this.pathString}.block: ${id !== null && id !== void 0 ? id : name}`;
            // get unique block id for the side (`start`/`end`) of the block
            const pathStringSide = `${blockPath}-${type}`;
            if (this.blocks[blockPath] && this.blocks[blockPath][type]) {
                throw new Error(`The event "${pathStringSide}" already marked in this group.`);
            }
            performance_ponyfill_1.performance.mark(pathStringSide);
            const [measure] = performance_ponyfill_1.performance.getEntriesByName(pathStringSide);
            const currentBlock = this.blocks[blockPath] || {
                path: blockPath,
                id: type === 'start' ? id : undefined,
                name: type === 'start' ? name : undefined,
            };
            currentBlock[blockOptions.type] = Object.assign(Object.assign({}, blockOptions), { path: pathStringSide });
            this.blocks[blockPath] = currentBlock;
            // only elements with id can have event listeners
            if (id && measure !== undefined) {
                const event = { id, name, type, measure };
                /**
                 * For the `end` event types, the measure ``
                 */
                if (type === 'end') {
                    const [startMeasure] = performance_ponyfill_1.performance.getEntriesByName(`${blockPath}-start`);
                    if (!startMeasure) {
                        throw new Error(`No start block found for event ${id}`);
                    }
                    event.measure = Object.assign(Object.assign({}, measure), { duration: measure.startTime - startMeasure.startTime });
                }
                this.onAnyEventEmitter.fire(event);
                this.invokeBlock(event);
            }
            return this;
        };
        /**
         * Mark the beginning of the block, same as above with `type: 'start'`
         */
        this.markBlockStart = (blockOptions) => {
            return this.markBlock(Object.assign({ type: 'start' }, blockOptions));
        };
        /**
         * Mark the end of the block, same as above with `type: 'end'`
         */
        this.markBlockEnd = (blockOptions) => {
            return this.markBlock(Object.assign({ type: 'end' }, blockOptions));
        };
        this.getBlock = (id) => {
            const blockPath = `${this.pathString}.block: ${id}`;
            const block = this.blocks[blockPath];
            if (!block) {
                return undefined;
            }
            return block;
        };
        /**
         * Convenience method around the `markBlock` since that later has to be
         * called twice - once for `start` and once for `end`, we created this
         * wrapper method that does that for the user.
         */
        this.measure = (options, callback) => __awaiter(this, void 0, void 0, function* () {
            this.markBlock(Object.assign(Object.assign({}, options), { type: 'start' }));
            try {
                return yield callback();
            }
            finally {
                this.markBlock(Object.assign(Object.assign({}, options), { type: 'end' }));
            }
        });
        /**
         * Sync version of the `measure`.
         */
        this.measureSync = (options, callback) => {
            this.markBlock(Object.assign(Object.assign({}, options), { type: 'start' }));
            try {
                return callback();
            }
            finally {
                this.markBlock(Object.assign(Object.assign({}, options), { type: 'end' }));
            }
        };
        /**
         * Method to calculate(measure) all the currently tracked timing blocks.
         */
        this.measures = () => {
            const blocks = [];
            for (let [id, block] of Object.entries(this.blocks)) {
                const { start, end } = block;
                if (!start || !end) {
                    continue;
                }
                performance_ponyfill_1.performance.measure(block.path, `${start.path}`, `${end.path}`);
                const [measure] = performance_ponyfill_1.performance.getEntriesByName(block.path);
                if (!measure) {
                    throw new Error(`No measure found in Performance API for "${id}".`);
                }
                blocks.push({
                    id: block.id,
                    name: block.name,
                    measure,
                });
            }
            return blocks;
        };
        this.invokeBlock = (options) => {
            const blockCallbackId = this.getBlockCallbackId(options);
            const emitter = PerformanceBlocks.onEventEmitters[blockCallbackId];
            if (!emitter) {
                return;
            }
            emitter.fire(options);
        };
        this.getBlockCallbackId = (options) => {
            const { id, type } = options;
            return `${id}-${type}`;
        };
        /**
         * Method to define event listeners for the `start` or `end` block sides.
         */
        this.onEvent = (options, callback) => {
            const blockCallbackId = this.getBlockCallbackId(options);
            let emitter = PerformanceBlocks.onEventEmitters[blockCallbackId];
            if (!emitter) {
                emitter = new vscode_jsonrpc_1.Emitter();
                PerformanceBlocks.onEventEmitters[blockCallbackId] = emitter;
            }
            emitter.event(callback);
            return this;
        };
    }
}
exports.PerformanceBlocks = PerformanceBlocks;
PerformanceBlocks.onEventEmitters = {};
//# sourceMappingURL=PerformanceBlocks.js.map

/***/ }),

/***/ "../../performance/dist/src/WaterfallNode.js":
/*!***************************************************!*\
  !*** ../../performance/dist/src/WaterfallNode.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaterfallNode = void 0;
class WaterfallNode {
    constructor(id, name, path, rawMeasure, blocks, perfGoups) {
        this.id = id;
        this.name = name;
        this.path = path;
        this.rawMeasure = rawMeasure;
        this.perfGoups = perfGoups;
        this.groups = [];
        this.getTotalDuration = () => {
            let maxTime = 0;
            for (let group of this.groups) {
                const totalTime = group.measure.startTime + group.measure.duration;
                if (totalTime > maxTime) {
                    maxTime = totalTime;
                }
            }
            return maxTime;
        };
        // measure properties are not
        // iterable, need to copy by hand
        this.measure = {
            name: rawMeasure.name,
            duration: rawMeasure.duration,
            startTime: rawMeasure.startTime,
            entryType: rawMeasure.entryType,
        };
        for (let block of blocks) {
            this.groups.push(Object.assign(Object.assign({}, block), { groups: [] }));
        }
        for (let group of this.perfGoups) {
            this.groups.push(group.getWaterfall());
        }
        const duration = this.getTotalDuration() - this.measure.startTime;
        this.measure = Object.assign(Object.assign({}, this.measure), { duration });
    }
}
exports.WaterfallNode = WaterfallNode;
//# sourceMappingURL=WaterfallNode.js.map

/***/ }),

/***/ "../../performance/dist/src/index.js":
/*!*******************************************!*\
  !*** ../../performance/dist/src/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mocks = exports.logPerformanceWaterfall = exports.getOrCreatePerformance = exports.initializePerformanceInstance = exports.Performance = void 0;
var Performance_1 = __webpack_require__(/*! ./Performance */ "../../performance/dist/src/Performance.js");
Object.defineProperty(exports, "Performance", ({ enumerable: true, get: function () { return Performance_1.Performance; } }));
Object.defineProperty(exports, "initializePerformanceInstance", ({ enumerable: true, get: function () { return Performance_1.initializePerformanceInstance; } }));
Object.defineProperty(exports, "getOrCreatePerformance", ({ enumerable: true, get: function () { return Performance_1.getOrCreatePerformance; } }));
var logPerformanceWaterfall_1 = __webpack_require__(/*! ./logPerformanceWaterfall */ "../../performance/dist/src/logPerformanceWaterfall.js");
Object.defineProperty(exports, "logPerformanceWaterfall", ({ enumerable: true, get: function () { return logPerformanceWaterfall_1.logPerformanceWaterfall; } }));
exports.mocks = __importStar(__webpack_require__(/*! ./mocks */ "../../performance/dist/src/mocks/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../performance/dist/src/logPerformanceWaterfall.js":
/*!*************************************************************!*\
  !*** ../../performance/dist/src/logPerformanceWaterfall.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logPerformanceWaterfall = void 0;
const ansi_colors_1 = __importDefault(__webpack_require__(/*! ansi-colors */ "../../node_modules/ansi-colors/index.js"));
const sortByStartTime_1 = __webpack_require__(/*! ./sortByStartTime */ "../../performance/dist/src/sortByStartTime.js");
const logInternal = (type, name, startTime, duration, rootStartTime) => {
    const connectionTimes = `[${startTime}ms - ${startTime + duration}ms]`;
    console[type]([
        `${name}:`,
        ansi_colors_1.default.cyan(`${duration}ms`),
        ansi_colors_1.default.magenta(`+${startTime - rootStartTime}ms`),
        ansi_colors_1.default.gray(connectionTimes),
    ].join(' '));
};
const log = (name, startTime, duration, rootStartTime) => {
    logInternal('log', name, startTime, duration, rootStartTime);
};
const group = (name, startTime, duration, rootStartTime) => {
    logInternal('groupCollapsed', name, startTime, duration, rootStartTime);
};
const logEmptyNode = (node, rootStartTime) => {
    const { name, measure } = node;
    const { startTime, duration } = measure;
    log(name, Math.round(startTime), Math.round(duration), rootStartTime);
};
const logPerformanceWaterfall = (root, rootStartTime) => {
    const { measure, name } = root;
    const { startTime, duration } = measure;
    const roundStartTime = Math.round(startTime);
    rootStartTime = rootStartTime !== null && rootStartTime !== void 0 ? rootStartTime : Math.round(startTime);
    // log the `root` group
    group(name, roundStartTime, Math.round(duration), rootStartTime);
    // log either `group` or `block`
    for (let item of (0, sortByStartTime_1.sortByStartTime)([...root.groups])) {
        item.groups.length
            ? (0, exports.logPerformanceWaterfall)(item, rootStartTime)
            : logEmptyNode(item, rootStartTime);
    }
    // end the `root` group
    console.groupEnd();
};
exports.logPerformanceWaterfall = logPerformanceWaterfall;
//# sourceMappingURL=logPerformanceWaterfall.js.map

/***/ }),

/***/ "../../performance/dist/src/mocks/PerformanceMock.js":
/*!***********************************************************!*\
  !*** ../../performance/dist/src/mocks/PerformanceMock.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceMock = void 0;
const Performance_1 = __webpack_require__(/*! ../Performance */ "../../performance/dist/src/Performance.js");
class PerformanceMock extends Performance_1.Performance {
    /**
     * Expose the `groups` for tests.
     */
    get groupsMock() {
        return this.groups;
    }
}
exports.PerformanceMock = PerformanceMock;
;
//# sourceMappingURL=PerformanceMock.js.map

/***/ }),

/***/ "../../performance/dist/src/mocks/index.js":
/*!*************************************************!*\
  !*** ../../performance/dist/src/mocks/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceMock = void 0;
var PerformanceMock_1 = __webpack_require__(/*! ./PerformanceMock */ "../../performance/dist/src/mocks/PerformanceMock.js");
Object.defineProperty(exports, "PerformanceMock", ({ enumerable: true, get: function () { return PerformanceMock_1.PerformanceMock; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../performance/dist/src/sortByStartTime.js":
/*!*****************************************************!*\
  !*** ../../performance/dist/src/sortByStartTime.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sortByStartTime = void 0;
const sortByStartTime = (items) => {
    const result = [...items].sort((item1, item2) => {
        return item1.measure.startTime - item2.measure.startTime;
    });
    return result;
};
exports.sortByStartTime = sortByStartTime;
//# sourceMappingURL=sortByStartTime.js.map

/***/ }),

/***/ "../dist/src/LocalPortForwarder.js":
/*!*****************************************!*\
  !*** ../dist/src/LocalPortForwarder.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalPortForwarder = exports.ErrorCodes = exports.DEFAULT_SERVER_ADDRESS = exports.MessageWorkspaceClientClosed = void 0;
const net = __importStar(__webpack_require__(/*! net */ "net"));
const get_port_1 = __importDefault(__webpack_require__(/*! get-port */ "../../node_modules/get-port/index.js"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
exports.MessageWorkspaceClientClosed = 'Workspace client was closed.';
exports.DEFAULT_SERVER_ADDRESS = '127.0.0.1';
var ErrorCodes;
(function (ErrorCodes) {
    ErrorCodes["AlreadyInUse"] = "EADDRINUSE";
    ErrorCodes["NoAccess"] = "EACCES";
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
;
/**
 * Accepts incoming TCP connections on a local port and forwards them to a
 * shared server on the remote host.
 */
class LocalPortForwarder extends vscs_utils_1.DisposableClass {
    constructor(trace, sharedServer, workspaceConnection, streamManagerClient, localPortRef, Server = net.Server, rebindToRandomPortOnErrors = [
        ErrorCodes.AlreadyInUse,
        ErrorCodes.NoAccess,
    ], getFreePortNumber = get_port_1.default) {
        super(trace.createChild(`local-port-forwarder[${sharedServer.sourcePort}]`));
        this.sharedServer = sharedServer;
        this.workspaceConnection = workspaceConnection;
        this.streamManagerClient = streamManagerClient;
        this.localPortRef = localPortRef;
        this.rebindToRandomPortOnErrors = rebindToRandomPortOnErrors;
        this.getFreePortNumber = getFreePortNumber;
        this.connections = [];
        this.channels = [];
        this.forecastChannels = [];
        this.stoppingSignal = new vscs_utils_1.Signal();
        this.isClosed = false;
        this.trace.info('rebindToRandomPortOnErrors: ', JSON.stringify(rebindToRandomPortOnErrors));
        this.server = new Server(this.onConnection.bind(this));
        this.addToDisposables(workspaceConnection.onHostConnectionChanged(e => {
            if (e.state === vso_workspace_core_1.ConnectedState.Closed) {
                this.trace.info(exports.MessageWorkspaceClientClosed);
                this.isClosed = true;
                this.dispose('workspace connection closed');
            }
        }), this.onDispose(() => {
            this.stop()
                .catch((err) => {
                this.trace.error('Failed to stop local server.', err);
            });
        }));
    }
    get localPort() {
        return this.localPortRef;
    }
    /**
     * Start listening for incoming connections.
     */
    start(channelForecast = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.info(`start with "${channelForecast}" channels`);
                this.trace.info(`start: sourcePort=${this.sharedServer.sourcePort} localPort=${this.localPortRef} host=${this.sharedServer.sessionName}`);
                yield this.listen();
                this.trace.info('server started');
            }
            catch (error) {
                if (error instanceof Error) {
                    this.trace.info('error while starting: ', JSON.stringify((0, vscs_utils_1.errorToObject)(error)));
                    /**
                     * If error code is not on the list - rethrow the error,
                     * if error code is in the list, bind to a random port.
                     */
                    (0, vscs_utils_1.assert)(this.rebindToRandomPortOnErrors.includes(error.code), error);
                }
                this.trace.info('rebinding to a random port');
                // Try again, this time with a RANDOM port number.
                this.localPortRef = yield this.getFreePortNumber();
                yield this.listen();
                this.trace.info(`start (failed): sourcePort=${this.sharedServer.sourcePort} localPort=${this.localPortRef} host=${this.sharedServer.sessionName}`);
            }
            // Start opening the forecasted number of channels, so they will
            // will be available more quickly when requested.
            for (let i = 0; i < channelForecast; i++) {
                this.forecastChannels.push(this.openChannel());
            }
        });
    }
    stop() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info('stopping');
            if (!this.server.listening) {
                return;
            }
            for (const channel of this.channels) {
                (_a = channel.close()) === null || _a === void 0 ? void 0 : _a.catch((err) => this.trace.error(`failed to close channel`, err));
            }
            this.trace.verbose(`stop: stopping local server port=${this.localPortRef} connections=${this.connections.length}`);
            this.server.close((err) => {
                if (err) {
                    this.trace.error(`stop: failed to stop local server port=${this.localPortRef}`, err);
                    return this.stoppingSignal.reject(err);
                }
                this.trace.verbose(`stop: stopped local server port=${this.localPortRef}`, err);
                this.stoppingSignal.resolve();
            });
            for (const conn of this.connections) {
                conn.destroy();
            }
            return yield this.stoppingSignal.promise;
        });
    }
    listen() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise((resolve, reject) => {
                // Listen on the IPv4 loopback interface, because connections are only expected
                // from local clients.
                this.server.once('listening', () => {
                    this.trace.info(`listening on local port=${this.localPortRef}`);
                    resolve();
                });
                this.server.once('error', (e) => {
                    this.trace.error(`failed to listen on local port=${this.localPortRef}`, e);
                    reject(e);
                });
                this.trace.info(`start listen to port: "${exports.DEFAULT_SERVER_ADDRESS}:${this.localPortRef}"`);
                this.server.listen(this.localPortRef, exports.DEFAULT_SERVER_ADDRESS);
            });
        });
    }
    /**
     * Accept incoming connections from VS Code and forward them to the shared server.
     */
    onConnection(socket) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.connections.push(socket);
            try {
                // Wait for a forecasted channel if available, otherwise wait for a new channel.
                const channel = yield ((_a = this.forecastChannels.shift()) !== null && _a !== void 0 ? _a : this.openChannel());
                this.addToDisposables((0, vscs_utils_1.createDisposable)(() => {
                    channel.close();
                    socket.end();
                }), channel);
                this.channels.push(channel);
                // Normally these are SSH channels, which have a `channelId` property, but it's not required.
                const channelId = (_b = channel.channelId) !== null && _b !== void 0 ? _b : '?';
                this.trace.info(`Forwarding connection on channel #${channelId}.`);
                // Forward data between the socket and the SSH channel.
                socket.on('data', (data) => {
                    // console.log(ssh.formatBuffer(data, ` sending`));
                    // Block further data events while sending.
                    socket.pause();
                    channel.send(data).then(() => {
                        socket.resume();
                    }, (e) => {
                        this.trace.error('Error sending channel data: ' + e.message, e);
                    });
                });
                channel.onDataReceived((data) => {
                    // Make a copy of the data before passing it to the async socket.write()
                    // because the current buffer may get re-used after this callback returns.
                    data = Buffer.from(data);
                    // console.log(ssh.formatBuffer(data, ` receiving`));
                    socket.write(data, () => {
                        // Notify the channel that the data has been consumed and more data may be sent.
                        channel.adjustWindow(data.length);
                    });
                });
                // Propagate close events both directions.
                socket.on('close', () => {
                    var _a;
                    const i = this.connections.indexOf(socket);
                    if (i >= 0) {
                        this.connections.splice(i, 1);
                    }
                    (_a = channel
                        .close()) === null || _a === void 0 ? void 0 : _a.catch((e) => this.trace.error('Channel close failed with error', e));
                });
                socket.on('error', (e) => {
                    var _a;
                    const i = this.connections.indexOf(socket);
                    if (i >= 0) {
                        this.connections.splice(i, 1);
                    }
                    (_a = channel
                        .close(e)) === null || _a === void 0 ? void 0 : _a.catch((err) => this.trace.error('Channel close failed with error', err));
                });
                channel.onClosed((e) => {
                    if (e.error || e.errorMessage) {
                        const errorMsg = `Port-forward channel #${channelId} closed with error: ${e.error && e.error.message ? e.error.message : e.errorMessage}`;
                        this.trace.error(errorMsg);
                    }
                    else {
                        this.trace.info(`Port-forward channel #${channelId} closed.`);
                    }
                    socket.end();
                });
            }
            catch (error) {
                if (error instanceof Error) {
                    this.trace.error('Failed to forward incoming connection to remote server: ' + error.message, error);
                }
                socket.end();
            }
        });
    }
    /**
     * Open a new SSH channel that is remotely connected to the shared server.
     */
    openChannel() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assert)(!this.isClosed, exports.MessageWorkspaceClientClosed);
            const streamId = yield this.streamManagerClient.getStreamAsync(this.sharedServer.streamName, this.sharedServer.streamCondition);
            return yield this.workspaceConnection.openStreamingChannel(streamId);
        });
    }
}
exports.LocalPortForwarder = LocalPortForwarder;
//# sourceMappingURL=LocalPortForwarder.js.map

/***/ }),

/***/ "../dist/src/SudoPortForwarderClient.js":
/*!**********************************************!*\
  !*** ../dist/src/SudoPortForwarderClient.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SudoPortforwarderClient = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class SudoPortforwarderClient extends vscs_utils_1.DisposableClass {
    constructor(trace, portforwarderClient) {
        super(trace.createChild('sudo-pf-client'));
        this.portforwarderClient = portforwarderClient;
    }
    connect(hubPipeName) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            yield this.portforwarderClient.connectAsync(hubPipeName);
            const time = Math.round(Date.now() - start);
            this.trace.verbose(`connect codespacePortForwarderService completed -> time:${time}`);
        });
    }
    startPortForwarding(sharedServer) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            const localPort = yield this.portforwarderClient.startPortForwardingAsync(sharedServer);
            const time = Math.round(Date.now() - start);
            this.trace.verbose(`start portforwarding using codespacePortForwarderService completed -> time:${time}`);
            return localPort;
        });
    }
    stopPortForwarding(sharedServer) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            yield this.portforwarderClient.stopPortForwardingAsync(sharedServer);
            const time = Math.round(Date.now() - start);
            this.trace.verbose(`stop portforwarding using codespacePortForwarderService completed -> time:${time}`);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            yield this.portforwarderClient.disconnectAsync();
            const time = Math.round(Date.now() - start);
            this.trace.verbose(`disconnect codespacePortForwarderService completed -> time:${time}`);
        });
    }
}
exports.SudoPortforwarderClient = SudoPortforwarderClient;
//# sourceMappingURL=SudoPortForwarderClient.js.map

/***/ }),

/***/ "../dist/src/SudoPortForwarderService.js":
/*!***********************************************!*\
  !*** ../dist/src/SudoPortForwarderService.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SudoPortForwarderService = void 0;
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
const vsls_contracts_1 = __webpack_require__(/*! @vs/vsls-contracts */ "../../vsls-contracts/dist/src/index.js");
const LocalPortForwarder_1 = __webpack_require__(/*! ./LocalPortForwarder */ "../dist/src/LocalPortForwarder.js");
const SudoPortForwarderServiceClient_1 = __webpack_require__(/*! ./SudoPortForwarderServiceClient */ "../dist/src/SudoPortForwarderServiceClient.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class SudoPortForwarderService extends vscs_utils_1.DisposableClass {
    constructor(trace, workspaceId, connectionHub) {
        super(trace.createChild('sudo-pf-service'));
        this.workspaceId = workspaceId;
        this.connectionHub = connectionHub;
        this.sudoLocalPortForwarders = new Map();
        this.hubPipeName = null;
        this.rpcServer = new vso_rpc_1.RpcServer(trace.createChild('RpcServer'));
        this.rpcServer.registerRpcService(this, SudoPortForwarderServiceClient_1.SudoPortForwarderServiceClient);
        this.addToDisposables(this.rpcServer);
        this.rpcServer.addToDisposables(this);
    }
    acceptStream(rpcMessageStream) {
        const rpcConnection = this.rpcServer.acceptRpcMessageStream(rpcMessageStream)[0];
        rpcConnection.onClose(() => {
            this.disconnectAsync();
        });
        return rpcConnection;
    }
    connectAsync(hubPipeName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.hubPipeName = hubPipeName;
                const start = Date.now();
                this.trace.info(`connectAsync: Connecting now.. pipename ${hubPipeName}`);
                const connection = yield this.connectionHub.connect({
                    hubPipeName,
                    workspaceId: this.workspaceId,
                    liveShareEndpoint: '',
                    token: '',
                });
                connection.workspaceClient.rpcClient.onClose(() => {
                    this.sudoLocalPortForwarders.forEach((portForwarder) => __awaiter(this, void 0, void 0, function* () {
                        yield portForwarder.stop();
                    }));
                    this.sudoLocalPortForwarders = new Map();
                });
                const time = (Date.now() - start).toFixed(1);
                this.trace.verbose(`connectAsync: connected -> total time:${time}`);
            }
            catch (err) {
                this.trace.error('connectAsync: Error connecting', err);
                throw err;
            }
        });
    }
    startPortForwardingAsync(sharedServer) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.verbose(`startPortForwardingAsync`);
                const start = Date.now();
                (0, vscs_utils_1.assertDefined)(this.hubPipeName, 'No hub pipe name set, please call `connectAsync` first.');
                const connection = yield this.connectionHub.connect({
                    hubPipeName: this.hubPipeName,
                    workspaceId: this.workspaceId,
                    liveShareEndpoint: '',
                    token: '',
                });
                const streamManagerClient = connection.workspaceClient.getServiceProxy(vsls_contracts_1.vsls.StreamManagerService);
                const portForwarder = new LocalPortForwarder_1.LocalPortForwarder(this.trace, sharedServer, connection.workspaceClient, streamManagerClient, sharedServer.sourcePort, undefined, []);
                this.sudoLocalPortForwarders.set(sharedServer.sourcePort, portForwarder);
                yield portForwarder.start();
                const time = (Date.now() - start).toFixed(1);
                this.trace.verbose(`startPortForwardingAsync: forwarded port -> total time:${time}`);
                return portForwarder.localPort;
            }
            catch (err) {
                this.trace.error('startPortForwardingAsync: Error forwarding port', err);
                throw err;
            }
        });
    }
    stopPortForwardingAsync(sharedServer) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const portForwarder = this.sudoLocalPortForwarders.get(sharedServer.sourcePort);
                if (!portForwarder) {
                    this.trace.error(`stopPortForwardingAsync: Trying to stop port forwarder (for port ${sharedServer.sourcePort}) which is not already forwarded`);
                    return;
                }
                yield portForwarder.stop();
                this.sudoLocalPortForwarders.delete(sharedServer.sourcePort);
                this.trace.verbose('stopPortForwardingAsync: stopped forwarded port');
            }
            catch (err) {
                this.trace.error('stopPortForwardingAsync: Error stopping forwarded port', err);
                throw err;
            }
        });
    }
    disconnectAsync() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hubPipeName) {
                this.trace.info('not connected');
                return;
            }
            const connection = yield this.connectionHub.getConnection({
                hubPipeName: this.hubPipeName,
                workspaceId: this.workspaceId,
                liveShareEndpoint: '',
                token: '',
            });
            yield ((_a = connection === null || connection === void 0 ? void 0 : connection.workspaceClient) === null || _a === void 0 ? void 0 : _a.disconnect());
        });
    }
}
exports.SudoPortForwarderService = SudoPortForwarderService;
//# sourceMappingURL=SudoPortForwarderService.js.map

/***/ }),

/***/ "../dist/src/SudoPortForwarderServiceClient.js":
/*!*****************************************************!*\
  !*** ../dist/src/SudoPortForwarderServiceClient.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SudoPortForwarderServiceClient = void 0;
exports.SudoPortForwarderServiceClient = {
    name: 'csSudoPortForwarderServiceClient',
    methods: ['connect', 'startPortForwarding', 'stopPortForwarding', 'disconnect'],
    events: [],
};
//# sourceMappingURL=SudoPortForwarderServiceClient.js.map

/***/ }),

/***/ "../dist/src/connection/HubClientConnection.js":
/*!*****************************************************!*\
  !*** ../dist/src/connection/HubClientConnection.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HubClientConnection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscs_connection_hub_1 = __webpack_require__(/*! @vs/vscs-connection-hub */ "../../workspace/connection-hub/dist/src/index.js");
const vso_workspace_client_hub_1 = __webpack_require__(/*! @vs/vso-workspace-client-hub */ "../../workspace/client-hub/dist/src/index.js");
const vso_node_utils_1 = __webpack_require__(/*! @vs/vso-node-utils */ "../../node/utils/dist/src/index.js");
const dev_tunnels_ssh_1 = __webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js");
let hubClientSession = 0;
const MAX_RETRIES = 20;
const WAIT_TIME_MS = 1000;
;
/**
 * A hub client connection to use the hub-agent to create
 * liveshare connections thru the separate process.
 */
class HubClientConnection extends vscs_connection_hub_1.LiveShareConnection {
    constructor() {
        super(...arguments);
        this.socket = null;
    }
    get type() {
        return vscs_connection_hub_1.TConnectionTypes.WorkspaceHub;
    }
    /**
     * Create the WorkspaceClient that is capable of connecting thru the "remote" WorkspaceHub.
     */
    createWorkspaceClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const { hubPipeName } = this.options;
            const socket = yield this.startSocketSessionForHubWorkspace(hubPipeName);
            return yield vso_workspace_client_hub_1.WorkspaceHubClient.create(new dev_tunnels_ssh_1.NodeStream(socket), this.trace.createChild(`workspace-hub-client:${++hubClientSession}`));
        });
    }
    /**
     * Connect to the WorkspaceHub socket.
     */
    startSocketSessionForHubWorkspace(hubPipeName) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, vscs_utils_1.withRetries)((retriesLeft) => __awaiter(this, void 0, void 0, function* () {
                const retry = MAX_RETRIES - retriesLeft;
                this.trace
                    .verbose(`trying to connect to the TCP socket, retries left: "${retriesLeft}" (retry: "${retry}")`);
                const pipeName = retry === 0 ? hubPipeName : `${hubPipeName}-${retry}`;
                this.socket = yield (0, vso_node_utils_1.startSocketSessionOnPipe)(pipeName);
                this.socket.on('close', this.dispose.bind(this, 'TCP socket closed.'));
                this.socket.on('end', this.dispose.bind(this, 'TCP socket ended'));
                return this.socket;
            }), {
                retries: MAX_RETRIES,
                retryDelay: WAIT_TIME_MS,
            });
        });
    }
    /**
     * Make sure we disconnect from the WorkspaceHub and close
     * the socket on dispose.
     */
    dispose(reason) {
        var _a, _b;
        if (this.isDisposed) {
            return;
        }
        // disconnect WorkspaceClient
        (_a = this.workspaceClientReference) === null || _a === void 0 ? void 0 : _a.disconnect().catch((error) => {
            this.trace.verbose('error while disconnecting workspace client: ', (0, vscs_utils_1.errorToObject)(error));
        }).finally(() => {
            var _a;
            (_a = this.workspaceClientReference) === null || _a === void 0 ? void 0 : _a.dispose(reason);
            this.workspaceClientReference = undefined;
            this.workspaceSessionInfoReference = undefined;
        });
        // close the socket
        (_b = this.socket) === null || _b === void 0 ? void 0 : _b.destroy();
        return;
    }
}
__decorate([
    (0, vscs_utils_1.withHelperDecorator)(vscs_utils_1.once),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], HubClientConnection.prototype, "startSocketSessionForHubWorkspace", null);
exports.HubClientConnection = HubClientConnection;
;
//# sourceMappingURL=HubClientConnection.js.map

/***/ }),

/***/ "../dist/src/connection/connection-hub.js":
/*!************************************************!*\
  !*** ../dist/src/connection/connection-hub.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initWorkspaceHubConnectionHub = void 0;
const vscs_connection_hub_1 = __webpack_require__(/*! @vs/vscs-connection-hub */ "../../workspace/connection-hub/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const HubClientConnection_1 = __webpack_require__(/*! ./HubClientConnection */ "../dist/src/connection/HubClientConnection.js");
const performance_1 = __webpack_require__(/*! ../performance/performance */ "../dist/src/performance/performance.js");
/**
 * "Persistent" conenction hub that maintains
 * conenction in a separate process.
 */
exports.initWorkspaceHubConnectionHub = (0, vscs_utils_1.once)((trace) => {
    // connection in separate process
    const remoteConnectionHub = new vscs_connection_hub_1.ConnectionHub(trace.createChild('sudo-pf-remote'), performance_1.performance, HubClientConnection_1.HubClientConnection);
    return remoteConnectionHub;
});
//# sourceMappingURL=connection-hub.js.map

/***/ }),

/***/ "../dist/src/constants.js":
/*!********************************!*\
  !*** ../dist/src/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LOGS_DIRECTORY = void 0;
exports.LOGS_DIRECTORY = 'CodespacePortForwarder_logs';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../dist/src/index.js":
/*!****************************!*\
  !*** ../dist/src/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LOGS_DIRECTORY = exports.LocalPortForwarder = exports.SudoPortforwarderClient = exports.SudoPortForwarderService = exports.initWorkspaceHubConnectionHub = exports.SudoPortForwarderServiceClient = void 0;
var SudoPortForwarderServiceClient_1 = __webpack_require__(/*! ./SudoPortForwarderServiceClient */ "../dist/src/SudoPortForwarderServiceClient.js");
Object.defineProperty(exports, "SudoPortForwarderServiceClient", ({ enumerable: true, get: function () { return SudoPortForwarderServiceClient_1.SudoPortForwarderServiceClient; } }));
var connection_hub_1 = __webpack_require__(/*! ./connection/connection-hub */ "../dist/src/connection/connection-hub.js");
Object.defineProperty(exports, "initWorkspaceHubConnectionHub", ({ enumerable: true, get: function () { return connection_hub_1.initWorkspaceHubConnectionHub; } }));
var SudoPortForwarderService_1 = __webpack_require__(/*! ./SudoPortForwarderService */ "../dist/src/SudoPortForwarderService.js");
Object.defineProperty(exports, "SudoPortForwarderService", ({ enumerable: true, get: function () { return SudoPortForwarderService_1.SudoPortForwarderService; } }));
var SudoPortForwarderClient_1 = __webpack_require__(/*! ./SudoPortForwarderClient */ "../dist/src/SudoPortForwarderClient.js");
Object.defineProperty(exports, "SudoPortforwarderClient", ({ enumerable: true, get: function () { return SudoPortForwarderClient_1.SudoPortforwarderClient; } }));
var LocalPortForwarder_1 = __webpack_require__(/*! ./LocalPortForwarder */ "../dist/src/LocalPortForwarder.js");
Object.defineProperty(exports, "LocalPortForwarder", ({ enumerable: true, get: function () { return LocalPortForwarder_1.LocalPortForwarder; } }));
var constants_1 = __webpack_require__(/*! ./constants */ "../dist/src/constants.js");
Object.defineProperty(exports, "LOGS_DIRECTORY", ({ enumerable: true, get: function () { return constants_1.LOGS_DIRECTORY; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../dist/src/performance/performance.js":
/*!**********************************************!*\
  !*** ../dist/src/performance/performance.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.performance = void 0;
const vscs_performance_1 = __webpack_require__(/*! @vs/vscs-performance */ "../../performance/dist/src/index.js");
exports.performance = (0, vscs_performance_1.initializePerformanceInstance)('start');
//# sourceMappingURL=performance.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/Channel.js":
/*!******************************************!*\
  !*** ../../rpc/core/dist/src/Channel.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Channel = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
/**
 * Implement IChannel with a set of callbacks and fire API.
 */
class Channel {
    constructor(send, close, adjustWindow, dispose) {
        this.send = send;
        this.onDataReceivedEmitter = new rpc.Emitter();
        this.onClosedEmitter = new rpc.Emitter();
        this.onDataReceived = this.onDataReceivedEmitter.event;
        this.onClosed = this.onClosedEmitter.event;
        const closeFunc = (error, cancellation) => Promise.resolve();
        this.close = close !== null && close !== void 0 ? close : closeFunc;
        const adjustWindowFunc = (messageLength) => { };
        this.adjustWindow = adjustWindow !== null && adjustWindow !== void 0 ? adjustWindow : adjustWindowFunc;
        const diposeFunc = () => { };
        this.dispose = dispose !== null && dispose !== void 0 ? dispose : diposeFunc;
    }
    fireDataReceived(data) {
        this.onDataReceivedEmitter.fire(data);
    }
    fireClosed(reason) {
        this.onClosedEmitter.fire(reason);
    }
}
exports.Channel = Channel;
//# sourceMappingURL=Channel.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/DataFormat.js":
/*!*********************************************!*\
  !*** ../../rpc/core/dist/src/DataFormat.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dataFormat = exports.DataFormat = void 0;
/** Describes the kind of data to be formatted. */
var DataFormat;
(function (DataFormat) {
    DataFormat[DataFormat["Default"] = 'default'] = "Default";
    DataFormat[DataFormat["Email"] = 'email'] = "Email";
    DataFormat[DataFormat["Token"] = 'token'] = "Token";
    DataFormat[DataFormat["Path"] = 'path'] = "Path";
    DataFormat[DataFormat["Text"] = 'text'] = "Text";
    DataFormat[DataFormat["Uri"] = 'uri'] = "Uri";
    DataFormat[DataFormat["Omit"] = 'omit'] = "Omit";
    DataFormat[DataFormat["OmitDefault"] = 'omitDefault'] = "OmitDefault";
    DataFormat[DataFormat["Hide"] = 'hide'] = "Hide";
    DataFormat[DataFormat["SingleMember"] = 'singleMember'] = "SingleMember";
})(DataFormat = exports.DataFormat || (exports.DataFormat = {}));
/** Creates a decorator that saves the property format in a map attached to the class constructor. */
function dataFormat(...format) {
    return (target, propertyKey) => {
        if (!target.constructor.dataFormat) {
            target.constructor.dataFormat = {};
        }
        target.constructor.dataFormat[propertyKey] = format;
    };
}
exports.dataFormat = dataFormat;
//# sourceMappingURL=DataFormat.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcClient.js":
/*!********************************************!*\
  !*** ../../rpc/core/dist/src/RpcClient.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcClient = void 0;
const RpcConnectionErrors_1 = __webpack_require__(/*! ./RpcConnectionErrors */ "../../rpc/core/dist/src/RpcConnectionErrors.js");
const RpcClientProxy_1 = __webpack_require__(/*! ./RpcClientProxy */ "../../rpc/core/dist/src/RpcClientProxy.js");
const RpcServiceHandler_1 = __webpack_require__(/*! ./RpcServiceHandler */ "../../rpc/core/dist/src/RpcServiceHandler.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class RpcClientProxy extends RpcClientProxy_1.RpcClientProxyBase {
    constructor(rpcClient, logger) {
        super(logger);
        this.rpcClient = rpcClient;
    }
    ensureConnectionAsync() {
        return this.rpcClient.ensureConnectionAsync();
    }
}
class RpcClient extends RpcServiceHandler_1.RpcServiceHandler {
    constructor(connectionFactory, logger, addDefaultContextFilter = true) {
        super(logger, addDefaultContextFilter);
        this.connectionFactory = connectionFactory;
        this.connection = null;
        this.connectionFactoryMutex = new vscs_utils_1.Mutex();
        this.rpcClientProxy = new RpcClientProxy(this, logger);
        if (connectionFactory.dispose) {
            this.addToDisposables(connectionFactory);
        }
    }
    static fromRpcMessageStream(rpcMessageStreamCallback, logger, disposeCallback) {
        return new RpcClient({
            create: (rpcClient) => __awaiter(this, void 0, void 0, function* () {
                const rpcMessageStream = yield rpcMessageStreamCallback();
                const rpcConnection = rpcClient.createRpcConnection(rpcMessageStream, logger);
                rpcConnection.listen();
                return rpcConnection;
            }),
            dispose: () => {
                if (disposeCallback) {
                    disposeCallback();
                }
            },
        }, logger);
    }
    sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args) {
        return this.rpcClientProxy.sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args);
    }
    sendNotification(logger, serviceAndName, args) {
        return this.rpcClientProxy.sendNotification(logger, serviceAndName, args);
    }
    onConnect(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureConnectionAsync();
            handler();
        });
    }
    onClose(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureConnectionAsync();
            this.connection.onClose(handler);
        });
    }
    ensureConnectionInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection) {
                yield this.connectionFactoryMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
                    if (!this.connection) {
                        this.setConnection(yield this.connectionFactory.create(this));
                    }
                }));
            }
        });
    }
    ensureConnectionAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureConnectionInternal();
            return this.connection;
        });
    }
    setConnection(conection) {
        this.connection = conection;
        if (conection) {
            this.attachConnection(conection);
            this.addToDisposables(conection);
        }
    }
    attachConnection(connection) {
        connection.onClose(() => {
            this.trace.info(`RPC connection closed. disposed: "${this.isDisposed}"`);
            if (!this.isDisposed) {
                // The connection was closed unexpectedly (not due to extension deactivation).
                // Dispose with an error that causes further communication attemps to be
                // rejected with an appropriate exception.
                this.dispose(new RpcConnectionErrors_1.RpcConnectionClosedError());
            }
        });
        // add generic request support
        connection.onRequest((method, ...params) => {
            return this.onRequest(null, connection, method, ...params);
        });
        // Add progress and generic notification support.
        connection.onNotification((method, ...params) => {
            this.onNotification(connection, method, ...params);
        });
    }
}
exports.RpcClient = RpcClient;
//# sourceMappingURL=RpcClient.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcClientProxy.js":
/*!*************************************************!*\
  !*** ../../rpc/core/dist/src/RpcClientProxy.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcClientProxy = exports.RpcClientProxyBase = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class RpcClientProxyBase extends vscs_utils_1.DisposableClass {
    constructor(logger) {
        super(logger);
    }
    sendNotification(logger, serviceAndName, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = yield this.ensureConnectionAsync();
            // Event args may contain sensitive data, so only trace when obfuscation is disabled.
            const argsString = vso_logging_1.LoggerSettings.disableObfuscation ? JSON.stringify(args) : '';
            logger.verbose(`sendNotification-> ${serviceAndName}: ${argsString}`);
            if (Array.isArray(args)) {
                // Method-style notification: 0 or more arguments.
                connection.sendNotification(serviceAndName, ...args);
            }
            else {
                // Event-style notification: a single EventArgs argument.
                connection.sendNotification(serviceAndName, args);
            }
        });
    }
    sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const cancellationMessage = 'The request was cancelled.';
            let connectionCompleted = false;
            const connection = yield Promise.race([
                this.ensureConnectionAsync(),
                new Promise((resolve, reject) => {
                    if (cancellationToken) {
                        if (cancellationToken.isCancellationRequested) {
                            return reject(new vscs_utils_1.CancellationError(cancellationMessage));
                        }
                        cancellationToken.onCancellationRequested(() => {
                            if (!connectionCompleted) {
                                reject(new vscs_utils_1.CancellationError(cancellationMessage));
                            }
                        });
                    }
                }),
            ]);
            connectionCompleted = true;
            let argsString = '';
            if (vso_logging_1.LoggerSettings.disableObfuscation) {
                // Arguments may contain sensitive data, so only trace when obfuscation is disabled.
                argsString = JSON.stringify(args);
                argsString = argsString.substr(1, argsString.length - 2);
            }
            logger.verbose(`< ${serviceAndMethodName}(${argsString})`);
            const start = Date.now();
            let result;
            try {
                if (progress) {
                    // Attach the progress handler to the args; the write filter will detect and register it.
                    // Also attach the cancellation token so progress notifications can be cancelled.
                    progress.cancellation = cancellationToken;
                    args.progress = progress;
                }
                // The vscode-jsonrpc sendRequest() method can only detect a cancellation token argument
                // if it is not null.
                let sendPromise;
                if (cancellationToken) {
                    sendPromise = connection.sendRequest(serviceAndMethodName, args, cancellationToken);
                }
                else {
                    sendPromise = connection.sendRequest(serviceAndMethodName, args);
                }
                result = yield sendPromise;
            }
            catch (err) {
                if (this.isDisposed) {
                    // // This will either block (during deactivation) or throw a connection-closed error.
                    // await this.initPromise;
                }
                // The error 'data' property should be the remote stack trace.
                logger.error(`> ${serviceAndMethodName}() error: ` + err.data);
                throw err;
            }
            const time = (Date.now() - start).toFixed(1);
            // Result may contain sensitive data, so only trace when obfuscation is disabled.
            if (vso_logging_1.LoggerSettings.disableObfuscation) {
                logger.verbose(`> ${serviceAndMethodName}() => ${JSON.stringify(result)} t:${time}`);
            }
            else {
                logger.verbose(`> ${serviceAndMethodName}() succeeded t:${time}`);
            }
            return result;
        });
    }
}
exports.RpcClientProxyBase = RpcClientProxyBase;
class RpcClientProxy extends RpcClientProxyBase {
    constructor(promise, logger) {
        super(logger);
        this.promise = promise;
        this.initPromise = Promise.resolve();
    }
    static fromRpcConnection(connection, logger) {
        return new RpcClientProxy(Promise.resolve(connection), logger);
    }
    static fromPromise(promise, logger) {
        return new RpcClientProxy(promise, logger);
    }
    ensureConnectionAsync() {
        return this.promise;
    }
}
exports.RpcClientProxy = RpcClientProxy;
//# sourceMappingURL=RpcClientProxy.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcConnectionErrors.js":
/*!******************************************************!*\
  !*** ../../rpc/core/dist/src/RpcConnectionErrors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcConnectionShutdownError = exports.RpcConnectionClosedError = void 0;
const RpcError_1 = __webpack_require__(/*! ./RpcError */ "../../rpc/core/dist/src/RpcError.js");
/**
 * Error thrown from RPC requests when the connection to the agent was unexpectedly
 * closed before or during the request.
 */
class RpcConnectionClosedError extends RpcError_1.RpcError {
    constructor() {
        super('RPC connection closed.');
        this.code = RpcConnectionClosedError.code;
        Object.setPrototypeOf(this, RpcConnectionClosedError.prototype);
    }
}
exports.RpcConnectionClosedError = RpcConnectionClosedError;
/** One of the well-known Node.js error code strings. */
RpcConnectionClosedError.code = 'EPIPE';
/**
 * Error thrown from RPC connection is closed due to explicit client shut down.
 */
class RpcConnectionShutdownError extends RpcError_1.RpcError {
    constructor() {
        super('RPC connection closed due to client shut down.');
        this.code = RpcConnectionShutdownError.code;
        Object.setPrototypeOf(this, RpcConnectionShutdownError.prototype);
    }
}
exports.RpcConnectionShutdownError = RpcConnectionShutdownError;
/** One of the well-known Node.js error code strings. */
RpcConnectionShutdownError.code = 'ECONNRESET';
//# sourceMappingURL=RpcConnectionErrors.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcError.js":
/*!*******************************************!*\
  !*** ../../rpc/core/dist/src/RpcError.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcError = void 0;
/**
 * Base RPC error class.
 */
class RpcError extends Error {
    constructor(message) {
        super(message);
        this.code = RpcError.code;
    }
}
exports.RpcError = RpcError;
RpcError.code = 'RpcError';
//# sourceMappingURL=RpcError.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcLoggerAdapter.js":
/*!***************************************************!*\
  !*** ../../rpc/core/dist/src/RpcLoggerAdapter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcLoggerAdapter = void 0;
class RpcLoggerAdapter {
    constructor(trace) {
        this.trace = trace;
    }
    error(message) {
        this.trace.error(message);
    }
    warn(message) {
        this.trace.warning(message);
    }
    info(message) {
        this.trace.info(message);
    }
    log(message) {
        this.trace.verbose(message);
    }
}
exports.RpcLoggerAdapter = RpcLoggerAdapter;
//# sourceMappingURL=RpcLoggerAdapter.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcMessageWriter.js":
/*!***************************************************!*\
  !*** ../../rpc/core/dist/src/RpcMessageWriter.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcMessageWriter = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const contentLengthHeaderPrefix = 'Content-Length: ';
const headersSeparator = '\r\n\r\n';
class RpcMessageWriter {
    constructor() {
        this.onErrorEmitter = new rpc.Emitter();
        this.onCloseEmitter = new rpc.Emitter();
        this.onError = this.onErrorEmitter.event;
        this.onClose = this.onCloseEmitter.event;
    }
    write(message) {
        const messageJson = JSON.stringify(message);
        const messageData = Buffer.from(messageJson);
        const headerData = Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);
        const data = Buffer.alloc(headerData.length + messageData.length);
        headerData.copy(data, 0);
        messageData.copy(data, headerData.length);
        if (this.onSendCallback) {
            this.onSendCallback(data).catch((e) => {
                this.onErrorEmitter.fire([e, undefined, undefined]);
            });
        }
    }
    dispose() { }
}
exports.RpcMessageWriter = RpcMessageWriter;
//# sourceMappingURL=RpcMessageWriter.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcProxy.js":
/*!*******************************************!*\
  !*** ../../rpc/core/dist/src/RpcProxy.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcProxy = exports.RpcErrorCodes = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const RpcClientProxy_1 = __webpack_require__(/*! ./RpcClientProxy */ "../../rpc/core/dist/src/RpcClientProxy.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const RpcUtils_1 = __webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js");
/**
 * Defines error codes returned by the VSLS agent implemention of JSON-RPC,
 * which are a super-set of standard JSON-RPC error codes.
 */
var RpcErrorCodes;
(function (RpcErrorCodes) {
    RpcErrorCodes[RpcErrorCodes["ParseError"] = rpc.ErrorCodes.ParseError] = "ParseError";
    RpcErrorCodes[RpcErrorCodes["InvalidRequest"] = rpc.ErrorCodes.InvalidRequest] = "InvalidRequest";
    RpcErrorCodes[RpcErrorCodes["MethodNotFound"] = rpc.ErrorCodes.MethodNotFound] = "MethodNotFound";
    RpcErrorCodes[RpcErrorCodes["InvalidParams"] = rpc.ErrorCodes.InvalidParams] = "InvalidParams";
    RpcErrorCodes[RpcErrorCodes["InternalError"] = rpc.ErrorCodes.InternalError] = "InternalError";
    RpcErrorCodes[RpcErrorCodes["ServerNotInitialized"] = rpc.ErrorCodes.ServerNotInitialized] = "ServerNotInitialized";
    RpcErrorCodes[RpcErrorCodes["UnknownErrorCode"] = rpc.ErrorCodes.UnknownErrorCode] = "UnknownErrorCode";
    RpcErrorCodes[RpcErrorCodes["RequestCancelled"] = rpc.ErrorCodes.RequestCancelled] = "RequestCancelled";
    RpcErrorCodes[RpcErrorCodes["MessageWriteError"] = rpc.ErrorCodes.MessageWriteError] = "MessageWriteError";
    RpcErrorCodes[RpcErrorCodes["MessageReadError"] = rpc.ErrorCodes.MessageReadError] = "MessageReadError";
    // VSLS extended RPC error codes
    RpcErrorCodes[RpcErrorCodes["ServiceNotAvailable"] = -32099] = "ServiceNotAvailable";
    RpcErrorCodes[RpcErrorCodes["InvocationException"] = -32098] = "InvocationException";
    RpcErrorCodes[RpcErrorCodes["MessageTooLarge"] = -32097] = "MessageTooLarge";
})(RpcErrorCodes = exports.RpcErrorCodes || (exports.RpcErrorCodes = {}));
/**
 * Base class for RPC service proxies. Traces all messages
 * and emits events for incoming notifications.
 */
class RpcProxy {
    constructor(client, serviceName, logger) {
        this.client = client;
        this.serviceName = serviceName;
        this.logger = logger;
    }
    /**
     * Creates a proxy for an RPC service.
     *
     * @param serviceInfo Information about the service contract
     * @param client RPC client
     * @param logger logger to use
     */
    static create(serviceInfo, client, logger) {
        if (!(serviceInfo && serviceInfo.name)) {
            throw new Error('Missing RPC service name.');
        }
        const proxy = new RpcProxy(client, serviceInfo.name, logger);
        // Generate async methods for requests.
        for (const methodName of serviceInfo.methods) {
            const methodPropertyName = `${methodName}Async`;
            proxy[methodPropertyName] = function () {
                // Detect whether optional cancellation token was supplied, and if so strip from args.
                let args;
                let cancellationToken = arguments[arguments.length - 1];
                if (cancellationToken &&
                    typeof cancellationToken === 'object' &&
                    typeof cancellationToken.isCancellationRequested === 'boolean') {
                    args = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
                }
                else {
                    args = Array.prototype.slice.call(arguments, 0, arguments.length);
                    cancellationToken = null;
                }
                // Detect whether optional progress was supplied, and if so strip from args.
                let progress = args[args.length - 1];
                if (progress &&
                    typeof progress === 'object' &&
                    typeof progress.report === 'function') {
                    args.splice(args.length - 1, 1);
                }
                else {
                    progress = null;
                }
                const serviceAndMethodName = proxy.serviceName + '.' + methodName;
                return proxy.client.sendRequest(this.logger, serviceAndMethodName, progress, cancellationToken, ...args);
            };
        }
        // Generate methods for method-style notifications.
        for (const methodName of serviceInfo.voidMethods || []) {
            proxy[methodName] = function () {
                const args = Array.prototype.slice.call(arguments, 0, arguments.length);
                const serviceAndMethodName = proxy.serviceName + '.' + methodName;
                proxy.client
                    .sendNotification(this.logger, serviceAndMethodName, args)
                    .then()
                    .catch();
            };
        }
        // Generate events for event-style notifications.
        for (const eventName of serviceInfo.events) {
            const emitter = new rpc.Emitter();
            const eventPropertyName = (0, RpcUtils_1.getEventPropertyName)(eventName);
            proxy[eventPropertyName] = emitter.event;
            const serviceAndEventName = proxy.serviceName + '.' + eventName;
            proxy.client
                .ensureConnectionAsync()
                .then((connection) => {
                connection.onNotification(serviceAndEventName, (...args) => {
                    const eventArgs = args[0];
                    // Event args may contain sensitive data, so only trace when obfuscation is disabled.
                    const argsString = vso_logging_1.LoggerSettings.disableObfuscation
                        ? JSON.stringify(eventArgs)
                        : '';
                    proxy.logger.log(vso_logging_1.LogLevel.Debug, `> ${serviceAndEventName}: ${argsString}`);
                    emitter.fire(eventArgs);
                });
            })
                .catch((e) => {
                // Failed to get the connection. There will already be errors traced elsewhere
                // about the connection failure, so there's no need to trace anything more here.
            });
        }
        return proxy;
    }
    static createWithConnection(serviceInfo, connection, logger) {
        return RpcProxy.create(serviceInfo, RpcClientProxy_1.RpcClientProxy.fromRpcConnection(connection, logger), logger);
    }
    static createWithPromise(serviceInfo, promise, logger) {
        return RpcProxy.create(serviceInfo, RpcClientProxy_1.RpcClientProxy.fromPromise(promise, logger), logger);
    }
    /**
     * Sends a notification (event) from this client to the service.
     *
     * (This is a static method because RPC contract interfaces do not define methods
     * for reverse notifications.)
     */
    static notifyAsync(proxy, eventName, args) {
        const rpcProxy = proxy;
        const serviceAndMethodName = rpcProxy.serviceName + '.' + eventName;
        return rpcProxy.client.sendNotification(rpcProxy.logger, serviceAndMethodName, args);
    }
}
exports.RpcProxy = RpcProxy;
//# sourceMappingURL=RpcProxy.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcProxyCache.js":
/*!************************************************!*\
  !*** ../../rpc/core/dist/src/RpcProxyCache.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcProxyCache = void 0;
const RpcProxy_1 = __webpack_require__(/*! ./RpcProxy */ "../../rpc/core/dist/src/RpcProxy.js");
class RpcProxyCache {
    constructor(clientProxy, logger) {
        this.clientProxy = clientProxy;
        this.logger = logger;
        this.proxyMap = new Map();
    }
    getOrCreate(serviceInfo, traceName) {
        let proxy = this.proxyMap.get(serviceInfo.name);
        if (!proxy) {
            this.logger.info(`Creating proxy for ${serviceInfo.name} service`);
            proxy = RpcProxy_1.RpcProxy.create(serviceInfo, this.clientProxy, traceName ? this.logger.withName(traceName) : this.logger);
            this.proxyMap.set(serviceInfo.name, proxy);
        }
        return proxy;
    }
}
exports.RpcProxyCache = RpcProxyCache;
//# sourceMappingURL=RpcProxyCache.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcServer.js":
/*!********************************************!*\
  !*** ../../rpc/core/dist/src/RpcServer.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcServer = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const RpcServiceHandler_1 = __webpack_require__(/*! ./RpcServiceHandler */ "../../rpc/core/dist/src/RpcServiceHandler.js");
const sendRpcRequest_1 = __webpack_require__(/*! ./sendRpcRequest */ "../../rpc/core/dist/src/sendRpcRequest.js");
const RpcUtils_1 = __webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js");
/**
 * define a class capable to host multiple rpc services
 */
class RpcServer extends RpcServiceHandler_1.RpcServiceHandler {
    constructor(logger, notifyEventProvider) {
        super(logger);
        this.rpcSessionNumber = 0;
        this.rpcConnections = [];
        const defaultNotifyProvider = (serviceAndMethod, e) => {
            (0, RpcUtils_1.notifyConnections)(this.rpcConnections, serviceAndMethod, e, logger);
        };
        this.notifyEventProvider = notifyEventProvider || defaultNotifyProvider;
    }
    registerRemoteRpcService(serviceName, messageConnection) {
        this.trace.info(`adding remote rpc service:${serviceName}`);
        const serviceNamePrefix = serviceName + '.';
        messageConnection.onNotification((method, ...params) => {
            if (method.startsWith(serviceNamePrefix)) {
                this.notifyEventProvider(method, params);
            }
        });
        const disposable = this.onHandleNoneRequest((rpcConnection, method, ...params) => __awaiter(this, void 0, void 0, function* () {
            if (method.startsWith(serviceNamePrefix)) {
                return yield (0, sendRpcRequest_1.sendRpcRequest)(messageConnection, method, params, true, this.trace);
            }
        }));
        messageConnection.onClose(() => disposable.dispose());
        messageConnection.onDispose(() => disposable.dispose());
        return disposable;
    }
    sendNotification(logger, serviceAndName, args) {
        this.notifyEventProvider(serviceAndName, args);
        return Promise.resolve();
    }
    acceptRpcMessageStream(rpcMessageStream) {
        let messageConnection;
        let rpcSessionNumber;
        const contextFilter = (msg) => {
            // Add the rpc request context to incoming request messages.
            // The default context read filter already injected
            // a placeholder in params[1]. Replace with the rpc request
            // context.
            const msgObj = msg;
            if (typeof msgObj.id !== 'undefined') {
                const rpcRequestContext = {
                    connection: messageConnection,
                    session: rpcSessionNumber,
                };
                RpcUtils_1.RpcParamManager.setContext(msgObj.params, rpcRequestContext);
            }
            return msgObj;
        };
        messageConnection = this.createRpcConnection(rpcMessageStream, this.trace, [contextFilter]);
        rpcSessionNumber = this.attachConnection(messageConnection);
        return [messageConnection, rpcSessionNumber];
    }
    attachConnection(messageConnection) {
        this.rpcConnections.push(messageConnection);
        const rpcSessionNumber = ++this.rpcSessionNumber;
        this.trace.verbose(`Rpc #${rpcSessionNumber} created`);
        messageConnection.onRequest((method, ...params) => {
            return this.onRequest((requestHandler, ...requestParams) => __awaiter(this, void 0, void 0, function* () {
                const result = yield Promise.resolve(requestHandler(...requestParams));
                const loggerResult = vso_logging_1.LoggerSettings.disableObfuscation
                    ? ` => ${JSON.stringify(result)}`
                    : '';
                this.trace.verbose(`> #${rpcSessionNumber} ${method}()${loggerResult}`);
                return result;
            }), messageConnection, method, ...params);
        });
        // Add progress and generic notification support.
        messageConnection.onNotification((method, ...params) => {
            this.onNotification(messageConnection, method, ...params);
        });
        const removeRpc = (event) => {
            const index = this.rpcConnections.indexOf(messageConnection);
            if (index !== -1) {
                this.trace.verbose(`Rpc #${rpcSessionNumber} removed event:${event}`);
                this.rpcConnections.splice(index, 1);
            }
        };
        messageConnection.onClose((e) => {
            removeRpc('closed');
        });
        messageConnection.onDispose((e) => {
            removeRpc('disposed');
        });
        return rpcSessionNumber;
    }
}
exports.RpcServer = RpcServer;
//# sourceMappingURL=RpcServer.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcServiceHandler.js":
/*!****************************************************!*\
  !*** ../../rpc/core/dist/src/RpcServiceHandler.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcServiceHandler = exports.RpcServiceHandlerBase = exports.methodProgress = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const RpcUtils_1 = __webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js");
const RpcLoggerAdapter_1 = __webpack_require__(/*! ./RpcLoggerAdapter */ "../../rpc/core/dist/src/RpcLoggerAdapter.js");
const RpcUtils_2 = __webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js");
exports.methodProgress = '$/progress';
const RESTRICTED_HANDLERS_FIELD = '$RestrictedHandlers$';
/**
 * Base class to handle common tasks related with handling rpc request and notifications.
 */
class RpcServiceHandlerBase extends vscs_utils_1.DisposableClass {
    constructor(logger, addDefaultContextFilter = true) {
        super(logger);
        this.rpcRequestsWithContext = new RpcUtils_1.RpcRequestsWithContext();
        this.rpcReadFilters = [
            this.rpcRequestsWithContext.readFilter,
        ];
        this.rpcWriteFilters = [];
        this.progressHandlers = new Map();
        this.requests = new Map();
        this.requestsWithProgress = new Set();
        this.notifications = new Map();
        this.notificationsCookies = 0;
        this.handleNoneRequestCallbacks = new vscs_utils_1.CallbackContainer();
        this.handleNoneNotificationCallbacks = new vscs_utils_1.CallbackContainer();
        this.addProgressFilters();
        if (addDefaultContextFilter) {
            this.addDefaultContextFilter();
        }
    }
    get serviceNames() {
        const serviceNames = new Set();
        const addServices = (keys) => {
            for (const key of keys) {
                serviceNames.add(key.split('.')[0]);
            }
        };
        addServices(this.requests.keys());
        addServices(this.notifications.keys());
        return Array.from(serviceNames);
    }
    clear() {
        this.requests.clear();
        this.requestsWithProgress.clear();
        this.notifications.clear();
        this.handleNoneRequestCallbacks.clear();
        this.handleNoneNotificationCallbacks.clear();
    }
    onHandleNoneRequest(callback) {
        return this.handleNoneRequestCallbacks.add(callback);
    }
    onHandleNoneNotification(callback) {
        return this.handleNoneNotificationCallbacks.add(callback);
    }
    createRpcConnection(rpcMessageStream, logger, readFilters = []) {
        const rpcConnection = rpc.createMessageConnection(this.createFilteredMessageReader(rpcMessageStream.reader, readFilters), this.createFilteredMessageWriter(rpcMessageStream.writer), new RpcLoggerAdapter_1.RpcLoggerAdapter(logger));
        return rpcConnection;
    }
    addReadFilter(filter) {
        return addRpcFilter(this.rpcReadFilters, filter);
    }
    addWriteFilter(filter) {
        return addRpcFilter(this.rpcWriteFilters, filter);
    }
    addRequestMethod(method, requestHandler) {
        this.requests.set(method, requestHandler);
    }
    addRequestMethodWithContext(method, requestHandler) {
        this.addRequestMethod(method, requestHandler);
        this.rpcRequestsWithContext.add(method);
    }
    addRequestMethodWithProgress(method, requestHandler) {
        this.addRequestMethod(method, requestHandler);
        this.requestsWithProgress.add(method);
    }
    removeRequestMethod(method) {
        this.requests.delete(method);
        this.requestsWithProgress.delete(method);
    }
    addNotificationHandler(method, notificationHandler) {
        let entrys = this.notifications.get(method);
        if (!entrys) {
            entrys = [];
            this.notifications.set(method, entrys);
        }
        const entry = {
            cookie: ++this.notificationsCookies,
            notificationHandler,
        };
        entrys.push(entry);
        return entry.cookie;
    }
    removeNotificationHandler(method, cookie) {
        const entrys = this.notifications.get(method);
        if (entrys) {
            const indexEntry = entrys.findIndex((i) => i.cookie === cookie);
            if (indexEntry !== -1) {
                return entrys.splice(indexEntry, 1)[0].notificationHandler;
            }
        }
        return undefined;
    }
    onRequest(requestHandlerInvoke, rpcConnection, method, ...params) {
        const requestHandler = this.requests.get(method);
        if (!requestHandler) {
            for (const callback of this.handleNoneRequestCallbacks.items) {
                const result = callback(rpcConnection, method, ...params);
                if (result !== undefined) {
                    return result;
                }
            }
            return Promise.resolve((0, RpcUtils_2.createMethodNotFoundResponse)(method));
        }
        // The request ID & rpcRequestContext were inserted into the args by the read filters.
        const { requestId, rpcRequestContext } = RpcUtils_1.RpcParamManager.removeInsertedParams(params);
        if (this.requestsWithProgress.has(method)) {
            const progress = {
                report: (value) => {
                    rpcConnection.sendNotification(exports.methodProgress, { id: requestId, value });
                },
            };
            // Insert progress into args just before the last (cancellation) arg.
            params.splice(params.length - 1, 0, progress);
        }
        // Inject rpc request context as the last argument
        if (rpcRequestContext) {
            params.push(rpcRequestContext);
        }
        if (requestHandlerInvoke) {
            return requestHandlerInvoke(requestHandler, ...params);
        }
        return requestHandler(...params);
    }
    onNotification(rpcConnection, method, ...params) {
        if (method === exports.methodProgress && typeof params[0] === 'object') {
            // Note: the progress notification is being handled on the rpc read filter
            // and its better to no op.
            return;
        }
        else if (this.notifications.has(method)) {
            this.notifications.get(method).forEach((item) => {
                item.notificationHandler(...params);
            });
        }
        else {
            for (const callback of this.handleNoneNotificationCallbacks.items) {
                callback(rpcConnection, method, ...params);
            }
        }
    }
    createFilteredMessageReader(reader, readFilters = []) {
        return new RpcUtils_1.WrappedMessageReader(reader, (msg) => RpcServiceHandlerBase.filterMessage(msg, this.rpcReadFilters.concat(readFilters)));
    }
    createFilteredMessageWriter(writer) {
        return new RpcUtils_1.WrappedMessageWriter(writer, (msg) => RpcServiceHandlerBase.filterMessage(msg, this.rpcWriteFilters));
    }
    static filterMessage(msg, filters) {
        for (const filter of filters) {
            msg = filter(msg);
        }
        return msg;
    }
    addProgressFilters() {
        this.rpcReadFilters.push((msg) => {
            const msgObj = msg;
            const requestId = msgObj.id;
            if (typeof requestId !== 'undefined') {
                // This is an incoming request message.
                // Insert the request ID into the params in case it is needed for progress.
                msgObj.params = RpcUtils_1.RpcParamManager.insertRequestId(msgObj.params, requestId);
                if (typeof msgObj.result !== 'undefined' || typeof msgObj.error !== 'undefined') {
                    // This is an incoming response message.
                    // Unregister any progress handler for the response's request ID.
                    this.progressHandlers.delete(requestId);
                }
            }
            else if (msgObj.method === exports.methodProgress) {
                let progressArgs = msgObj.params;
                if (progressArgs.id === undefined) {
                    progressArgs = msgObj.params[0];
                }
                const progress = this.progressHandlers.get(progressArgs.id);
                if (progress) {
                    progress.report(progressArgs.value, progressArgs.id);
                }
            }
            return msg;
        });
        this.rpcWriteFilters.push((msg) => {
            const msgObj = msg;
            const requestId = msgObj.id;
            const params = msgObj.params;
            if (typeof requestId !== 'undefined' &&
                params &&
                params.progress &&
                typeof params.progress.report === 'function') {
                // An outgoing message has a progress handler attached to the params.
                // Register the progress handler for the request ID.
                this.progressHandlers.set(msgObj.id, msgObj.params.progress);
                // Unregister the progress handler when the request is cancelled.
                const cancellation = params.progress.cancellation;
                if (cancellation) {
                    cancellation.onCancellationRequested(() => {
                        this.progressHandlers.delete(requestId);
                    });
                }
                delete params.progress;
            }
            return msg;
        });
    }
    addDefaultContextFilter() {
        // Add a placeholder rpc request context. This is overwritten by the
        // RPCServer in agentless. The RPCServiceHandler expects
        // this param to be present in the onRequest handler.
        this.rpcReadFilters.push((msg) => {
            const msgObj = msg;
            if (typeof msgObj.id !== 'undefined') {
                RpcUtils_1.RpcParamManager.insertPlaceholderContext(msgObj.params);
            }
            return msgObj;
        });
    }
}
exports.RpcServiceHandlerBase = RpcServiceHandlerBase;
class RpcServiceHandler extends RpcServiceHandlerBase {
    /**
     * Registers an RPC service and returns a disposable registration object.
     * @param service Service instance. The class should implement the service interface.
     * @param serviceInfo Service metadata.
     * @param trace Trace source.
     * @param disposables Collection of disposable objects where the registration object will be added to.
     */
    registerRpcService(service, serviceInfo, contextMethods, strict) {
        if (!service) {
            throw new Error('service argument is missing or undefined');
        }
        if (!serviceInfo) {
            throw new Error('serviceInfo argument is missing or undefined');
        }
        if (contextMethods &&
            contextMethods.filter((method) => serviceInfo.methods.indexOf(method) < 0).length > 0) {
            throw new Error('invalid context method');
        }
        const serviceName = serviceInfo.name;
        if (!serviceName) {
            throw new Error('serviceInfo.serviceName is empty or undefined');
        }
        let isServiceActive = true;
        const addedRequestMethods = new Set();
        const addedNotificationMethods = new Map();
        let eventDisposables = [];
        const result = {
            dispose: () => {
                isServiceActive = false;
                for (const d of eventDisposables) {
                    d.dispose();
                }
                eventDisposables = [];
                for (const handlerName of addedRequestMethods) {
                    this.removeRequestMethod(handlerName);
                }
                addedRequestMethods.clear();
                for (const [handlerName, cookie] of addedNotificationMethods) {
                    this.removeNotificationHandler(handlerName, cookie);
                }
                addedNotificationMethods.clear();
            },
        };
        const restrictedHandlers = service[RESTRICTED_HANDLERS_FIELD];
        try {
            for (const method of serviceInfo.methods) {
                const handlerName = `${serviceName}.${method}`;
                const restrictedHandler = restrictedHandlers && restrictedHandlers.get(method);
                if (restrictedHandler) {
                    this.addRequestMethodWithContext(handlerName, (...args) => restrictedHandler.apply(service, args));
                    addedRequestMethods.add(handlerName);
                    continue;
                }
                const impl = service[method] || service[method + 'Async'];
                if (typeof impl !== 'function') {
                    if (strict || strict === undefined) {
                        throw new Error(`Object ${serviceInfo.name} does not implement method '${method}' of service '${serviceName}'.`);
                    }
                    else {
                        continue;
                    }
                }
                if (contextMethods && contextMethods.indexOf(method) >= 0) {
                    this.addRequestMethodWithContext(handlerName, (...args) => impl.apply(service, args));
                }
                else {
                    this.addRequestMethod(handlerName, (...args) => impl.apply(service, args));
                }
                addedRequestMethods.add(handlerName);
            }
            if (serviceInfo.voidMethods) {
                for (const method of serviceInfo.voidMethods) {
                    const handlerName = `${serviceName}.${method}`;
                    if (restrictedHandlers && restrictedHandlers.get(method)) {
                        throw new Error(`Restricted operation check is not supported yet for notification methods. Object ${serviceInfo.name} restricts notification '${method}' of service '${serviceName}'.`);
                    }
                    const impl = this[method] || service[method];
                    if (typeof impl !== 'function') {
                        if (strict) {
                            throw new Error(`Object ${serviceInfo.name} does not implement notification '${method}' of service '${serviceName}'.`);
                        }
                        else {
                            continue;
                        }
                    }
                    const cookie = this.addNotificationHandler(handlerName, (...args) => impl.apply(service, args));
                    addedNotificationMethods.set(handlerName, cookie);
                }
            }
            if (serviceInfo.events) {
                for (const eventName of serviceInfo.events) {
                    if (!eventName) {
                        continue;
                    }
                    const propertyName = (0, RpcUtils_2.getEventPropertyName)(eventName);
                    const event = service[propertyName];
                    if (typeof event === 'function') {
                        event((e) => {
                            if (isServiceActive) {
                                this.sendNotification(this.trace, `${serviceName}.${eventName}`, e).catch((err) => this.trace.error(`Failed to send notification:${serviceName}.${eventName}`, err));
                            }
                        }, eventDisposables);
                    }
                }
            }
        }
        catch (err) {
            result.dispose();
            throw err;
        }
        return result;
    }
}
exports.RpcServiceHandler = RpcServiceHandler;
/**
 * helper function to add an rpc filter and be able to remove it.
 */
function addRpcFilter(filters, filter) {
    filters.push(filter);
    return {
        dispose: () => {
            const index = filters.indexOf(filter);
            if (index !== -1) {
                filters.splice(index, 1);
            }
        },
    };
}
//# sourceMappingURL=RpcServiceHandler.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/RpcUtils.js":
/*!*******************************************!*\
  !*** ../../rpc/core/dist/src/RpcUtils.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMethodNotFoundResponse = exports.RpcRequestsWithContext = exports.addContextToRpcMessage = exports.TimedRpcMessageUtils = exports.TimingFilter = exports.WrappedMessageWriter = exports.WrappedMessageReader = exports.RpcParamManager = exports.notifyConnections = exports.onAllEvents = exports.getEventPropertyName = void 0;
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
function getEventPropertyName(eventName) {
    return `on${eventName.substr(0, 1).toUpperCase()}${eventName.substr(1)}`;
}
exports.getEventPropertyName = getEventPropertyName;
/**
 * Hookup all events from a service and invoke a generic listener
 * @param service The service instance
 * @param eventNames the name of the rpc events to hookup.
 * @param listener Callback to invoke when each event is fired.
 * @returns A disposable instance to un hookup
 */
function onAllEvents(service, eventNames, listener) {
    const disposables = [];
    for (const eventName of eventNames) {
        const eventPropertyName = getEventPropertyName(eventName);
        const event = service[eventPropertyName];
        disposables.push(event((e) => listener(eventName, e)));
    }
    return (0, vscs_utils_1.createDisposable)(() => {
        disposables.forEach((d) => d.dispose());
    });
}
exports.onAllEvents = onAllEvents;
/**
 * notify a set of rpc connections
 * @param rpcConnections list of rpc connections.
 * @param serviceAndMethod service and method name
 * @param e Event argument
 * @param logger optional logger instance.
 */
function notifyConnections(rpcConnections, serviceAndMethod, e, logger) {
    rpcConnections.forEach((mc) => {
        try {
            mc.sendNotification(serviceAndMethod, e);
        }
        catch (err) {
            logger === null || logger === void 0 ? void 0 : logger.error(`failed to send notification method:${serviceAndMethod} index:${rpcConnections.indexOf(mc)}`);
        }
    });
}
exports.notifyConnections = notifyConnections;
// Note: when modifying ensure all consumers
// of this enum are adjusted accordingly
var RpcInsertedParamPosition;
(function (RpcInsertedParamPosition) {
    RpcInsertedParamPosition[RpcInsertedParamPosition["RequestId"] = 0] = "RequestId";
    RpcInsertedParamPosition[RpcInsertedParamPosition["RequestContext"] = 1] = "RequestContext";
})(RpcInsertedParamPosition || (RpcInsertedParamPosition = {}));
class RpcParamManager {
    static insertRequestId(params, requestId) {
        if (Array.isArray(params)) {
            params.splice(RpcInsertedParamPosition.RequestId, 0, requestId);
        }
        else if (params !== undefined) {
            // single parameter support
            params = [requestId, params];
        }
        else {
            params = [requestId];
        }
        return params;
    }
    static insertPlaceholderContext(params) {
        params.splice(RpcInsertedParamPosition.RequestContext, 0, undefined);
    }
    static setContext(params, rpcRequestContext) {
        params[RpcInsertedParamPosition.RequestContext] = rpcRequestContext;
    }
    static removeInsertedParams(params, removeRpcRequestContext = true) {
        const deleteCount = removeRpcRequestContext
            ? this.insertedParamCount
            : this.insertedParamCount - 1;
        const [requestId, rpcRequestContext] = params.splice(0, deleteCount);
        return {
            requestId,
            rpcRequestContext,
        };
    }
}
exports.RpcParamManager = RpcParamManager;
// Inserted param count is the length of RpcInsertedParamPosition/2 to remove reverse mapping enum keys
RpcParamManager.insertedParamCount = Object.keys(RpcInsertedParamPosition).length / 2;
class WrappedMessageReader {
    constructor(messageReader, messageTransformer) {
        this.messageReader = messageReader;
        this.messageTransformer = messageTransformer;
        this.onError = this.messageReader.onError;
        this.onClose = this.messageReader.onClose;
        this.onPartialMessage = this.messageReader.onPartialMessage;
    }
    listen(callback) {
        const wrappedCallback = (msg) => {
            callback(this.messageTransformer(msg));
        };
        this.messageReader.listen(wrappedCallback);
    }
    dispose() {
        this.messageReader.dispose();
    }
}
exports.WrappedMessageReader = WrappedMessageReader;
class WrappedMessageWriter {
    constructor(messageWriter, messageTransformer) {
        this.messageWriter = messageWriter;
        this.messageTransformer = messageTransformer;
        this.onError = this.messageWriter.onError;
        this.onClose = this.messageWriter.onClose;
    }
    write(msg) {
        this.messageWriter.write(this.messageTransformer(msg));
    }
    dispose() {
        this.messageWriter.dispose();
    }
}
exports.WrappedMessageWriter = WrappedMessageWriter;
class TimingFilter {
    constructor() {
        // Map from message ids to when the message was received/sent
        this.times = new Map();
    }
    filter(isWrite, msg) {
        if (typeof msg.id !== 'number') {
            return msg;
        }
        if (this.times.has(msg.id)) {
            const duration = Date.now() - this.times.get(msg.id);
            this.times.delete(msg.id);
            // If one of the RPC clients doesn't include timing information (e.g. they are an older version),
            // none of them should to avoid misleading data.
            if (isWrite || typeof msg.times !== 'undefined') {
                msg.times = TimedRpcMessageUtils.addTime(msg.times, duration);
            }
        }
        else {
            this.times.set(msg.id, Date.now());
        }
        return msg;
    }
}
exports.TimingFilter = TimingFilter;
/*
The "times" property on an RPC message is an
array of times in milliseconds taken to send/receive/respond to requests
Includes times from sending requests to receiving responses and
time from receiving requests to returning responses.

E.g. a simple scenario where A makes a request to B:
A sends a request to B and begins timing.
B receives the request and begins timing.
B processes the request.
B is ready to resolve the request, so stops timing, stamps
the time it took to respond on the response message, and sends the reponse.
A receives the response, stops timing, subtracts off the time taken for B to respond (this time is
included in the response message) and adds another item to the list of handling times on the response message.
The first time in the list of handling times is the amount of time it took B to process the request,
and the second time in the list is the communication latency between A and B.

In more complicated scenarios where requests go through multiple clients,
the list of handling times can be used to find the communication latency between
each RPC client in the chain, and how long processing took at each client.

In general, the last client in the chain will only contribute one time to the list:
the amount of time it took to respond to the request. So this is always
the first item in the list. Similarly, the first client in the chain (the one that made the initial request)
only contributes one time to the list: the communication latency between itself and the
first client in the chain. So this is always the last item in the list. Intermediate clients contribute 2 times each:
the first is the communication latency between the client and the next in the chain. The second is the time
it took the client to do any intermediate processing before forwarding the request on to the next client and
returning the response to the previous client.

E.g. if times = [a, b, c, d], there were three clients involved in the request. a is the time it took
the last client to handle the request, b is the communication latency between the second and third client,
c is the time it took the second client from receiving the request from the first client to forward the request
to the third client plus the time from receiving the response from the third client to sending it to the first client,
and d is the communication latency between the first and second client. The full time from the first client
making the request to receiving the response is a + b + c + d. In general, the latency of the request is the sum of
every other item in the list, starting at index 1 (here b + d), and the processing time is the sum of every other item
in the list, starting at index 0 (here a + c).
*/
class TimedRpcMessageUtils {
    static addTime(times, time) {
        if (typeof times === 'undefined') {
            times = [];
        }
        const timeToAdd = time - TimedRpcMessageUtils.getTotalTime(times);
        times.push(timeToAdd > 0 ? timeToAdd : 0);
        return times;
    }
    // The latency is the sum of every other item in the list of times, starting at index 1.
    // See comment above this class for detailed explanation.
    static getLatency(times) {
        let latency = 0;
        if (times) {
            for (let i = 1; i < times.length; i += 2) {
                latency += times[i];
            }
        }
        return latency;
    }
    // The processing time is the sum of every other item in the list of times, starting at index 0.
    // See comment above this class for detailed explanation.
    static getProcessingTime(times) {
        let processingTime = 0;
        if (times) {
            for (let i = 0; i < times.length; i += 2) {
                processingTime += times[i];
            }
        }
        return processingTime;
    }
    static getTotalTime(times) {
        return (TimedRpcMessageUtils.getLatency(times) + TimedRpcMessageUtils.getProcessingTime(times));
    }
}
exports.TimedRpcMessageUtils = TimedRpcMessageUtils;
/*
    RPC message filter that adds message context to the parameter object of RPC messages
*/
function addContextToRpcMessage(msg) {
    if (!msg) {
        return msg;
    }
    const context = msg.context;
    const params = msg.params;
    if (typeof context !== 'object' ||
        typeof params !== 'object' ||
        Array.isArray(params) ||
        params.context) {
        return msg;
    }
    return Object.assign({}, msg, { params: Object.assign({ context }, params) });
}
exports.addContextToRpcMessage = addContextToRpcMessage;
class RpcRequestsWithContext {
    constructor() {
        this.methods = new Set();
        this.readFilter = this.filterMessage.bind(this);
    }
    add(method) {
        if (method) {
            this.methods.add(method);
        }
    }
    filterMessage(msg) {
        const request = msg;
        if (!request.method || !this.methods.has(request.method)) {
            return msg;
        }
        const context = msg.context || {};
        if (!request.params) {
            request.params = [context];
        }
        else if (Array.isArray(request.params)) {
            request.params.push(context);
        }
        return request;
    }
}
exports.RpcRequestsWithContext = RpcRequestsWithContext;
function createMethodNotFoundResponse(method) {
    return new vscode_jsonrpc_1.ResponseError(vscode_jsonrpc_1.ErrorCodes.MethodNotFound, `method:${method} not supported`);
}
exports.createMethodNotFoundResponse = createMethodNotFoundResponse;
//# sourceMappingURL=RpcUtils.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/assertRpcRequestContext.js":
/*!**********************************************************!*\
  !*** ../../rpc/core/dist/src/assertRpcRequestContext.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertRpcRequestContext = exports.rpcContextNoSessionMessage = exports.rpcContextExpectedMessage = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
exports.rpcContextExpectedMessage = 'Rpc Request context expected';
exports.rpcContextNoSessionMessage = 'No session being defined';
function assertRpcRequestContext(rpcRequestContext) {
    (0, vscs_utils_1.assertDefined)(rpcRequestContext, exports.rpcContextExpectedMessage);
    (0, vscs_utils_1.assertDefined)(rpcRequestContext.session, exports.rpcContextNoSessionMessage);
}
exports.assertRpcRequestContext = assertRpcRequestContext;
//# sourceMappingURL=assertRpcRequestContext.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/createDuplexRpcMessageStreams.js":
/*!****************************************************************!*\
  !*** ../../rpc/core/dist/src/createDuplexRpcMessageStreams.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDuplexRpcMessageStreams = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const events_1 = __webpack_require__(/*! events */ "events");
/**
 * Create a duplex rpc stream loopback to connect to rpc connections on the same process.
 * @returns the pair of rpc message streams.
 */
function createDuplexRpcMessageStreams() {
    const readableStream1 = new DuplexReadableStream();
    const writableStream1 = new DuplexWritableStream(readableStream1);
    const readableStream2 = new DuplexReadableStream();
    const writableStream2 = new DuplexWritableStream(readableStream2);
    const messageReader1 = new rpc.StreamMessageReader(readableStream1);
    const messageWriter1 = new rpc.StreamMessageWriter(writableStream1);
    const messageReader2 = new rpc.StreamMessageReader(readableStream2);
    const messageWriter2 = new rpc.StreamMessageWriter(writableStream2);
    return [
        {
            reader: messageReader1,
            writer: messageWriter2,
        },
        {
            reader: messageReader2,
            writer: messageWriter1,
        },
    ];
}
exports.createDuplexRpcMessageStreams = createDuplexRpcMessageStreams;
class DuplexReadableStream extends events_1.EventEmitter {
}
class DuplexWritableStream extends events_1.EventEmitter {
    constructor(readableStream) {
        super();
        this.readableStream = readableStream;
    }
    write(str, encoding, cb) {
        this.readableStream.emit('data', str);
        return true;
    }
}
//# sourceMappingURL=createDuplexRpcMessageStreams.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/index.js":
/*!****************************************!*\
  !*** ../../rpc/core/dist/src/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rpcMaxMessageSize = exports.createDuplexRpcMessageStreams = exports.rpcUtils = exports.Channel = exports.RpcProxyCache = exports.dataFormat = exports.DataFormat = exports.RpcMessageWriter = exports.RpcServer = exports.RpcError = exports.RpcConnectionShutdownError = exports.RpcConnectionClosedError = exports.RpcLoggerAdapter = exports.RpcClientProxyBase = exports.RpcClientProxy = exports.RpcClient = exports.methodProgress = exports.RpcServiceHandler = exports.RpcProxy = exports.RpcErrorCodes = void 0;
var RpcProxy_1 = __webpack_require__(/*! ./RpcProxy */ "../../rpc/core/dist/src/RpcProxy.js");
Object.defineProperty(exports, "RpcErrorCodes", ({ enumerable: true, get: function () { return RpcProxy_1.RpcErrorCodes; } }));
Object.defineProperty(exports, "RpcProxy", ({ enumerable: true, get: function () { return RpcProxy_1.RpcProxy; } }));
var RpcServiceHandler_1 = __webpack_require__(/*! ./RpcServiceHandler */ "../../rpc/core/dist/src/RpcServiceHandler.js");
Object.defineProperty(exports, "RpcServiceHandler", ({ enumerable: true, get: function () { return RpcServiceHandler_1.RpcServiceHandler; } }));
Object.defineProperty(exports, "methodProgress", ({ enumerable: true, get: function () { return RpcServiceHandler_1.methodProgress; } }));
var RpcClient_1 = __webpack_require__(/*! ./RpcClient */ "../../rpc/core/dist/src/RpcClient.js");
Object.defineProperty(exports, "RpcClient", ({ enumerable: true, get: function () { return RpcClient_1.RpcClient; } }));
var RpcClientProxy_1 = __webpack_require__(/*! ./RpcClientProxy */ "../../rpc/core/dist/src/RpcClientProxy.js");
Object.defineProperty(exports, "RpcClientProxy", ({ enumerable: true, get: function () { return RpcClientProxy_1.RpcClientProxy; } }));
Object.defineProperty(exports, "RpcClientProxyBase", ({ enumerable: true, get: function () { return RpcClientProxy_1.RpcClientProxyBase; } }));
var RpcLoggerAdapter_1 = __webpack_require__(/*! ./RpcLoggerAdapter */ "../../rpc/core/dist/src/RpcLoggerAdapter.js");
Object.defineProperty(exports, "RpcLoggerAdapter", ({ enumerable: true, get: function () { return RpcLoggerAdapter_1.RpcLoggerAdapter; } }));
var RpcConnectionErrors_1 = __webpack_require__(/*! ./RpcConnectionErrors */ "../../rpc/core/dist/src/RpcConnectionErrors.js");
Object.defineProperty(exports, "RpcConnectionClosedError", ({ enumerable: true, get: function () { return RpcConnectionErrors_1.RpcConnectionClosedError; } }));
Object.defineProperty(exports, "RpcConnectionShutdownError", ({ enumerable: true, get: function () { return RpcConnectionErrors_1.RpcConnectionShutdownError; } }));
var RpcError_1 = __webpack_require__(/*! ./RpcError */ "../../rpc/core/dist/src/RpcError.js");
Object.defineProperty(exports, "RpcError", ({ enumerable: true, get: function () { return RpcError_1.RpcError; } }));
var RpcServer_1 = __webpack_require__(/*! ./RpcServer */ "../../rpc/core/dist/src/RpcServer.js");
Object.defineProperty(exports, "RpcServer", ({ enumerable: true, get: function () { return RpcServer_1.RpcServer; } }));
var RpcMessageWriter_1 = __webpack_require__(/*! ./RpcMessageWriter */ "../../rpc/core/dist/src/RpcMessageWriter.js");
Object.defineProperty(exports, "RpcMessageWriter", ({ enumerable: true, get: function () { return RpcMessageWriter_1.RpcMessageWriter; } }));
var DataFormat_1 = __webpack_require__(/*! ./DataFormat */ "../../rpc/core/dist/src/DataFormat.js");
Object.defineProperty(exports, "DataFormat", ({ enumerable: true, get: function () { return DataFormat_1.DataFormat; } }));
Object.defineProperty(exports, "dataFormat", ({ enumerable: true, get: function () { return DataFormat_1.dataFormat; } }));
var RpcProxyCache_1 = __webpack_require__(/*! ./RpcProxyCache */ "../../rpc/core/dist/src/RpcProxyCache.js");
Object.defineProperty(exports, "RpcProxyCache", ({ enumerable: true, get: function () { return RpcProxyCache_1.RpcProxyCache; } }));
var Channel_1 = __webpack_require__(/*! ./Channel */ "../../rpc/core/dist/src/Channel.js");
Object.defineProperty(exports, "Channel", ({ enumerable: true, get: function () { return Channel_1.Channel; } }));
const rpcUtils = __importStar(__webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js"));
exports.rpcUtils = rpcUtils;
__exportStar(__webpack_require__(/*! ./sendRpcRequest */ "../../rpc/core/dist/src/sendRpcRequest.js"), exports);
var createDuplexRpcMessageStreams_1 = __webpack_require__(/*! ./createDuplexRpcMessageStreams */ "../../rpc/core/dist/src/createDuplexRpcMessageStreams.js");
Object.defineProperty(exports, "createDuplexRpcMessageStreams", ({ enumerable: true, get: function () { return createDuplexRpcMessageStreams_1.createDuplexRpcMessageStreams; } }));
exports.rpcMaxMessageSize = 10 * 1024 * 1024; // 10 MB
__exportStar(__webpack_require__(/*! ./assertRpcRequestContext */ "../../rpc/core/dist/src/assertRpcRequestContext.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../rpc/core/dist/src/sendRpcRequest.js":
/*!*************************************************!*\
  !*** ../../rpc/core/dist/src/sendRpcRequest.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendRpcRequest = exports.normalizeRpcParameters = exports.getRawRpcParameters = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const RpcUtils_1 = __webpack_require__(/*! ./RpcUtils */ "../../rpc/core/dist/src/RpcUtils.js");
/**
 * Return the 'raw' message parametes array from a previously filtered array
 * @param filteredRcpParams The filtered rpc params
 * @returns raw rpc parameters without any 'injected' parameter.
 */
function getRawRpcParameters(filteredRcpParams, removeRpcRequestContext) {
    const rpcParams = [...filteredRcpParams];
    normalizeRpcParameters(rpcParams, removeRpcRequestContext);
    return rpcParams;
}
exports.getRawRpcParameters = getRawRpcParameters;
function normalizeRpcParameters(rpcParams, removeRpcRequestContext = true) {
    // Note: we need to remove the injected parameters that are coming from RpcServiceHandler
    const { requestId } = RpcUtils_1.RpcParamManager.removeInsertedParams(rpcParams, removeRpcRequestContext);
    // Note: json-rpc lib will inject a Cancellation token also at the end. Next block
    // will attempt to remove it since we want a pure rpc message to flow.
    if (rpcParams.length > 0) {
        const cancellationTokenParam = rpcParams[rpcParams.length - 1];
        // Check if the param is a 'MutableToken'
        // cancellationTokenParam.constructor.name === 'MutableToken'
        // We cannot check the constructor name as it can be different due to minification at run-time
        if (cancellationTokenParam &&
            'isCancellationRequested' in cancellationTokenParam &&
            'onCancellationRequested' in cancellationTokenParam) {
            const token = rpcParams.splice(rpcParams.length - 1, 1)[0];
            return [requestId, token];
        }
    }
    return [requestId, null];
}
exports.normalizeRpcParameters = normalizeRpcParameters;
/**
 * send an rpc request to a message connection from an rpc service handler.
 */
function sendRpcRequest(messageConnection, method, filteredRcpParams, removeRpcRequestContext = true, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const start = Date.now();
            const result = yield messageConnection.sendRequest(method, getRawRpcParameters(filteredRcpParams, removeRpcRequestContext));
            const time = (Date.now() - start).toFixed(1);
            logger === null || logger === void 0 ? void 0 : logger.info(`remote rpc request method: "${method}" result: "${vso_logging_1.TraceFormat.stringify(result)}
            t:${time}`);
            return result;
        }
        catch (err) {
            logger === null || logger === void 0 ? void 0 : logger.error(`failed to handle request for method:${method}`, err);
            throw err;
        }
    });
}
exports.sendRpcRequest = sendRpcRequest;
//# sourceMappingURL=sendRpcRequest.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/MultiChannelRpcServer.js":
/*!*******************************************************!*\
  !*** ../../rpc/ssh/dist/src/MultiChannelRpcServer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiChannelRpcServer = void 0;
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
class MultiChannelRpcServer extends vso_rpc_1.RpcServer {
    constructor() {
        super(...arguments);
        this.acceptedStreams = new Map();
        this.onRpcConnectionDisposedEmitter = new rpc.Emitter();
        this.onRpcConnectionDisposed = this.onRpcConnectionDisposedEmitter.event;
    }
    acceptStream(transportStream) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiChannelStream = new ssh.MultiChannelStream(transportStream);
            const sshChannel = yield multiChannelStream.acceptChannel();
            const rpcMessageStream = new ssh.SshRpcMessageStream(sshChannel);
            const rpcConnectionInfo = this.acceptRpcMessageStream(rpcMessageStream);
            const rpcConnection = rpcConnectionInfo[0];
            this.acceptedStreams.set(rpcConnection, multiChannelStream);
            const disposable = transportStream.closed(() => {
                // Note: on Windows we may receive the closed event twice due to an 'error' event
                // or a 'closed' event.
                disposable.dispose();
                rpcConnection.dispose();
            });
            // if this rpc connection is closed we need to remove
            // the joined connection if exists
            rpcConnection.onDispose((e) => __awaiter(this, void 0, void 0, function* () {
                disposable.dispose();
                this.acceptedStreams.delete(rpcConnection);
                this.onRpcConnectionDisposedEmitter.fire(rpcConnection);
                // if we have the stream wasn't closed we should
                if (!transportStream.isDisposed) {
                    yield transportStream.close();
                }
            }));
            return rpcConnectionInfo;
        });
    }
    /**
     * Return the current multi channel stream request
     */
    getMultiChannelStream(rpcConnection) {
        return this.acceptedStreams.get(rpcConnection);
    }
}
exports.MultiChannelRpcServer = MultiChannelRpcServer;
//# sourceMappingURL=MultiChannelRpcServer.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/SshRpcServer.js":
/*!**********************************************!*\
  !*** ../../rpc/ssh/dist/src/SshRpcServer.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshRpcServer = void 0;
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vscs_utils_2 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const reconnectTimeout = 1000 * 60;
/**
 * Ssh rpc server class.
 */
class SshRpcServer extends vso_rpc_1.RpcServer {
    constructor(sshPrivateKeys, logger) {
        super(logger);
        this.sshPrivateKeys = sshPrivateKeys;
        this.rpcServerProviders = [];
        this.reconnectableSessions = [];
        this.rpcSessions = new Map();
        this.onSessionClosedEmitter = new rpc.Emitter();
        this.onUserAuthenticateCallbacks = new vscs_utils_2.CallbackContainer();
        this.sshServerSessionNumber = 0;
        this.onSessionClosed = this.onSessionClosedEmitter.event;
    }
    dispose(reason) {
        this.reconnectableSessions.forEach((item) => item.dispose());
        super.dispose(reason);
    }
    acceptConnections(cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.rpcServerProviders.map((p) => p.acceptConnections(cancellationToken)));
        });
    }
    registerRpcServerProvider(rpcServerProvider) {
        this.rpcServerProviders.push(rpcServerProvider);
        const onRpcStreamJoinedDisposable = rpcServerProvider.onRpcStreamJoined((e) => {
            this.acceptRpcStream(rpcServerProvider.name, e).catch((err) => {
                this.trace.error('Failed to accept rpc stream', err);
            });
        });
        return {
            dispose: () => __awaiter(this, void 0, void 0, function* () {
                this.trace.info(`unregister rpc server provider:${rpcServerProvider.name}`);
                onRpcStreamJoinedDisposable.dispose();
                const index = this.rpcServerProviders.indexOf(rpcServerProvider);
                if (index !== -1) {
                    this.rpcServerProviders.splice(index, 1);
                }
                if (typeof rpcServerProvider.dispose === 'function') {
                    this.trace.verbose(`dispose rpc server provider:${rpcServerProvider.name}`);
                    yield rpcServerProvider.dispose();
                }
            }),
        };
    }
    onUserAuthenticate(callback) {
        return this.onUserAuthenticateCallbacks.add(callback);
    }
    /**
     * Close the ssh server session associated with an rpc connection.
     * @param rpcMessageConnection the rpc message connection using the ssh session channel
     */
    closeSshSession(rpcMessageConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            const sshServerSession = this.getSshSession(rpcMessageConnection);
            if (sshServerSession) {
                yield sshServerSession.close(ssh.SshDisconnectReason.byApplication);
            }
        });
    }
    /**
     * Get the associated ssh session from an rpc connection.
     * @param rpcMessageConnection the rpc message connection using the ssh session channel
     */
    getSshSession(rpcMessageConnection) {
        return this.rpcSessions.get(rpcMessageConnection);
    }
    acceptRpcStream(providerName, stream) {
        return __awaiter(this, void 0, void 0, function* () {
            const sshChannel = yield createServerSession(stream, this.sshPrivateKeys, this.trace, (userToken) => __awaiter(this, void 0, void 0, function* () {
                for (const callback of this.onUserAuthenticateCallbacks.items) {
                    const result = yield callback(userToken);
                    if (result !== undefined) {
                        return result;
                    }
                }
            }), this.reconnectableSessions);
            const sshServerSessionNumber = ++this.sshServerSessionNumber;
            this.trace.verbose(`Created ssh server session:${sshServerSessionNumber} for provider:${providerName}`);
            const sshServerSession = sshChannel.session;
            let rpcMessageConnection;
            const onRpcSessionClosed = (reason) => {
                this.trace.verbose(`ssh server session:${sshServerSessionNumber} closed reason:${reason}`);
                this.onSessionClosedEmitter.fire(rpcMessageConnection);
                this.rpcSessions.delete(rpcMessageConnection);
            };
            sshServerSession.onDisconnected((e) => __awaiter(this, void 0, void 0, function* () {
                this.trace.info(`Disconnected server session:${sshServerSessionNumber} waiting to reconnect.`);
                let reconnected = false;
                sshServerSession.onReconnected((reconnectedEvent) => {
                    this.trace.info(`Reconnected server session:${sshServerSessionNumber}`);
                    reconnected = true;
                });
                yield (0, vscs_utils_1.wait)(reconnectTimeout);
                if (!reconnected) {
                    this.trace.info(`Closing disconnected server session:${sshServerSessionNumber} because the client ` +
                        'has not reconnected within the timeout.');
                    yield sshServerSession.close(ssh.SshDisconnectReason.connectionLost);
                    onRpcSessionClosed(ssh.SshDisconnectReason.connectionLost);
                }
            }));
            const rpcMessageStream = new ssh.SshRpcMessageStream(sshChannel);
            rpcMessageConnection = this.acceptRpcMessageStream(rpcMessageStream)[0];
            rpcMessageConnection.listen();
            this.rpcSessions.set(rpcMessageConnection, sshServerSession);
            sshServerSession.onClosed((e) => onRpcSessionClosed(e.reason));
        });
    }
}
exports.SshRpcServer = SshRpcServer;
function createSshServerSession(reconnectableSessions) {
    const config = new ssh.SshSessionConfiguration();
    config.keyExchangeAlgorithms.splice(0);
    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);
    config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionReconnect);
    config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionLatency);
    return new ssh.SshServerSession(config, reconnectableSessions);
}
/**
 * Create a server ssh channel
 */
function createServerSession(socketStream, privateKeys, logger, authenticationCallback, reconnectableSessions) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.verbose('Created socket stream');
        const sshServerSession = yield createSshServerSession(reconnectableSessions);
        logger.verbose('created SSH server session');
        sshServerSession.credentials = { publicKeys: privateKeys };
        sshServerSession.onAuthenticating((e) => {
            // Password should be a Cascade token.
            const userToken = e.password;
            logger.verbose('authenticating request');
            if (userToken !== null) {
                e.authenticationPromise = authenticationCallback(userToken);
            }
        });
        sshServerSession.onChannelOpening((e) => {
            if (sshServerSession.principal === undefined) {
                logger.error('unauthenticated request');
                e.failureReason = ssh.SshChannelOpenFailureReason.administrativelyProhibited;
                e.failureDescription = 'Not authenticated';
            }
        });
        const disposable = sshServerSession.onChannelOpening((e) => {
            e.channel.onRequest((requestEvent) => {
                requestEvent.isAuthorized = requestEvent.requestType === 'json-rpc';
                logger.info('rpc channel opening request ' + requestEvent.requestType);
                disposable.dispose();
            });
        });
        yield sshServerSession.connect(socketStream);
        logger.verbose('connected to server session');
        const sshChannel = yield sshServerSession.acceptChannel();
        logger.verbose(`opened channel ${sshChannel.channelId}`);
        return sshChannel;
    });
}
//# sourceMappingURL=SshRpcServer.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/createDuplexMultiChannelRpcClient.js":
/*!*******************************************************************!*\
  !*** ../../rpc/ssh/dist/src/createDuplexMultiChannelRpcClient.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDuplexMultiChannelRpcClient = void 0;
const createDuplexStreams_1 = __webpack_require__(/*! ./createDuplexStreams */ "../../rpc/ssh/dist/src/createDuplexStreams.js");
const createMultiChannelRpcClient_1 = __webpack_require__(/*! ./createMultiChannelRpcClient */ "../../rpc/ssh/dist/src/createMultiChannelRpcClient.js");
function createDuplexMultiChannelRpcClient(rcpServer, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const [stream1, stream2] = (0, createDuplexStreams_1.createDuplexStreams)();
        const serverPromise = rcpServer.acceptStream(stream1);
        const multiChannelRpcClientPromise = (0, createMultiChannelRpcClient_1.createMultiChannelRpcClient)(stream2, logger, true, false);
        const [messageConnectionInfo, rpcClient] = yield Promise.all([
            serverPromise,
            multiChannelRpcClientPromise,
        ]);
        messageConnectionInfo[0].listen();
        return rpcClient;
    });
}
exports.createDuplexMultiChannelRpcClient = createDuplexMultiChannelRpcClient;
//# sourceMappingURL=createDuplexMultiChannelRpcClient.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/createDuplexStreams.js":
/*!*****************************************************!*\
  !*** ../../rpc/ssh/dist/src/createDuplexStreams.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDuplexStreams = void 0;
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
function createDuplexStreams() {
    return DuplexStream.createStreams();
}
exports.createDuplexStreams = createDuplexStreams;
class DuplexStream extends ssh.BaseStream {
    constructor() {
        super();
    }
    static createStreams() {
        const stream1 = new DuplexStream();
        const stream2 = new DuplexStream();
        stream1.other = stream2;
        stream2.other = stream1;
        return [stream1, stream2];
    }
    write(data, cancellation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                throw new TypeError('Data is required.');
            this.other.onData(Buffer.from(data));
            return;
        });
    }
    close(error, cancellation) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!error) {
                this.dispose();
                this.other.onEnd();
                this.other.dispose();
            }
            else {
                this.onError(error);
                this.dispose();
                this.other.onError(error);
                this.other.dispose();
            }
            return;
        });
    }
    dispose() {
        super.dispose();
        if (!this.other.isDisposed) {
            this.other.onError(new Error('Stream disposed.'));
            this.other.dispose();
        }
    }
}
//# sourceMappingURL=createDuplexStreams.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/createMultiChannelRpcClient.js":
/*!*************************************************************!*\
  !*** ../../rpc/ssh/dist/src/createMultiChannelRpcClient.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMultiChannelRpcClient = void 0;
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
function createMultiChannelRpcClient(transportStream, logger, listen = true, addDefaultContextFilter = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const multiChannelStream = new ssh.MultiChannelStream(transportStream);
        const sshChannel = yield multiChannelStream.openChannel();
        const rcpClient = new MultiChannelRpcClient(multiChannelStream, sshChannel, logger, addDefaultContextFilter);
        rcpClient.addToDisposables(multiChannelStream, {
            dispose: () => transportStream.close(),
        });
        if (listen) {
            rcpClient.rpcConnection.listen();
        }
        return rcpClient;
    });
}
exports.createMultiChannelRpcClient = createMultiChannelRpcClient;
class MultiChannelRpcClient extends vso_rpc_1.RpcClient {
    constructor(multiChannelStream, sshChannel, logger, addDefaultContextFilter) {
        super({}, logger, addDefaultContextFilter);
        this.multiChannelStream = multiChannelStream;
        const rpcStream = new ssh.SshRpcMessageStream(sshChannel);
        this.setConnection(this.createRpcConnection(rpcStream, logger));
    }
    get rpcConnection() {
        return this.connection;
    }
}
//# sourceMappingURL=createMultiChannelRpcClient.js.map

/***/ }),

/***/ "../../rpc/ssh/dist/src/index.js":
/*!***************************************!*\
  !*** ../../rpc/ssh/dist/src/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDuplexMultiChannelRpcClient = exports.createDuplexStreams = exports.MultiChannelRpcServer = exports.SshRpcServer = void 0;
var SshRpcServer_1 = __webpack_require__(/*! ./SshRpcServer */ "../../rpc/ssh/dist/src/SshRpcServer.js");
Object.defineProperty(exports, "SshRpcServer", ({ enumerable: true, get: function () { return SshRpcServer_1.SshRpcServer; } }));
var MultiChannelRpcServer_1 = __webpack_require__(/*! ./MultiChannelRpcServer */ "../../rpc/ssh/dist/src/MultiChannelRpcServer.js");
Object.defineProperty(exports, "MultiChannelRpcServer", ({ enumerable: true, get: function () { return MultiChannelRpcServer_1.MultiChannelRpcServer; } }));
var createDuplexStreams_1 = __webpack_require__(/*! ./createDuplexStreams */ "../../rpc/ssh/dist/src/createDuplexStreams.js");
Object.defineProperty(exports, "createDuplexStreams", ({ enumerable: true, get: function () { return createDuplexStreams_1.createDuplexStreams; } }));
var createDuplexMultiChannelRpcClient_1 = __webpack_require__(/*! ./createDuplexMultiChannelRpcClient */ "../../rpc/ssh/dist/src/createDuplexMultiChannelRpcClient.js");
Object.defineProperty(exports, "createDuplexMultiChannelRpcClient", ({ enumerable: true, get: function () { return createDuplexMultiChannelRpcClient_1.createDuplexMultiChannelRpcClient; } }));
__exportStar(__webpack_require__(/*! ./createMultiChannelRpcClient */ "../../rpc/ssh/dist/src/createMultiChannelRpcClient.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/FaultType.js":
/*!**************************************************!*\
  !*** ../../telemetry/core/dist/src/FaultType.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FaultType = void 0;
var FaultType;
(function (FaultType) {
    FaultType[FaultType["Error"] = 0] = "Error";
    FaultType[FaultType["User"] = 1] = "User";
    FaultType[FaultType["Unknown"] = 2] = "Unknown";
    FaultType[FaultType["NonBlockingFault"] = 3] = "NonBlockingFault";
    FaultType[FaultType["UserCancelled"] = 4] = "UserCancelled";
    FaultType[FaultType["ByDesign"] = 5] = "ByDesign";
})(FaultType = exports.FaultType || (exports.FaultType = {}));
//# sourceMappingURL=FaultType.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/Result.js":
/*!***********************************************!*\
  !*** ../../telemetry/core/dist/src/Result.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Result = void 0;
var Result;
(function (Result) {
    Result[Result["Cancel"] = 0] = "Cancel";
    Result[Result["Success"] = 1] = "Success";
    Result[Result["Failure"] = 2] = "Failure";
    Result[Result["UserFailure"] = 3] = "UserFailure";
    Result[Result["IndeterminateFailure"] = 4] = "IndeterminateFailure";
    Result[Result["NonBlockingFailure"] = 5] = "NonBlockingFailure";
    Result[Result["ByDesignFailure"] = 6] = "ByDesignFailure";
})(Result = exports.Result || (exports.Result = {}));
//# sourceMappingURL=Result.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/Telemetry.js":
/*!**************************************************!*\
  !*** ../../telemetry/core/dist/src/Telemetry.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.propagateOffsetMarkTime = exports.cleanSensitiveInformation = exports.TimedEvent = exports.Fault = exports.TelemetryEvent = exports.Telemetry = exports.TelemetryClass = void 0;
const uuid = __webpack_require__(/*! uuid */ "../../node_modules/uuid/index.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const FaultType_1 = __webpack_require__(/*! ./FaultType */ "../../telemetry/core/dist/src/FaultType.js");
const TelemetryStrings_1 = __webpack_require__(/*! ./TelemetryStrings */ "../../telemetry/core/dist/src/TelemetryStrings.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const Result_1 = __webpack_require__(/*! ./Result */ "../../telemetry/core/dist/src/Result.js");
let sequence = 0;
function setSequence() {
    sequence += 1;
    return sequence;
}
class TelemetryClass {
    constructor() {
        this.telemetryEvents = {};
        this.filters = [];
        this.canSendSensitiveFlag = false;
    }
    get reporter() {
        return this.telemetryReporter;
    }
    get canSendSensitiveInformation() {
        return this.canSendSensitiveFlag;
    }
    init(reporter, featureName, canSendSensitiveInformation, faultSendCallbackParam) {
        this.telemetryReporter = reporter;
        this.canSendSensitiveFlag = canSendSensitiveInformation;
        TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME = featureName || '';
        if (faultSendCallbackParam) {
            faultSendCallback = faultSendCallbackParam;
        }
        this.contextProperties = {};
        this.addContextProperty(TelemetryStrings_1.TelemetryPropertyNames.SESSION_ID, uuid());
    }
    addFilter(filter) {
        this.filters.push(filter);
    }
    removeFilter(filter) {
        const idx = this.filters.indexOf(filter);
        if (idx >= 0) {
            this.filters.splice(idx, 1);
        }
    }
    addContextProperties(props, isPII = false) {
        for (const [key, value] of Object.entries(props)) {
            this.addContextProperty(key, value, isPII);
        }
        return this;
    }
    addContextProperty(property, value, isPII = false) {
        // no need to set `undefined` values
        if (value === undefined) {
            return this;
        }
        const valueString = String(value);
        if (isPII && !this.canSendSensitiveInformation) {
            this.contextProperties[property] = vso_logging_1.Privacy.getShortHash(valueString);
        }
        else {
            this.contextProperties[property] = valueString;
        }
        return this;
    }
    removeContextProperty(property) {
        delete this.contextProperties[property];
    }
    getContextProperty(property) {
        return this.contextProperties[property];
    }
    addContextPropertiesToObject(properties) {
        return Object.assign({}, this.contextProperties, properties);
    }
    filterAndSendTelemetryEvent(eventName, callback, properties, measures) {
        if (!this.reporter) {
            // init not called
            return;
        }
        const augmentedMeasures = Object.assign({}, measures);
        const augmentedProperties = this.addContextPropertiesToObject(properties);
        for (const filter of this.filters) {
            if (!filter.shouldSend(eventName, augmentedProperties, augmentedMeasures)) {
                return;
            }
        }
        augmentedMeasures[TelemetryStrings_1.TelemetryPropertyNames.SEQUENCE_NUMBER] = setSequence();
        callback(augmentedProperties, augmentedMeasures);
    }
    sendTelemetryEvent(eventName, properties, measures) {
        const cb = (augmentedProperties, augmentedMeasures) => this.reporter.sendTelemetryEvent(eventName, augmentedProperties, augmentedMeasures);
        this.filterAndSendTelemetryEvent(eventName, cb, properties, measures);
    }
    sendTelemetryErrorEvent(eventName, properties, measures, errorProps) {
        const cb = (augmentedProperties, augmentedMeasures) => this.reporter.sendTelemetryErrorEvent(eventName, augmentedProperties, augmentedMeasures, errorProps);
        this.filterAndSendTelemetryEvent(eventName, cb, properties, measures);
    }
    sendFault(eventName, type, details, exception, correlatedEvent) {
        (new Fault(eventName, type, details, exception, correlatedEvent)).send();
    }
    startTimedEvent(eventName, correlate = false) {
        const timedEvent = new TimedEvent(eventName, correlate);
        // save the event to telemetry events queue
        this.telemetryEvents[timedEvent.id] = timedEvent;
        return timedEvent;
    }
    setCorrelationEvent(correlationEvent) {
        this.correlationEvent = correlationEvent;
    }
    removeCorrelationEvent(correlationEvent) {
        if (this.correlationEvent === correlationEvent) {
            this.correlationEvent = undefined;
        }
    }
    correlate(telemetryEvent) {
        if (this.correlationEvent) {
            telemetryEvent.correlateWith(this.correlationEvent);
        }
    }
    endAllPendingEvents() {
        for (let eventId of Object.keys(this.telemetryEvents)) {
            const event = this.telemetryEvents[eventId];
            event.endIfNotSent();
            delete this.telemetryEvents[eventId];
        }
    }
    disposeAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.reporter.dispose();
        });
    }
}
exports.TelemetryClass = TelemetryClass;
// tslint:disable-next-line: variable-name
const Telemetry = new TelemetryClass();
exports.Telemetry = Telemetry;
let faultSendCallback;
class TelemetryEvent {
    constructor(eventName, correlate = false) {
        this.isSent = false;
        this.id = uuid();
        this.eventName = eventName;
        this.properties = {};
        this.measures = {};
        this.correlationId = uuid();
        if (correlate) {
            Telemetry.correlate(this);
        }
    }
    static create(property, data) {
        const correlate = data ? !!data.correlate : false;
        const telemetryEvent = new TelemetryEvent(property, correlate);
        if (data.properties) {
            Object.keys(data.properties)
                .forEach(key => telemetryEvent.addProperty(TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.properties[key]));
        }
        if (data.measures) {
            Object.keys(data.measures)
                .forEach(key => telemetryEvent.addMeasure(TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.measures[key]));
        }
        return telemetryEvent;
    }
    addProperty(property, value, isPII = false, unkeyed = false) {
        // no need to set `undefined` values
        if (value === undefined) {
            return this;
        }
        const valueString = String(value);
        if (isPII && !Telemetry.canSendSensitiveInformation) {
            this.properties[property] = vso_logging_1.Privacy.getHash(valueString, unkeyed);
        }
        else {
            this.properties[property] = valueString;
        }
        return this;
    }
    addProperties(props, isPII = true) {
        for (let [key, value] of Object.entries(props)) {
            this.addProperty(key, value, isPII);
        }
        return this;
    }
    addPropertyIfNotExists(property, value, isPII = false, unkeyed = false) {
        if (!this.propertyExists(property)) {
            this.addProperty(property, value, isPII, unkeyed);
        }
        return this;
    }
    propertyExists(property) {
        return property in this.properties;
    }
    addMeasure(measure, value) {
        this.measures[measure] = value;
    }
    addMeasureIfNotExists(measure, value) {
        if (this.measures[measure] === undefined) {
            this.addMeasure(measure, value);
        }
    }
    getCorrelationId() {
        return this.correlationId;
    }
    correlateWith(otherEvent) {
        this.correlationId = otherEvent.getCorrelationId();
        return this;
    }
    correlateWithId(correlationId) {
        this.correlationId = correlationId;
        return this;
    }
    addCommonProperties() {
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_ID, this.id);
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.CORRELATION_ID, this.correlationId);
    }
    send() {
        this.addCommonProperties();
        Telemetry.sendTelemetryEvent(this.eventName, this.properties, this.measures);
        this.isSent = true;
    }
    sendAsError(errorProps) {
        this.addCommonProperties();
        Telemetry.sendTelemetryErrorEvent(this.eventName, this.properties, this.measures, errorProps);
        this.isSent = true;
    }
}
exports.TelemetryEvent = TelemetryEvent;
class Fault extends TelemetryEvent {
    constructor(eventName, type, details, exception, correlatedEvent) {
        super(eventName);
        this.exception = exception;
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.FAULT_TYPE, FaultType_1.FaultType[type]);
        if (details) {
            this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(details));
        }
        let exceptionStack = '';
        if (exception && exception instanceof vscode_jsonrpc_1.ResponseError) {
            if (exception.code && typeof exception.code === 'number') {
                this.addMeasure(TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_CODE, exception.code);
            }
            if (exception.data && typeof exception.data === 'string') {
                // RPC response errors have the remote stack trace in the data property.
                exceptionStack += cleanSensitiveInformation(exception.data) +
                    '\n   --- End of remote exception stack trace ---\n';
            }
        }
        if (exception && exception.stack && typeof exception.stack === 'string') {
            exceptionStack += cleanSensitiveInformation((0, vso_logging_1.errorToString)(exception));
        }
        if (!exceptionStack) {
            exceptionStack = 'No Stack';
        }
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK, exceptionStack);
        if (correlatedEvent) {
            this.correlateWith(correlatedEvent);
        }
    }
    send() {
        const _super = Object.create(null, {
            sendAsError: { get: () => super.sendAsError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let errorProps = [];
            if (faultSendCallback) {
                errorProps = yield faultSendCallback(this);
            }
            return _super.sendAsError.call(this, [...errorProps, TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK]);
        });
    }
}
exports.Fault = Fault;
class TimedEvent extends TelemetryEvent {
    constructor(eventName, correlate = false, sendStartEvent = false) {
        super(eventName, correlate);
        this.startTime = (new Date()).getTime();
        this.lastMarkTime = this.startTime;
        TimedEvent.scopeStack.push(this);
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_CREATION_TIME, new Date().toISOString());
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_TYPE, TelemetryStrings_1.TelemetryPropertyValues.END);
        if (sendStartEvent) {
            const startEvent = new TelemetryEvent(eventName);
            startEvent.correlateWith(this);
            startEvent.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_TYPE, TelemetryStrings_1.TelemetryPropertyValues.START);
            startEvent.send();
        }
    }
    markTime(markName, fromStart = false) {
        let currentTime = (new Date()).getTime();
        let duration = fromStart ? (currentTime - this.startTime) : (currentTime - this.lastMarkTime);
        this.lastMarkTime = currentTime;
        this.addMeasure(markName, duration);
        return duration;
    }
    end(result, message, sendNow = true) {
        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_RESULT, Result_1.Result[result]);
        if (message) {
            this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(message));
        }
        const duration = this.markTime(TelemetryStrings_1.TelemetryPropertyNames.EVENT_DURATION, true);
        Telemetry.removeCorrelationEvent(this);
        if (sendNow) {
            this.send();
        }
        for (let i = TimedEvent.scopeStack.length - 1; i >= 0; i--) {
            if (TimedEvent.scopeStack[i] === this) {
                TimedEvent.scopeStack.splice(i, 1);
            }
        }
        return duration;
    }
    endIfNotSent() {
        if (this.isSent) {
            return;
        }
        this.end(Result_1.Result.Cancel, 'Completing pending telemetry events.');
    }
}
exports.TimedEvent = TimedEvent;
TimedEvent.scopeStack = [];
function removeEmailAddresses(str) {
    return str.replace(/[\S]+@[\S]+/gi, '[EMAIL]');
}
function cleanSensitiveInformation(str) {
    return str ? removeEmailAddresses(removePath(str, '[PATH]/')) : str;
}
exports.cleanSensitiveInformation = cleanSensitiveInformation;
function removePath(filePath, replacementString = '') {
    return filePath.replace(/([A-Za-z]:)?(\S*[\\\/])+\S*/gi, (match, drive, directory, offset, whole) => {
        if (/^\d{1,4}\/\d{1,2}\/\d{1,4}$/.test(match)) { // This is a date. No need to scrub.
            return match;
        }
        else {
            const driveAndDirectoryLength = (drive ? drive.length : 0) + directory.length;
            const fileName = match.substr(driveAndDirectoryLength);
            return replacementString + fileName;
        }
    });
}
const propagateOffsetMarkTime = (markName, markEvent) => {
    for (let i = 0; i < TimedEvent.scopeStack.length; i++) {
        const targetEvent = TimedEvent.scopeStack[i];
        if (targetEvent !== markEvent) {
            targetEvent.markTime(markName);
        }
    }
};
exports.propagateOffsetMarkTime = propagateOffsetMarkTime;
//# sourceMappingURL=Telemetry.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/TelemetryFilters.js":
/*!*********************************************************!*\
  !*** ../../telemetry/core/dist/src/TelemetryFilters.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SamplingFilter = exports.SendOnceFilter = void 0;
const TelemetryStrings_1 = __webpack_require__(/*! ./TelemetryStrings */ "../../telemetry/core/dist/src/TelemetryStrings.js");
// This filter ensures that only one telemetry event with the given
// event name and set of properties is ever sent. This is useful in
// situations where the same event can be sent many times; e.g. exceptions.
class SendOnceFilter {
    constructor(eventName, distinctProperties = []) {
        this.eventName = eventName;
        this.distinctProperties = distinctProperties;
        this.sentEventsProperties = [];
    }
    shouldSend(eventName, properties, measures) {
        if (eventName === this.eventName) {
            for (const sentProperties of this.sentEventsProperties) {
                if (this.propertySubsetsEqual(properties, sentProperties)) {
                    return false;
                }
            }
            this.sentEventsProperties.push(this.createPropertySubset(properties));
        }
        return true;
    }
    reset() {
        this.sentEventsProperties = [];
    }
    createPropertySubset(properties) {
        const propertySubset = {};
        for (const p of this.distinctProperties) {
            propertySubset[p] = properties[p];
        }
        return propertySubset;
    }
    propertySubsetsEqual(properties1, properties2) {
        for (const p of this.distinctProperties) {
            if (properties1[p] !== properties2[p]) {
                return false;
            }
        }
        return true;
    }
}
exports.SendOnceFilter = SendOnceFilter;
class SamplingFilter {
    constructor(samplingConfig) {
        this.samplingConfig = samplingConfig;
    }
    shouldSend(eventName, properties, measures) {
        if (!eventName) {
            return true;
        }
        // Check if sampling is enabled for this event
        const sampleRate = this.samplingConfig[eventName];
        if (typeof sampleRate === 'number' && !isNaN(sampleRate)) {
            if (sampleRate === 0 || Math.random() * sampleRate > 1) {
                // The event is disabled (sampleRate is 0) or sampled out
                return false;
            }
            // Include into the sample - add sample rate measure
            measures[TelemetryStrings_1.TelemetryPropertyNames.SAMPLE_RATE] = sampleRate;
        }
        return true;
    }
}
exports.SamplingFilter = SamplingFilter;
//# sourceMappingURL=TelemetryFilters.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/TelemetryStrings.js":
/*!*********************************************************!*\
  !*** ../../telemetry/core/dist/src/TelemetryStrings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryPropertyValues = exports.TelemetryPropertyNames = void 0;
class TelemetryPropertyNames {
    static get FAULT_TYPE() {
        return TelemetryPropertyNames.FEATURE_NAME + 'FaultType';
    }
    static get EVENT_ID() {
        return TelemetryPropertyNames.FEATURE_NAME + 'EventId';
    }
    static get CORRELATION_ID() {
        return TelemetryPropertyNames.FEATURE_NAME + 'CorrelationId';
    }
    static get LOG_LINES() {
        return TelemetryPropertyNames.FEATURE_NAME + 'LogLines';
    }
    static get EVENT_MESSAGE() {
        return TelemetryPropertyNames.FEATURE_NAME + 'Message';
    }
    static get EVENT_EXCEPTION_STACK() {
        return TelemetryPropertyNames.FEATURE_NAME + 'ExceptionStack';
    }
    static get EVENT_RESULT() {
        return TelemetryPropertyNames.FEATURE_NAME + 'Result';
    }
    static get EVENT_TYPE() {
        return TelemetryPropertyNames.FEATURE_NAME + 'Type';
    }
    static get EVENT_DURATION() {
        return TelemetryPropertyNames.FEATURE_NAME + 'Duration';
    }
    static get EVENT_CREATION_TIME() {
        return TelemetryPropertyNames.FEATURE_NAME + 'CreationTime';
    }
    static get SESSION_ID() {
        return TelemetryPropertyNames.FEATURE_NAME + 'SessionId';
    }
    static get EVENT_EXCEPTION_CODE() {
        return TelemetryPropertyNames.FEATURE_NAME + 'ExceptionCode';
    }
    static get SAMPLE_RATE() {
        return TelemetryPropertyNames.FEATURE_NAME + 'SampleRate';
    }
    static get SEQUENCE_NUMBER() {
        return TelemetryPropertyNames.FEATURE_NAME + 'SequenceNumber';
    }
}
exports.TelemetryPropertyNames = TelemetryPropertyNames;
TelemetryPropertyNames.FEATURE_NAME = 'liveshare.';
class TelemetryPropertyValues {
}
exports.TelemetryPropertyValues = TelemetryPropertyValues;
TelemetryPropertyValues.START = 'start';
TelemetryPropertyValues.END = 'end';
TelemetryPropertyValues.SUCCESS = 'success';
TelemetryPropertyValues.FAILURE = 'failure';
//# sourceMappingURL=TelemetryStrings.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/TelemetryUtil.js":
/*!******************************************************!*\
  !*** ../../telemetry/core/dist/src/TelemetryUtil.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryUtil = void 0;
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
const Telemetry_1 = __webpack_require__(/*! ./Telemetry */ "../../telemetry/core/dist/src/Telemetry.js");
const TelemetryStrings_1 = __webpack_require__(/*! ./TelemetryStrings */ "../../telemetry/core/dist/src/TelemetryStrings.js");
/**
 * Helper functions for sending telemetry events.
 */
class TelemetryUtil {
    /**
     * Sends telemetry for a specified event on completion of a promise
     * The duration & result of the promise will be added to event properties
     * @param {string} eventName The name of the event
     * @param {() => Promise<T>} promise A promise to complete before sending the event.
     * @param {{ key: string; value: any }[]} [properties] An optional array of properties to add to the event
     * @return {Promise<T>} The result of the promise
     */
    static sendTelemetryForPromise(eventName, promise, properties) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = undefined;
            let exception;
            let duration;
            const start = new Date().getTime();
            try {
                result = yield promise();
            }
            catch (e) {
                exception = e;
            }
            const stop = new Date().getTime();
            duration = stop - start;
            const event = new Telemetry_1.TelemetryEvent(eventName, true);
            event.addMeasure(TelemetryStrings_1.TelemetryPropertyNames.EVENT_DURATION, duration);
            properties === null || properties === void 0 ? void 0 : properties.forEach((element) => {
                event.addProperty(element.key, element.value);
            });
            if (exception) {
                event.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_RESULT, TelemetryStrings_1.TelemetryPropertyValues.FAILURE);
                event.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK, exception);
                event.send();
                throw exception;
            }
            event.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_RESULT, TelemetryStrings_1.TelemetryPropertyValues.SUCCESS);
            event.send();
            return result;
        });
    }
}
exports.TelemetryUtil = TelemetryUtil;
//# sourceMappingURL=TelemetryUtil.js.map

/***/ }),

/***/ "../../telemetry/core/dist/src/index.js":
/*!**********************************************!*\
  !*** ../../telemetry/core/dist/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryUtil = exports.SamplingFilter = exports.SendOnceFilter = exports.TelemetryResult = exports.FaultType = exports.TelemetryPropertyNames = exports.propagateOffsetMarkTime = exports.cleanSensitiveInformation = exports.TimedEvent = exports.Fault = exports.TelemetryEvent = exports.TelemetryClass = exports.Telemetry = void 0;
var Telemetry_1 = __webpack_require__(/*! ./Telemetry */ "../../telemetry/core/dist/src/Telemetry.js");
Object.defineProperty(exports, "Telemetry", ({ enumerable: true, get: function () { return Telemetry_1.Telemetry; } }));
Object.defineProperty(exports, "TelemetryClass", ({ enumerable: true, get: function () { return Telemetry_1.TelemetryClass; } }));
Object.defineProperty(exports, "TelemetryEvent", ({ enumerable: true, get: function () { return Telemetry_1.TelemetryEvent; } }));
Object.defineProperty(exports, "Fault", ({ enumerable: true, get: function () { return Telemetry_1.Fault; } }));
Object.defineProperty(exports, "TimedEvent", ({ enumerable: true, get: function () { return Telemetry_1.TimedEvent; } }));
Object.defineProperty(exports, "cleanSensitiveInformation", ({ enumerable: true, get: function () { return Telemetry_1.cleanSensitiveInformation; } }));
Object.defineProperty(exports, "propagateOffsetMarkTime", ({ enumerable: true, get: function () { return Telemetry_1.propagateOffsetMarkTime; } }));
var TelemetryStrings_1 = __webpack_require__(/*! ./TelemetryStrings */ "../../telemetry/core/dist/src/TelemetryStrings.js");
Object.defineProperty(exports, "TelemetryPropertyNames", ({ enumerable: true, get: function () { return TelemetryStrings_1.TelemetryPropertyNames; } }));
var FaultType_1 = __webpack_require__(/*! ./FaultType */ "../../telemetry/core/dist/src/FaultType.js");
Object.defineProperty(exports, "FaultType", ({ enumerable: true, get: function () { return FaultType_1.FaultType; } }));
var Result_1 = __webpack_require__(/*! ./Result */ "../../telemetry/core/dist/src/Result.js");
Object.defineProperty(exports, "TelemetryResult", ({ enumerable: true, get: function () { return Result_1.Result; } }));
var TelemetryFilters_1 = __webpack_require__(/*! ./TelemetryFilters */ "../../telemetry/core/dist/src/TelemetryFilters.js");
Object.defineProperty(exports, "SendOnceFilter", ({ enumerable: true, get: function () { return TelemetryFilters_1.SendOnceFilter; } }));
Object.defineProperty(exports, "SamplingFilter", ({ enumerable: true, get: function () { return TelemetryFilters_1.SamplingFilter; } }));
var TelemetryUtil_1 = __webpack_require__(/*! ./TelemetryUtil */ "../../telemetry/core/dist/src/TelemetryUtil.js");
Object.defineProperty(exports, "TelemetryUtil", ({ enumerable: true, get: function () { return TelemetryUtil_1.TelemetryUtil; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../telemetry/node-telemetry-reporter/dist/src/TelemetryReporter.js":
/*!*****************************************************************************!*\
  !*** ../../telemetry/node-telemetry-reporter/dist/src/TelemetryReporter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryReporter = void 0;
const os = __webpack_require__(/*! os */ "os");
const appInsights = __webpack_require__(/*! applicationinsights */ "../../node_modules/applicationinsights/out/applicationinsights.js");
class TelemetryReporter {
    // tslint:disable-next-line
    constructor(key, params, firstParty, logger) {
        this.key = key;
        this.params = params;
        this.logger = logger;
        this.firstParty = false;
        this.firstParty = !!firstParty;
        this.createAppInsightsClient(key);
    }
    createAppInsightsClient(key) {
        //check if another instance is already initialized
        if (appInsights.defaultClient) {
            this.appInsightsClient = new appInsights.TelemetryClient(key);
            // no other way to enable offline mode
            this.appInsightsClient.channel.setUseDiskRetryCaching(true);
        }
        else {
            appInsights.setup(key)
                .setAutoCollectRequests(false)
                .setAutoCollectPerformance(false)
                .setAutoCollectExceptions(false)
                .setAutoCollectDependencies(false)
                .setAutoDependencyCorrelation(false)
                .setAutoCollectConsole(false)
                .setUseDiskRetryCaching(true)
                .start();
            this.appInsightsClient = appInsights.defaultClient;
        }
        this.appInsightsClient.commonProperties = this.getCommonProperties();
        if (this.params.env) {
            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = this.params.env.machineId;
            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = this.params.env.sessionId;
        }
        //check if it's an Asimov key to change the endpoint
        if (key && key.indexOf('AIF-') === 0) {
            this.appInsightsClient.config.endpointUrl = "https://vortex.data.microsoft.com/collect/v1";
            this.firstParty = true;
        }
    }
    getCommonProperties() {
        const commonProperties = Object.create(null);
        commonProperties['common.os'] = os.platform();
        commonProperties['common.platformversion'] = (os.release() || '').replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, '$1$2$3');
        commonProperties['common.extname'] = this.params.name;
        commonProperties['common.extversion'] = this.params.version;
        if (this.params.env) {
            commonProperties['common.vscodemachineid'] = this.params.env.machineId;
            commonProperties['common.vscodesessionid'] = this.params.env.sessionId;
            commonProperties['common.vscodeversion'] = this.params.version;
            commonProperties['common.uikind'] = 'desktop';
            commonProperties['common.remotename'] = this.cleanRemoteName(this.params.env.remoteName);
        }
        return commonProperties;
    }
    cleanRemoteName(remoteName) {
        if (!remoteName) {
            return 'none';
        }
        let ret = 'other';
        // Allowed remote authorities
        ['ssh-remote', 'dev-container', 'attached-container', 'wsl'].forEach((res) => {
            if (remoteName.indexOf(`${res}+`) === 0) {
                ret = res;
            }
        });
        return ret;
    }
    cloneAndChange(obj, change) {
        if (obj === null || typeof obj !== 'object')
            return obj;
        if (typeof change !== 'function')
            return obj;
        const ret = {};
        for (const key in obj) {
            ret[key] = change(key, obj[key]);
        }
        return ret;
    }
    anonymizeFilePaths(stack, anonymizeFilePaths) {
        if (stack === undefined || stack === null) {
            return '';
        }
        const cleanupPatterns = [];
        if (this.params.env) {
            cleanupPatterns.push(new RegExp(this.params.env.appRoot.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'));
        }
        if (this.params.extensionPath) {
            cleanupPatterns.push(new RegExp(this.params.extensionPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'));
        }
        let updatedStack = stack;
        if (anonymizeFilePaths) {
            const cleanUpIndexes = [];
            for (let regexp of cleanupPatterns) {
                while (true) {
                    const result = regexp.exec(stack);
                    if (!result) {
                        break;
                    }
                    cleanUpIndexes.push([result.index, regexp.lastIndex]);
                }
            }
            const nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
            const fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
            let lastIndex = 0;
            updatedStack = '';
            while (true) {
                const result = fileRegex.exec(stack);
                if (!result) {
                    break;
                }
                // Anoynimize user file paths that do not need to be retained or cleaned up.
                if (!nodeModulesRegex.test(result[0]) && cleanUpIndexes.every(([x, y]) => result.index < x || result.index >= y)) {
                    updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';
                    lastIndex = fileRegex.lastIndex;
                }
            }
            if (lastIndex < stack.length) {
                updatedStack += stack.substr(lastIndex);
            }
        }
        // sanitize with configured cleanup patterns
        for (let regexp of cleanupPatterns) {
            updatedStack = updatedStack.replace(regexp, '');
        }
        return updatedStack;
    }
    shouldSendErrorTelemetry() {
        return true;
    }
    sendTelemetryEvent(eventName, properties, measurements) {
        if (eventName && this.appInsightsClient) {
            const cleanProperties = this.cloneAndChange(properties, (_key, prop) => this.anonymizeFilePaths(prop, this.firstParty));
            this.appInsightsClient.trackEvent({
                name: `${this.params.name}/${eventName}`,
                properties: cleanProperties,
                measurements: measurements
            });
            if (this.logger) {
                this.logger.info(`telemetry/${eventName} ${JSON.stringify({ properties, measurements })}`);
            }
        }
    }
    sendTelemetryErrorEvent(eventName, properties, measurements, errorProps) {
        if (eventName && this.appInsightsClient) {
            // always clean the properties if first party
            // do not send any error properties if we shouldn't send error telemetry
            // if we have no errorProps, assume all are error props
            const cleanProperties = this.cloneAndChange(properties, (key, prop) => {
                if (this.shouldSendErrorTelemetry()) {
                    return this.anonymizeFilePaths(prop, this.firstParty);
                }
                if (errorProps === undefined || errorProps.indexOf(key) !== -1) {
                    return 'REDACTED';
                }
                return this.anonymizeFilePaths(prop, this.firstParty);
            });
            this.appInsightsClient.trackEvent({
                name: `${this.params.name}/${eventName}`,
                properties: cleanProperties,
                measurements: measurements
            });
            if (this.logger) {
                this.logger.info(`telemetry/${eventName} ${JSON.stringify({ properties, measurements })}`);
            }
        }
    }
    dispose() {
        const flushEventsToAI = new Promise(resolve => {
            if (this.appInsightsClient) {
                this.appInsightsClient.flush({
                    callback: () => {
                        // all data flushed
                        this.appInsightsClient = undefined;
                        resolve(void 0);
                    }
                });
            }
            else {
                resolve(void 0);
            }
        });
        return Promise.all([flushEventsToAI]);
    }
}
exports.TelemetryReporter = TelemetryReporter;
//# sourceMappingURL=TelemetryReporter.js.map

/***/ }),

/***/ "../../telemetry/node-telemetry-reporter/dist/src/index.js":
/*!*****************************************************************!*\
  !*** ../../telemetry/node-telemetry-reporter/dist/src/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryReporter = void 0;
var TelemetryReporter_1 = __webpack_require__(/*! ./TelemetryReporter */ "../../telemetry/node-telemetry-reporter/dist/src/TelemetryReporter.js");
Object.defineProperty(exports, "TelemetryReporter", ({ enumerable: true, get: function () { return TelemetryReporter_1.TelemetryReporter; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/components/CallbackContainer.js":
/*!************************************************************!*\
  !*** ../../utils/dist/src/components/CallbackContainer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallbackContainer = void 0;
class CallbackContainer {
    constructor() {
        this.callbacks = [];
    }
    clear() {
        this.callbacks.length = 0;
    }
    get items() {
        return this.callbacks;
    }
    add(callback) {
        if (callback) {
            this.callbacks.push(callback);
        }
        return {
            dispose: () => {
                if (!callback) {
                    return;
                }
                const index = this.callbacks.indexOf(callback);
                if (index !== -1) {
                    this.callbacks.splice(index, 1);
                }
            }
        };
    }
}
exports.CallbackContainer = CallbackContainer;
//# sourceMappingURL=CallbackContainer.js.map

/***/ }),

/***/ "../../utils/dist/src/components/DisposableClass.js":
/*!**********************************************************!*\
  !*** ../../utils/dist/src/components/DisposableClass.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisposableClass = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const dispose_1 = __webpack_require__(/*! ../utils/dispose */ "../../utils/dist/src/utils/dispose.js");
const utils_1 = __webpack_require__(/*! ../utils */ "../../utils/dist/src/utils/index.js");
/**
 * Disposable class can handle multiple child disposable that will
 * be disposed when the disposable class isntance is disposed itself.
 * It provides the `onDispose` event for your convenience and will
 * handle the disposables lifecycle, including removing the child
 * disposable object reference from the disposables list when the
 * child gets disposed, hence enable the garbage collection of the
 * object.
 * Also holds the `trace` instance so all classes that inherit from
 * this one will have the tracing available by default.
 */
class DisposableClass {
    constructor(traceReference) {
        this.traceReference = traceReference;
        this.disposablesReference = [];
        this.isDisposedReference = false;
        this.onDisposeEmitter = new vscode_jsonrpc_1.Emitter();
        this.onDisposeEvent = this.onDisposeEmitter.event;
        /**
         * Dispose a particular single disposable object.
         */
        this.disposeObject = (disposable, reason) => {
            try {
                disposable.dispose(reason);
            }
            catch (e) {
                this.trace.verbose('Error from disposable', disposable, reason, e);
            }
            finally {
                this.removeFromDisposables(disposable);
            }
        };
        /**
         * Remove a particular disposable from the child disposables list.
         */
        this.removeFromDisposables = (disposable) => {
            const index = this.disposablesReference.indexOf(disposable);
            if (index < 0) {
                return this;
            }
            this.disposablesReference.splice(index, 1);
            return this;
        };
        this.dispose = this.dispose.bind(this);
        this.onDispose = this.onDispose.bind(this);
    }
    /**
     * Trace instance used by the disposable class instance.
     */
    get disposables() {
        return [...this.disposablesReference];
    }
    /**
     * Trace instance used by the disposable class instance.
     */
    get trace() {
        return this.traceReference;
    }
    /**
     * Whether the disposable class is already disposed.
     */
    get isDisposed() {
        return this.isDisposedReference;
    }
    /**
     * Dispose all child disposables.
     */
    dispose(reason) {
        if (this.isDisposed) {
            return;
        }
        this.isDisposedReference = true;
        const reasonToLog = () => {
            var _a;
            if (reason) {
                if (typeof reason === 'function') {
                    return `${(_a = reason.constructor) === null || _a === void 0 ? void 0 : _a.name}-${JSON.stringify(reason)}`;
                }
                return String(reason);
            }
            return 'n/a';
        };
        try {
            const reason = reasonToLog();
            this.trace.verbose(`disposing reason: '${reason}', disposing ${this.disposables.length} objects`);
            /**
             * We use the public property here since it will make the disposables array clone,
             * otherwise it might be a problem since the the `disposeObject` (or rather the
             * `removeFromDisposables`) will modify the `disposablesReference` array in-place
             * which will mess up the `forEach` loop.
             */
            this.disposables.forEach((disposable, i) => {
                if (!disposable) {
                    this.trace.warning('disposable is not set in the disposables object');
                    return;
                }
                if (disposable.isDisposed) {
                    return;
                }
                return this.disposeObject(disposable, `${reason} $${i}`);
            });
            this.disposablesReference.length = 0;
        }
        catch (e) {
            this.trace.warning('error while disposing an object', e);
        }
        this.onDisposeEmitter.fire(this);
        this.onDisposeEmitter.dispose();
    }
    /**
     * Adds an `IDisposable` to the list of the child disposables, each of which will be
     * disposed when the disposable class is disposed.
     */
    addToDisposables(...disposables) {
        for (const disposable of disposables) {
            (0, utils_1.assertDefined)(disposable, 'Disposable must be defined.');
            /**
             * Subscribe to `onDispose` from child disposables and remove the disposable
             * from the `disposables` array so we don't hold the reference to the object.
             */
            if ('onDispose' in disposable) {
                const eventListener = disposable.onDispose(() => {
                    this.disposeObject(eventListener);
                    this.removeFromDisposables(disposable);
                });
            }
            if ('dispose' in disposable) {
                this.disposablesReference.push(disposable);
            }
        }
        return this;
    }
    /**
     * Event fired only once, when the disposable class is disposed.
     * If the disposable class already disposed the callback called immediatelly.
     */
    onDispose(callback, thisArgs) {
        if (this.isDisposed) {
            this.trace.verbose('already disposed, calling callback immediately');
            callback.call(thisArgs, this);
            return {
                dispose: () => { },
            };
        }
        this.trace.verbose('subscribing to onDispose event');
        const onDisposeEvent = this.onDisposeEvent(callback.bind(thisArgs !== null && thisArgs !== void 0 ? thisArgs : this, this));
        // delay the `onDispose()` event disposal, sp the `onDisposeEmitter` has a
        // chance to fire see `this.dispose()` method for more info.
        return (0, dispose_1.createDisposable)((reason) => {
            (0, utils_1.defer)(() => {
                try {
                    onDisposeEvent.dispose(reason);
                }
                catch ( /* noop */_a) { /* noop */ }
            }, 1);
        }, this.trace.createChild('delayed-disposable'));
    }
}
exports.DisposableClass = DisposableClass;
//# sourceMappingURL=DisposableClass.js.map

/***/ }),

/***/ "../../utils/dist/src/components/Lazy.js":
/*!***********************************************!*\
  !*** ../../utils/dist/src/components/Lazy.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLazyLoadMutable = exports.delayedLoadMutable = exports.lazyLoadNotImplemented = exports.lazyLoadMutable = exports.lazyLoad = void 0;
/**
 * Create a readonly lazy instance.
 * If createIfNotCreated = false, we return either the cached instance if it exists or undefined if it does not exist.
 */
function lazyLoad(loader) {
    let cache;
    return (createIfNotCreated = true) => {
        if (cache !== undefined) {
            return cache;
        }
        else if (createIfNotCreated) {
            return (cache = loader());
        }
        return undefined;
    };
}
exports.lazyLoad = lazyLoad;
/** Create a mutable lazy load wrapper.
 * @param loader - optional value loader. If not provided, value property must be set before the value function is called.
 */
function lazyLoadMutable(loader) {
    const result = () => {
        if (result.value === undefined && result.loader) {
            result.value = result.loader();
        }
        if (result.value === undefined) {
            throw new Error('No loader o value was supplied.');
        }
        return result.value;
    };
    result.loader = loader;
    return result;
}
exports.lazyLoadMutable = lazyLoadMutable;
function lazyLoadNotImplemented() {
    throw new Error('Dependencies: Instance not provided.');
}
exports.lazyLoadNotImplemented = lazyLoadNotImplemented;
function delayedLoadMutable(propertyName) {
    return lazyLoadMutable(() => {
        throw Error(`Dependencies: ${propertyName} is not yet initialized`);
    });
}
exports.delayedLoadMutable = delayedLoadMutable;
/** Set a new loader (if it's defined) on the lazy object. Return the updated lazy object. */
function setLazyLoadMutable(orignal, loader) {
    if (typeof loader === 'function') {
        orignal.loader = loader;
    }
    return orignal;
}
exports.setLazyLoadMutable = setLazyLoadMutable;
//# sourceMappingURL=Lazy.js.map

/***/ }),

/***/ "../../utils/dist/src/components/Mutex.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/components/Mutex.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mutex = void 0;
class Mutex {
    constructor() {
        this.mutex = Promise.resolve();
    }
    dispatch(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const unlock = yield this.lock();
            try {
                return yield Promise.resolve(fn());
            }
            finally {
                unlock();
            }
        });
    }
    lock() {
        let begin = (unlock) => { };
        this.mutex = this.mutex.then(() => {
            return new Promise(begin);
        });
        return new Promise((resolve) => {
            begin = resolve;
        });
    }
}
exports.Mutex = Mutex;
//# sourceMappingURL=Mutex.js.map

/***/ }),

/***/ "../../utils/dist/src/components/Signal.js":
/*!*************************************************!*\
  !*** ../../utils/dist/src/components/Signal.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signal = void 0;
const utils_1 = __webpack_require__(/*! ../utils */ "../../utils/dist/src/utils/index.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../utils/dist/src/errors/index.js");
/**
 * An abstraction above a promise, makes it easy to `resolve`/`reject`
 * promise afterward and keeps the promise state attributes.
 */
class Signal {
    constructor(cancellationToken) {
        this.stateReference = 'pending';
        // tslint:disable-next-line: promise-must-complete
        this.promiseReference = new Promise((resolve, reject) => {
            this.promiseResolve = resolve;
            this.promiseReject = reject;
        });
        this.resolve = this.resolve.bind(this);
        this.reject = this.reject.bind(this);
        this.cancel = this.cancel.bind(this);
        if (!cancellationToken) {
            return;
        }
        if (cancellationToken.isCancellationRequested) {
            this.cancel();
        }
        else if (cancellationToken.onCancellationRequested) {
            cancellationToken.onCancellationRequested(() => {
                if (this.isFulfilled) {
                    return;
                }
                this.cancel();
            });
        }
    }
    get isFulfilled() {
        return this.state !== 'pending';
    }
    get state() {
        return this.stateReference;
    }
    get isResolved() {
        return this.state === 'resolved';
    }
    get isRejected() {
        return this.state === 'rejected';
    }
    get isCancelled() {
        return this.state === 'cancelled';
    }
    resolve(result) {
        if (this.isFulfilled) {
            return;
        }
        this.stateReference = 'resolved';
        (0, utils_1.assertDefined)(this.promiseResolve, 'No `promiseResolve` function found.');
        this.promiseResolve(result);
    }
    reject(error) {
        if (this.isFulfilled) {
            return;
        }
        this.stateReference = 'rejected';
        (0, utils_1.assertDefined)(this.promiseReject, 'No `promiseReject` function found.');
        this.promiseReject(error);
    }
    cancel() {
        if (this.isFulfilled) {
            return;
        }
        this.stateReference = 'cancelled';
        (0, utils_1.assertDefined)(this.promiseReject, 'No `promiseReject` function found.');
        this.promiseReject(new errors_1.CancellationError());
    }
    get promise() {
        return this.promiseReference;
    }
    static from(value) {
        const signal = new Signal();
        if ((0, utils_1.isThenable)(value)) {
            value.then(signal.resolve, signal.reject);
        }
        else {
            signal.resolve(value);
        }
        return signal;
    }
    dispose() {
        if (this.isFulfilled) {
            return;
        }
        this.cancel();
    }
}
exports.Signal = Signal;
//# sourceMappingURL=Signal.js.map

/***/ }),

/***/ "../../utils/dist/src/components/index.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/components/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallbackContainer = exports.Mutex = exports.Signal = exports.DisposableClass = void 0;
var DisposableClass_1 = __webpack_require__(/*! ./DisposableClass */ "../../utils/dist/src/components/DisposableClass.js");
Object.defineProperty(exports, "DisposableClass", ({ enumerable: true, get: function () { return DisposableClass_1.DisposableClass; } }));
var Signal_1 = __webpack_require__(/*! ./Signal */ "../../utils/dist/src/components/Signal.js");
Object.defineProperty(exports, "Signal", ({ enumerable: true, get: function () { return Signal_1.Signal; } }));
var Mutex_1 = __webpack_require__(/*! ./Mutex */ "../../utils/dist/src/components/Mutex.js");
Object.defineProperty(exports, "Mutex", ({ enumerable: true, get: function () { return Mutex_1.Mutex; } }));
var CallbackContainer_1 = __webpack_require__(/*! ./CallbackContainer */ "../../utils/dist/src/components/CallbackContainer.js");
Object.defineProperty(exports, "CallbackContainer", ({ enumerable: true, get: function () { return CallbackContainer_1.CallbackContainer; } }));
__exportStar(__webpack_require__(/*! ./Lazy */ "../../utils/dist/src/components/Lazy.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/constants/index.js":
/*!***********************************************!*\
  !*** ../../utils/dist/src/constants/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globalTrace = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
__exportStar(__webpack_require__(/*! ./time */ "../../utils/dist/src/constants/time.js"), exports);
exports.globalTrace = new vso_logging_1.TraceSource('vscs');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/constants/time.js":
/*!**********************************************!*\
  !*** ../../utils/dist/src/constants/time.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TIME_DAY_MS = exports.TIME_HOUR_MS = exports.TIME_MINUTE_MS = exports.TIME_SECOND_MS = void 0;
exports.TIME_SECOND_MS = 1000;
exports.TIME_MINUTE_MS = 60 * exports.TIME_SECOND_MS;
exports.TIME_HOUR_MS = 60 * exports.TIME_MINUTE_MS;
exports.TIME_DAY_MS = 24 * exports.TIME_HOUR_MS;
//# sourceMappingURL=time.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/AggregateError.js":
/*!*****************************************************!*\
  !*** ../../utils/dist/src/errors/AggregateError.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AggregateError = void 0;
const _1 = __webpack_require__(/*! . */ "../../utils/dist/src/errors/index.js");
/**
 * Aggregate error holds a list of errors.
 */
class AggregateError extends _1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'AggregateError';
        /**
         * The errors list as a private reference.
         */
        this.errorsReference = [];
    }
    /**
     * Get a copy aggregate error list.
     */
    get errors() {
        return [...this.errorsReference];
    }
    /**
     * Add errors to the aggregate error list.
     */
    addErrors(...errors) {
        this.errorsReference.push(...errors);
        return this;
    }
    /**
     * Creates new `AggregateError` copy from the current one and adds the errors.
     */
    cloneWithErrors(...errors) {
        const newError = new AggregateError();
        newError.addErrors(...this.errors, ...errors);
        return newError;
    }
    /**
     * Return the last error in the error sequence.s
     */
    get lastError() {
        const lastErrorIndex = this.errorsReference.length - 1;
        return this.errorsReference[lastErrorIndex];
    }
}
exports.AggregateError = AggregateError;
;
//# sourceMappingURL=AggregateError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/AssertionError.js":
/*!*****************************************************!*\
  !*** ../../utils/dist/src/errors/AssertionError.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssertionError = void 0;
const BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
/**
 * Error thrown when an assertion fails.
 */
class AssertionError extends BaseError_1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'AssertionError';
    }
}
exports.AssertionError = AssertionError;
;
//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/AuthenticationError.js":
/*!**********************************************************!*\
  !*** ../../utils/dist/src/errors/AuthenticationError.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationError = void 0;
const BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
/**
 * Error inticates authentication failure.
 */
class AuthenticationError extends BaseError_1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'AuthenticationError';
    }
}
exports.AuthenticationError = AuthenticationError;
;
//# sourceMappingURL=AuthenticationError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/BaseError.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/errors/BaseError.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
/**
 * Base error, all errors should extened it and specify new `errorType`.
 *
 * The error has:

 *  - `errorType` - idetifies the eror type, every eror that inherits from
 *      this one, override the `errorType` with its own value.
 * - `errorCode` - error code (number) for the specific error case.
 * - `originalErrorType` - if an error with an `errorType`/`errorCode` is
 *     "wrapped" with this error, the data is reserved in the `originalErrorType`
 *     so we don't loose the original context.
 * - `stack`[optional] - error stack trace. If an error is wrapped with this
 *     error, the stack is copied over.
 */
class BaseError extends Error {
    constructor(error, errorCode) {
        super((typeof error === 'string')
            ? error
            : error === null || error === void 0 ? void 0 : error.message);
        this.errorCode = errorCode;
        this.errorType = 'BaseError';
        if (error instanceof Error) {
            this.originalError = error;
            this.stack = error.stack;
            this.originalErrorType = this.getOriginalErrorCode(error);
            this.errorCode = errorCode !== null && errorCode !== void 0 ? errorCode : error.errorCode;
        }
    }
    getOriginalErrorCode(error) {
        const { errorType = '<no-type>', errorCode = '<no-code>', } = error;
        return `[${errorType}:${errorCode}]`;
    }
}
exports.BaseError = BaseError;
;
//# sourceMappingURL=BaseError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/ByDesignError.js":
/*!****************************************************!*\
  !*** ../../utils/dist/src/errors/ByDesignError.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ByDesignError = void 0;
class ByDesignError extends Error {
    constructor(message, code, isSuppressUserNotification) {
        super(message);
        this.code = code;
        this.isSuppressUserNotification = isSuppressUserNotification;
    }
}
exports.ByDesignError = ByDesignError;
//# sourceMappingURL=ByDesignError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/CancellationError.js":
/*!********************************************************!*\
  !*** ../../utils/dist/src/errors/CancellationError.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationError = void 0;
const BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
/**
 * Error thrown when something is cancelled. Used by `Signal`.
 */
class CancellationError extends BaseError_1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'CancellationError';
    }
}
exports.CancellationError = CancellationError;
//# sourceMappingURL=CancellationError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/NotImplementedError.js":
/*!**********************************************************!*\
  !*** ../../utils/dist/src/errors/NotImplementedError.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotImplementedError = void 0;
const BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
/**
 * Error thrown when an some function or method is not implemented.
 */
class NotImplementedError extends BaseError_1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'NotImplementedError';
    }
}
exports.NotImplementedError = NotImplementedError;
;
//# sourceMappingURL=NotImplementedError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/PromiseRaceError.js":
/*!*******************************************************!*\
  !*** ../../utils/dist/src/errors/PromiseRaceError.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiseRaceError = void 0;
const BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
/**
 * The promise race error is thrown when all promises have thrown.
 * In this case the error will be derrived from the last thrown
 * error and `errorList` will contain entire error list.
 */
class PromiseRaceError extends BaseError_1.BaseError {
    constructor(errorList, error, errorCode) {
        super(error, errorCode);
        this.errorList = errorList;
        this.errorType = 'PromiseRaceError';
    }
}
exports.PromiseRaceError = PromiseRaceError;
;
//# sourceMappingURL=PromiseRaceError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/TimeoutCancellationError.js":
/*!***************************************************************!*\
  !*** ../../utils/dist/src/errors/TimeoutCancellationError.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutCancellationError = void 0;
const CancellationError_1 = __webpack_require__(/*! ./CancellationError */ "../../utils/dist/src/errors/CancellationError.js");
/**
 * Error thrown when some operation should be cancelled by a timeout.
 */
class TimeoutCancellationError extends CancellationError_1.CancellationError {
    constructor() {
        super(...arguments);
        this.errorType = 'TimeoutCancellationError';
    }
}
exports.TimeoutCancellationError = TimeoutCancellationError;
//# sourceMappingURL=TimeoutCancellationError.js.map

/***/ }),

/***/ "../../utils/dist/src/errors/index.js":
/*!********************************************!*\
  !*** ../../utils/dist/src/errors/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutCancellationError = exports.AuthenticationError = exports.NotImplementedError = exports.CancellationError = exports.PromiseRaceError = exports.AssertionError = exports.AggregateError = exports.ByDesignError = exports.BaseError = void 0;
var BaseError_1 = __webpack_require__(/*! ./BaseError */ "../../utils/dist/src/errors/BaseError.js");
Object.defineProperty(exports, "BaseError", ({ enumerable: true, get: function () { return BaseError_1.BaseError; } }));
var ByDesignError_1 = __webpack_require__(/*! ./ByDesignError */ "../../utils/dist/src/errors/ByDesignError.js");
Object.defineProperty(exports, "ByDesignError", ({ enumerable: true, get: function () { return ByDesignError_1.ByDesignError; } }));
var AggregateError_1 = __webpack_require__(/*! ./AggregateError */ "../../utils/dist/src/errors/AggregateError.js");
Object.defineProperty(exports, "AggregateError", ({ enumerable: true, get: function () { return AggregateError_1.AggregateError; } }));
var AssertionError_1 = __webpack_require__(/*! ./AssertionError */ "../../utils/dist/src/errors/AssertionError.js");
Object.defineProperty(exports, "AssertionError", ({ enumerable: true, get: function () { return AssertionError_1.AssertionError; } }));
var PromiseRaceError_1 = __webpack_require__(/*! ./PromiseRaceError */ "../../utils/dist/src/errors/PromiseRaceError.js");
Object.defineProperty(exports, "PromiseRaceError", ({ enumerable: true, get: function () { return PromiseRaceError_1.PromiseRaceError; } }));
var CancellationError_1 = __webpack_require__(/*! ./CancellationError */ "../../utils/dist/src/errors/CancellationError.js");
Object.defineProperty(exports, "CancellationError", ({ enumerable: true, get: function () { return CancellationError_1.CancellationError; } }));
var NotImplementedError_1 = __webpack_require__(/*! ./NotImplementedError */ "../../utils/dist/src/errors/NotImplementedError.js");
Object.defineProperty(exports, "NotImplementedError", ({ enumerable: true, get: function () { return NotImplementedError_1.NotImplementedError; } }));
var AuthenticationError_1 = __webpack_require__(/*! ./AuthenticationError */ "../../utils/dist/src/errors/AuthenticationError.js");
Object.defineProperty(exports, "AuthenticationError", ({ enumerable: true, get: function () { return AuthenticationError_1.AuthenticationError; } }));
var TimeoutCancellationError_1 = __webpack_require__(/*! ./TimeoutCancellationError */ "../../utils/dist/src/errors/TimeoutCancellationError.js");
Object.defineProperty(exports, "TimeoutCancellationError", ({ enumerable: true, get: function () { return TimeoutCancellationError_1.TimeoutCancellationError; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/index.js":
/*!*************************************!*\
  !*** ../../utils/dist/src/index.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Utilities
 */
__exportStar(__webpack_require__(/*! ./utils */ "../../utils/dist/src/utils/index.js"), exports);
/**
 * Components
 */
__exportStar(__webpack_require__(/*! ./components */ "../../utils/dist/src/components/index.js"), exports);
/**
 * Errors
 */
__exportStar(__webpack_require__(/*! ./errors */ "../../utils/dist/src/errors/index.js"), exports);
/**
 * Constants
 */
__exportStar(__webpack_require__(/*! ./constants */ "../../utils/dist/src/constants/index.js"), exports);
/**
 * Mocks
 */
__exportStar(__webpack_require__(/*! ./mocks */ "../../utils/dist/src/mocks/index.js"), exports);
/**
 * Interfaces
 */
__exportStar(__webpack_require__(/*! ./interfaces */ "../../utils/dist/src/interfaces/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/interfaces/index.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/interfaces/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/mocks/DisposableClassMock.js":
/*!*********************************************************!*\
  !*** ../../utils/dist/src/mocks/DisposableClassMock.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisposableClassMock = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
class DisposableClassMock {
    constructor() {
        this.trace = new vso_logging_1.TraceSource('test-logger');
        this.addToDisposables = (disposable) => {
            return this;
        };
        this.isDisposed = false;
        this.onDispose = (callback, thisArgs) => {
            return {
                dispose: () => { },
            };
        };
        this.dispose = () => {
            return this;
        };
    }
}
exports.DisposableClassMock = DisposableClassMock;
//# sourceMappingURL=DisposableClassMock.js.map

/***/ }),

/***/ "../../utils/dist/src/mocks/index.js":
/*!*******************************************!*\
  !*** ../../utils/dist/src/mocks/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisposableClassMock = void 0;
var DisposableClassMock_1 = __webpack_require__(/*! ./DisposableClassMock */ "../../utils/dist/src/mocks/DisposableClassMock.js");
Object.defineProperty(exports, "DisposableClassMock", ({ enumerable: true, get: function () { return DisposableClassMock_1.DisposableClassMock; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/arrayUnique.js":
/*!*************************************************!*\
  !*** ../../utils/dist/src/utils/arrayUnique.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayUnique = void 0;
/**
 * Reduce an array to one that has unique items only.
 */
const arrayUnique = (arr) => {
    const set = new Set(arr);
    return [...set];
};
exports.arrayUnique = arrayUnique;
//# sourceMappingURL=arrayUnique.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/asserts/assert.js":
/*!****************************************************!*\
  !*** ../../utils/dist/src/utils/asserts/assert.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = void 0;
const AssertionError_1 = __webpack_require__(/*! ../../errors/AssertionError */ "../../utils/dist/src/errors/AssertionError.js");
/**
 * Assert that the expression that results in `val` holds, otherwise throw
 * an `AssertionError` with the `errorMessage`. Alternatively, if an error
 * instance is passed as the `errorMessage`, throw that instead.
 */
const assert = (val, errorMessage) => {
    if (val !== true) {
        const error = (typeof errorMessage === 'string')
            ? new AssertionError_1.AssertionError(errorMessage)
            : errorMessage;
        throw error;
    }
};
exports.assert = assert;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/asserts/assertDefined.js":
/*!***********************************************************!*\
  !*** ../../utils/dist/src/utils/asserts/assertDefined.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertDefined = void 0;
const assert_1 = __webpack_require__(/*! ./assert */ "../../utils/dist/src/utils/asserts/assert.js");
/**
 * Assert the `val` object is not `null` nor `undefined`, if it is
 * throw an `AssertionError` with the `errorMessage`. Alternatively,
 * if an error instance is passed as the `errorMessage`, throw that instead.
 */
const assertDefined = (val, errorMessage) => {
    return (0, assert_1.assert)(val != null, errorMessage);
};
exports.assertDefined = assertDefined;
//# sourceMappingURL=assertDefined.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/asserts/assertInstance.js":
/*!************************************************************!*\
  !*** ../../utils/dist/src/utils/asserts/assertInstance.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertInstance = void 0;
const assert_1 = __webpack_require__(/*! ./assert */ "../../utils/dist/src/utils/asserts/assert.js");
/**
 * Assert the `val` is instance of `classObject`.
 */
const assertInstance = (val, classObject, errorMessage) => {
    return (0, assert_1.assert)(val instanceof classObject, errorMessage);
};
exports.assertInstance = assertInstance;
//# sourceMappingURL=assertInstance.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/asserts/assertNever.js":
/*!*********************************************************!*\
  !*** ../../utils/dist/src/utils/asserts/assertNever.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertNever = void 0;
const errors_1 = __webpack_require__(/*! ../../errors */ "../../utils/dist/src/errors/index.js");
/**
 * Assert to cover the cases that should never happen.
 */
// TODO legomushroom - test this
const assertNever = (value, errorMessage) => {
    const error = (typeof errorMessage === 'string')
        ? new errors_1.AssertionError(errorMessage)
        : errorMessage;
    throw error;
};
exports.assertNever = assertNever;
//# sourceMappingURL=assertNever.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/asserts/index.js":
/*!***************************************************!*\
  !*** ../../utils/dist/src/utils/asserts/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = exports.assertNever = exports.assertDefined = exports.assertInstance = void 0;
var assertInstance_1 = __webpack_require__(/*! ./assertInstance */ "../../utils/dist/src/utils/asserts/assertInstance.js");
Object.defineProperty(exports, "assertInstance", ({ enumerable: true, get: function () { return assertInstance_1.assertInstance; } }));
var assertDefined_1 = __webpack_require__(/*! ./assertDefined */ "../../utils/dist/src/utils/asserts/assertDefined.js");
Object.defineProperty(exports, "assertDefined", ({ enumerable: true, get: function () { return assertDefined_1.assertDefined; } }));
var assertNever_1 = __webpack_require__(/*! ./assertNever */ "../../utils/dist/src/utils/asserts/assertNever.js");
Object.defineProperty(exports, "assertNever", ({ enumerable: true, get: function () { return assertNever_1.assertNever; } }));
var assert_1 = __webpack_require__(/*! ./assert */ "../../utils/dist/src/utils/asserts/assert.js");
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return assert_1.assert; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/cleanupPII.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/cleanupPII.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanupObjectValuesPII = exports.cleanupPII = exports.obfusticateEmailAddresses = exports.obfusticatePaths = exports.obfusticateCodespaceNames = exports.CODESPACE_URL_PII_LABEL = exports.EMAIL_PII_LABEL = exports.PATH_PII_LABEL = void 0;
// regex to target filesystem paths, like /Users/olegsolomka/repos/Cascade/vscode/codespaces
const PATH_REGEX = /([A-Za-z]:)?(\S*[\\\/])+\S*/gim;
// regex to target emails, like legomushroom@gmail.com
const EMAIL_REGEX = /[\S]+@[\S]+/gim;
// regex to target codespace name URLs, like https://legomushroom-codespaces-contrib-tunnel-tun-w9wpr963969x.github.dev/
const CODESPACE_NAME_REGEX = /(https?:\/\/)?([\w|-]+)\.github\.dev((\S*[\\\/])+\S*)?/gim; // (https?://)?(www.)?(codespace-name).github.dev/path/component/
// file system paths replaced with this label
exports.PATH_PII_LABEL = '[PATH]/';
// all emails replaced with this label
exports.EMAIL_PII_LABEL = '[EMAIL]';
// all codespace names replaced with this label
exports.CODESPACE_URL_PII_LABEL = '[CODESPACE_URL]';
/**
 * Function to replace all codespace names with [CODESPACE_URL] label.
 */
const obfusticateCodespaceNames = (str, replacementString = exports.CODESPACE_URL_PII_LABEL) => {
    return str.replace(CODESPACE_NAME_REGEX, replacementString);
};
exports.obfusticateCodespaceNames = obfusticateCodespaceNames;
/**
 * Function to replace all paths with [PATH] label.
 */
const obfusticatePaths = (str, replacementString = exports.PATH_PII_LABEL) => {
    return str.replace(PATH_REGEX, (match, drive, directory, offset, whole) => {
        if (/^\d{1,4}\/\d{1,2}\/\d{1,4}$/.test(match)) { // This is a date. No need to scrub.
            return match;
        }
        else {
            const driveAndDirectoryLength = (drive ? drive.length : 0) + directory.length;
            const fileName = match.substr(driveAndDirectoryLength);
            return replacementString + fileName;
        }
    });
};
exports.obfusticatePaths = obfusticatePaths;
/**
 *  Function to replace all emails with `[EMAIL]` label.
 */
const obfusticateEmailAddresses = (str, replacementString = exports.EMAIL_PII_LABEL) => {
    return str.replace(EMAIL_REGEX, replacementString);
};
exports.obfusticateEmailAddresses = obfusticateEmailAddresses;
/**
 *  Function to remove PII from a string.
 */
const cleanupPII = (str) => {
    if (!str) {
        return str;
    }
    return (0, exports.obfusticateEmailAddresses)((0, exports.obfusticatePaths)((0, exports.obfusticateCodespaceNames)(str)));
};
exports.cleanupPII = cleanupPII;
/**
 * Function to remove PII data from the object values.
 */
const cleanupObjectValuesPII = (obj) => {
    for (let [key, value] of Object.entries(obj)) {
        // cleanup strings
        if (typeof value === 'string') {
            obj[key] = (0, exports.cleanupPII)(value);
        }
    }
    return obj;
};
exports.cleanupObjectValuesPII = cleanupObjectValuesPII;
//# sourceMappingURL=cleanupPII.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/connectEvents.js":
/*!***************************************************!*\
  !*** ../../utils/dist/src/utils/connectEvents.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectEvents = void 0;
const createDisposable_1 = __webpack_require__(/*! ./createDisposable */ "../../utils/dist/src/utils/createDisposable.js");
/**
 * Function to connect 2 events, then the `event` fired,
 * fire the `event` also.
 */
const connectEvents = (notify, ...events) => {
    const disposables = events.map((event) => {
        return event(notify.fire.bind(notify));
    });
    return (0, createDisposable_1.createDisposable)(() => {
        for (const disposable of disposables) {
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
    });
};
exports.connectEvents = connectEvents;
//# sourceMappingURL=connectEvents.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/continueWhen.js":
/*!**************************************************!*\
  !*** ../../utils/dist/src/utils/continueWhen.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.continueWhen = void 0;
const timeoutPromise_1 = __webpack_require__(/*! ./timeoutPromise */ "../../utils/dist/src/utils/timeoutPromise.js");
const components_1 = __webpack_require__(/*! ../components */ "../../utils/dist/src/components/index.js");
const asserts_1 = __webpack_require__(/*! ./asserts */ "../../utils/dist/src/utils/asserts/index.js");
const utils_1 = __webpack_require__(/*! ../utils */ "../../utils/dist/src/utils/index.js");
/**
 * Function to transform and event into a promise so it can be `awaited` in-place.
 *
 * ## Example:
 *
 * ```
 *  //..
 *  [1] const result = await continueWhen(this.onResolveComplete);
 *  [2] //..
 * ```
 * [1] will wait on the `onResolveComplete` event to happen before proceeding further to [2],
 * the `result` will contain the first (and only) argument of the `onResolveComplete` event.
 *
 * ```
 * /..
 *  [1] const result = await continueWhen(this.onResolveComplete, 2000);
 *  [2] //..
 * ```
 * Same as example above, but will throw the `TimeoutCancellationError`
 * error, if the event is not fired before the timeout elapses.
 *
 * ## Throws:
 *
 *  - `TimeoutCancellationError` when the finite timeout is passed and the
 *      event is not fired before the timeout is elapsed.
 *  - `AssertionError` when passed `timeout` number is `NaN`.
 */
const continueWhen = (event, timeout = Infinity, error) => __awaiter(void 0, void 0, void 0, function* () {
    const signal = new components_1.Signal();
    try {
        // resolve the signal when even is fired
        const eventDisposable = event((arg) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                eventDisposable.dispose();
            }
            catch ( /* noop */_a) { /* noop */ }
            // give other event subscribers a chance to run
            yield (0, utils_1.wait)(1);
            // resolve the main signal
            signal.resolve(arg);
        }));
        (0, asserts_1.assert)(!Number.isNaN(timeout), 'Timeout is NaN.');
        (0, asserts_1.assert)(timeout > 0, `Timeout must be greater than zero, but "${timeout}" passed.`);
        /**
         * if we got finite timeout, throw the `TimeoutCancellationError`
         * if the event is not fired before the timeout elapses.
         */
        if (Number.isFinite(timeout)) {
            return yield (0, timeoutPromise_1.timeoutPromise)(signal.promise, timeout, error);
        }
        // no timeout - wait on the promise itself
        return yield signal.promise;
    }
    catch (e) {
        throw e;
    }
});
exports.continueWhen = continueWhen;
//# sourceMappingURL=continueWhen.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/crc32.js":
/*!*******************************************!*\
  !*** ../../utils/dist/src/utils/crc32.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crc32 = void 0;
let crcTable;
function makeCrcTable() {
    let c;
    const table = [];
    for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        table[n] = c;
    }
    return table;
}
function crc32(data) {
    if (!crcTable) {
        crcTable = makeCrcTable();
    }
    let crc = 0 ^ -1;
    for (let i = 0; i < data.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xff];
    }
    const result = (crc ^ -1) >>> 0;
    return (result + 0x100000000)
        .toString(16)
        .substr(-8)
        .toUpperCase();
}
exports.crc32 = crc32;
//# sourceMappingURL=crc32.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/createDisposable.js":
/*!******************************************************!*\
  !*** ../../utils/dist/src/utils/createDisposable.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDisposable = void 0;
/**
 * Wrap some code to create a disposable.
 */
const createDisposable = (dispose) => {
    return {
        dispose,
    };
};
exports.createDisposable = createDisposable;
//# sourceMappingURL=createDisposable.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/debounce.js":
/*!**********************************************!*\
  !*** ../../utils/dist/src/utils/debounce.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debounce = void 0;
/**
 * Interval version of a debounce util.
 */
const debounce = (fn, timeout) => {
    let interval;
    const debounced = (...args) => {
        clearInterval(interval);
        interval = setInterval(() => {
            fn(...args);
        }, timeout);
    };
    debounced.stop = () => {
        clearInterval(interval);
    };
    return debounced;
};
exports.debounce = debounce;
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/decorators/index.js":
/*!******************************************************!*\
  !*** ../../utils/dist/src/utils/decorators/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withHelperDecorator = exports.withRetriesDecorator = void 0;
var withRetriesDecorator_1 = __webpack_require__(/*! ./withRetriesDecorator */ "../../utils/dist/src/utils/decorators/withRetriesDecorator.js");
Object.defineProperty(exports, "withRetriesDecorator", ({ enumerable: true, get: function () { return withRetriesDecorator_1.withRetriesDecorator; } }));
var withHelperDecorator_1 = __webpack_require__(/*! ./withHelperDecorator */ "../../utils/dist/src/utils/decorators/withHelperDecorator.js");
Object.defineProperty(exports, "withHelperDecorator", ({ enumerable: true, get: function () { return withHelperDecorator_1.withHelperDecorator; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/decorators/withHelperDecorator.js":
/*!********************************************************************!*\
  !*** ../../utils/dist/src/utils/decorators/withHelperDecorator.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withHelperDecorator = void 0;
const assertDefined_1 = __webpack_require__(/*! ../asserts/assertDefined */ "../../utils/dist/src/utils/asserts/assertDefined.js");
const assert_1 = __webpack_require__(/*! ../asserts/assert */ "../../utils/dist/src/utils/asserts/assert.js");
/**
 * Factory function to construct a helper with
 * specific execution context.
 */
const contextMap = new Map();
const getHelper = (method, helper, options, context) => {
    /**
     * The overriden method should be associated with both
     * class instance and the class method, hence we are
     * using 2 maps here.
     */
    const existingHelpers = contextMap.get(context);
    if (existingHelpers) {
        const existingHelper = existingHelpers.get(method);
        if (existingHelper) {
            return existingHelper;
        }
    }
    else {
        contextMap.set(context, new Map());
    }
    const newHelper = helper(method.bind(context), options);
    const helpers = contextMap.get(context);
    (0, assertDefined_1.assertDefined)(helpers, 'No helpers found.');
    helpers.set(method, newHelper);
    return newHelper;
};
/**
 * Generic decorator to wrap a method with a helper.
 */
function withHelperDecorator(helper, options) {
    return function (target, propertyName, propertyDesciptor) {
        const { value: method } = propertyDesciptor;
        (0, assert_1.assert)(method instanceof Function, 'This decorator works only on methods');
        (0, assertDefined_1.assertDefined)(method, `The method "${propertyName}" is not defined.`);
        // must be `function` to not loose `this` context
        propertyDesciptor.value = function (...args) {
            return __awaiter(this, void 0, void 0, function* () {
                const wrappedMethod = getHelper(method, helper, options, this);
                return yield wrappedMethod.call(this, ...args);
            });
        };
        return propertyDesciptor;
    };
}
exports.withHelperDecorator = withHelperDecorator;
;
//# sourceMappingURL=withHelperDecorator.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/decorators/withRetriesDecorator.js":
/*!*********************************************************************!*\
  !*** ../../utils/dist/src/utils/decorators/withRetriesDecorator.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withRetriesDecorator = void 0;
const assertDefined_1 = __webpack_require__(/*! ../asserts/assertDefined */ "../../utils/dist/src/utils/asserts/assertDefined.js");
const withRetries_1 = __webpack_require__(/*! ../withRetries */ "../../utils/dist/src/utils/withRetries.js");
const assert_1 = __webpack_require__(/*! ../asserts/assert */ "../../utils/dist/src/utils/asserts/assert.js");
/**
 * Method decorator, analog of the `withRetries` util.
 */
// TODO legomushroom - test this
const withRetriesDecorator = (options = {}) => {
    return (target, propertyName, propertyDesciptor) => {
        const { value: method } = propertyDesciptor;
        (0, assert_1.assert)(method instanceof Function, 'This decorator works only on methods');
        (0, assertDefined_1.assertDefined)(method, `The method "${propertyName}" is not defined.`);
        // must be `function` to not loose `this` context
        const result = function (...args) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield (0, withRetries_1.withRetries)((retry) => __awaiter(this, void 0, void 0, function* () {
                    return yield method.call(this, ...args, retry);
                }), options);
            });
        };
        propertyDesciptor.value = result;
        return propertyDesciptor;
    };
};
exports.withRetriesDecorator = withRetriesDecorator;
//# sourceMappingURL=withRetriesDecorator.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/defer.js":
/*!*******************************************!*\
  !*** ../../utils/dist/src/utils/defer.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defer = void 0;
/**
 * Defer execution by `timout` milliseconds.
 */
const defer = (fn, timeout = 1) => {
    const timer = setTimeout(fn, timeout);
    return timer;
};
exports.defer = defer;
//# sourceMappingURL=defer.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/dispose.js":
/*!*********************************************!*\
  !*** ../../utils/dist/src/utils/dispose.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDisposablesSeries = exports.createDisposablesAll = exports.createDisposable = void 0;
function createDisposable(callback, logger) {
    return {
        dispose: (reason) => {
            logger === null || logger === void 0 ? void 0 : logger.verbose(`Disposing reason:${reason}`);
            return callback(reason);
        }
    };
}
exports.createDisposable = createDisposable;
function createDisposablesAll(logger, ...disposables) {
    return {
        dispose: (reason) => {
            logger === null || logger === void 0 ? void 0 : logger.verbose(`createDisposablesAll->dispose reason:${reason}`);
            return Promise.all(disposables.map(d => d.dispose(reason)));
        }
    };
}
exports.createDisposablesAll = createDisposablesAll;
function createDisposablesSeries(logger, ...disposables) {
    return {
        dispose: (reason) => __awaiter(this, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.verbose(`createDisposablesSeries->dispose reason:${reason}`);
            for (let d of disposables) {
                try {
                    yield d.dispose(reason);
                }
                catch (err) {
                    logger === null || logger === void 0 ? void 0 : logger.error(`Failed to dispose`, err);
                }
            }
        })
    };
}
exports.createDisposablesSeries = createDisposablesSeries;
//# sourceMappingURL=dispose.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/errorToObject.js":
/*!***************************************************!*\
  !*** ../../utils/dist/src/utils/errorToObject.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorToObject = void 0;
const cleanupPII_1 = __webpack_require__(/*! ./cleanupPII */ "../../utils/dist/src/utils/cleanupPII.js");
/**
 * Create a plain object that represents an error.
 * Can be used to send the error to telemetry or
 * log it to the console.
 */
// TODO legomushroom - test this
const errorToObject = (error, isInternal = true) => {
    const vscsError = error;
    const { errorCode = -1, errorType = 'GenericError', message = '<no message>', originalErrorType = '<no original type>', } = vscsError;
    const stack = (isInternal)
        ? vscsError.stack
        : (0, cleanupPII_1.cleanupPII)(vscsError.stack);
    return {
        errorMessage: message,
        originalErrorType,
        errorCode,
        errorType,
        stack,
    };
};
exports.errorToObject = errorToObject;
//# sourceMappingURL=errorToObject.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/errorToString.js":
/*!***************************************************!*\
  !*** ../../utils/dist/src/utils/errorToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorToString = void 0;
const errorToObject_1 = __webpack_require__(/*! ./errorToObject */ "../../utils/dist/src/utils/errorToObject.js");
/**
 * Create a stringified object that represents an error.
 */
// TODO legomushroom - test this
const errorToString = (error, isInternal = false) => {
    return JSON.stringify((0, errorToObject_1.errorToObject)(error, isInternal), null, 2);
};
exports.errorToString = errorToString;
//# sourceMappingURL=errorToString.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/getPromiseState.js":
/*!*****************************************************!*\
  !*** ../../utils/dist/src/utils/getPromiseState.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPromiseState = void 0;
const components_1 = __webpack_require__(/*! ../components */ "../../utils/dist/src/components/index.js");
const wait_1 = __webpack_require__(/*! ./wait */ "../../utils/dist/src/utils/wait.js");
/**
 * Function to get promise state.
 */
const getPromiseState = (promise) => __awaiter(void 0, void 0, void 0, function* () {
    const resultSignal = new components_1.Signal();
    promise.then((data) => {
        resultSignal.resolve({
            isPending: false,
            error: null,
            data,
        });
        return data;
    }, (error) => {
        resultSignal.resolve({
            isPending: false,
            error,
        });
    });
    // make sure `then`/`catch` above had a chance to run
    yield (0, wait_1.wait)(1);
    // if `then`/`catch` didn't run, resolve as pending
    resultSignal.resolve({
        isPending: true,
        error: null,
    });
    return yield resultSignal.promise;
});
exports.getPromiseState = getPromiseState;
//# sourceMappingURL=getPromiseState.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/hashString.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/hashString.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashString = void 0;
/**
 * Generate a hash from a string.
 */
const hashString = (str) => {
    return str
        .split('')
        .reduce((a, b) => {
        a = (((a << 5) - a) + b).charCodeAt(0);
        return a & a;
    }, 0)
        .toString();
};
exports.hashString = hashString;
//# sourceMappingURL=hashString.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/idFunction.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/idFunction.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.idFunction = void 0;
/**
 * Identity function.
 */
// TODO legomushroom - test this
const idFunction = (...args) => {
    return args;
};
exports.idFunction = idFunction;
//# sourceMappingURL=idFunction.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/index.js":
/*!*******************************************!*\
  !*** ../../utils/dist/src/utils/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.propertiesToString = exports.propertiesToJSON = exports.crc32 = exports.toCamelCase = exports.promiseAny = exports.notImplemented = exports.errorToString = exports.errorToObject = exports.timeoutPromise = exports.createDisposable = exports.isThenable = exports.arrayUnique = exports.defer = exports.throttle = exports.debounce = exports.hashString = exports.randomBoolean = exports.randomString = exports.randomBytes = exports.randomItem = exports.randomInt = exports.CODESPACE_URL_PII_LABEL = exports.obfusticateCodespaceNames = exports.obfusticateEmailAddresses = exports.obfusticatePaths = exports.cleanupObjectValuesPII = exports.cleanupPII = exports.withMutexByArguments = exports.connectEvents = exports.withRetries = exports.idFunction = exports.getPromiseState = exports.continueWhen = exports.withCache = exports.raceAsync = exports.onlyOnce = exports.once = exports.wait = void 0;
// decorators
__exportStar(__webpack_require__(/*! ./decorators */ "../../utils/dist/src/utils/decorators/index.js"), exports);
// assertion utils
__exportStar(__webpack_require__(/*! ./asserts */ "../../utils/dist/src/utils/asserts/index.js"), exports);
// misc utils
var wait_1 = __webpack_require__(/*! ./wait */ "../../utils/dist/src/utils/wait.js");
Object.defineProperty(exports, "wait", ({ enumerable: true, get: function () { return wait_1.wait; } }));
var once_1 = __webpack_require__(/*! ./once */ "../../utils/dist/src/utils/once.js");
Object.defineProperty(exports, "once", ({ enumerable: true, get: function () { return once_1.once; } }));
var onlyOnce_1 = __webpack_require__(/*! ./onlyOnce */ "../../utils/dist/src/utils/onlyOnce.js");
Object.defineProperty(exports, "onlyOnce", ({ enumerable: true, get: function () { return onlyOnce_1.onlyOnce; } }));
var raceAsync_1 = __webpack_require__(/*! ./raceAsync */ "../../utils/dist/src/utils/raceAsync.js");
Object.defineProperty(exports, "raceAsync", ({ enumerable: true, get: function () { return raceAsync_1.raceAsync; } }));
var withCache_1 = __webpack_require__(/*! ./withCache */ "../../utils/dist/src/utils/withCache.js");
Object.defineProperty(exports, "withCache", ({ enumerable: true, get: function () { return withCache_1.withCache; } }));
var continueWhen_1 = __webpack_require__(/*! ./continueWhen */ "../../utils/dist/src/utils/continueWhen.js");
Object.defineProperty(exports, "continueWhen", ({ enumerable: true, get: function () { return continueWhen_1.continueWhen; } }));
var getPromiseState_1 = __webpack_require__(/*! ./getPromiseState */ "../../utils/dist/src/utils/getPromiseState.js");
Object.defineProperty(exports, "getPromiseState", ({ enumerable: true, get: function () { return getPromiseState_1.getPromiseState; } }));
var idFunction_1 = __webpack_require__(/*! ./idFunction */ "../../utils/dist/src/utils/idFunction.js");
Object.defineProperty(exports, "idFunction", ({ enumerable: true, get: function () { return idFunction_1.idFunction; } }));
var withRetries_1 = __webpack_require__(/*! ./withRetries */ "../../utils/dist/src/utils/withRetries.js");
Object.defineProperty(exports, "withRetries", ({ enumerable: true, get: function () { return withRetries_1.withRetries; } }));
var connectEvents_1 = __webpack_require__(/*! ./connectEvents */ "../../utils/dist/src/utils/connectEvents.js");
Object.defineProperty(exports, "connectEvents", ({ enumerable: true, get: function () { return connectEvents_1.connectEvents; } }));
var withMutexByArguments_1 = __webpack_require__(/*! ./withMutexByArguments */ "../../utils/dist/src/utils/withMutexByArguments.js");
Object.defineProperty(exports, "withMutexByArguments", ({ enumerable: true, get: function () { return withMutexByArguments_1.withMutexByArguments; } }));
var cleanupPII_1 = __webpack_require__(/*! ./cleanupPII */ "../../utils/dist/src/utils/cleanupPII.js");
Object.defineProperty(exports, "cleanupPII", ({ enumerable: true, get: function () { return cleanupPII_1.cleanupPII; } }));
Object.defineProperty(exports, "cleanupObjectValuesPII", ({ enumerable: true, get: function () { return cleanupPII_1.cleanupObjectValuesPII; } }));
Object.defineProperty(exports, "obfusticatePaths", ({ enumerable: true, get: function () { return cleanupPII_1.obfusticatePaths; } }));
Object.defineProperty(exports, "obfusticateEmailAddresses", ({ enumerable: true, get: function () { return cleanupPII_1.obfusticateEmailAddresses; } }));
Object.defineProperty(exports, "obfusticateCodespaceNames", ({ enumerable: true, get: function () { return cleanupPII_1.obfusticateCodespaceNames; } }));
Object.defineProperty(exports, "CODESPACE_URL_PII_LABEL", ({ enumerable: true, get: function () { return cleanupPII_1.CODESPACE_URL_PII_LABEL; } }));
var randomInt_1 = __webpack_require__(/*! ./randomInt */ "../../utils/dist/src/utils/randomInt.js");
Object.defineProperty(exports, "randomInt", ({ enumerable: true, get: function () { return randomInt_1.randomInt; } }));
var randomItem_1 = __webpack_require__(/*! ./randomItem */ "../../utils/dist/src/utils/randomItem.js");
Object.defineProperty(exports, "randomItem", ({ enumerable: true, get: function () { return randomItem_1.randomItem; } }));
var randomBytes_1 = __webpack_require__(/*! ./randomBytes */ "../../utils/dist/src/utils/randomBytes.js");
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return randomBytes_1.randomBytes; } }));
var randomString_1 = __webpack_require__(/*! ./randomString */ "../../utils/dist/src/utils/randomString.js");
Object.defineProperty(exports, "randomString", ({ enumerable: true, get: function () { return randomString_1.randomString; } }));
var randomBoolean_1 = __webpack_require__(/*! ./randomBoolean */ "../../utils/dist/src/utils/randomBoolean.js");
Object.defineProperty(exports, "randomBoolean", ({ enumerable: true, get: function () { return randomBoolean_1.randomBoolean; } }));
var hashString_1 = __webpack_require__(/*! ./hashString */ "../../utils/dist/src/utils/hashString.js");
Object.defineProperty(exports, "hashString", ({ enumerable: true, get: function () { return hashString_1.hashString; } }));
var debounce_1 = __webpack_require__(/*! ./debounce */ "../../utils/dist/src/utils/debounce.js");
Object.defineProperty(exports, "debounce", ({ enumerable: true, get: function () { return debounce_1.debounce; } }));
var throttle_1 = __webpack_require__(/*! ./throttle */ "../../utils/dist/src/utils/throttle.js");
Object.defineProperty(exports, "throttle", ({ enumerable: true, get: function () { return throttle_1.throttle; } }));
var defer_1 = __webpack_require__(/*! ./defer */ "../../utils/dist/src/utils/defer.js");
Object.defineProperty(exports, "defer", ({ enumerable: true, get: function () { return defer_1.defer; } }));
var arrayUnique_1 = __webpack_require__(/*! ./arrayUnique */ "../../utils/dist/src/utils/arrayUnique.js");
Object.defineProperty(exports, "arrayUnique", ({ enumerable: true, get: function () { return arrayUnique_1.arrayUnique; } }));
var isThenable_1 = __webpack_require__(/*! ./isThenable */ "../../utils/dist/src/utils/isThenable.js");
Object.defineProperty(exports, "isThenable", ({ enumerable: true, get: function () { return isThenable_1.isThenable; } }));
var createDisposable_1 = __webpack_require__(/*! ./createDisposable */ "../../utils/dist/src/utils/createDisposable.js");
Object.defineProperty(exports, "createDisposable", ({ enumerable: true, get: function () { return createDisposable_1.createDisposable; } }));
var timeoutPromise_1 = __webpack_require__(/*! ./timeoutPromise */ "../../utils/dist/src/utils/timeoutPromise.js");
Object.defineProperty(exports, "timeoutPromise", ({ enumerable: true, get: function () { return timeoutPromise_1.timeoutPromise; } }));
var errorToObject_1 = __webpack_require__(/*! ./errorToObject */ "../../utils/dist/src/utils/errorToObject.js");
Object.defineProperty(exports, "errorToObject", ({ enumerable: true, get: function () { return errorToObject_1.errorToObject; } }));
var errorToString_1 = __webpack_require__(/*! ./errorToString */ "../../utils/dist/src/utils/errorToString.js");
Object.defineProperty(exports, "errorToString", ({ enumerable: true, get: function () { return errorToString_1.errorToString; } }));
var notImplemented_1 = __webpack_require__(/*! ./notImplemented */ "../../utils/dist/src/utils/notImplemented.js");
Object.defineProperty(exports, "notImplemented", ({ enumerable: true, get: function () { return notImplemented_1.notImplemented; } }));
var promiseAny_1 = __webpack_require__(/*! ./promiseAny */ "../../utils/dist/src/utils/promiseAny.js");
Object.defineProperty(exports, "promiseAny", ({ enumerable: true, get: function () { return promiseAny_1.promiseAny; } }));
var toCamelCase_1 = __webpack_require__(/*! ./toCamelCase */ "../../utils/dist/src/utils/toCamelCase.js");
Object.defineProperty(exports, "toCamelCase", ({ enumerable: true, get: function () { return toCamelCase_1.toCamelCase; } }));
var crc32_1 = __webpack_require__(/*! ./crc32 */ "../../utils/dist/src/utils/crc32.js");
Object.defineProperty(exports, "crc32", ({ enumerable: true, get: function () { return crc32_1.crc32; } }));
__exportStar(__webpack_require__(/*! ./dispose */ "../../utils/dist/src/utils/dispose.js"), exports);
// TODO legomushroom - cleanup?
function propertiesToJSON(o) {
    if (o) {
        return JSON.stringify(o, Object.getOwnPropertyNames(o));
    }
}
exports.propertiesToJSON = propertiesToJSON;
function propertiesToString(o) {
    var _a;
    return `type:${(_a = o === null || o === void 0 ? void 0 : o.constructor) === null || _a === void 0 ? void 0 : _a.name} props:${propertiesToJSON(o)}`;
}
exports.propertiesToString = propertiesToString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/isThenable.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/isThenable.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isThenable = void 0;
/**
 * Check if `val` is thenable or promiseLike.
 */
const isThenable = (val) => {
    if (val == null) {
        return false;
    }
    if (typeof val.then !== 'function') {
        return false;
    }
    return true;
};
exports.isThenable = isThenable;
//# sourceMappingURL=isThenable.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/notImplemented.js":
/*!****************************************************!*\
  !*** ../../utils/dist/src/utils/notImplemented.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = void 0;
function notImplemented() {
    throw new Error('Method not implemented.');
}
exports.notImplemented = notImplemented;
;
//# sourceMappingURL=notImplemented.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/once.js":
/*!******************************************!*\
  !*** ../../utils/dist/src/utils/once.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.once = void 0;
/**
 * Function to wrap any function (let say `fun`) with the wrapper that will
 * ensure that the `fun` will be called only once. The wrapper will cache
 * the first return value of the `fun` and return it immediately on any
 * subsequent calls.
 */
const once = (fun, thisArg) => {
    const invocationSymbol = Symbol();
    let result;
    function onceFunction(...args) {
        if (fun[invocationSymbol]) {
            return result;
        }
        fun[invocationSymbol] = true;
        result = fun.call(thisArg !== null && thisArg !== void 0 ? thisArg : this, ...args);
        return result;
    }
    ;
    return onceFunction;
};
exports.once = once;
//# sourceMappingURL=once.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/onlyOnce.js":
/*!**********************************************!*\
  !*** ../../utils/dist/src/utils/onlyOnce.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onlyOnce = void 0;
function onlyOnce(fun, ...defaultParams) {
    const invocationSymbol = Symbol();
    let recursionCount = 0;
    let firstParams;
    let firstResult;
    return function (...params) {
        if (params.length === 0) {
            params = defaultParams;
        }
        if (!fun[invocationSymbol]) {
            recursionCount++;
            let result;
            try {
                result = fun(...params);
                if (recursionCount > 1) {
                    return result;
                }
            }
            finally {
                recursionCount--;
            }
            // Set the flag after we have called the function and got the result to allow recursion for the first invocation
            fun[invocationSymbol] = true;
            firstParams = params;
            firstResult = result;
        }
        else if (!parametersEqual(firstParams, params)) {
            throw new Error(`Parameters must be the same as in the first call of ${onlyOnce.name}(${fun.name}).`);
        }
        return firstResult;
    };
}
exports.onlyOnce = onlyOnce;
;
/** Check if two parameter arrays match.
 *
 * This check only uses === to compare the elements, so they must be of primitive type only.
 * If one array is larger than the other, the extra elements must be all undefined.
 */
function parametersEqual(a1, a2) {
    if (!Array.isArray(a1) || !Array.isArray(a2)) {
        return false;
    }
    if (a1 === a2) {
        return true;
    }
    const l = Math.min(a1.length, a2.length);
    for (var i = 0; i < l; i++) {
        if (a1[i] !== a2[i]) {
            return false;
        }
    }
    const a = a1.length > l ? a1 : a2;
    for (var i = l; i < a.length; i++) {
        if (a[i] !== undefined) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=onlyOnce.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/promiseAny.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/promiseAny.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.promiseAny = void 0;
const promiseAny = (iterable) => __awaiter(void 0, void 0, void 0, function* () {
    return Promise.all([...iterable].map(promise => {
        return new Promise((resolve, reject) => Promise.resolve(promise).then(reject, resolve));
    })).then(errors => Promise.reject(errors), value => Promise.resolve(value));
});
exports.promiseAny = promiseAny;
//# sourceMappingURL=promiseAny.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/raceAsync.js":
/*!***********************************************!*\
  !*** ../../utils/dist/src/utils/raceAsync.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.raceAsync = void 0;
const components_1 = __webpack_require__(/*! ../components */ "../../utils/dist/src/components/index.js");
const PromiseRaceError_1 = __webpack_require__(/*! ../errors/PromiseRaceError */ "../../utils/dist/src/errors/PromiseRaceError.js");
/**
 * Method to wait on first promise resolve or all promises rejected.
 * If a single promise resolves, the function with resolve with its result.
 * If all promises have rejected, then the function rejects with the last
 * rejection error and the `PromiseRaceError` will have all the rejected
 * errors in the order of rejection.
 */
const raceAsync = (promises) => {
    const signal = new components_1.Signal();
    const errors = [];
    let cnt = promises.length;
    promises.forEach((promise) => {
        promise
            .then((value) => {
            signal.resolve(value);
        })
            .catch((error) => {
            cnt--;
            errors.push(error);
            if (cnt === 0) {
                signal.reject(new PromiseRaceError_1.PromiseRaceError(errors, error));
            }
        });
    });
    return signal.promise;
};
exports.raceAsync = raceAsync;
//# sourceMappingURL=raceAsync.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/randomBoolean.js":
/*!***************************************************!*\
  !*** ../../utils/dist/src/utils/randomBoolean.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBoolean = void 0;
const randomInt_1 = __webpack_require__(/*! ./randomInt */ "../../utils/dist/src/utils/randomInt.js");
/**
 * Return a random boolean.
 */
const randomBoolean = () => {
    return ((0, randomInt_1.randomInt)(1) === 1);
};
exports.randomBoolean = randomBoolean;
//# sourceMappingURL=randomBoolean.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/randomBytes.js":
/*!*************************************************!*\
  !*** ../../utils/dist/src/utils/randomBytes.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = void 0;
const randombytes_1 = __importDefault(__webpack_require__(/*! randombytes */ "../../node_modules/randombytes/index.js"));
/**
 * Safe random bytes utility, depends on crypto API which
 * should be polyfilled for NodeJS.
 */
const randomBytes = (length) => {
    return (0, randombytes_1.default)(length);
};
exports.randomBytes = randomBytes;
//# sourceMappingURL=randomBytes.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/randomInt.js":
/*!***********************************************!*\
  !*** ../../utils/dist/src/utils/randomInt.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomInt = void 0;
const assert_1 = __webpack_require__(/*! ./asserts/assert */ "../../utils/dist/src/utils/asserts/assert.js");
/**
 * Function to get a random integer from a defined range.
 */
const randomInt = (max, min = 0) => {
    (0, assert_1.assert)(!isNaN(min), '"min" param is not a number.');
    (0, assert_1.assert)(!isNaN(max), '"max" param is not a number.');
    (0, assert_1.assert)(isFinite(max), '"max" param is not finite.');
    (0, assert_1.assert)(isFinite(min), '"min" param is not finite.');
    (0, assert_1.assert)(max > min, `"max"(${max}) param should be greater than "min"(${min}).`);
    const delta = max - min;
    const randomFloat = delta * Math.random();
    return Math.round(min + randomFloat);
};
exports.randomInt = randomInt;
//# sourceMappingURL=randomInt.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/randomItem.js":
/*!************************************************!*\
  !*** ../../utils/dist/src/utils/randomItem.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomItem = void 0;
const randomInt_1 = __webpack_require__(/*! ./randomInt */ "../../utils/dist/src/utils/randomInt.js");
/**
 * Function to return a random item from an array.
 */
const randomItem = (items) => {
    const max = items.length;
    const randomIndex = (0, randomInt_1.randomInt)(max - 1);
    return items[randomIndex];
};
exports.randomItem = randomItem;
//# sourceMappingURL=randomItem.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/randomString.js":
/*!**************************************************!*\
  !*** ../../utils/dist/src/utils/randomString.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomString = void 0;
const randomBytes_1 = __webpack_require__(/*! ./randomBytes */ "../../utils/dist/src/utils/randomBytes.js");
/**
 * Generate random string (`hex` by default) using `length` bytes.
 */
const randomString = (length = 16, encoding = 'hex') => {
    const randomBuffer = (0, randomBytes_1.randomBytes)(length);
    return randomBuffer.toString(encoding);
};
exports.randomString = randomString;
//# sourceMappingURL=randomString.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/throttle.js":
/*!**********************************************!*\
  !*** ../../utils/dist/src/utils/throttle.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throttle = void 0;
;
/**
 * Function that throttles a function invocation to
 * at most one per every `interval` milliseconds.
 */
function throttle(fn, options) {
    let lockInterval;
    // wrap the original function
    return function throttledFunction(...args) {
        /**
         * If still locked, return immediatelly.
         */
        if (lockInterval) {
            return;
        }
        /**
         * If not locked, invoke the original function and
         * lock so no invocation
         */
        const { interval } = options;
        lockInterval = setTimeout(() => {
            if (lockInterval) {
                clearInterval(lockInterval);
                lockInterval = undefined;
            }
        }, interval);
        /**
         * Run the original function and return the result.
         */
        return fn.call(this, ...args);
    };
}
exports.throttle = throttle;
;
//# sourceMappingURL=throttle.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/timeoutPromise.js":
/*!****************************************************!*\
  !*** ../../utils/dist/src/utils/timeoutPromise.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeoutPromise = void 0;
const CancellationError_1 = __webpack_require__(/*! ../errors/CancellationError */ "../../utils/dist/src/errors/CancellationError.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../utils/dist/src/errors/index.js");
const getRejectionError = (timeout, error) => {
    if (error === undefined) {
        return new errors_1.TimeoutCancellationError(`Promise rejected after ${timeout}ms`);
    }
    if (typeof error === 'string') {
        return new errors_1.TimeoutCancellationError(error);
    }
    if (error instanceof Error) {
        return error;
    }
};
const timeoutPromise = (promise, timeout, error, promiseCancellationSource) => __awaiter(void 0, void 0, void 0, function* () {
    let timeoutReference;
    let ctsDisposable;
    const dispose = () => {
        ctsDisposable === null || ctsDisposable === void 0 ? void 0 : ctsDisposable.dispose();
        clearTimeout(timeoutReference);
    };
    const result = yield Promise.race([
        /**
         * Original promise.
         */
        // promise,
        promise.finally(() => {
            dispose();
        }),
        /**
         * Timeout promise.
         */
        new Promise((_, reject) => {
            var _a;
            ctsDisposable = (_a = promiseCancellationSource === null || promiseCancellationSource === void 0 ? void 0 : promiseCancellationSource.token) === null || _a === void 0 ? void 0 : _a.onCancellationRequested(() => {
                dispose();
                reject(new CancellationError_1.CancellationError());
            });
            timeoutReference = setTimeout(() => {
                dispose();
                reject(getRejectionError(timeout, error));
            }, timeout);
        }),
    ]);
    return result;
});
exports.timeoutPromise = timeoutPromise;
//# sourceMappingURL=timeoutPromise.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/toCamelCase.js":
/*!*************************************************!*\
  !*** ../../utils/dist/src/utils/toCamelCase.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCamelCase = void 0;
function toCamelCase(str) {
    if (str && str.length > 0) {
        return str.substring(0, 1).toLowerCase() + str.substring(1);
    }
    return str;
}
exports.toCamelCase = toCamelCase;
//# sourceMappingURL=toCamelCase.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/wait.js":
/*!******************************************!*\
  !*** ../../utils/dist/src/utils/wait.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wait = void 0;
/**
 * Wait on `delay` milliseconds asynronously before proceeding.
 */
const wait = (delay) => {
    return new Promise((resolve) => {
        setTimeout(resolve, delay);
    });
};
exports.wait = wait;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/withCache.js":
/*!***********************************************!*\
  !*** ../../utils/dist/src/utils/withCache.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withCache = void 0;
const assertDefined_1 = __webpack_require__(/*! ./asserts/assertDefined */ "../../utils/dist/src/utils/asserts/assertDefined.js");
const Signal_1 = __webpack_require__(/*! ../components/Signal */ "../../utils/dist/src/components/Signal.js");
const defer_1 = __webpack_require__(/*! ./defer */ "../../utils/dist/src/utils/defer.js");
/**
 * Utility to run an asynchronous function and reuse
 * the currently running version of it, if present.
 */
const withCache = (fn) => {
    let runningSignal;
    const res = (...args) => __awaiter(void 0, void 0, void 0, function* () {
        if (runningSignal && !runningSignal.isFulfilled) {
            return yield runningSignal.promise;
        }
        runningSignal = new Signal_1.Signal();
        /**
         * Defer function execution so we can return the signal promise
         * that will resolve to the result of the original function.
         */
        (0, defer_1.defer)(() => __awaiter(void 0, void 0, void 0, function* () {
            (0, assertDefined_1.assertDefined)(runningSignal, 'No running signal is defined.');
            try {
                const result = yield fn(...args);
                runningSignal.resolve(result);
            }
            catch (e) {
                runningSignal.reject(e);
            }
        }), 1);
        return yield runningSignal.promise;
    });
    return res;
};
exports.withCache = withCache;
//# sourceMappingURL=withCache.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/withMutexByArguments.js":
/*!**********************************************************!*\
  !*** ../../utils/dist/src/utils/withMutexByArguments.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withMutexByArguments = void 0;
const Signal_1 = __webpack_require__(/*! ../components/Signal */ "../../utils/dist/src/components/Signal.js");
const hashString_1 = __webpack_require__(/*! ./hashString */ "../../utils/dist/src/utils/hashString.js");
const defer_1 = __webpack_require__(/*! ./defer */ "../../utils/dist/src/utils/defer.js");
/**
 * Given a list of arguments, return a serialized
 * string (id) for the arguments list.
 */
const serializeArgs = (...args) => {
    const hashedArgs = args.map((str) => {
        return (0, hashString_1.hashString)(`${str}`);
    });
    return hashedArgs.join('::');
};
;
/**
 * Default arguments for the `withMutexByArguments` helper.
 */
const DEFAULT_OPTIONS = {
    serializeArguments: serializeArgs,
};
/**
 * Utility to run an asynchronous function and reuse the currently
 * running instance of it, based on the arguments list. To work
 * correctly all the arguments should be serializable to string,
 * as they will be used as an `id` for each invocation instance.
 *
 * Any prior invocation result is ignored, e.g. we reuse only currently
 * running function instances, ignoring any previously finished ones.
 */
const withMutexByArguments = (fn, options = DEFAULT_OPTIONS) => {
    // the map that holds current running signals for the function invocations.
    const mutextMap = new Map();
    // result function
    const result = (...args) => __awaiter(void 0, void 0, void 0, function* () {
        const { serializeArguments = serializeArgs } = options;
        const id = serializeArguments(...args);
        const runningSignal = mutextMap.get(id);
        if (runningSignal && !runningSignal.isFulfilled) {
            return yield runningSignal.promise;
        }
        const newRunningSignal = new Signal_1.Signal();
        mutextMap.set(id, newRunningSignal);
        /**
         * Defer function execution so we can return the signal promise
         * that will resolve to the result of the original function.
         */
        (0, defer_1.defer)(() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const result = yield fn(...args);
                newRunningSignal.resolve(result);
            }
            catch (e) {
                newRunningSignal.reject(e);
            }
            finally {
                mutextMap.delete(id);
            }
        }), 1);
        return yield newRunningSignal.promise;
    });
    return result;
};
exports.withMutexByArguments = withMutexByArguments;
//# sourceMappingURL=withMutexByArguments.js.map

/***/ }),

/***/ "../../utils/dist/src/utils/withRetries.js":
/*!*************************************************!*\
  !*** ../../utils/dist/src/utils/withRetries.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withRetries = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "../../utils/dist/src/errors/index.js");
const assert_1 = __webpack_require__(/*! ./asserts/assert */ "../../utils/dist/src/utils/asserts/assert.js");
const wait_1 = __webpack_require__(/*! ./wait */ "../../utils/dist/src/utils/wait.js");
/**
 * Function to throw either the `AggregateError`, or,
 * if the `isThrowLastError` is `true`, the last error
 * in the aggregate error list.
 */
const throwAggregateError = (error, isThrowLastError) => {
    if (isThrowLastError) {
        throw error.lastError;
    }
    throw error;
};
/**
 * Defaults.
 */
const WITH_RETRIES_DEFAULTS = {
    // 1 call + 2 retries = 3 calls total
    retries: 2,
    // no delay by default
    retryDelay: 0,
    // no-op `shouldStopRetries` callback
    shouldStopRetries: () => { return false; },
    // should throw the last error instead of `AggregateError`
    isAggregateError: true,
};
/**
 * Utility to run an asynchronous function with a number of retries.
 * Can be used as a polling helper if the `retryDelay` is specified.
 *
 * Throws `AggregateError` with all the thrown `errors` that we risen
 * during the retry attempts. The `last` property of the `AggregateError`
 * is the last throw error in the sequence.
 *
 * - Returns the return value of the last `fn` call. If the last `fn` call
 *   throws, the `AggregateError` is thrown.
 *
 * - Throw `CancellationError` inside the `fn` callback to cancel the retries.
 *
 * - If the `CancellationToken` is passed and cancellation is requested,
 *   the `AggregateError` is thrown, with the `CancellationError` error
 *   as the last in the list.
 *
 * - `shouldStopRetries`, optional callback meant for implementing an early bail-out
 *   from the retry loop. It receives an `error` from the last failed retry attempt
 *   and should return a `boolean` indicating if we should stop the retry loop.
 *   Helpful for the cases when the error thrown is known to be fatal, so doesn't
 *   make sense to continue the remaining retries.
 */
const withRetries = (fn, opts = {}, aggregateError = new errors_1.AggregateError()) => __awaiter(void 0, void 0, void 0, function* () {
    /**
     * Extend the options with defaults.
     */
    const options = Object.assign(Object.assign({}, WITH_RETRIES_DEFAULTS), opts);
    const { retries, retryDelay, shouldStopRetries, cancellationToken, isAggregateError, } = options;
    /**
     * Make sure a number of retries left. In theory should never
     * go in this case, unless wrong `retries` option was passed.
     *
     * Throwing the `AggregateError` with a single `AssertionError`
     * for consistency.
     */
    const assertionError = new errors_1.AssertionError('Retries should have at least zero retries.');
    /**
     * If `isAggregateError` option set, throw the error itself,
     * to be consistent with the logic inside the catch block.
     */
    (0, assert_1.assert)(retries > -1, (!isAggregateError)
        ? assertionError
        : aggregateError.cloneWithErrors(assertionError));
    try {
        /**
         * Check that the cancellation is not requested yet on the `CancellationToken`.
         */
        (0, assert_1.assert)(!(cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.isCancellationRequested), new errors_1.CancellationError('CancellationToken is cancelled.'));
        /**
         * Invoke the main procedure callback.
         */
        return yield fn(retries);
    }
    catch (e) {
        /**
         * If the invocation fails, add the error to the aggregate
         * error list.
         */
        aggregateError.addErrors(e);
        /**
         * Check if we should stop retrying premarturely.
         * Helpful in the cases hwen the error throw is indicative of a
         * fatal failure, hence does not make sence to retry anymore.
         *
         * The `shouldStopRetries` is awaited, to enable optional delays
         * in the callback, e.g. if the error is of known type, a delay
         * can be applied for that specific error kind.
         */
        const isStop = yield shouldStopRetries(e);
        if (isStop) {
            return throwAggregateError(aggregateError, !isAggregateError);
        }
        /**
         * If cancelled inside the callback, stop retrying.
         */
        if (e instanceof errors_1.CancellationError) {
            return throwAggregateError(aggregateError, !isAggregateError);
        }
        /**
         * Check that the cancellation is not requested yet on the `CancellationToken`.
         */
        const cancellationError = new errors_1.CancellationError('CancellationToken is cancelled after retry.');
        (0, assert_1.assert)(!(cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.isCancellationRequested), 
        /**
         * Throw either `AggregateError` with the `CancellationError` at the end,
         * or the `CancellationError` itself (if the `isAggregateError` is set).
         */
        (!isAggregateError)
            ? cancellationError
            : aggregateError.cloneWithErrors(cancellationError));
        /**
         * If retries left, call the same function recursively.
         */
        if (retries > 0) {
            /**
             * Wait for `retryDelay`ms before making another retry.
             */
            yield (0, wait_1.wait)(retryDelay);
            /**
             * Retry, decrementing the retries count.
             */
            return yield (0, exports.withRetries)(fn, Object.assign(Object.assign({}, options), { retries: retries - 1 }), aggregateError);
        }
        /**
         * No retries, throw the result error.
         * - by default, throw the  aggregate error that contains
         *   the list of all errors thrown during the retries.
         * - if `isAggregateError` set to `false`, throw the last
         *  error in the list.
         */
        return throwAggregateError(aggregateError, !isAggregateError);
    }
});
exports.withRetries = withRetries;
//# sourceMappingURL=withRetries.js.map

/***/ }),

/***/ "../../vsls-contracts/dist/src/contracts/VSLS.js":
/*!*******************************************************!*\
  !*** ../../vsls-contracts/dist/src/contracts/VSLS.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v9.10.19.0 (Newtonsoft.Json v13.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerSharingFailedEventArgs = exports.ServerSharingSucceededEventArgs = exports.TunnelType = exports.ChangeKind = exports.ServerSharingChangedEventArgs = exports.PipeSharingStoppedEventArgs = exports.ServerSharingStoppedEventArgs = exports.PipeSharingStartedEventArgs = exports.ServerSharingStartedEventArgs = exports.SharedPipe = exports.SharedServer = exports.PrivacyEnum = exports.LiveShareSessionState = exports.FirewallStatus = exports.ClientVersionInfo = exports.AgentVersionInfo = exports.AddressAndMask = exports.CommentThreadLocation = exports.CommentThreadChangedEventArgs = exports.CommentThread = exports.Comment = exports.CommentThreadContext = exports.CommentThreadStatus = exports.Position = exports.MessageReceivedEventArgs = exports.ChatMessage = exports.ChatMessageBody = exports.ChatParticipant = exports.ChatMessageType = exports.BrokerEventArgs = exports.BrokerManifest = exports.AuthenticatedUserInfo = exports.AuthenticationChangedEventArgs = exports.AuthenticationOptions = exports.RecentCollaborator = exports.UserAccountStatus = exports.UserInfo = exports.UserAccountInfo = exports.AuthenticationToken = exports.AgentSessionResponse = exports.AgentSessionRequest = exports.AgentTraceEventArgs = exports.EventArgs = exports.FeatureFlagStore = exports.SeekOrigin = exports.AccessControl = exports.MaybeImmutableOfAccessControl = exports.FileServiceRootConfiguration = exports.FileServiceRootDirectoryConfiguration = exports.RemoteStreamMoniker = void 0;
exports.WorkspaceSessionInfo = exports.WorkspaceListOptions = exports.WorkspaceJoinInfo = exports.ClientCapabilities = exports.ConnectionMode = exports.WorkspaceShareInfo = exports.WorkspaceProgressEventArgs = exports.WorkspaceProgress = exports.WorkspaceReadyForConnectionEventArgs = exports.WorkspaceConnectionStatusChangedEventArgs = exports.WorkspaceDisconnectedReason = exports.WorkspaceConnectionStatus = exports.WorkspaceInfo = exports.InvitationLinkInfo = exports.DiagnosticDataChangedEventArgs = exports.DiagnosticEntry = exports.ErrorSeverity = exports.RestrictedOperationAccessRequestedEventArgs = exports.WorkspaceAccessControlEventArgs = exports.WorkspaceAccessControl = exports.MaybeImmutableOfWorkspaceAccessControl = exports.SharedTerminalRestrictedOperation = exports.RestrictedOperation = exports.TerminalEventArgs = exports.TerminalInfo = exports.TerminalOptions = exports.FaultTelemetryEventArgs = exports.TelemetryResult = exports.GenericOperationEventArgs = exports.TelemetrySettings = exports.TaskOutputEventArgs = exports.TaskOutputInfo = exports.TaskOutputOptions = exports.TaskOutputFeedInfo = exports.TaskOutputContentType = exports.SyncStatus = exports.SourceControlResourceChangedEventArgs = exports.SourceControlChangedEventArgs = exports.SourceControlChange = exports.SourceControlResourceDiff = exports.SourceControlInstance = exports.SourceControlResourceGroup = exports.SourceControlResourceIdentifier = exports.SourceControlResourceState = exports.SourceControlResource = exports.SourceControlChangeType = exports.SourceControlResourceType = exports.SourceControlVersion = exports.SourceControlIdentifier = exports.SessionUpdateEventArgs = void 0;
exports.LanguageServerProviderMetadata = exports.DocumentFilter = exports.CoeditingInformation = exports.DocumentChangesNotificationFlags = exports.PingMessage = exports.SummonMessage = exports.FileOpenAcknowledgeMessage = exports.ServerVersionSnapshot = exports.ProjectFileClosedMessage = exports.ProjectFileOpenedMessage = exports.ReadOnlyChangeMessage = exports.TextChangeMessage = exports.AnonymousAcccessLevelChangedMessage = exports.FileReleaseMessage = exports.SaveNotebookMessage = exports.SaveFileMessage = exports.HandshakeMessage = exports.DiffViewClosedMessage = exports.DiffViewOpenMessage = exports.DiffViewMessage = exports.UntitledFileClosedMessage = exports.UntitledFileOpenedMessage = exports.UntitledFileSavedMessage = exports.ResetFileClientMessage = exports.FileOpenRequestMessage = exports.VisibleRangesChangeMessage = exports.EditorVisibleRanges = exports.NotebookScrollMessage = exports.LayoutScrollMessage = exports.Range = exports.NotebookSelectionChangeMessage = exports.SelectionChangeMessage = exports.FollowChangeMessage = exports.PresenterUpdateMessage = exports.JoinAcknowledgeMessage = exports.JoinRequestMessage = exports.FileMessageBase = exports.MessageType = exports.MessageBase = exports.TextChange = exports.VSOnlineSettings = exports.UserSettings = exports.PolicySettings = exports.GroupPolicySettings = exports.WorkspaceSessionChangedEventArgs = exports.WorkspaceSessionChangeType = exports.GuestAcceptance = exports.CollectionChangeType = exports.WorkspaceServicesChangedEventArgs = exports.WorkspaceUserProfile = void 0;
exports.TraceEventIds = exports.ErrorCodes = exports.WorkspaceTaskRestrictedOperation = exports.RunTaskResult = exports.RunTaskStatus = exports.TaskExecutionStatusEventArgs = exports.TaskExecutionStatusChange = exports.TaskExecutionMoniker = exports.WorkspaceTask = exports.TaskScope = exports.StreamTraits = exports.SourceEventArgs = exports.SolutionChangeType = exports.WorkspaceMode = exports.WorkspaceRootChangedEventArgs = exports.SolutionChangedEventArgs = exports.SolutionWorkspaceNode = exports.NodeType = exports.TextSearchOptions = exports.ReadTextResult = exports.TextSearchResult = exports.TextSearchResultRange = exports.ExternalFileMapResult = exports.DiffBaseInfo = exports.RootsChangedEventArgs = exports.ExternalFilesChangedEventArgs = exports.FilesChangedEventArgs = exports.FileChangeType = exports.FileChange = exports.FileWatchOptions = exports.FileDeleteOptions = exports.FileMoveOptions = exports.FileWriteOptions = exports.FileReadOptions = exports.FileTextInfo = exports.FileRootInfo = exports.FileInfo = exports.FileAttributes = exports.FileRecurseMode = exports.FileListOptions = exports.RestrictedOperationAccessEventArgs = exports.RestrictedOperationAccess = exports.AccessControlEventArgs = exports.ContinueReason = exports.LaunchConfigurationChangedEventArgs = exports.DebugSessionChangedEventArgs = exports.DebugSessionChangeType = exports.DebugSession = exports.LspMessage = exports.NotificationEventArgs = void 0;
exports.WorkspaceTaskService = exports.StreamService = exports.StreamManagerService = exports.SourceEventService = exports.SolutionViewService = exports.FileService = exports.AccessControlService = exports.DebuggerHostService = exports.LanguageServerProvider = exports.WorkspaceUserService = exports.WorkspaceService = exports.WorkspaceDiagnosticsService = exports.WorkspaceAccessControlService = exports.TextSearchService = exports.TerminalService = exports.TerminalEndpoint = exports.TelemetryService = exports.TaskOutputService = exports.SyncService = exports.SourceControlService = exports.SessionContextService = exports.ServerSidePolicyService = exports.ServerSharingService = exports.PortForwardingService = exports.OnlineEnvironmentSessionService = exports.FirewallService = exports.ConfigurationService = exports.CommentService = exports.ChatService = exports.BrokerManagerService = exports.BrokerAuthorizationService = exports.AuthenticationService = exports.AuthenticationCoreService = exports.AgentSessionService = exports.TraceSources = void 0;
/** Describes the kind of data to be formatted. */
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
/** Represents a data object containing attributes needed to access a remote stream. */
class RemoteStreamMoniker {
}
exports.RemoteStreamMoniker = RemoteStreamMoniker;
/** File service root directory configuration. */
class FileServiceRootDirectoryConfiguration {
}
exports.FileServiceRootDirectoryConfiguration = FileServiceRootDirectoryConfiguration;
/** File service root configuration. */
class FileServiceRootConfiguration {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(FileServiceRootDirectoryConfiguration),
    __metadata("design:type", Array)
], FileServiceRootConfiguration.prototype, "directories", void 0);
exports.FileServiceRootConfiguration = FileServiceRootConfiguration;
class MaybeImmutableOfAccessControl {
}
exports.MaybeImmutableOfAccessControl = MaybeImmutableOfAccessControl;
/** Access control */
class AccessControl extends MaybeImmutableOfAccessControl {
}
exports.AccessControl = AccessControl;
var SeekOrigin;
(function (SeekOrigin) {
    SeekOrigin[SeekOrigin["Begin"] = 'begin'] = "Begin";
    SeekOrigin[SeekOrigin["Current"] = 'current'] = "Current";
    SeekOrigin[SeekOrigin["End"] = 'end'] = "End";
})(SeekOrigin = exports.SeekOrigin || (exports.SeekOrigin = {}));
class FeatureFlagStore {
}
exports.FeatureFlagStore = FeatureFlagStore;
class EventArgs {
}
exports.EventArgs = EventArgs;
class AgentTraceEventArgs extends EventArgs {
}
exports.AgentTraceEventArgs = AgentTraceEventArgs;
class AgentSessionRequest {
}
exports.AgentSessionRequest = AgentSessionRequest;
class AgentSessionResponse {
}
exports.AgentSessionResponse = AgentSessionResponse;
class AuthenticationToken {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], AuthenticationToken.prototype, "token", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], AuthenticationToken.prototype, "code", void 0);
exports.AuthenticationToken = AuthenticationToken;
/** UserAccountInfo represents the minimum information we require in order to retrieve cached credentials in a machine. It purposefully doesn't include the User's Id, as that is unknown at the time of retrieval. */
class UserAccountInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], UserAccountInfo.prototype, "accountId", void 0);
exports.UserAccountInfo = UserAccountInfo;
class UserInfo extends UserAccountInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], UserInfo.prototype, "id", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], UserInfo.prototype, "displayName", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Email),
    __metadata("design:type", String)
], UserInfo.prototype, "emailAddress", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], UserInfo.prototype, "userName", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Uri),
    __metadata("design:type", String)
], UserInfo.prototype, "avatarUri", void 0);
exports.UserInfo = UserInfo;
var UserAccountStatus;
(function (UserAccountStatus) {
    UserAccountStatus[UserAccountStatus["Unknown"] = 'unknown'] = "Unknown";
    UserAccountStatus[UserAccountStatus["Transient"] = 'transient'] = "Transient";
    UserAccountStatus[UserAccountStatus["Pending"] = 'pending'] = "Pending";
    UserAccountStatus[UserAccountStatus["Accepted"] = 'accepted'] = "Accepted";
    UserAccountStatus[UserAccountStatus["Deleted"] = 'deleted'] = "Deleted";
})(UserAccountStatus = exports.UserAccountStatus || (exports.UserAccountStatus = {}));
class RecentCollaborator {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Email),
    __metadata("design:type", String)
], RecentCollaborator.prototype, "email", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], RecentCollaborator.prototype, "name", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Uri),
    __metadata("design:type", String)
], RecentCollaborator.prototype, "avatarUri", void 0);
exports.RecentCollaborator = RecentCollaborator;
class AuthenticationOptions {
}
exports.AuthenticationOptions = AuthenticationOptions;
class AuthenticationChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(UserInfo),
    __metadata("design:type", UserInfo)
], AuthenticationChangedEventArgs.prototype, "account", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], AuthenticationChangedEventArgs.prototype, "accessToken", void 0);
exports.AuthenticationChangedEventArgs = AuthenticationChangedEventArgs;
class AuthenticatedUserInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(UserInfo),
    __metadata("design:type", UserInfo)
], AuthenticatedUserInfo.prototype, "userInfo", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], AuthenticatedUserInfo.prototype, "accessToken", void 0);
exports.AuthenticatedUserInfo = AuthenticatedUserInfo;
/** A data object containing charasteristics necessary to establish and configure a broker RPC session. */
class BrokerManifest {
}
exports.BrokerManifest = BrokerManifest;
/** Represents event data associated with certain broker events. */
class BrokerEventArgs extends EventArgs {
}
exports.BrokerEventArgs = BrokerEventArgs;
var ChatMessageType;
(function (ChatMessageType) {
    ChatMessageType[ChatMessageType["Text"] = 'text'] = "Text";
    ChatMessageType[ChatMessageType["Typing"] = 'typing'] = "Typing";
})(ChatMessageType = exports.ChatMessageType || (exports.ChatMessageType = {}));
class ChatParticipant {
}
exports.ChatParticipant = ChatParticipant;
class ChatMessageBody {
}
exports.ChatMessageBody = ChatMessageBody;
class ChatMessage {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(ChatMessageBody),
    __metadata("design:type", ChatMessageBody)
], ChatMessage.prototype, "body", void 0);
exports.ChatMessage = ChatMessage;
class MessageReceivedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(ChatMessage),
    __metadata("design:type", ChatMessage)
], MessageReceivedEventArgs.prototype, "message", void 0);
exports.MessageReceivedEventArgs = MessageReceivedEventArgs;
class Position {
    constructor() {
        /** The zero-based index of the character in the buffer. */
        this.startOffset = -1;
    }
}
exports.Position = Position;
var CommentThreadStatus;
(function (CommentThreadStatus) {
    CommentThreadStatus[CommentThreadStatus["Active"] = 'active'] = "Active";
    CommentThreadStatus[CommentThreadStatus["Closed"] = 'closed'] = "Closed";
})(CommentThreadStatus = exports.CommentThreadStatus || (exports.CommentThreadStatus = {}));
class CommentThreadContext {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], CommentThreadContext.prototype, "filePath", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Position),
    __metadata("design:type", Position)
], CommentThreadContext.prototype, "leftFileStart", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Position),
    __metadata("design:type", Position)
], CommentThreadContext.prototype, "leftFileEnd", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Position),
    __metadata("design:type", Position)
], CommentThreadContext.prototype, "rightFileStart", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Position),
    __metadata("design:type", Position)
], CommentThreadContext.prototype, "rightFileEnd", void 0);
exports.CommentThreadContext = CommentThreadContext;
class Comment {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], Comment.prototype, "participantId", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], Comment.prototype, "participantLabel", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], Comment.prototype, "text", void 0);
exports.Comment = Comment;
class CommentThread {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(Comment),
    __metadata("design:type", Array)
], CommentThread.prototype, "comments", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(CommentThreadContext),
    __metadata("design:type", CommentThreadContext)
], CommentThread.prototype, "threadContext", void 0);
exports.CommentThread = CommentThread;
class CommentThreadChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(CommentThread),
    __metadata("design:type", CommentThread)
], CommentThreadChangedEventArgs.prototype, "newThread", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Comment),
    __metadata("design:type", Comment)
], CommentThreadChangedEventArgs.prototype, "changedComment", void 0);
exports.CommentThreadChangedEventArgs = CommentThreadChangedEventArgs;
class CommentThreadLocation {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(CommentThreadContext),
    (0, vso_rpc_1.dataFormat)(CommentThreadContext),
    __metadata("design:type", CommentThreadContext)
], CommentThreadLocation.prototype, "threadContext", void 0);
exports.CommentThreadLocation = CommentThreadLocation;
class AddressAndMask {
}
exports.AddressAndMask = AddressAndMask;
class AgentVersionInfo {
}
exports.AgentVersionInfo = AgentVersionInfo;
class ClientVersionInfo {
}
exports.ClientVersionInfo = ClientVersionInfo;
var FirewallStatus;
(function (FirewallStatus) {
    FirewallStatus[FirewallStatus["None"] = 'none'] = "None";
    FirewallStatus[FirewallStatus["Allow"] = 'allow'] = "Allow";
    FirewallStatus[FirewallStatus["Block"] = 'block'] = "Block";
})(FirewallStatus = exports.FirewallStatus || (exports.FirewallStatus = {}));
/** Represents state of Live Share session at online environment client. */
var LiveShareSessionState;
(function (LiveShareSessionState) {
    LiveShareSessionState[LiveShareSessionState["Idle"] = 'idle'] = "Idle";
    LiveShareSessionState[LiveShareSessionState["Shared"] = 'shared'] = "Shared";
})(LiveShareSessionState = exports.LiveShareSessionState || (exports.LiveShareSessionState = {}));
var PrivacyEnum;
(function (PrivacyEnum) {
    PrivacyEnum[PrivacyEnum["Private"] = 'private'] = "Private";
    PrivacyEnum[PrivacyEnum["Public"] = 'public'] = "Public";
    PrivacyEnum[PrivacyEnum["Org"] = 'org'] = "Org";
})(PrivacyEnum = exports.PrivacyEnum || (exports.PrivacyEnum = {}));
/** Shared server info. StreamName and Condition can be used to get the streams from CancellationToken). */
class SharedServer {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Uri),
    __metadata("design:type", String)
], SharedServer.prototype, "browseUrl", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(PrivacyEnum),
    __metadata("design:type", Number)
], SharedServer.prototype, "privacy", void 0);
exports.SharedServer = SharedServer;
/** Shared pipe info. StreamName and Condition can be used to get the streams from CancellationToken). */
class SharedPipe {
}
exports.SharedPipe = SharedPipe;
/** Event args for an event when a new server is shared. */
class ServerSharingStartedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingStartedEventArgs.prototype, "server", void 0);
exports.ServerSharingStartedEventArgs = ServerSharingStartedEventArgs;
/** Event args for an event when a new pipe is shared. */
class PipeSharingStartedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedPipe),
    __metadata("design:type", SharedPipe)
], PipeSharingStartedEventArgs.prototype, "pipe", void 0);
exports.PipeSharingStartedEventArgs = PipeSharingStartedEventArgs;
/** Event args for an event when a server is no longer shared. */
class ServerSharingStoppedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingStoppedEventArgs.prototype, "server", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingStoppedEventArgs.prototype, "previousServerState", void 0);
exports.ServerSharingStoppedEventArgs = ServerSharingStoppedEventArgs;
/** Event args for an event when a pipe is no longer shared. */
class PipeSharingStoppedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedPipe),
    __metadata("design:type", SharedPipe)
], PipeSharingStoppedEventArgs.prototype, "pipe", void 0);
exports.PipeSharingStoppedEventArgs = PipeSharingStoppedEventArgs;
/** Event args for an event when a server is updated. */
class ServerSharingChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingChangedEventArgs.prototype, "server", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingChangedEventArgs.prototype, "previousServerState", void 0);
exports.ServerSharingChangedEventArgs = ServerSharingChangedEventArgs;
var ChangeKind;
(function (ChangeKind) {
    ChangeKind[ChangeKind["Start"] = 'start'] = "Start";
    ChangeKind[ChangeKind["Update"] = 'update'] = "Update";
    ChangeKind[ChangeKind["Stop"] = 'stop'] = "Stop";
})(ChangeKind = exports.ChangeKind || (exports.ChangeKind = {}));
var TunnelType;
(function (TunnelType) {
    TunnelType[TunnelType["Basis"] = 'basis'] = "Basis";
    TunnelType[TunnelType["Liveshare"] = 'liveshare'] = "Liveshare";
})(TunnelType = exports.TunnelType || (exports.TunnelType = {}));
/** Event args for an event when a server change succeeds. */
class ServerSharingSucceededEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(ChangeKind),
    __metadata("design:type", Number)
], ServerSharingSucceededEventArgs.prototype, "changeKind", void 0);
exports.ServerSharingSucceededEventArgs = ServerSharingSucceededEventArgs;
/** Event args for an event when a server change fails. */
class ServerSharingFailedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(ChangeKind),
    __metadata("design:type", Number)
], ServerSharingFailedEventArgs.prototype, "changeKind", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SharedServer),
    __metadata("design:type", SharedServer)
], ServerSharingFailedEventArgs.prototype, "previousServerState", void 0);
exports.ServerSharingFailedEventArgs = ServerSharingFailedEventArgs;
class SessionUpdateEventArgs extends EventArgs {
}
exports.SessionUpdateEventArgs = SessionUpdateEventArgs;
/** Source control identity. */
class SourceControlIdentifier {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlIdentifier.prototype, "instanceId", void 0);
exports.SourceControlIdentifier = SourceControlIdentifier;
/** Version within source control. */
class SourceControlVersion {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlVersion.prototype, "version", void 0);
exports.SourceControlVersion = SourceControlVersion;
/** Type of source control resource. */
var SourceControlResourceType;
(function (SourceControlResourceType) {
    SourceControlResourceType[SourceControlResourceType["Workspace"] = 'workspace'] = "Workspace";
    SourceControlResourceType[SourceControlResourceType["External"] = 'external'] = "External";
    SourceControlResourceType[SourceControlResourceType["SpecificVerision"] = 'specificVerision'] = "SpecificVerision";
    SourceControlResourceType[SourceControlResourceType["WorkspaceWithSpecificVersion"] = 'workspaceWithSpecificVersion'] = "WorkspaceWithSpecificVersion";
})(SourceControlResourceType = exports.SourceControlResourceType || (exports.SourceControlResourceType = {}));
/** Type of source control resource change or diff. */
var SourceControlChangeType;
(function (SourceControlChangeType) {
    SourceControlChangeType[SourceControlChangeType["None"] = 'none'] = "None";
    SourceControlChangeType[SourceControlChangeType["Add"] = 'add'] = "Add";
    SourceControlChangeType[SourceControlChangeType["Edit"] = 'edit'] = "Edit";
    SourceControlChangeType[SourceControlChangeType["Delete"] = 'delete'] = "Delete";
    SourceControlChangeType[SourceControlChangeType["Rename"] = 'rename'] = "Rename";
    SourceControlChangeType[SourceControlChangeType["Conflict"] = 'conflict'] = "Conflict";
    SourceControlChangeType[SourceControlChangeType["IndexEdit"] = 'indexEdit'] = "IndexEdit";
    SourceControlChangeType[SourceControlChangeType["IndexDelete"] = 'indexDelete'] = "IndexDelete";
    SourceControlChangeType[SourceControlChangeType["IndexCopy"] = 'indexCopy'] = "IndexCopy";
    SourceControlChangeType[SourceControlChangeType["Untracked"] = 'untracked'] = "Untracked";
    SourceControlChangeType[SourceControlChangeType["Ignored"] = 'ignored'] = "Ignored";
    SourceControlChangeType[SourceControlChangeType["AddByUs"] = 'addByUs'] = "AddByUs";
    SourceControlChangeType[SourceControlChangeType["AddByThem"] = 'addByThem'] = "AddByThem";
    SourceControlChangeType[SourceControlChangeType["DeleteByUs"] = 'deleteByUs'] = "DeleteByUs";
    SourceControlChangeType[SourceControlChangeType["DeleteByThem"] = 'deleteByThem'] = "DeleteByThem";
    SourceControlChangeType[SourceControlChangeType["AddBoth"] = 'addBoth'] = "AddBoth";
    SourceControlChangeType[SourceControlChangeType["DeleteBoth"] = 'deleteBoth'] = "DeleteBoth";
})(SourceControlChangeType = exports.SourceControlChangeType || (exports.SourceControlChangeType = {}));
/** Resource under source control. */
class SourceControlResource {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlResource.prototype, "path", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlResource.prototype, "version", void 0);
exports.SourceControlResource = SourceControlResource;
/** Individual file state under source control. */
class SourceControlResourceState {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResource),
    __metadata("design:type", SourceControlResource)
], SourceControlResourceState.prototype, "current", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResource),
    __metadata("design:type", SourceControlResource)
], SourceControlResourceState.prototype, "original", void 0);
exports.SourceControlResourceState = SourceControlResourceState;
/** Identifier of the source control resource. */
class SourceControlResourceIdentifier extends SourceControlResource {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Uri),
    __metadata("design:type", String)
], SourceControlResourceIdentifier.prototype, "instanceId", void 0);
exports.SourceControlResourceIdentifier = SourceControlResourceIdentifier;
/** Group of source-controlled states, e.g. 'Changes', 'Index', or 'Merge' in git. */
class SourceControlResourceGroup {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResourceState),
    __metadata("design:type", Array)
], SourceControlResourceGroup.prototype, "resourceStates", void 0);
exports.SourceControlResourceGroup = SourceControlResourceGroup;
/** Source control data. */
class SourceControlInstance extends SourceControlIdentifier {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlInstance.prototype, "name", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResourceGroup),
    __metadata("design:type", Array)
], SourceControlInstance.prototype, "resourceGroups", void 0);
exports.SourceControlInstance = SourceControlInstance;
/** Source control resource diff info. */
class SourceControlResourceDiff {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResource),
    __metadata("design:type", SourceControlResource)
], SourceControlResourceDiff.prototype, "right", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResource),
    __metadata("design:type", SourceControlResource)
], SourceControlResourceDiff.prototype, "left", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], SourceControlResourceDiff.prototype, "title", void 0);
exports.SourceControlResourceDiff = SourceControlResourceDiff;
/** Source control change type. */
var SourceControlChange;
(function (SourceControlChange) {
    SourceControlChange[SourceControlChange["Updated"] = 'updated'] = "Updated";
    SourceControlChange[SourceControlChange["Added"] = 'added'] = "Added";
    SourceControlChange[SourceControlChange["Removed"] = 'removed'] = "Removed";
})(SourceControlChange = exports.SourceControlChange || (exports.SourceControlChange = {}));
/** Event args for event when source control changed on the host. */
class SourceControlChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlIdentifier),
    __metadata("design:type", SourceControlIdentifier)
], SourceControlChangedEventArgs.prototype, "sourceControl", void 0);
exports.SourceControlChangedEventArgs = SourceControlChangedEventArgs;
/** Event args for event when source control resources changed on the host. */
class SourceControlResourceChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlIdentifier),
    __metadata("design:type", SourceControlIdentifier)
], SourceControlResourceChangedEventArgs.prototype, "sourceControl", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(SourceControlResource),
    __metadata("design:type", Array)
], SourceControlResourceChangedEventArgs.prototype, "resources", void 0);
exports.SourceControlResourceChangedEventArgs = SourceControlResourceChangedEventArgs;
class SyncStatus {
}
exports.SyncStatus = SyncStatus;
/** A content type of a task output or feed. */
var TaskOutputContentType;
(function (TaskOutputContentType) {
    TaskOutputContentType[TaskOutputContentType["PlainText"] = 'plainText'] = "PlainText";
    TaskOutputContentType[TaskOutputContentType["TextWithAnsiEscapeCodes"] = 'textWithAnsiEscapeCodes'] = "TextWithAnsiEscapeCodes";
})(TaskOutputContentType = exports.TaskOutputContentType || (exports.TaskOutputContentType = {}));
/** Single task execution feed */
class TaskOutputFeedInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(RemoteStreamMoniker),
    __metadata("design:type", RemoteStreamMoniker)
], TaskOutputFeedInfo.prototype, "streamMoniker", void 0);
exports.TaskOutputFeedInfo = TaskOutputFeedInfo;
/** Options pertaining to a task output */
class TaskOutputOptions {
}
exports.TaskOutputOptions = TaskOutputOptions;
/** Represents a task output, typically associated with a output or terminal window in IDE. It can be used to send ouput from task execution feeds. Only one feed can be active. */
class TaskOutputInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TaskOutputFeedInfo),
    __metadata("design:type", TaskOutputFeedInfo)
], TaskOutputInfo.prototype, "feed", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(TaskOutputOptions),
    __metadata("design:type", TaskOutputOptions)
], TaskOutputInfo.prototype, "options", void 0);
exports.TaskOutputInfo = TaskOutputInfo;
/** Represents an event data sent with a task output event. */
class TaskOutputEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TaskOutputInfo),
    __metadata("design:type", TaskOutputInfo)
], TaskOutputEventArgs.prototype, "taskOutput", void 0);
exports.TaskOutputEventArgs = TaskOutputEventArgs;
class TelemetrySettings {
}
exports.TelemetrySettings = TelemetrySettings;
class GenericOperationEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Object)
], GenericOperationEventArgs.prototype, "payload", void 0);
exports.GenericOperationEventArgs = GenericOperationEventArgs;
var TelemetryResult;
(function (TelemetryResult) {
    TelemetryResult[TelemetryResult["None"] = 'none'] = "None";
    TelemetryResult[TelemetryResult["Success"] = 'success'] = "Success";
    TelemetryResult[TelemetryResult["Failure"] = 'failure'] = "Failure";
    TelemetryResult[TelemetryResult["UserFault"] = 'userFault'] = "UserFault";
    TelemetryResult[TelemetryResult["UserCancel"] = 'userCancel'] = "UserCancel";
})(TelemetryResult = exports.TelemetryResult || (exports.TelemetryResult = {}));
class FaultTelemetryEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Object)
], FaultTelemetryEventArgs.prototype, "payload", void 0);
exports.FaultTelemetryEventArgs = FaultTelemetryEventArgs;
/** Options that control how terminal is started */
class TerminalOptions {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], TerminalOptions.prototype, "cwd", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], TerminalOptions.prototype, "app", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", Array)
], TerminalOptions.prototype, "commandLine", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], TerminalOptions.prototype, "verbatimCommandLine", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Object)
], TerminalOptions.prototype, "environment", void 0);
exports.TerminalOptions = TerminalOptions;
/** Info on running terminal */
class TerminalInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TerminalOptions),
    __metadata("design:type", TerminalOptions)
], TerminalInfo.prototype, "options", void 0);
exports.TerminalInfo = TerminalInfo;
/** Event args for notification for a terminal */
class TerminalEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TerminalInfo),
    __metadata("design:type", TerminalInfo)
], TerminalEventArgs.prototype, "terminal", void 0);
exports.TerminalEventArgs = TerminalEventArgs;
/** A class that describes a restricted operation which is controlled by access control. By default, the operation is disabled in read-only session. */
class RestrictedOperation {
}
exports.RestrictedOperation = RestrictedOperation;
/** Restricted operation for a specific terminal */
class SharedTerminalRestrictedOperation extends RestrictedOperation {
}
exports.SharedTerminalRestrictedOperation = SharedTerminalRestrictedOperation;
class MaybeImmutableOfWorkspaceAccessControl {
}
exports.MaybeImmutableOfWorkspaceAccessControl = MaybeImmutableOfWorkspaceAccessControl;
/** Event args for an event when user access control changes. */
class WorkspaceAccessControl extends MaybeImmutableOfWorkspaceAccessControl {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(AccessControl),
    __metadata("design:type", AccessControl)
], WorkspaceAccessControl.prototype, "defaultAccessControl", void 0);
exports.WorkspaceAccessControl = WorkspaceAccessControl;
/** Event args for an event when user access control changes. */
class WorkspaceAccessControlEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(WorkspaceAccessControl),
    __metadata("design:type", WorkspaceAccessControl)
], WorkspaceAccessControlEventArgs.prototype, "accessControl", void 0);
exports.WorkspaceAccessControlEventArgs = WorkspaceAccessControlEventArgs;
/** Event args for an event when a guest requests access to a restricted operation. */
class RestrictedOperationAccessRequestedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(RestrictedOperation),
    __metadata("design:type", RestrictedOperation)
], RestrictedOperationAccessRequestedEventArgs.prototype, "operation", void 0);
exports.RestrictedOperationAccessRequestedEventArgs = RestrictedOperationAccessRequestedEventArgs;
/** Represents severity of an error reported by a workspace task. */
var ErrorSeverity;
(function (ErrorSeverity) {
    ErrorSeverity[ErrorSeverity["Error"] = 'error'] = "Error";
    ErrorSeverity[ErrorSeverity["Warning"] = 'warning'] = "Warning";
    ErrorSeverity[ErrorSeverity["Message"] = 'message'] = "Message";
})(ErrorSeverity = exports.ErrorSeverity || (exports.ErrorSeverity = {}));
/** An entry representing error, warning or message generated by a workspace task */
class DiagnosticEntry {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], DiagnosticEntry.prototype, "fileId", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], DiagnosticEntry.prototype, "message", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Object)
], DiagnosticEntry.prototype, "properties", void 0);
exports.DiagnosticEntry = DiagnosticEntry;
/** Describes a diagnostic data event containing a collection of diagnostic entries emitted by a workspace task. */
class DiagnosticDataChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(DiagnosticEntry),
    __metadata("design:type", Array)
], DiagnosticDataChangedEventArgs.prototype, "entries", void 0);
exports.DiagnosticDataChangedEventArgs = DiagnosticDataChangedEventArgs;
/** Invitation link info provided to the agent to create an access control link */
class InvitationLinkInfo {
}
exports.InvitationLinkInfo = InvitationLinkInfo;
class WorkspaceInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], WorkspaceInfo.prototype, "conversationId", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceInfo.prototype, "name", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], WorkspaceInfo.prototype, "joinUri", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", String)
], WorkspaceInfo.prototype, "ownerId", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "disableAnonymousGuest", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "disableSharedServer", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "disableReadWriteTerminal", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "disableChat", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "enableDirectConnectionMode", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Omit),
    __metadata("design:type", Boolean)
], WorkspaceInfo.prototype, "enableGuestApproval", void 0);
exports.WorkspaceInfo = WorkspaceInfo;
var WorkspaceConnectionStatus;
(function (WorkspaceConnectionStatus) {
    WorkspaceConnectionStatus[WorkspaceConnectionStatus["Unknown"] = 'unknown'] = "Unknown";
    WorkspaceConnectionStatus[WorkspaceConnectionStatus["Available"] = 'available'] = "Available";
    WorkspaceConnectionStatus[WorkspaceConnectionStatus["Unavailable"] = 'unavailable'] = "Unavailable";
    WorkspaceConnectionStatus[WorkspaceConnectionStatus["Connected"] = 'connected'] = "Connected";
    WorkspaceConnectionStatus[WorkspaceConnectionStatus["Disconnected"] = 'disconnected'] = "Disconnected";
})(WorkspaceConnectionStatus = exports.WorkspaceConnectionStatus || (exports.WorkspaceConnectionStatus = {}));
var WorkspaceDisconnectedReason;
(function (WorkspaceDisconnectedReason) {
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["None"] = 'none'] = "None";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["Requested"] = 'requested'] = "Requested";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["UserRemoved"] = 'userRemoved'] = "UserRemoved";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["UserBlocked"] = 'userBlocked'] = "UserBlocked";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["SessionEnded"] = 'sessionEnded'] = "SessionEnded";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["ConnectionLost"] = 'connectionLost'] = "ConnectionLost";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["InternalError"] = 'internalError'] = "InternalError";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["SessionExpired"] = 'sessionExpired'] = "SessionExpired";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["NetworkDisconnected"] = 'networkDisconnected'] = "NetworkDisconnected";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["ListenerWentOffline"] = 'listenerWentOffline'] = "ListenerWentOffline";
    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason["CollaborationServiceFactoryCriticalFailure"] = 'collaborationServiceFactoryCriticalFailure'] = "CollaborationServiceFactoryCriticalFailure";
})(WorkspaceDisconnectedReason = exports.WorkspaceDisconnectedReason || (exports.WorkspaceDisconnectedReason = {}));
class WorkspaceConnectionStatusChangedEventArgs extends EventArgs {
}
exports.WorkspaceConnectionStatusChangedEventArgs = WorkspaceConnectionStatusChangedEventArgs;
/** Event that is fired by IWorkspaceService when shared workspace become ready for connections */
class WorkspaceReadyForConnectionEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(WorkspaceInfo),
    __metadata("design:type", WorkspaceInfo)
], WorkspaceReadyForConnectionEventArgs.prototype, "workspace", void 0);
exports.WorkspaceReadyForConnectionEventArgs = WorkspaceReadyForConnectionEventArgs;
var WorkspaceProgress;
(function (WorkspaceProgress) {
    WorkspaceProgress[WorkspaceProgress["None"] = 'none'] = "None";
    WorkspaceProgress[WorkspaceProgress["CreatedWorkspace"] = 'createdWorkspace'] = "CreatedWorkspace";
    WorkspaceProgress[WorkspaceProgress["InitializedAgentServices"] = 'initializedAgentServices'] = "InitializedAgentServices";
    WorkspaceProgress[WorkspaceProgress["InitializedRelayAndTCP"] = 'initializedRelayAndTCP'] = "InitializedRelayAndTCP";
    WorkspaceProgress[WorkspaceProgress["AddedUserToWorkspace"] = 'addedUserToWorkspace'] = "AddedUserToWorkspace";
    WorkspaceProgress[WorkspaceProgress["JoinedLocalWorkspace"] = 'joinedLocalWorkspace'] = "JoinedLocalWorkspace";
    WorkspaceProgress[WorkspaceProgress["ReadWorkspaceInfo"] = 'readWorkspaceInfo'] = "ReadWorkspaceInfo";
    WorkspaceProgress[WorkspaceProgress["OpeningRemoteSession"] = 'openingRemoteSession'] = "OpeningRemoteSession";
    WorkspaceProgress[WorkspaceProgress["OpenedRemoteSession"] = 'openedRemoteSession'] = "OpenedRemoteSession";
    WorkspaceProgress[WorkspaceProgress["JoiningRemoteSession"] = 'joiningRemoteSession'] = "JoiningRemoteSession";
    WorkspaceProgress[WorkspaceProgress["JoinedRemoteSession"] = 'joinedRemoteSession'] = "JoinedRemoteSession";
    WorkspaceProgress[WorkspaceProgress["WaitingForHost"] = 'waitingForHost'] = "WaitingForHost";
    WorkspaceProgress[WorkspaceProgress["DoneWaitingForHost"] = 'doneWaitingForHost'] = "DoneWaitingForHost";
    WorkspaceProgress[WorkspaceProgress["ReconnectingToHost"] = 'reconnectingToHost'] = "ReconnectingToHost";
    WorkspaceProgress[WorkspaceProgress["ReconnectedToHost"] = 'reconnectedToHost'] = "ReconnectedToHost";
    WorkspaceProgress[WorkspaceProgress["ReconnectionFailed"] = 'reconnectionFailed'] = "ReconnectionFailed";
    WorkspaceProgress[WorkspaceProgress["UpdatedWorkspace"] = 'updatedWorkspace'] = "UpdatedWorkspace";
})(WorkspaceProgress = exports.WorkspaceProgress || (exports.WorkspaceProgress = {}));
class WorkspaceProgressEventArgs extends EventArgs {
}
exports.WorkspaceProgressEventArgs = WorkspaceProgressEventArgs;
class WorkspaceShareInfo extends WorkspaceInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", Array)
], WorkspaceShareInfo.prototype, "rootDirectories", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(FileServiceRootConfiguration),
    __metadata("design:type", FileServiceRootConfiguration)
], WorkspaceShareInfo.prototype, "persistentRootConfiguration", void 0);
exports.WorkspaceShareInfo = WorkspaceShareInfo;
/** Defines the ways that an RPC caller can connect to a workspace when joining. */
var ConnectionMode;
(function (ConnectionMode) {
    ConnectionMode[ConnectionMode["Auto"] = 'auto'] = "Auto";
    ConnectionMode[ConnectionMode["Direct"] = 'direct'] = "Direct";
    ConnectionMode[ConnectionMode["Relay"] = 'relay'] = "Relay";
    ConnectionMode[ConnectionMode["Local"] = 'local'] = "Local";
    ConnectionMode[ConnectionMode["SignalR"] = 'signalR'] = "SignalR";
    ConnectionMode[ConnectionMode["DevTunnel"] = 'devTunnel'] = "DevTunnel";
})(ConnectionMode = exports.ConnectionMode || (exports.ConnectionMode = {}));
class ClientCapabilities {
}
exports.ClientCapabilities = ClientCapabilities;
class WorkspaceJoinInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "directAddress", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "relayAddress", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Token),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "relaySharedAccessSignature", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Token),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "joiningUserSessionToken", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(ClientCapabilities),
    __metadata("design:type", ClientCapabilities)
], WorkspaceJoinInfo.prototype, "clientCapabilities", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Token),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "userIdentity", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Token),
    __metadata("design:type", String)
], WorkspaceJoinInfo.prototype, "initialViewName", void 0);
exports.WorkspaceJoinInfo = WorkspaceJoinInfo;
class WorkspaceListOptions {
    constructor() {
        /** Optionally include remote workspaces. */
        this.includeRemoteWorkspaces = true;
        /** Get only the managed workspaces. */
        this.onlyManagedWorkspaces = false;
    }
}
exports.WorkspaceListOptions = WorkspaceListOptions;
class WorkspaceSessionInfo extends WorkspaceInfo {
}
exports.WorkspaceSessionInfo = WorkspaceSessionInfo;
class WorkspaceUserProfile {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceUserProfile.prototype, "name", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Email),
    __metadata("design:type", String)
], WorkspaceUserProfile.prototype, "email", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceUserProfile.prototype, "userName", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], WorkspaceUserProfile.prototype, "provider", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Uri),
    __metadata("design:type", String)
], WorkspaceUserProfile.prototype, "avatarUri", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(ClientCapabilities),
    __metadata("design:type", ClientCapabilities)
], WorkspaceUserProfile.prototype, "clientCapabilities", void 0);
exports.WorkspaceUserProfile = WorkspaceUserProfile;
class WorkspaceServicesChangedEventArgs extends EventArgs {
}
exports.WorkspaceServicesChangedEventArgs = WorkspaceServicesChangedEventArgs;
var CollectionChangeType;
(function (CollectionChangeType) {
    CollectionChangeType[CollectionChangeType["None"] = 'none'] = "None";
    CollectionChangeType[CollectionChangeType["Add"] = 'add'] = "Add";
    CollectionChangeType[CollectionChangeType["Remove"] = 'remove'] = "Remove";
    CollectionChangeType[CollectionChangeType["Replace"] = 'replace'] = "Replace";
})(CollectionChangeType = exports.CollectionChangeType || (exports.CollectionChangeType = {}));
class GuestAcceptance {
}
exports.GuestAcceptance = GuestAcceptance;
var WorkspaceSessionChangeType;
(function (WorkspaceSessionChangeType) {
    WorkspaceSessionChangeType[WorkspaceSessionChangeType["None"] = 'none'] = "None";
    WorkspaceSessionChangeType[WorkspaceSessionChangeType["Joined"] = 'joined'] = "Joined";
    WorkspaceSessionChangeType[WorkspaceSessionChangeType["Unjoined"] = 'unjoined'] = "Unjoined";
    WorkspaceSessionChangeType[WorkspaceSessionChangeType["Canceled"] = 'canceled'] = "Canceled";
    WorkspaceSessionChangeType[WorkspaceSessionChangeType["Requested"] = 'requested'] = "Requested";
})(WorkspaceSessionChangeType = exports.WorkspaceSessionChangeType || (exports.WorkspaceSessionChangeType = {}));
class WorkspaceSessionChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(WorkspaceUserProfile),
    __metadata("design:type", WorkspaceUserProfile)
], WorkspaceSessionChangedEventArgs.prototype, "userProfile", void 0);
exports.WorkspaceSessionChangedEventArgs = WorkspaceSessionChangedEventArgs;
/** Group policy settings */
var GroupPolicySettings;
(function (GroupPolicySettings) {
    GroupPolicySettings[GroupPolicySettings["AnonymousGuest"] = 'anonymousGuest'] = "AnonymousGuest";
    GroupPolicySettings[GroupPolicySettings["DisableSharedServer"] = 'disableSharedServer'] = "DisableSharedServer";
    GroupPolicySettings[GroupPolicySettings["DisableReadWriteTerminal"] = 'disableReadWriteTerminal'] = "DisableReadWriteTerminal";
    GroupPolicySettings[GroupPolicySettings["DirectConnectionMode"] = 'directConnectionMode'] = "DirectConnectionMode";
    GroupPolicySettings[GroupPolicySettings["GuestApprovalRequired"] = 'guestApprovalRequired'] = "GuestApprovalRequired";
    GroupPolicySettings[GroupPolicySettings["DomainJoined"] = 'domainJoined'] = "DomainJoined";
    GroupPolicySettings[GroupPolicySettings["DisableChat"] = 'disableChat'] = "DisableChat";
})(GroupPolicySettings = exports.GroupPolicySettings || (exports.GroupPolicySettings = {}));
/** Enterprise policy settings */
var PolicySettings;
(function (PolicySettings) {
    PolicySettings[PolicySettings["DisableAnonymousGuest"] = 'disableAnonymousGuest'] = "DisableAnonymousGuest";
    PolicySettings[PolicySettings["DisableSharedServer"] = 'disableSharedServer'] = "DisableSharedServer";
    PolicySettings[PolicySettings["DisableReadWriteTerminal"] = 'disableReadWriteTerminal'] = "DisableReadWriteTerminal";
    PolicySettings[PolicySettings["EnableDirectConnectionMode"] = 'enableDirectConnectionMode'] = "EnableDirectConnectionMode";
    PolicySettings[PolicySettings["EnableGuestApproval"] = 'enableGuestApproval'] = "EnableGuestApproval";
    PolicySettings[PolicySettings["EnableDomainRestriction"] = 'enableDomainRestriction'] = "EnableDomainRestriction";
    PolicySettings[PolicySettings["DisableChat"] = 'disableChat'] = "DisableChat";
})(PolicySettings = exports.PolicySettings || (exports.PolicySettings = {}));
class UserSettings {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(FeatureFlagStore),
    __metadata("design:type", FeatureFlagStore)
], UserSettings.prototype, "experimentalFeatures", void 0);
exports.UserSettings = UserSettings;
class VSOnlineSettings {
}
exports.VSOnlineSettings = VSOnlineSettings;
class TextChange {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], TextChange.prototype, "newText", void 0);
exports.TextChange = TextChange;
class MessageBase {
    constructor() {
        this.messageType = MessageType.Unknown;
    }
}
exports.MessageBase = MessageBase;
var MessageType;
(function (MessageType) {
    MessageType[MessageType["SelectionChange"] = 'selectionChange'] = "SelectionChange";
    MessageType[MessageType["NotebookSelectionChange"] = 'notebookSelectionChange'] = "NotebookSelectionChange";
    MessageType[MessageType["VisibleRangesChange"] = 'visibleRangesChange'] = "VisibleRangesChange";
    MessageType[MessageType["TextChange"] = 'textChange'] = "TextChange";
    MessageType[MessageType["FileOpenRequest"] = 'fileOpenRequest'] = "FileOpenRequest";
    MessageType[MessageType["ResetFileClient"] = 'resetFileClient'] = "ResetFileClient";
    MessageType[MessageType["UntitledFileSaved"] = 'untitledFileSaved'] = "UntitledFileSaved";
    MessageType[MessageType["UntitledFileOpened"] = 'untitledFileOpened'] = "UntitledFileOpened";
    MessageType[MessageType["UntitledFileClosed"] = 'untitledFileClosed'] = "UntitledFileClosed";
    MessageType[MessageType["DiffViewOpen"] = 'diffViewOpen'] = "DiffViewOpen";
    MessageType[MessageType["DiffViewClosed"] = 'diffViewClosed'] = "DiffViewClosed";
    MessageType[MessageType["FileOpenAcknowledge"] = 'fileOpenAcknowledge'] = "FileOpenAcknowledge";
    MessageType[MessageType["FileRelease"] = 'fileRelease'] = "FileRelease";
    MessageType[MessageType["SaveFile"] = 'saveFile'] = "SaveFile";
    MessageType[MessageType["SaveNotebook"] = 'saveNotebook'] = "SaveNotebook";
    MessageType[MessageType["JoinRequest"] = 'joinRequest'] = "JoinRequest";
    MessageType[MessageType["JoinAcknowledge"] = 'joinAcknowledge'] = "JoinAcknowledge";
    MessageType[MessageType["ReadOnlyChange"] = 'readOnlyChange'] = "ReadOnlyChange";
    MessageType[MessageType["Handshake"] = 'handshake'] = "Handshake";
    MessageType[MessageType["Summon"] = 'summon'] = "Summon";
    MessageType[MessageType["LayoutScroll"] = 'layoutScroll'] = "LayoutScroll";
    MessageType[MessageType["NotebookScroll"] = 'notebookScroll'] = "NotebookScroll";
    MessageType[MessageType["ProjectFileOpened"] = 'projectFileOpened'] = "ProjectFileOpened";
    MessageType[MessageType["ProjectFileClosed"] = 'projectFileClosed'] = "ProjectFileClosed";
    MessageType[MessageType["PresenterUpdate"] = 'presenterUpdate'] = "PresenterUpdate";
    MessageType[MessageType["FollowChange"] = 'followChange'] = "FollowChange";
    MessageType[MessageType["AnonymousAccessLevelChange"] = 'anonymousAccessLevelChange'] = "AnonymousAccessLevelChange";
    MessageType[MessageType["Ping"] = 'ping'] = "Ping";
    MessageType[MessageType["Unknown"] = 'unknown'] = "Unknown";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
class FileMessageBase extends MessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], FileMessageBase.prototype, "fileName", void 0);
exports.FileMessageBase = FileMessageBase;
class JoinRequestMessage extends MessageBase {
}
exports.JoinRequestMessage = JoinRequestMessage;
class JoinAcknowledgeMessage extends MessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", Array)
], JoinAcknowledgeMessage.prototype, "files", void 0);
exports.JoinAcknowledgeMessage = JoinAcknowledgeMessage;
class PresenterUpdateMessage extends MessageBase {
}
exports.PresenterUpdateMessage = PresenterUpdateMessage;
class FollowChangeMessage extends MessageBase {
}
exports.FollowChangeMessage = FollowChangeMessage;
class SelectionChangeMessage extends FileMessageBase {
}
exports.SelectionChangeMessage = SelectionChangeMessage;
class NotebookSelectionChangeMessage extends FileMessageBase {
}
exports.NotebookSelectionChangeMessage = NotebookSelectionChangeMessage;
class Range {
}
exports.Range = Range;
class LayoutScrollMessage extends FileMessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(Range),
    __metadata("design:type", Array)
], LayoutScrollMessage.prototype, "visibleRanges", void 0);
exports.LayoutScrollMessage = LayoutScrollMessage;
class NotebookScrollMessage extends FileMessageBase {
}
exports.NotebookScrollMessage = NotebookScrollMessage;
class EditorVisibleRanges {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], EditorVisibleRanges.prototype, "fileName", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(Range),
    __metadata("design:type", Array)
], EditorVisibleRanges.prototype, "visibleRanges", void 0);
exports.EditorVisibleRanges = EditorVisibleRanges;
class VisibleRangesChangeMessage extends MessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(EditorVisibleRanges),
    __metadata("design:type", Array)
], VisibleRangesChangeMessage.prototype, "clientVisibleRanges", void 0);
exports.VisibleRangesChangeMessage = VisibleRangesChangeMessage;
class FileOpenRequestMessage extends FileMessageBase {
}
exports.FileOpenRequestMessage = FileOpenRequestMessage;
class ResetFileClientMessage extends FileMessageBase {
}
exports.ResetFileClientMessage = ResetFileClientMessage;
class UntitledFileSavedMessage extends FileMessageBase {
}
exports.UntitledFileSavedMessage = UntitledFileSavedMessage;
class UntitledFileOpenedMessage extends FileMessageBase {
}
exports.UntitledFileOpenedMessage = UntitledFileOpenedMessage;
class UntitledFileClosedMessage extends FileMessageBase {
}
exports.UntitledFileClosedMessage = UntitledFileClosedMessage;
class DiffViewMessage extends MessageBase {
}
exports.DiffViewMessage = DiffViewMessage;
class DiffViewOpenMessage extends DiffViewMessage {
}
exports.DiffViewOpenMessage = DiffViewOpenMessage;
class DiffViewClosedMessage extends DiffViewMessage {
}
exports.DiffViewClosedMessage = DiffViewClosedMessage;
class HandshakeMessage extends FileMessageBase {
}
exports.HandshakeMessage = HandshakeMessage;
class SaveFileMessage extends FileMessageBase {
}
exports.SaveFileMessage = SaveFileMessage;
class SaveNotebookMessage extends FileMessageBase {
}
exports.SaveNotebookMessage = SaveNotebookMessage;
class FileReleaseMessage extends FileMessageBase {
}
exports.FileReleaseMessage = FileReleaseMessage;
class AnonymousAcccessLevelChangedMessage extends FileMessageBase {
}
exports.AnonymousAcccessLevelChangedMessage = AnonymousAcccessLevelChangedMessage;
class TextChangeMessage extends FileMessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TextChange),
    __metadata("design:type", Array)
], TextChangeMessage.prototype, "changes", void 0);
exports.TextChangeMessage = TextChangeMessage;
class ReadOnlyChangeMessage extends FileMessageBase {
}
exports.ReadOnlyChangeMessage = ReadOnlyChangeMessage;
/** Message sent by a guest or Nexus client when he or she opens the first editor window for a project file. */
class ProjectFileOpenedMessage extends FileMessageBase {
}
exports.ProjectFileOpenedMessage = ProjectFileOpenedMessage;
/** Message sent by a guest or Nexus client when he or she closes the last editor window for a project file. */
class ProjectFileClosedMessage extends FileMessageBase {
}
exports.ProjectFileClosedMessage = ProjectFileClosedMessage;
class ServerVersionSnapshot {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TextChangeMessage),
    __metadata("design:type", TextChangeMessage)
], ServerVersionSnapshot.prototype, "message", void 0);
exports.ServerVersionSnapshot = ServerVersionSnapshot;
class FileOpenAcknowledgeMessage extends FileMessageBase {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(ServerVersionSnapshot),
    __metadata("design:type", Array)
], FileOpenAcknowledgeMessage.prototype, "history", void 0);
exports.FileOpenAcknowledgeMessage = FileOpenAcknowledgeMessage;
class SummonMessage extends MessageBase {
}
exports.SummonMessage = SummonMessage;
class PingMessage extends MessageBase {
}
exports.PingMessage = PingMessage;
var DocumentChangesNotificationFlags;
(function (DocumentChangesNotificationFlags) {
    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags["NotifyDidOpenClose"] = 'notifyDidOpenClose'] = "NotifyDidOpenClose";
    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags["NotifyDidChange"] = 'notifyDidChange'] = "NotifyDidChange";
    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags["NotifyDidSave"] = 'notifyDidSave'] = "NotifyDidSave";
    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags["NotifyAll"] = 'notifyAll'] = "NotifyAll";
})(DocumentChangesNotificationFlags = exports.DocumentChangesNotificationFlags || (exports.DocumentChangesNotificationFlags = {}));
class CoeditingInformation {
}
exports.CoeditingInformation = CoeditingInformation;
class DocumentFilter {
}
exports.DocumentFilter = DocumentFilter;
class LanguageServerProviderMetadata {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(DocumentFilter),
    __metadata("design:type", Array)
], LanguageServerProviderMetadata.prototype, "documentFilters", void 0);
exports.LanguageServerProviderMetadata = LanguageServerProviderMetadata;
class NotificationEventArgs extends EventArgs {
}
exports.NotificationEventArgs = NotificationEventArgs;
class LspMessage {
}
exports.LspMessage = LspMessage;
class DebugSession {
}
exports.DebugSession = DebugSession;
var DebugSessionChangeType;
(function (DebugSessionChangeType) {
    DebugSessionChangeType[DebugSessionChangeType["None"] = 'none'] = "None";
    DebugSessionChangeType[DebugSessionChangeType["Add"] = 'add'] = "Add";
    DebugSessionChangeType[DebugSessionChangeType["Remove"] = 'remove'] = "Remove";
})(DebugSessionChangeType = exports.DebugSessionChangeType || (exports.DebugSessionChangeType = {}));
class DebugSessionChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(DebugSession),
    __metadata("design:type", DebugSession)
], DebugSessionChangedEventArgs.prototype, "debugSession", void 0);
exports.DebugSessionChangedEventArgs = DebugSessionChangedEventArgs;
class LaunchConfigurationChangedEventArgs extends EventArgs {
}
exports.LaunchConfigurationChangedEventArgs = LaunchConfigurationChangedEventArgs;
var ContinueReason;
(function (ContinueReason) {
    ContinueReason[ContinueReason["Go"] = 'go'] = "Go";
    ContinueReason[ContinueReason["StepIn"] = 'stepIn'] = "StepIn";
    ContinueReason[ContinueReason["StepOut"] = 'stepOut'] = "StepOut";
    ContinueReason[ContinueReason["StepOver"] = 'stepOver'] = "StepOver";
})(ContinueReason = exports.ContinueReason || (exports.ContinueReason = {}));
/** Event args for an event when access control changes. */
class AccessControlEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(AccessControl),
    __metadata("design:type", AccessControl)
], AccessControlEventArgs.prototype, "accessControl", void 0);
exports.AccessControlEventArgs = AccessControlEventArgs;
/** Access for a restricted operation. */
var RestrictedOperationAccess;
(function (RestrictedOperationAccess) {
    RestrictedOperationAccess[RestrictedOperationAccess["Allowed"] = 'allowed'] = "Allowed";
    RestrictedOperationAccess[RestrictedOperationAccess["RejectedInReadOnlySession"] = 'rejectedInReadOnlySession'] = "RejectedInReadOnlySession";
    RestrictedOperationAccess[RestrictedOperationAccess["RejectedForNotOwner"] = 'rejectedForNotOwner'] = "RejectedForNotOwner";
    RestrictedOperationAccess[RestrictedOperationAccess["DisabledByHostConfiguration"] = 'disabledByHostConfiguration'] = "DisabledByHostConfiguration";
    RestrictedOperationAccess[RestrictedOperationAccess["ExplicitlyRejectedByHost"] = 'explicitlyRejectedByHost'] = "ExplicitlyRejectedByHost";
    RestrictedOperationAccess[RestrictedOperationAccess["RejectedPersistentRootNotSupported"] = 'rejectedPersistentRootNotSupported'] = "RejectedPersistentRootNotSupported";
})(RestrictedOperationAccess = exports.RestrictedOperationAccess || (exports.RestrictedOperationAccess = {}));
/** Event args for an event when a restricted operation has failed. */
class RestrictedOperationAccessEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(RestrictedOperation),
    __metadata("design:type", RestrictedOperation)
], RestrictedOperationAccessEventArgs.prototype, "operation", void 0);
exports.RestrictedOperationAccessEventArgs = RestrictedOperationAccessEventArgs;
class FileListOptions {
}
exports.FileListOptions = FileListOptions;
/** Specifies what descendents should be included when listing or watching a path. */
var FileRecurseMode;
(function (FileRecurseMode) {
    FileRecurseMode[FileRecurseMode["None"] = 'none'] = "None";
    FileRecurseMode[FileRecurseMode["Children"] = 'children'] = "Children";
    FileRecurseMode[FileRecurseMode["SingleChildDescendants"] = 'singleChildDescendants'] = "SingleChildDescendants";
    FileRecurseMode[FileRecurseMode["AllDescendants"] = 'allDescendants'] = "AllDescendants";
})(FileRecurseMode = exports.FileRecurseMode || (exports.FileRecurseMode = {}));
var FileAttributes;
(function (FileAttributes) {
    FileAttributes[FileAttributes["None"] = 'none'] = "None";
    FileAttributes[FileAttributes["Hidden"] = 'hidden'] = "Hidden";
    FileAttributes[FileAttributes["ReadOnly"] = 'readOnly'] = "ReadOnly";
    FileAttributes[FileAttributes["Excluded"] = 'excluded'] = "Excluded";
    FileAttributes[FileAttributes["External"] = 'external'] = "External";
})(FileAttributes = exports.FileAttributes || (exports.FileAttributes = {}));
class FileInfo {
    constructor() {
        this.exists = true;
    }
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], FileInfo.prototype, "path", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(FileInfo),
    __metadata("design:type", Array)
], FileInfo.prototype, "children", void 0);
exports.FileInfo = FileInfo;
class FileRootInfo extends FileInfo {
}
exports.FileRootInfo = FileRootInfo;
class FileTextInfo extends FileInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], FileTextInfo.prototype, "text", void 0);
exports.FileTextInfo = FileTextInfo;
class FileReadOptions {
}
exports.FileReadOptions = FileReadOptions;
class FileWriteOptions {
}
exports.FileWriteOptions = FileWriteOptions;
class FileMoveOptions {
}
exports.FileMoveOptions = FileMoveOptions;
class FileDeleteOptions {
}
exports.FileDeleteOptions = FileDeleteOptions;
class FileWatchOptions {
}
exports.FileWatchOptions = FileWatchOptions;
class FileChange {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], FileChange.prototype, "path", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], FileChange.prototype, "fullPath", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], FileChange.prototype, "localFullPath", void 0);
exports.FileChange = FileChange;
var FileChangeType;
(function (FileChangeType) {
    FileChangeType[FileChangeType["None"] = 'none'] = "None";
    FileChangeType[FileChangeType["Updated"] = 'updated'] = "Updated";
    FileChangeType[FileChangeType["Added"] = 'added'] = "Added";
    FileChangeType[FileChangeType["Deleted"] = 'deleted'] = "Deleted";
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
class FilesChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(FileChange),
    __metadata("design:type", Array)
], FilesChangedEventArgs.prototype, "changes", void 0);
exports.FilesChangedEventArgs = FilesChangedEventArgs;
class ExternalFilesChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", Array)
], ExternalFilesChangedEventArgs.prototype, "localPaths", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", Array)
], ExternalFilesChangedEventArgs.prototype, "vslsPaths", void 0);
exports.ExternalFilesChangedEventArgs = ExternalFilesChangedEventArgs;
/** File service root changed event args. */
class RootsChangedEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], RootsChangedEventArgs.prototype, "root", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], RootsChangedEventArgs.prototype, "fullPath", void 0);
exports.RootsChangedEventArgs = RootsChangedEventArgs;
class DiffBaseInfo {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], DiffBaseInfo.prototype, "description", void 0);
exports.DiffBaseInfo = DiffBaseInfo;
class ExternalFileMapResult {
}
exports.ExternalFileMapResult = ExternalFileMapResult;
class TextSearchResultRange {
}
exports.TextSearchResultRange = TextSearchResultRange;
class TextSearchResult {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Path),
    __metadata("design:type", String)
], TextSearchResult.prototype, "path", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], TextSearchResult.prototype, "text", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(TextSearchResultRange),
    __metadata("design:type", Array)
], TextSearchResult.prototype, "ranges", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(TextSearchResultRange),
    __metadata("design:type", Array)
], TextSearchResult.prototype, "previewRanges", void 0);
exports.TextSearchResult = TextSearchResult;
class ReadTextResult {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(FileTextInfo),
    __metadata("design:type", Array)
], ReadTextResult.prototype, "results", void 0);
exports.ReadTextResult = ReadTextResult;
class TextSearchOptions {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", Array)
], TextSearchOptions.prototype, "fileIncludes", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", Array)
], TextSearchOptions.prototype, "fileExcludes", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Text),
    __metadata("design:type", String)
], TextSearchOptions.prototype, "pattern", void 0);
exports.TextSearchOptions = TextSearchOptions;
/** Types of nodes present in a solution view */
class NodeType {
}
exports.NodeType = NodeType;
/** Represents a node in solution view */
class SolutionWorkspaceNode {
}
exports.SolutionWorkspaceNode = SolutionWorkspaceNode;
/** Hierarchy change event data */
class SolutionChangedEventArgs extends EventArgs {
}
exports.SolutionChangedEventArgs = SolutionChangedEventArgs;
/** Workspace root changed!: solution || folder opened || closed */
class WorkspaceRootChangedEventArgs extends EventArgs {
}
exports.WorkspaceRootChangedEventArgs = WorkspaceRootChangedEventArgs;
/** The type of workspace being shared */
var WorkspaceMode;
(function (WorkspaceMode) {
    WorkspaceMode[WorkspaceMode["Empty"] = 'empty'] = "Empty";
    WorkspaceMode[WorkspaceMode["Folder"] = 'folder'] = "Folder";
    WorkspaceMode[WorkspaceMode["Solution"] = 'solution'] = "Solution";
})(WorkspaceMode = exports.WorkspaceMode || (exports.WorkspaceMode = {}));
/** Types of hierarchy node operations */
class SolutionChangeType {
}
exports.SolutionChangeType = SolutionChangeType;
class SourceEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(vso_rpc_1.DataFormat.Hide),
    __metadata("design:type", String)
], SourceEventArgs.prototype, "jsonContent", void 0);
exports.SourceEventArgs = SourceEventArgs;
var StreamTraits;
(function (StreamTraits) {
    StreamTraits[StreamTraits["None"] = 'none'] = "None";
    StreamTraits[StreamTraits["CanRead"] = 'canRead'] = "CanRead";
    StreamTraits[StreamTraits["CanWrite"] = 'canWrite'] = "CanWrite";
    StreamTraits[StreamTraits["CanSeek"] = 'canSeek'] = "CanSeek";
})(StreamTraits = exports.StreamTraits || (exports.StreamTraits = {}));
/** The scope a task is associated with */
var TaskScope;
(function (TaskScope) {
    TaskScope[TaskScope["Global"] = 'global'] = "Global";
    TaskScope[TaskScope["Workspace"] = 'workspace'] = "Workspace";
    TaskScope[TaskScope["WorkspaceFolder"] = 'workspaceFolder'] = "WorkspaceFolder";
})(TaskScope = exports.TaskScope || (exports.TaskScope = {}));
/** Represents a task declared in a collaboration workspace. Examples!: build, publish, pack, lint, etc. */
class WorkspaceTask {
}
exports.WorkspaceTask = WorkspaceTask;
/** Represents a task execution. Any single task may be executed multiple times. Each execution will receive a new moniker with unique ID. */
class TaskExecutionMoniker {
}
exports.TaskExecutionMoniker = TaskExecutionMoniker;
/** Event occured to a task that may lead to a task state change. */
var TaskExecutionStatusChange;
(function (TaskExecutionStatusChange) {
    TaskExecutionStatusChange[TaskExecutionStatusChange["Started"] = 'started'] = "Started";
    TaskExecutionStatusChange[TaskExecutionStatusChange["Terminated"] = 'terminated'] = "Terminated";
})(TaskExecutionStatusChange = exports.TaskExecutionStatusChange || (exports.TaskExecutionStatusChange = {}));
/** Message sent by a remote task to signal change in the status. */
class TaskExecutionStatusEventArgs extends EventArgs {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TaskExecutionMoniker),
    __metadata("design:type", TaskExecutionMoniker)
], TaskExecutionStatusEventArgs.prototype, "taskExecution", void 0);
__decorate([
    (0, vso_rpc_1.dataFormat)(WorkspaceTask),
    __metadata("design:type", WorkspaceTask)
], TaskExecutionStatusEventArgs.prototype, "task", void 0);
exports.TaskExecutionStatusEventArgs = TaskExecutionStatusEventArgs;
/** List of statuses produced by IWorkspaceTaskService in response to start a task execution. */
var RunTaskStatus;
(function (RunTaskStatus) {
    RunTaskStatus[RunTaskStatus["Started"] = 'started'] = "Started";
    RunTaskStatus[RunTaskStatus["AlreadyRunning"] = 'alreadyRunning'] = "AlreadyRunning";
    RunTaskStatus[RunTaskStatus["RetryLater"] = 'retryLater'] = "RetryLater";
    RunTaskStatus[RunTaskStatus["TaskNotFound"] = 'taskNotFound'] = "TaskNotFound";
    RunTaskStatus[RunTaskStatus["RejectedByHost"] = 'rejectedByHost'] = "RejectedByHost";
})(RunTaskStatus = exports.RunTaskStatus || (exports.RunTaskStatus = {}));
/** Represents a result of a run task operation. */
class RunTaskResult {
}
__decorate([
    (0, vso_rpc_1.dataFormat)(TaskExecutionMoniker),
    __metadata("design:type", TaskExecutionMoniker)
], RunTaskResult.prototype, "taskExecution", void 0);
exports.RunTaskResult = RunTaskResult;
/** Restricted operation for a control action performed for a specific task, including run and terminate actions. */
class WorkspaceTaskRestrictedOperation extends RestrictedOperation {
}
exports.WorkspaceTaskRestrictedOperation = WorkspaceTaskRestrictedOperation;
var ErrorCodes;
(function (ErrorCodes) {
    ErrorCodes[ErrorCodes["CouldNotConnectToServer"] = -32000] = "CouldNotConnectToServer";
    ErrorCodes[ErrorCodes["OlderThanServer"] = -32001] = "OlderThanServer";
    ErrorCodes[ErrorCodes["NewerThanServer"] = -32002] = "NewerThanServer";
    ErrorCodes[ErrorCodes["OlderThanPeer"] = -32003] = "OlderThanPeer";
    ErrorCodes[ErrorCodes["NewerThanPeer"] = -32004] = "NewerThanPeer";
    ErrorCodes[ErrorCodes["OlderThanAgent"] = -32005] = "OlderThanAgent";
    ErrorCodes[ErrorCodes["NewerThanAgent"] = -32006] = "NewerThanAgent";
    ErrorCodes[ErrorCodes["NoIPAddressesDetected"] = -32010] = "NoIPAddressesDetected";
    ErrorCodes[ErrorCodes["NoConnectionAddresses"] = -32011] = "NoConnectionAddresses";
    ErrorCodes[ErrorCodes["AutoConnectionFailed"] = -32012] = "AutoConnectionFailed";
    ErrorCodes[ErrorCodes["RelayConnectionFailed"] = -32013] = "RelayConnectionFailed";
    ErrorCodes[ErrorCodes["DirectConnectionFailed"] = -32014] = "DirectConnectionFailed";
    ErrorCodes[ErrorCodes["SessionProtocolError"] = -32015] = "SessionProtocolError";
    ErrorCodes[ErrorCodes["SessionAuthenticationFailed"] = -32016] = "SessionAuthenticationFailed";
    ErrorCodes[ErrorCodes["ReconnectFailed"] = -32017] = "ReconnectFailed";
    ErrorCodes[ErrorCodes["SignalRConnectionFailed"] = -32018] = "SignalRConnectionFailed";
    ErrorCodes[ErrorCodes["DirectConnectionNotEnabled"] = -32020] = "DirectConnectionNotEnabled";
    ErrorCodes[ErrorCodes["RelayConnectionNotEnabled"] = -32021] = "RelayConnectionNotEnabled";
    ErrorCodes[ErrorCodes["CollaborationSessionUsersLimitReached"] = -32022] = "CollaborationSessionUsersLimitReached";
    ErrorCodes[ErrorCodes["CollaborationSessionGuestRejected"] = -32023] = "CollaborationSessionGuestRejected";
    ErrorCodes[ErrorCodes["CollaborationSessionRequestTimedOut"] = -32024] = "CollaborationSessionRequestTimedOut";
    ErrorCodes[ErrorCodes["CollaborationSessionGuestCanceled"] = -32025] = "CollaborationSessionGuestCanceled";
    ErrorCodes[ErrorCodes["CollaborationSessionNotFound"] = -32026] = "CollaborationSessionNotFound";
    ErrorCodes[ErrorCodes["CollaborationSessionEnded"] = -32027] = "CollaborationSessionEnded";
    ErrorCodes[ErrorCodes["CollaborationSessionGuestBlocked"] = -32028] = "CollaborationSessionGuestBlocked";
    ErrorCodes[ErrorCodes["NonSuccessHttpStatusCodeReceived"] = -32030] = "NonSuccessHttpStatusCodeReceived";
    ErrorCodes[ErrorCodes["KeychainAccessFailed"] = -32031] = "KeychainAccessFailed";
    ErrorCodes[ErrorCodes["UnauthorizedHttpStatusCode"] = -32032] = "UnauthorizedHttpStatusCode";
    ErrorCodes[ErrorCodes["ForbiddenHttpStatusCode"] = -32033] = "ForbiddenHttpStatusCode";
    ErrorCodes[ErrorCodes["RelayConnectionHostFailure"] = -32040] = "RelayConnectionHostFailure";
    ErrorCodes[ErrorCodes["RelayConnectionGuestFailure"] = -32041] = "RelayConnectionGuestFailure";
    ErrorCodes[ErrorCodes["RelayHubNotFoundFailure"] = -32045] = "RelayHubNotFoundFailure";
    ErrorCodes[ErrorCodes["RelayHubNoHostFailure"] = -32046] = "RelayHubNoHostFailure";
    ErrorCodes[ErrorCodes["RelayHubNotConnectedFailure"] = -32047] = "RelayHubNotConnectedFailure";
    ErrorCodes[ErrorCodes["BrokerNotAuthorized"] = -32050] = "BrokerNotAuthorized";
    ErrorCodes[ErrorCodes["CouldNotConnectToServerAuthFailed"] = -32060] = "CouldNotConnectToServerAuthFailed";
    ErrorCodes[ErrorCodes["RemoteLaunchNotEnabled"] = -32200] = "RemoteLaunchNotEnabled";
    ErrorCodes[ErrorCodes["CollaborationSessionGuestRejectedWithSpecificReason"] = -32300] = "CollaborationSessionGuestRejectedWithSpecificReason";
    ErrorCodes[ErrorCodes["OperationRejected"] = -32400] = "OperationRejected";
    ErrorCodes[ErrorCodes["OperationRejectedInReadOnlySession"] = -32401] = "OperationRejectedInReadOnlySession";
    ErrorCodes[ErrorCodes["OperationRejectedForNotOwner"] = -32402] = "OperationRejectedForNotOwner";
    ErrorCodes[ErrorCodes["OperationRejectedAsPersistentRootNotSupported"] = -32403] = "OperationRejectedAsPersistentRootNotSupported";
    ErrorCodes[ErrorCodes["FileOperationNotSupported"] = -32500] = "FileOperationNotSupported";
    ErrorCodes[ErrorCodes["ErrorFileAdditionFailed"] = -32501] = "ErrorFileAdditionFailed";
    ErrorCodes[ErrorCodes["ErrorFileDeleteFailed"] = -32502] = "ErrorFileDeleteFailed";
    ErrorCodes[ErrorCodes["ErrorFileRenameFailed"] = -32503] = "ErrorFileRenameFailed";
    ErrorCodes[ErrorCodes["FileAlreadyExists"] = -32504] = "FileAlreadyExists";
    ErrorCodes[ErrorCodes["ErrorFolderAdditionFailed"] = -32505] = "ErrorFolderAdditionFailed";
    ErrorCodes[ErrorCodes["ErrorFolderRenameFailed"] = -32506] = "ErrorFolderRenameFailed";
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
var TraceEventIds;
(function (TraceEventIds) {
    TraceEventIds[TraceEventIds["None"] = 0] = "None";
    TraceEventIds[TraceEventIds["AgentLogCreated"] = 1002] = "AgentLogCreated";
    TraceEventIds[TraceEventIds["AgentOutput"] = 2001] = "AgentOutput";
    TraceEventIds[TraceEventIds["CallingOutput"] = 10001] = "CallingOutput";
    TraceEventIds[TraceEventIds["RpcListeningOnPipe"] = 1001] = "RpcListeningOnPipe";
})(TraceEventIds = exports.TraceEventIds || (exports.TraceEventIds = {}));
var TraceSources;
(function (TraceSources) {
    TraceSources["Agent"] = "Agent";
    TraceSources["AgentAuth"] = "Agent.Auth";
    TraceSources["AgentCSharpLS"] = "Agent.CSharpLS";
    TraceSources["AgentFile"] = "Agent.File";
    TraceSources["AgentFirewall"] = "Agent.Firewall";
    TraceSources["AgentHttp"] = "Agent.Http";
    TraceSources["AgentProxy"] = "Agent.Proxy";
    TraceSources["AgentPortForwarding"] = "Agent.PortFowrading";
    TraceSources["AgentTcpListenersObserver"] = "Agent.TcpListeners";
    TraceSources["AgentRpc"] = "Agent.Rpc";
    TraceSources["AgentRpcAuth"] = "Agent.Rpc.Auth";
    TraceSources["AgentRpcChat"] = "Agent.Rpc.Chat";
    TraceSources["AgentRpcFile"] = "Agent.Rpc.File";
    TraceSources["AgentRpcFirewall"] = "Agent.Rpc.Firewall";
    TraceSources["AgentRpcServerSharing"] = "Agent.Rpc.ServerSharing";
    TraceSources["AgentRpcSourceEvent"] = "Agent.Rpc.SourceEvent";
    TraceSources["AgentRpcStream"] = "Agent.Rpc.Stream";
    TraceSources["AgentRpcStreamManager"] = "Agent.Rpc.StreamManager";
    TraceSources["AgentRpcStreamTransport"] = "Agent.Rpc.StreamTransport";
    TraceSources["AgentRpcTerminal"] = "Agent.Rpc.Terminal";
    TraceSources["AgentTerminalConnection"] = "Agent.Terminal.Connection";
    TraceSources["AgentRpcWorkspace"] = "Agent.Rpc.Workspace";
    TraceSources["AgentRpcWorkspaceUser"] = "Agent.Rpc.WorkspaceUser";
    TraceSources["AgentRpcTaskOutput"] = "Agent.Rpc.TaskOutput";
    TraceSources["AgentSsh"] = "Agent.Ssh";
    TraceSources["AgentTSLS"] = "Agent.TSLS";
    TraceSources["AgentWorkspace"] = "Agent.Workspace";
    TraceSources["AgentRpcServerSidePolicy"] = "Agent.Rpc.ServerSidePolicy";
    TraceSources["AgentWorkspaceSessionAccessControl"] = "Agent.WorkspaceSession.AccessControl";
    TraceSources["ClientAgent"] = "Client.Agent";
    TraceSources["ClientCoEditing"] = "Client.CoEditing";
    TraceSources["ClientCoEditingBufferManager"] = "Client.CoEditing.BufferManager";
    TraceSources["ClientCoEditingVSCodeEvent"] = "Client.CoEditing.VSCodeEvent";
    TraceSources["ClientFileProvider"] = "Client.FileProvider";
    TraceSources["ClientLauncher"] = "Client.Launcher";
    TraceSources["ClientRpc"] = "Client.Rpc";
    TraceSources["ClientRpcAgentSession"] = "Client.Rpc.AgentSession";
    TraceSources["ClientRpcAuth"] = "Client.Rpc.Auth";
    TraceSources["ClientRpcFile"] = "Client.Rpc.File";
    TraceSources["ClientRpcPortForwarding"] = "Client.Rpc.PortForwarding";
    TraceSources["ClientRpcServerSharing"] = "Client.Rpc.ServerSharing";
    TraceSources["ClientRpcSourceEvent"] = "Client.Rpc.SourceEvent";
    TraceSources["ClientRpcStream"] = "Client.Rpc.Stream";
    TraceSources["ClientRpcStreamManager"] = "Client.Rpc.StreamManager";
    TraceSources["ClientRpcTerminal"] = "Client.Rpc.Terminal";
    TraceSources["ClientRpcChat"] = "Client.Rpc.Chat";
    TraceSources["ClientRpcTerminalEndpoint"] = "Client.Rpc.TerminalEndpoint";
    TraceSources["ClientRpcWorkspace"] = "Client.Rpc.Workspace";
    TraceSources["ClientRpcWorkspaceUser"] = "Client.Rpc.WorkspaceUser";
    TraceSources["ClientRpcSessionContext"] = "Client.Rpc.SessionContext";
    TraceSources["ClientRpcContact"] = "Client.Rpc.Contact";
    TraceSources["ClientWorkspace"] = "Client.Workspace";
    TraceSources["ClientRemoteBuild"] = "Client.RemoteBuild";
    TraceSources["ClientCSharpLS"] = "Client.CSharpLS";
    TraceSources["ClientSharedTerminal"] = "Client.SharedTerminal";
    TraceSources["ClientWorkspaceAccessControl"] = "Client.Workspace.AccessControl";
    TraceSources["ClientAccessControl"] = "Client.AccessControl";
    TraceSources["ClientSearch"] = "Client.Search";
    TraceSources["ClientRpcServerSidePolicy"] = "Client.Rpc.ServerSidePolicy";
    TraceSources["ClientSourceControl"] = "Client.SourceControl";
    TraceSources["ClientSyncService"] = "Client.SyncService";
    TraceSources["ClientCommentService"] = "Client.CommentService";
    TraceSources["ClientGettingStartedPageContentProvider"] = "Client.GettingStartedPageContentProvider";
    TraceSources["ClientPortForwardingBrowser"] = "Client.PortForwardingBrowser";
    TraceSources["ClientOnlineEnvironmentSessionService"] = "Client.OnlineEnvironmentSessionService";
    TraceSources["ClientNotebook"] = "Client.Notebook";
    TraceSources["DebugHostAdapter"] = "Debug.HostAdapter";
    TraceSources["DebugRpcHostAdapter"] = "Debug.Rpc.HostAdapter";
    TraceSources["DebugAdapterHost"] = "Debug.AdapterHost";
    TraceSources["ForwardingTcpServer"] = "ForwardingTcpServer";
    TraceSources["ForwardingPipeServer"] = "ForwardingPipeServer";
    TraceSources["Telemetry"] = "Telemetry";
    TraceSources["ClientAccessCheck"] = "ClientAccessCheck";
    TraceSources["LSPCoauthoringManager"] = "LSP.CoauthoringManager";
    TraceSources["RemoteServiceBroker"] = "RemoteServiceBroker";
    TraceSources["ReviewsDiffs"] = "Reviews.Diffs";
    TraceSources["Cli"] = "CLI";
    TraceSources["CliRestore"] = "CLI.restore";
    TraceSources["CliStart"] = "CLI.start";
    TraceSources["CliStop"] = "CLI.stop";
    TraceSources["TTY"] = "TTY";
    TraceSources["Settings"] = "Settings";
    TraceSources["API"] = "API";
    TraceSources["VmAgent"] = "VmAgent";
    TraceSources["SelfHostedAgent"] = "SelfHostedAgent";
    TraceSources["EnvironmentConfig"] = "EnvConfig";
    TraceSources["VMConfig"] = "VMCFG";
    TraceSources["LinuxContainerUpdate"] = "LinuxContainerUpdate";
    TraceSources["ShutDownEnvironmentHandler"] = "ShutdownEnvironment";
    TraceSources["StartEnvironmentHandler"] = "StartEnvironment";
    TraceSources["VmAgentRpcService"] = "VmAgentRpcService";
    TraceSources["RebuildEnvironmentHandler"] = "RebuildEnvironment";
    TraceSources["WarmupEnvironmentHandler"] = "WarmupEnvironment";
    TraceSources["ResizeStorageHandler"] = "ResizeStorage";
    TraceSources["StartLiveShareHandler"] = "StartLiveShare";
    TraceSources["StartPortForwardingHandler"] = "StartPortForwardingHandler";
    TraceSources["ContainerEnvironmentMonitor"] = "ContainerMonitor";
    TraceSources["SSHServerMonitor"] = "SSHServerMonitor";
    TraceSources["ContainerTunnel"] = "ContainerTunnel";
    TraceSources["RunningContainerInfoProvider"] = "RunningContainerInfo";
    TraceSources["DevContainerChangesWatcher"] = "DevContainerChangesWatcher";
    TraceSources["VSCodeServerHostService"] = "VSCodeServerHostService";
    TraceSources["SshServerHostService"] = "SSHServerHostService";
    TraceSources["CodespaceHostService"] = "CodespaceHostService";
    TraceSources["ClientAutoSuspendMonitor"] = "ClientAutoSuspendMonitor";
    TraceSources["DockerImagePrune"] = "DockerImagePrune";
    TraceSources["PrebuildPoolUpdateHandler"] = "PrebuildPoolUpdate";
    TraceSources["StandAloneAgent"] = "StandAloneAgent";
    TraceSources["StopCodespacePolicyMonitor"] = "StopCodespacePolicy";
    TraceSources["GrpcService"] = "GrpcService";
    TraceSources["JupyterRpcService"] = "JupyterRpcService";
    TraceSources["Viewlet"] = "Viewlet";
    TraceSources["VSIX"] = "VSIX";
    TraceSources["ClientPrefix"] = "Client.";
    TraceSources["ClientLSP"] = "Client.LSP";
    TraceSources["LSPHost"] = "LSP.Host";
    TraceSources["BreakpointManager"] = "BreakpointManager";
    TraceSources["DebugAdapter"] = "Debug.Adapter";
    TraceSources["DebugRemote"] = "Debug.Remote";
    TraceSources["DebugSessionHost"] = "Debug.SessionHost";
    TraceSources["DebugHost"] = "Debug.Host";
    TraceSources["DebugRpcHost"] = "Debug.Rpc.Host";
    TraceSources["DebugTargetHostProcess"] = "Debug.TargetHostProcess";
    TraceSources["DebugRpcSessionHost"] = "Debug.Rpc.SessionHost";
})(TraceSources = exports.TraceSources || (exports.TraceSources = {}));
exports.AgentSessionService = {
    name: 'agentSessionService',
    methods: ['initializeSession', 'enableReconnect', 'keepAlive', 'forceKill'],
    events: [],
};
exports.AuthenticationCoreService = {
    methods: ['getCurrentAuthenticatedUser', 'getCurrentUser', 'removeRecentCollaborator', 'removeAllRecentCollaborators'],
    events: ['authenticationChanged'],
};
exports.AuthenticationService = {
    name: 'auth',
    methods: ['getLoginUri', 'findLoginCode', 'login', 'loginAsAnonymous', 'loginWithCachedToken', 'loginWithExternalToken', 'logout', 'getCachedToken', 'getCurrentAuthenticatedUser', 'getCurrentUser', 'removeRecentCollaborator', 'removeAllRecentCollaborators'],
    events: ['authenticationChanged'],
};
exports.BrokerAuthorizationService = {
    name: 'brokerAuthorization',
    methods: ['authorize'],
    events: [],
};
exports.BrokerManagerService = {
    name: 'brokerManager',
    methods: ['register', 'tryRevoke'],
    events: [],
};
exports.ChatService = {
    name: 'chat',
    methods: ['getMessageHistory', 'getParticipants', 'sendMessage', 'dispose'],
    events: ['messageReceived'],
};
exports.CommentService = {
    name: 'commentService',
    methods: ['createCommentThread', 'createComment', 'updateComment', 'deleteComment', 'getAllCommentThreads', 'getCommentThreadPositions', 'updateLike'],
    events: ['commentThreadChanged'],
};
exports.ConfigurationService = {
    name: 'version',
    methods: ['exchangeVersions', 'exchangeSettings', 'getSubnetMasks'],
    events: [],
};
exports.FirewallService = {
    name: 'firewall',
    methods: ['getFirewallStatus'],
    events: [],
};
exports.OnlineEnvironmentSessionService = {
    name: 'onlineEnvironmentLiveShareSessionService',
    methods: ['getSessionState', 'updateSessionState'],
    events: [],
};
exports.PortForwardingService = {
    name: 'portForwarding',
    methods: ['getSharedServers', 'getSharedPipes', 'getLastAccessTime', 'setDestinationPort'],
    events: ['sharingStarted', 'pipeSharingStarted', 'browseSharingStarted', 'sharingStopped', 'pipeSharingStopped', 'sharingChanged'],
};
exports.ServerSharingService = {
    name: 'serverSharing',
    methods: ['startSharing', 'startSharingPipe', 'stopSharing', 'stopSharingPipe', 'stopSharingBrowseSessions', 'getSharedServers', 'getSharedPipes', 'updateSessionName', 'updateSharedServerVisibility', 'updateSharedServerProtocol', 'updateSharedServerPrivacy'],
    voidMethods: ['invokeSharingSucceeded', 'invokeSharingFailed'],
    events: ['sharingStarted', 'pipeSharingStarted', 'browseSharingStarted', 'sharingStopped', 'pipeSharingStopped', 'sharingChanged', 'sharingSucceeded', 'sharingFailed'],
};
exports.ServerSidePolicyService = {
    name: 'serverSidePolicy',
    methods: ['setServerSidePolicies', 'getSetting', 'resetServerSidePolicies'],
    events: [],
};
exports.SessionContextService = {
    name: 'sessionContext',
    methods: ['getServiceNames'],
    voidMethods: ['sendSessionStateUpdateToClient', 'sendSessionStatusUpdateToClient'],
    events: ['sessionStateUpdate', 'sessionStatusUpdate'],
};
exports.SourceControlService = {
    name: 'sourceControl',
    methods: ['getAllSourceControls', 'getSourceControls', 'getSourceControl', 'getRecentVersions', 'getRecentVersionsTillMergeVersion', 'getDiffsForVersion', 'getDiffForResource', 'getResource', 'cleanResources', 'getMergeVersion', 'getRemoteVersionsNames', 'getCurrentVersionName'],
    events: ['sourceControlChanged', 'resourceChanged'],
};
exports.SyncService = {
    name: 'syncService',
    methods: ['checkSync', 'checkSyncForVersion', 'checkSyncForVersion2'],
    events: [],
};
exports.TaskOutputService = {
    name: 'taskOutput',
    methods: ['getTaskOutputs', 'shareTaskOutput', 'updateTaskOutputFeed', 'closeTaskOutput'],
    events: ['taskOutputShared', 'taskOutputFeedUpdated', 'taskOutputClosed'],
};
exports.TelemetryService = {
    name: 'telemetry',
    methods: ['initialize', 'getServiceUri'],
    events: ['genericOperation', 'fault'],
};
exports.TerminalEndpoint = {
    name: 'terminalEndpoint',
    methods: ['readBytes', 'writeBytes', 'readString', 'writeString'],
    events: [],
};
exports.TerminalService = {
    name: 'terminal',
    methods: ['startTerminal', 'getRunningTerminals', 'resizeTerminal', 'stopTerminal', 'clearTerminalBuffer', 'setTerminalReadOnlyForGuests'],
    events: ['terminalStarted', 'terminalResized', 'terminalStopped', 'terminalReadOnlyChanged'],
};
exports.TextSearchService = {
    name: 'textSearch',
    methods: ['getTextSearchResults', 'getTextSearchResultsWithProgress'],
    events: [],
};
exports.WorkspaceAccessControlService = {
    name: 'workspaceAccessControl',
    methods: ['getAccessControl', 'setAccessControl', 'requestOperationAccess', 'setOperationAccess', 'rejectOperation'],
    events: ['accessControlChanged', 'operationRejected', 'operationAccessChanged', 'opeationAccessRequested'],
};
exports.WorkspaceDiagnosticsService = {
    name: 'workspaceDiagnostics',
    methods: ['getDiagnostics'],
    events: ['diagnosticDataChanged'],
};
exports.WorkspaceService = {
    name: 'workspace',
    methods: ['getWorkspace', 'listWorkspaces', 'createPersistentWorkspace', 'deleteWorkspace', 'renameWorkspace', 'shareWorkspace', 'removeChatService', 'createInvitationLink', 'getInvitationLinks', 'unshareWorkspace', 'beginJoinWorkspace', 'joinWorkspace', 'unjoinWorkspace', 'registerServices', 'canUserShareWorkspace', 'canUserHostWorkspace', 'createPublicInviteLink', 'disconnectGuest', 'unjoinOnlineEnvironmentsGuests', 'setWorkspaceReadyForConnection', 'updateWorkspaceOwner'],
    events: ['servicesChanged', 'connectionStatusChanged', 'progressUpdated', 'userRemoved', 'userBlocked', 'workspaceReadyForConnection'],
};
exports.WorkspaceUserService = {
    name: 'workspaceuser',
    methods: ['acceptOrRejectGuest', 'autoAcceptGuests', 'removeUser', 'removeAllInteractiveUsers', 'fireProgressUpdatedToGuest', 'getCountOfGuestsWithSameAccount', 'createGuestDisplayName', 'getCachedGuestDisplayName', 'getGuestUserProfile', 'getCountOfInteractiveGuests'],
    events: ['workspaceSessionChanged'],
};
exports.LanguageServerProvider = {
    methods: ['getMetadata', 'request'],
    voidMethods: ['notify'],
    events: ['notified'],
};
exports.DebuggerHostService = {
    name: 'DebuggerHostService',
    methods: ['getCurrentDebugSessions', 'launchDebugSession', 'getLaunchConfigurations', 'isDebuggingSupported'],
    events: ['debugSessionChanged', 'launchConfigurationsChanged'],
};
exports.AccessControlService = {
    name: 'accessControl',
    methods: ['getAccessControl'],
    events: ['accessControlChanged'],
};
exports.FileService = {
    name: 'file',
    methods: ['registerExternalFiles', 'registerNamedExternalFiles', 'listRoots', 'list', 'readText', 'readTextWithProgress', 'writeText', 'createDirectory', 'delete', 'copy', 'move', 'getFiles', 'isExcluded', 'findFiles', 'getTextSearchResults', 'getTextSearchResultsWithProgress', 'clearRoots', 'addRoot', 'removeRoot', 'replaceRoot'],
    events: ['filesChanged', 'rootsChanged', 'externalFilesChanged'],
};
exports.SolutionViewService = {
    name: 'solutionView',
    methods: ['getSolutionMode', 'getSolutionCaption', 'getChildrenNodes', 'getRootNodes', 'addNewItem', 'renameItem', 'deleteItem'],
    events: ['solutionChanged', 'workspaceRootChanged'],
};
exports.SourceEventService = {
    name: 'sourceEvent',
    methods: ['fireEvent', 'setSourceData', 'getSourceData'],
    events: ['event'],
};
exports.StreamManagerService = {
    name: 'streamManager',
    methods: ['getStream'],
    events: [],
};
exports.StreamService = {
    name: 'stream',
    methods: ['getStreamTraits', 'getLength', 'setLength', 'seek', 'readBytes', 'writeBytes', 'disposeStream'],
    events: [],
};
exports.WorkspaceTaskService = {
    name: 'workspaceTask',
    methods: ['getSupportedTasks', 'getTaskExecutions', 'runTask', 'runProjectTask', 'runDefaultBuildTask', 'terminateTask'],
    events: ['taskStarted', 'taskTerminated'],
};
//# sourceMappingURL=VSLS.js.map

/***/ }),

/***/ "../../vsls-contracts/dist/src/index.js":
/*!**********************************************!*\
  !*** ../../vsls-contracts/dist/src/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vsls = void 0;
// export auto generated VSLS
exports.vsls = __webpack_require__(/*! ./contracts/VSLS */ "../../vsls-contracts/dist/src/contracts/VSLS.js");
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/client-hub/dist/src/WorkspaceHubClient.js":
/*!*****************************************************************!*\
  !*** ../../workspace/client-hub/dist/src/WorkspaceHubClient.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceHubClient = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
const vso_rpc_ssh_1 = __webpack_require__(/*! @vs/vso-rpc-ssh */ "../../rpc/ssh/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const workspaceNotJoined = 'workspace not joined';
class WorkspaceHubClient extends vscs_utils_1.DisposableClass {
    constructor(multiChannelRpcClient, logger) {
        super(logger);
        this.multiChannelRpcClient = multiChannelRpcClient;
        this.onHostConnectionChangedEmitter = new rpc.Emitter();
        this.onWorkspaceMetricsUpdatedEmitter = new rpc.Emitter();
        this.onProgressUpdatedEmitter = new rpc.Emitter();
        this.onHostConnectionChanged = this.onHostConnectionChangedEmitter.event;
        this.onWorkspaceMetricsUpdated = this.onWorkspaceMetricsUpdatedEmitter.event;
        this.onProgressUpdated = this.onProgressUpdatedEmitter.event;
        const fireHostConnectionChanged = (e) => {
            this.onHostConnectionChangedEmitter.fire(e);
        };
        let fireHostClosed = false;
        const fireHostConnectionClosed = (reason, e) => {
            if (!fireHostClosed) {
                logger.info(`firing host connection closed -> reason:${reason}`);
                fireHostClosed = true;
                fireHostConnectionChanged(e !== null && e !== void 0 ? e : {
                    state: vso_workspace_core_1.ConnectedState.Closed,
                    duration: 0,
                });
                this.disconnect().catch((error) => {
                    logger.info(`error while disconnecting workspace hub client`, (0, vscs_utils_1.errorToObject)(error));
                });
                this.dispose('host connection closed');
            }
        };
        multiChannelRpcClient.rpcConnection.onDispose(() => {
            // fire host closed if needed.
            fireHostConnectionClosed('onDisposed');
            // Note: if the rpc is being closed it is for 2 reasons, one of them is that we dispose this
            // instance or we are being closed because of the remote connection is dropped.
            if (!this.isDisposed) {
                logger.warning('Rpc connection was disposed from our hub service');
            }
        });
        const proxyLogger = logger.createChild('rpc');
        this.workspaceServiceClient = vso_rpc_1.RpcProxy.create(vso_workspace_core_1.workspaceServiceClient, this.rpcClient, new vso_logging_1.Logger(logger.name, (logLevel, message, ...args) => {
            // remove rpc verbose messages we know about
            if (message.startsWith('> workspaceServiceClient.workspaceMetricsUpdated') ||
                message.includes('workspaceServiceClient.checkConnection()')) {
                return;
            }
            proxyLogger.log(logLevel, message, ...args);
        }));
        // Route event from the hub
        this.workspaceServiceClient.onHostConnectionChanged((e) => {
            if (e.workspaceId === this.joinedWorkspaceId) {
                if (e.state === vso_workspace_core_1.ConnectedState.Closed) {
                    fireHostConnectionClosed('onHostConnectionChanged', e);
                }
                else {
                    fireHostConnectionChanged(e);
                }
            }
        });
        this.workspaceServiceClient.onWorkspaceMetricsUpdated((e) => {
            if (e.workspaceId === this.joinedWorkspaceId) {
                this.onWorkspaceMetricsUpdatedEmitter.fire(e);
            }
        });
        this.workspaceServiceClient.onProgressUpdated((e) => {
            if (e.workspaceId === this.joinedWorkspaceId) {
                this.onProgressUpdatedEmitter.fire(e);
            }
        });
        this.addToDisposables({
            dispose: () => fireHostConnectionClosed('disposed'),
        }, multiChannelRpcClient);
        this.rpcProxyCache = new vso_rpc_1.RpcProxyCache(this.multiChannelRpcClient, logger);
    }
    static create(transportStream, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiChannelRpcClient = yield (0, vso_rpc_ssh_1.createMultiChannelRpcClient)(transportStream, logger);
            return new WorkspaceHubClient(multiChannelRpcClient, logger);
        });
    }
    get rpcClient() {
        return this.multiChannelRpcClient;
    }
    getServiceProxy(serviceInfo) {
        return this.rpcProxyCache.getOrCreate(serviceInfo);
    }
    join(joinConnectOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            this.joinedWorkspaceId = joinConnectOptions.workspaceId;
            let workspaceSessionInfo;
            // if seesion factory defined it may be worth to retrieve the session info on the hub service.
            if (joinConnectOptions.sessionInfoFactory) {
                workspaceSessionInfo = yield this.workspaceServiceClient.getSessionInfoAsync(this.joinedWorkspaceId);
            }
            if (!workspaceSessionInfo) {
                try {
                    const liveshareConnectOptions = Object.assign({}, joinConnectOptions);
                    // Note: remove any properties that should not be serialize trough JSON
                    ['performance', 'sessionInfoFactory'].forEach(
                    // @ts-ignore
                    (key) => delete liveshareConnectOptions[key]);
                    // delete any mock keys
                    Object.keys(liveshareConnectOptions)
                        .filter((k) => k.startsWith('mock'))
                        // @ts-ignore
                        .forEach((k) => delete liveshareConnectOptions[k]);
                    if (joinConnectOptions.sessionInfoFactory) {
                        liveshareConnectOptions.connectionInfo = yield joinConnectOptions.sessionInfoFactory(this.joinedWorkspaceId);
                    }
                    workspaceSessionInfo = yield this.workspaceServiceClient.joinAsync(liveshareConnectOptions);
                }
                catch (err) {
                    if (err instanceof rpc.ResponseError) {
                        if (err.code === vso_workspace_core_1.RPC_ERR_NO_HOST_NOT_CONNECTED) {
                            throw new vso_workspace_core_1.NoHostConnectedError(err.data);
                        }
                        else if (err.code === vso_workspace_core_1.RPC_ERR_RELAY_CONNECTIONY_SSH) {
                            throw new vso_workspace_core_1.RelayConnectionError(err.message, err.data);
                        }
                    }
                    throw err;
                }
            }
            const time = (Date.now() - start).toFixed(1);
            this.trace.info(`join completed -> time:${time} session:${workspaceSessionInfo.sessionNumber} conversation:${workspaceSessionInfo.conversationId}`);
            return workspaceSessionInfo;
        });
    }
    openStreamingChannel(streamId, cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(this.joinedWorkspaceId, 'Workspace not joined.');
            // open the channel and then open a remote stream channel on the hub and wait
            const [sshChannel] = yield Promise.all([
                this.multiChannelRpcClient.multiChannelStream.openChannel(),
                this.workspaceServiceClient.openStreamingChannelAsync(this.joinedWorkspaceId, streamId, cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : rpc.CancellationToken.None),
            ]);
            return sshChannel;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(this.joinedWorkspaceId, workspaceNotJoined);
            yield this.workspaceServiceClient.disconnectAsync(this.joinedWorkspaceId);
            this.dispose();
        });
    }
    keepAlive(time) {
        return this.workspaceServiceClient.keepAliveAsync(time);
    }
    checkConnection(cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(this.joinedWorkspaceId, workspaceNotJoined);
            yield this.workspaceServiceClient.checkConnectionAsync(this.joinedWorkspaceId, cancellationToken);
        });
    }
    setCheckConnectionOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(this.joinedWorkspaceId, workspaceNotJoined);
            yield this.workspaceServiceClient.setCheckConnectionOptionsAsync(this.joinedWorkspaceId, options);
        });
    }
}
exports.WorkspaceHubClient = WorkspaceHubClient;
//# sourceMappingURL=WorkspaceHubClient.js.map

/***/ }),

/***/ "../../workspace/client-hub/dist/src/index.js":
/*!****************************************************!*\
  !*** ../../workspace/client-hub/dist/src/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceHubClient = void 0;
var WorkspaceHubClient_1 = __webpack_require__(/*! ./WorkspaceHubClient */ "../../workspace/client-hub/dist/src/WorkspaceHubClient.js");
Object.defineProperty(exports, "WorkspaceHubClient", ({ enumerable: true, get: function () { return WorkspaceHubClient_1.WorkspaceHubClient; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/client/dist/src/SshHelpers.js":
/*!*****************************************************!*\
  !*** ../../workspace/client/dist/src/SshHelpers.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNode = exports.SshHelpers = void 0;
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const websocket_1 = __webpack_require__(/*! websocket */ "../../node_modules/websocket/index.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
const strings_nls_json_1 = __importDefault(__webpack_require__(/*! ./strings.nls.json */ "../../workspace/client/dist/src/strings.nls.json"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class SshHelpers {
    static getRelayUri(workspace, action) {
        if (!workspace.relayLink) {
            throw new Error('Workspace does not have a relay endpoint.');
        }
        // Reference:
        // https://github.com/Azure/azure-relay-node/blob/7b57225365df3010163bf4b9e640868a02737eb6/hyco-ws/index.js#L107-L137
        const relayUri = workspace.relayLink.replace('sb:', 'wss:').replace('.net/', '.net:443/$hc/') +
            `?sb-hc-action=${action}&sb-hc-token=` +
            encodeURIComponent(workspace.relaySas || '');
        return relayUri;
    }
    static openConnection(workspaceConnectionInfo, logger) {
        const relayUri = SshHelpers.getRelayUri(workspaceConnectionInfo, 'connect');
        logger.log(vso_logging_1.LogLevel.Debug, `connecting to relay link:${workspaceConnectionInfo.relayLink}`);
        if ((0, exports.isNode)()) {
            logger.log(vso_logging_1.LogLevel.Debug, `creating node SSH...`);
            return (0, vscs_utils_1.timeoutPromise)(SshHelpers.nodeSshStreamFactory(relayUri, workspaceConnectionInfo), this.connectionTimeout, new vso_workspace_core_1.RelayConnectionTimeoutError('Timed out creating node SSH stream'));
        }
        logger.log(vso_logging_1.LogLevel.Debug, `creating web SSH...`);
        return (0, vscs_utils_1.timeoutPromise)(SshHelpers.webSshStreamFactory(new WebSocket(relayUri)), this.connectionTimeout, new vso_workspace_core_1.RelayConnectionTimeoutError('Timed out creating web SSH stream'));
    }
    static createSshClientSession() {
        return SshHelpers.createSshSession((config) => new ssh.SshClientSession(config));
    }
    static createSshServerSession(reconnectableSessions) {
        return SshHelpers.createSshSession((config) => new ssh.SshServerSession(config, reconnectableSessions));
    }
    static authenticate(sshSession, workspaceInfo, workspaceAccess, socketStream, clientAuthenticatedCompletion) {
        return __awaiter(this, void 0, void 0, function* () {
            // The client authenticates over SSH using the workspace session token.
            const clientCredentials = {
                username: '',
                password: workspaceAccess.sessionToken,
            };
            // The server authenticates over SSH via a public key.
            sshSession.onAuthenticating((e) => {
                // At this point the SSH protocol has already validated that the server holds
                // the private key that corresponds to the public key in e.key. So we just need
                // to check if the public key matches one of the host keys published for the workspace.
                e.authenticationPromise = SshHelpers.authenticateServer(workspaceInfo, e.publicKey);
            });
            yield sshSession.connect(socketStream);
            if (!(yield sshSession.authenticateServer())) {
                throw new Error('Live Share server authentication failed.');
            }
            if (clientAuthenticatedCompletion) {
                // A completion was supplied. Send the client authentication request but don't
                // directly wait for the response. Route the response to the completion instead.
                yield sshSession.authenticateClient(clientCredentials, (err, result) => {
                    if (!err && !result) {
                        // Convert from a false result to an Error.
                        err = new Error('Live Share client authentication failed.');
                    }
                    if (err) {
                        clientAuthenticatedCompletion.reject(err);
                    }
                    else {
                        clientAuthenticatedCompletion.resolve(err);
                    }
                });
            }
            else {
                // No completion was supplied, so just wait for full client authentication now.
                if (!(yield sshSession.authenticateClient(clientCredentials))) {
                    throw new Error('Live Share client authentication failed.');
                }
            }
            return sshSession;
        });
    }
    static createWebSocketStreamAdapter(connection) {
        return new ssh.WebSocketStream(new WebsocketStreamAdapter(connection));
    }
    static webSshStreamFactory(socket) {
        socket.binaryType = 'arraybuffer';
        return new Promise((resolve, reject) => {
            const relayError = 'Failed to connect to relay url';
            socket.onopen = () => {
                resolve(new ssh.WebSocketStream(socket));
            };
            socket.onerror = () => {
                /**
                 * When the socket is connected and an error occurs then `onclose` event (containing error information) occurs after `onerror`.
                 * However, the promise is already rejected by `onerror` and we loose the error information, hence the timeout helps.
                 * We need the `onerror` event to handle errors when the socket fails to connect.
                 */
                setTimeout(() => reject(new Error(relayError)), 100);
            };
            socket.onclose = (e) => {
                if (e.code !== 1000) {
                    reject(new Error(`${relayError} Code: ${e.code} Reason: ${e.reason}`));
                }
            };
        });
    }
    static createSshSession(factoryCallback) {
        const config = new ssh.SshSessionConfiguration();
        config.keyExchangeAlgorithms.splice(0);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);
        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);
        config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionReconnect);
        config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionLatency);
        return factoryCallback(config);
    }
    static nodeSshStreamFactory(relayUri, workspaceConnectionInfo) {
        const client = new websocket_1.client();
        return new Promise((resolve, reject) => {
            client.on('connect', (connection) => {
                resolve(new ssh.WebSocketStream(new WebsocketStreamAdapter(connection)));
            });
            client.on('connectFailed', (e) => {
                if (e.message && e.message.startsWith('Error: ')) {
                    e.message = e.message.substr(7);
                }
                let errorType = vso_workspace_core_1.RelayErrorType.ServerError;
                // Unfortunately the status code can only be obtained from the error message.
                // Also status 404 may be used for at least two distinct error conditions.
                // So we have to match on the error message text. This could break when
                // the relay server behavior changes or when updating the client websocket library.
                // But then in the worst case the original error message will be reported.
                if (/status: 401/.test(e.message)) {
                    e.message = strings_nls_json_1.default['error.relaySasInvalid'];
                    errorType = vso_workspace_core_1.RelayErrorType.SasInvalid;
                }
                else if (/status: 404 Endpoint does not exist/.test(e.message)) {
                    e.message = strings_nls_json_1.default['error.relayEndpointNotFound'];
                    errorType = vso_workspace_core_1.RelayErrorType.EndpointNotFound;
                }
                else if (/status: 404 There are no listeners connected/.test(e.message)) {
                    e.message = strings_nls_json_1.default['error.relayListenerOffline'];
                    errorType = vso_workspace_core_1.RelayErrorType.ListenerOffline;
                }
                else if (/status: 500/.test(e.message)) {
                    e.message = strings_nls_json_1.default['error.relayServerError'];
                    errorType = vso_workspace_core_1.RelayErrorType.ServerError;
                }
                else {
                    // Other errors are most likely connectivity issues.
                    // The original error message may have additional helpful details.
                    e.message = strings_nls_json_1.default['error.relayConnectionError'] + ' ' + e.message;
                }
                reject(new vso_workspace_core_1.RelayConnectionError(e.message, {
                    errorType,
                    workspaceConnectionInfo,
                }));
            });
            client.connect(relayUri, undefined, undefined, undefined, {
                agent: workspaceConnectionInfo.proxyAgent,
            });
        });
    }
    static authenticateServer(workspaceInfo, serverKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const rsa = ssh.SshAlgorithms.publicKey.rsaWithSha512;
            const serverKeyBytes = (yield serverKey.getPublicKeyBytes());
            for (const knownHostKey of (workspaceInfo && workspaceInfo.hostPublicKeys) || []) {
                // Get the public key bytes using the matching algorithm name to ensure a valid comparison.
                const hostKey = rsa.createKeyPair();
                yield hostKey.setPublicKeyBytes(Buffer.from(knownHostKey, 'base64'));
                const hostKeyBytes = (yield hostKey.getPublicKeyBytes());
                if (serverKeyBytes.equals(hostKeyBytes)) {
                    // Returning a non-null object indicates successful authentication.
                    // (We're not using the principal here.)
                    const serverPrincipal = {};
                    return serverPrincipal;
                }
            }
            return null;
        });
    }
}
exports.SshHelpers = SshHelpers;
SshHelpers.connectionTimeout = 20000;
/**
 * Partially adapts a Node websocket connection object to the browser websocket API,
 * enough so that it can be used as an SSH stream.
 */
class WebsocketStreamAdapter {
    constructor(connection) {
        this.connection = connection;
    }
    set onmessage(messageHandler) {
        if (messageHandler) {
            this.connection.on('message', (message) => {
                // This assumes all messages are binary.
                messageHandler({ data: message.binaryData });
            });
        }
        else {
            // Removing event handlers is not implemented.
        }
    }
    set onclose(closeHandler) {
        if (closeHandler) {
            this.connection.on('close', (code, reason) => {
                closeHandler({ code, reason, wasClean: !(code || reason) });
            });
        }
        else {
            // Removing event handlers is not implemented.
        }
    }
    send(data) {
        if (Buffer.isBuffer(data)) {
            this.connection.sendBytes(data);
        }
        else {
            this.connection.sendBytes(Buffer.from(data));
        }
    }
    close(code, reason) {
        if (code || reason) {
            this.connection.drop(code, reason);
        }
        else {
            this.connection.close();
        }
    }
}
const isNode = () => typeof process !== 'undefined' &&
    typeof process.release !== 'undefined' &&
    process.release.name === 'node';
exports.isNode = isNode;
//# sourceMappingURL=SshHelpers.js.map

/***/ }),

/***/ "../../workspace/client/dist/src/SshWorkspaceSession.js":
/*!**************************************************************!*\
  !*** ../../workspace/client/dist/src/SshWorkspaceSession.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshWorkspaceSession = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
class SshWorkspaceSession extends vscs_utils_1.DisposableClass {
    constructor(sshSession, authCompletion, logger, reconnectCallback) {
        super(logger);
        this.sshSession = sshSession;
        this.authCompletion = authCompletion;
        this.onConnectedStateChangedEmitter = new vscode_jsonrpc_1.Emitter();
        this.isReconnectingFlag = false;
        this.onConnectedStateChanged = this.onConnectedStateChangedEmitter.event;
        this.addToDisposables(sshSession, sshSession.onDisconnected((e) => {
            if (reconnectCallback) {
                this.isReconnectingFlag = true;
                this.onConnectedStateChangedEmitter.fire({
                    state: vso_workspace_core_1.ConnectedState.Reconnecting,
                    retryCount: 0,
                });
                reconnectCallback()
                    .then((result) => {
                    this.isReconnectingFlag = false;
                    this.onConnectedStateChangedEmitter.fire({
                        state: result.error === undefined
                            ? vso_workspace_core_1.ConnectedState.Reconnected
                            : vso_workspace_core_1.ConnectedState.Closed,
                        retryCount: result.retryCount,
                        error: result.error,
                    });
                })
                    .catch((err) => {
                    this.isReconnectingFlag = false;
                    // ignore err
                });
            }
            else {
                this.isReconnectingFlag = false;
                this.onConnectedStateChangedEmitter.fire({
                    state: vso_workspace_core_1.ConnectedState.Closed,
                    retryCount: 0,
                });
                this.dispose('auto reconnect disabled');
            }
        }));
    }
    get isReconnecting() {
        return this.isReconnectingFlag;
    }
    createRpcMessageStream() {
        return __awaiter(this, void 0, void 0, function* () {
            const channelRequest = new ssh.ChannelRequestMessage();
            channelRequest.requestType = 'json-rpc';
            channelRequest.wantReply = true;
            const channel = yield this.sshSession.openChannel(null, channelRequest);
            return new ssh.SshRpcMessageStream(channel);
        });
    }
    openStreamingChannel(streamId, cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sshSession) {
                throw new Error('Ssh session not initiated yet');
            }
            const channel = yield this.sshSession.openChannel();
            const channelRequestType = `stream-transport-${streamId}`;
            const result = yield channel.request(new ssh.ChannelRequestMessage(channelRequestType), cancellationToken);
            if (!result) {
                throw new Error(`Failed to create stream transport channel with streamId - ${streamId}`);
            }
            return channel;
        });
    }
}
exports.SshWorkspaceSession = SshWorkspaceSession;
//# sourceMappingURL=SshWorkspaceSession.js.map

/***/ }),

/***/ "../../workspace/client/dist/src/SshWorkspaceSessionFactory.js":
/*!*********************************************************************!*\
  !*** ../../workspace/client/dist/src/SshWorkspaceSessionFactory.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SshWorkspaceSessionFactory = void 0;
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const SshHelpers_1 = __webpack_require__(/*! ./SshHelpers */ "../../workspace/client/dist/src/SshHelpers.js");
const SshWorkspaceSession_1 = __webpack_require__(/*! ./SshWorkspaceSession */ "../../workspace/client/dist/src/SshWorkspaceSession.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "../../node_modules/debug/src/index.js"));
const maxConnectionRetries = 3;
const connectionRetryWaitTime = 5 * vscs_utils_1.TIME_SECOND_MS; // 5 secs
const sessionConnectionTimeout = 20 * vscs_utils_1.TIME_SECOND_MS; // 20 secs
const defaultMaxTimeReconnect = 60 * vscs_utils_1.TIME_SECOND_MS; // around 1 min
const defaultRetryTimeout = 5 * vscs_utils_1.TIME_SECOND_MS; // 5 secs
const maxReconnectTimeout = 60 * vscs_utils_1.TIME_SECOND_MS; // 60 secs
class SshWorkspaceSessionFactory {
    static createSshWorkspaceSession(sessionInfo, logger, checkConnectionMutex, socketStreamFactory, sshReconnectOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const streamFactory = socketStreamFactory || SshHelpers_1.SshHelpers.openConnection;
            // Enable SSH protocol tracing and route it to the current logger. For now this
            // uses static properties on the `debug` package; currently that package is
            // instanced because this package references a different version than others.
            // If package versions are consolidated, the settings here could have broader impact.
            // TODO: Consider supporting a more flexible logging interface in the SSH lib.
            const sshTrace = logger.createChild('ssh');
            debug_1.default.enable(debug_1.default.disable() + ',vs-ssh');
            if (typeof debug_1.default.inspectOpts === 'object') {
                debug_1.default.inspectOpts.hideDate = true;
            }
            const defaultLog = debug_1.default.log;
            debug_1.default.log = function (...args) {
                if (this.namespace === 'vs-ssh') {
                    sshTrace.info(args[0], ...args.slice(1));
                }
                else {
                    defaultLog();
                }
            };
            const reconnectOptions = sshReconnectOptions || { enabled: true };
            let socketStream = yield streamFactory(sessionInfo, logger);
            let sshSession = yield SshHelpers_1.SshHelpers.createSshClientSession();
            let clientAuthCompletion = new ssh.PromiseCompletionSource();
            let result = false;
            yield (0, vscs_utils_1.withRetries)((retriesLeft) => __awaiter(this, void 0, void 0, function* () {
                const retry = maxConnectionRetries - retriesLeft;
                logger.verbose(`Trying to create an ssh client session retries left: '${retriesLeft}' (retry: '${retry}')`);
                if (retry > 0) {
                    socketStream = yield streamFactory(sessionInfo, logger);
                    sshSession = yield SshHelpers_1.SshHelpers.createSshClientSession();
                    clientAuthCompletion = new ssh.PromiseCompletionSource();
                }
                try {
                    logger.verbose(`authenticating...`);
                    yield (0, vscs_utils_1.timeoutPromise)(SshHelpers_1.SshHelpers.authenticate(sshSession, sessionInfo, sessionInfo, socketStream, clientAuthCompletion), sessionConnectionTimeout);
                    result = true;
                }
                catch (err) {
                    yield sshSession.close(ssh.SshDisconnectReason.byApplication);
                    yield socketStream.close();
                    clientAuthCompletion.resolve();
                    const message = `Could not connect to ssh session, retry. err: ${err} `;
                    logger.verbose(message);
                    throw new Error(message);
                }
            }), {
                retries: maxConnectionRetries,
                retryDelay: connectionRetryWaitTime,
            });
            if (!result) {
                throw new Error('Could not connect to ssh session');
            }
            const reconnect = () => __awaiter(this, void 0, void 0, function* () {
                const maxTimeReconnect = reconnectOptions.maxTimeReconnect || defaultMaxTimeReconnect;
                const retryTimeout = reconnectOptions.retryTimeout || defaultRetryTimeout;
                logger.info(`reconnect started maxTimeReconnect:${maxTimeReconnect} retryTimeout:${retryTimeout}`);
                const start = Date.now();
                let retryCount = 1;
                let error;
                while (Date.now() - start <= maxTimeReconnect && !sshSession.isClosed) {
                    try {
                        socketStream = yield streamFactory(sessionInfo, logger);
                        logger.info(`reconnecting ssh session retryCount:${retryCount}`);
                        // socket connection has been reestablished. Only one request can
                        // be made to vs-ssh at a time. There could be a checkConnection
                        // heartbeat in flight. We need to wait for that to be canceled
                        // before making the reconnect request.
                        yield (0, vscs_utils_1.timeoutPromise)(checkConnectionMutex.dispatch(() => sshSession.reconnect(socketStream)), maxReconnectTimeout, new Error('timeout on ssh reconnection'));
                        logger.info(`ssh session successfully reconnected on retryCount:${retryCount} time:${(Date.now() - start).toFixed(1)}`);
                        error = undefined;
                        break;
                    }
                    catch (e) {
                        error = e;
                        if (e instanceof ssh.SshReconnectError) {
                            // Retry is not likely to succeed after an SshReconnectError
                            logger.error(`failed to reconnect ssh session: ${e.message}`);
                            break;
                        }
                        logger.verbose(`failed to reconnect ssh session retryCount:${retryCount} error:${e}`);
                        // wait for 5 secs to retry.
                        yield (0, vscs_utils_1.wait)(retryTimeout);
                    }
                    ++retryCount;
                }
                // if error log & dispose the ssh session.
                if (error) {
                    logger.error(`unable to reconnect ssh session -> retryCount:${retryCount}`);
                    sshSession.dispose();
                }
                return {
                    retryCount,
                    error,
                };
            });
            return new SshWorkspaceSession_1.SshWorkspaceSession(sshSession, clientAuthCompletion.promise, logger.createChild('SshWorkspaceSession'), reconnectOptions.enabled ? reconnect : undefined);
        });
    }
}
exports.SshWorkspaceSessionFactory = SshWorkspaceSessionFactory;
//# sourceMappingURL=SshWorkspaceSessionFactory.js.map

/***/ }),

/***/ "../../workspace/client/dist/src/WorkspaceClient.js":
/*!**********************************************************!*\
  !*** ../../workspace/client/dist/src/WorkspaceClient.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceClient = void 0;
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
const vsls_contracts_1 = __webpack_require__(/*! @vs/vsls-contracts */ "../../vsls-contracts/dist/src/index.js");
const SshWorkspaceSessionFactory_1 = __webpack_require__(/*! ./SshWorkspaceSessionFactory */ "../../workspace/client/dist/src/SshWorkspaceSessionFactory.js");
const vso_telemetry_1 = __webpack_require__(/*! @vs/vso-telemetry */ "../../telemetry/core/dist/src/index.js");
const dev_tunnels_ssh_1 = __webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js");
class WorkspaceClient extends vso_workspace_core_1.WorkspaceClientBase {
    constructor(logger, socketStreamFactory, sshReconnectOptions) {
        super(new vso_rpc_1.RpcClient({
            create: (rpcClient) => this.rpcConnected.promise,
        }, logger), logger);
        this.socketStreamFactory = socketStreamFactory;
        this.sshReconnectOptions = sshReconnectOptions;
        this.checkConnectionMutex = new vscs_utils_1.Mutex();
        this.rpcConnected = new vscs_utils_1.Signal();
    }
    join(joinConnectOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const performance = (_a = joinConnectOptions.performance) !== null && _a !== void 0 ? _a : {
                measure: (options, callback) => {
                    return callback();
                },
            };
            (0, vscs_utils_1.assertDefined)(joinConnectOptions.connectionInfo ||
                joinConnectOptions.sessionInfoFactory ||
                joinConnectOptions.liveShareEndpoint.length !== 0, 'join connect options expected');
            const sessionInfo = yield vso_telemetry_1.TelemetryUtil.sendTelemetryForPromise(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +
                vso_workspace_core_1.TelemetryEventNames.WORKSPACE_GET_SESSION_INFO, () => this.getSessionInfo(joinConnectOptions, performance));
            // throw if host not connected
            if (sessionInfo.isHostConnected === false) {
                throw new vso_workspace_core_1.NoHostConnectedError(joinConnectOptions.workspaceId);
            }
            // create the workspace session
            this.sshWorkspaceSession = yield vso_telemetry_1.TelemetryUtil.sendTelemetryForPromise(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME + vso_workspace_core_1.TelemetryEventNames.WORKSPACE_CREATE_SESSION, () => this.createWorkspaceSession(performance, sessionInfo));
            performance
                .measure({
                id: 'ssh-auth-completion',
                name: 'Ssh auth completion',
            }, () => this.sshWorkspaceSession.authCompletion)
                .catch((err) => {
                this.trace.error('auth failed');
            });
            this.addToDisposables(this.sshWorkspaceSession);
            const sshSession = this.sshWorkspaceSession.sshSession;
            // hookup metrics events
            const fireMetricsUpdated = (bytesIn, bytesOut, latency) => {
                this.onWorkspaceMetricsUpdatedEmitter.fire({
                    bytesIn,
                    bytesOut,
                    latency,
                });
            };
            sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onMessageReceived(() => {
                fireMetricsUpdated(sshSession.metrics.bytesReceived, undefined, undefined);
            });
            sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onMessageSent(() => {
                fireMetricsUpdated(undefined, sshSession.metrics.bytesSent, undefined);
            });
            sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onLatencyUpdated(() => {
                const latency = new vso_workspace_core_1.LatencyMetrics(sshSession.metrics.latencyCurrentMs, sshSession.metrics.latencyAverageMs, sshSession.metrics.latencyMinMs, sshSession.metrics.latencyMaxMs);
                fireMetricsUpdated(undefined, undefined, latency);
            });
            this.trace.info(`join started`);
            const { clientVersionInfo, workspaceJoinInfo, clientCapabilities } = joinConnectOptions;
            const joinPromise = performance.measure({
                id: 'join-internal',
                name: 'Joining the workspace',
            }, () => this.joinInternal(sessionInfo, clientVersionInfo !== null && clientVersionInfo !== void 0 ? clientVersionInfo : {}, workspaceJoinInfo, clientCapabilities));
            yield vso_telemetry_1.TelemetryUtil.sendTelemetryForPromise(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME + vso_workspace_core_1.TelemetryEventNames.WORKSPACE_JOIN, () => { var _a; return Promise.all([(_a = this.sshWorkspaceSession) === null || _a === void 0 ? void 0 : _a.authCompletion, joinPromise]); });
            this.onWorkspaceSessionConnectionChange(joinConnectOptions);
            // if check connection options is enabled.
            if (joinConnectOptions.checkConnectionOptions) {
                yield this.setCheckConnectionOptions(joinConnectOptions.checkConnectionOptions);
            }
            return this.workspaceSessionInfo;
        });
    }
    ensureIsJoined() {
        (0, vscs_utils_1.assertDefined)(this.sshWorkspaceSession, 'Ssh session not initiated yet');
    }
    canCheckConnection() {
        var _a;
        return ((_a = this.sshWorkspaceSession) === null || _a === void 0 ? void 0 : _a.isReconnecting) === false;
    }
    createWorkspaceSession(performance, sessionInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield performance.measure({
                id: 'createSshWorkspaceSession',
                name: 'Creating the ssh workspace session',
            }, () => SshWorkspaceSessionFactory_1.SshWorkspaceSessionFactory.createSshWorkspaceSession(sessionInfo, this.trace, this.checkConnectionMutex, this.socketStreamFactory, this.sshReconnectOptions));
        });
    }
    onWorkspaceSessionConnectionChange(joinConnectOptions) {
        var _a;
        // wire up reconnection
        const sendReconnectEvent = (elapsed, result) => {
            var _a;
            const reconnectEvent = new vso_telemetry_1.TelemetryEvent(vso_workspace_core_1.TelemetryEventNames.WORKSPACE_RECONNECT);
            const telemetryProperties = joinConnectOptions.telemetryProperties;
            if (telemetryProperties) {
                Object.keys(telemetryProperties).forEach((key) => reconnectEvent.addProperty(key, telemetryProperties[key]));
            }
            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +
                vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_SUCCEEDED, result.error === undefined ? true : false);
            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME + vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ELAPSED, elapsed);
            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +
                vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_RETRY_COUNT, result.retryCount);
            if (result.error !== undefined) {
                if (result.error instanceof ssh.SshReconnectError) {
                    const reason = (_a = result.error.reason) !== null && _a !== void 0 ? _a : ssh.SshReconnectFailureReason.unknownClientFailure;
                    reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +
                        vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ERROR_REASON, reason);
                }
                reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +
                    vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ERROR_MESSAGE, result.error.message);
            }
            reconnectEvent.send();
        };
        let start;
        (_a = this.sshWorkspaceSession) === null || _a === void 0 ? void 0 : _a.onConnectedStateChanged((e) => {
            const elapsed = start ? Date.now() - start : 0;
            if (e.state === vso_workspace_core_1.ConnectedState.Reconnecting) {
                start = Date.now();
            }
            else if (e.state === vso_workspace_core_1.ConnectedState.Reconnected) {
                if (start) {
                    sendReconnectEvent(elapsed, e);
                }
                start = undefined;
            }
            else if (e.state === vso_workspace_core_1.ConnectedState.Closed) {
                if (start) {
                    sendReconnectEvent(elapsed, e);
                }
                start = undefined;
            }
            this.onHostConnectionChangedEmitter.fire({
                state: e.state,
                duration: elapsed,
            });
        });
        this.trace.info(`join completed`);
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.workspaceSessionInfo) {
                const sessionInfo = this.workspaceSessionInfo;
                this.workspaceSessionInfo = undefined;
                this.trace.info(`unjoing`);
                yield this.getServiceProxy(vsls_contracts_1.vsls.WorkspaceService).unjoinWorkspaceAsync(sessionInfo.id);
                this.dispose('disconnect');
            }
        });
    }
    getSessionInfo(joinConnectOptions, performance) {
        return __awaiter(this, void 0, void 0, function* () {
            if (joinConnectOptions.connectionInfo) {
                return joinConnectOptions.connectionInfo;
            }
            else if (joinConnectOptions.sessionInfoFactory) {
                return yield joinConnectOptions.sessionInfoFactory(joinConnectOptions.workspaceId);
            }
            else {
                return yield performance.measure({
                    id: 'workspaceApi-getWorkspaceSessionInfo',
                    name: 'get workspace session info from liveshare',
                }, () => vso_workspace_core_1.WorkspaceApi.getWorkspaceSessionInfo(joinConnectOptions.workspaceId, joinConnectOptions, this.trace.createChild('WorkspaceApi')));
            }
        });
    }
    joinInternal(sessionInfo, clientVersionInfo, workspaceJoinInfo, clientCapabilities) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcStream = yield this.sshWorkspaceSession.createRpcMessageStream();
            // Note: we want to wrap the 'raw' ssh rpc reader stream
            const joinMessages = [];
            const listen = rpcStream.reader.listen.bind(rpcStream.reader);
            let dataCallback;
            const listenWrapper = (callback) => {
                dataCallback = callback;
                listen((data) => {
                    if (!this.rpcConnected.isFulfilled && data.hasOwnProperty('method')) {
                        joinMessages.push(data);
                    }
                    callback(data);
                });
            };
            // inject the listen wrapper
            rpcStream.reader.listen = listenWrapper;
            const rpcConnection = this.rcpClientInstance.createRpcConnection(rpcStream, this.trace);
            rpcConnection.listen();
            const configClient = this.getServiceProxyWithConnection(rpcConnection, vsls_contracts_1.vsls.ConfigurationService);
            const hostVersionInfo = yield configClient.exchangeVersionsAsync({}, clientVersionInfo);
            this.trace.info('Host version: ' + JSON.stringify(hostVersionInfo));
            if (!clientCapabilities) {
                clientCapabilities = new vsls_contracts_1.vsls.ClientCapabilities();
                clientCapabilities.isNonInteractive = false;
            }
            // default workspace join info
            let joinInfo = {
                id: sessionInfo.id,
                connectionMode: vsls_contracts_1.vsls.ConnectionMode.Local,
                joiningUserSessionToken: sessionInfo.sessionToken,
                clientCapabilities,
            };
            if (workspaceJoinInfo) {
                joinInfo = Object.assign(Object.assign({}, joinInfo), workspaceJoinInfo);
            }
            const workspaceService = this.getServiceProxyWithConnection(rpcConnection, {
                name: vsls_contracts_1.vsls.WorkspaceService.name,
                methods: vsls_contracts_1.vsls.WorkspaceService.methods,
                voidMethods: vsls_contracts_1.vsls.WorkspaceService.voidMethods,
                events: vsls_contracts_1.vsls.WorkspaceService.events,
            });
            // onServicesChanged will be invoked
            // before joinWorkspaceAsync completes
            let serviceNames = [];
            workspaceService.onServicesChanged((e) => {
                serviceNames = e.serviceNames;
            });
            workspaceService.onProgressUpdated((e) => {
                this.onProgressUpdatedEmitter.fire(e);
            });
            this.workspaceSessionInfo = yield workspaceService.joinWorkspaceAsync(joinInfo);
            this.workspaceSessionInfo.serviceNames = serviceNames;
            // complete rpc connections
            this.rpcConnected.resolve(rpcConnection);
            // flush rpc messages that would happen during the join
            joinMessages.forEach((m) => {
                dataCallback(m);
            });
            this.trace.info(`joinWorkspace -> session:${this.workspaceSessionInfo.sessionNumber} conversation:${this.workspaceSessionInfo.conversationId} join messages count:${joinMessages.length}`);
        });
    }
    getServiceProxyWithConnection(rpcConnection, serviceInfo) {
        return vso_rpc_1.RpcProxy.createWithConnection(serviceInfo, rpcConnection, this.trace);
    }
    openStreamingChannel(streamId, cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(this.sshWorkspaceSession, 'Ssh session not initiated yet');
            this.trace.info(`openStreamingChannel -> streamId:${streamId}`);
            const sshChannel = yield this.sshWorkspaceSession.openStreamingChannel(streamId, cancellationToken);
            return sshChannel;
        });
    }
    checkConnection(cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const disposables = [];
            let isReconnecting = false;
            (0, vscs_utils_1.assertDefined)(this.sshWorkspaceSession, 'Ssh session not initiated yet');
            this.trace.verbose('checking ssh connection');
            const sshSession = this.sshWorkspaceSession.sshSession;
            (0, vscs_utils_1.assert)(!sshSession.isClosed, 'ssh session is closed');
            const cts = new dev_tunnels_ssh_1.CancellationTokenSource();
            if (cancellationToken) {
                disposables.push(cancellationToken.onCancellationRequested(() => {
                    cts.cancel();
                }));
            }
            disposables.push(this.sshWorkspaceSession.onConnectedStateChanged((e) => {
                if (e.state === vso_workspace_core_1.ConnectedState.Reconnecting) {
                    isReconnecting = true;
                    cts.cancel();
                }
            }));
            // Note: by sending a simple request to the ssh server session we want to guarantee a packet
            // was properly send and received no matter we know it won't be handled by the server logic.
            const request = new ssh.SessionRequestMessage('ping-check-connection', true);
            try {
                yield this.checkConnectionMutex.dispatch(() => {
                    if (!isReconnecting) {
                        return sshSession.request(request, cts.token);
                    }
                });
            }
            catch (err) {
                if (!(err instanceof dev_tunnels_ssh_1.CancellationError)) {
                    throw err;
                }
            }
            finally {
                disposables.forEach((d) => d.dispose());
            }
        });
    }
}
exports.WorkspaceClient = WorkspaceClient;
//# sourceMappingURL=WorkspaceClient.js.map

/***/ }),

/***/ "../../workspace/client/dist/src/index.js":
/*!************************************************!*\
  !*** ../../workspace/client/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNode = exports.SshHelpers = exports.WorkspaceClient = void 0;
var WorkspaceClient_1 = __webpack_require__(/*! ./WorkspaceClient */ "../../workspace/client/dist/src/WorkspaceClient.js");
Object.defineProperty(exports, "WorkspaceClient", ({ enumerable: true, get: function () { return WorkspaceClient_1.WorkspaceClient; } }));
var SshHelpers_1 = __webpack_require__(/*! ./SshHelpers */ "../../workspace/client/dist/src/SshHelpers.js");
Object.defineProperty(exports, "SshHelpers", ({ enumerable: true, get: function () { return SshHelpers_1.SshHelpers; } }));
Object.defineProperty(exports, "isNode", ({ enumerable: true, get: function () { return SshHelpers_1.isNode; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connectionHub/ConnectionHub.js":
/*!******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connectionHub/ConnectionHub.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionHub = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const constants_1 = __webpack_require__(/*! ./constants */ "../../workspace/connection-hub/dist/src/connectionHub/constants.js");
const ConnectionTimeoutError_1 = __webpack_require__(/*! ../errors/ConnectionTimeoutError */ "../../workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js");
const ConnectionHubRecord_1 = __webpack_require__(/*! ./ConnectionHubRecord */ "../../workspace/connection-hub/dist/src/connectionHub/ConnectionHubRecord.js");
const errorToConnectionError_1 = __webpack_require__(/*! ../utils/errorToConnectionError */ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js");
const optionsWithDefaults = (connectionOptions) => {
    return Object.assign(Object.assign({}, constants_1.HUB_CONNECTION_DEFAULT_OPTIONS), connectionOptions);
};
/**
 * Orchestrator class for a `Connection`s. Gives back a LiveShare or
 * VSCode connection, either exisiting or create a new one for you.
 */
class ConnectionHub extends vscs_utils_1.DisposableClass {
    constructor(trace, performance, connectionClass, childConnectionHubs = []) {
        super(trace);
        this.performance = performance;
        this.connectionClass = connectionClass;
        this.childConnectionHubs = childConnectionHubs;
        /**
         * The `onConnection` callback when a connection is created.
         */
        this.onConnectionEmitter = new vscode_jsonrpc_1.Emitter();
        this.onConnection = this.onConnectionEmitter.event;
        /**
         * Get connection `id` by `connectionOptions`. Each connection
         * type must provide the `getId` method that identifies
         * the connection by the `connectionOptions`. Same connection
         * type with the same options must have the same resulting `id`.
         */
        this.getConnectionId = (connectionOptions) => {
            const connection = new this.connectionClass(this.trace, this.performance, connectionOptions);
            return connection.getId(connectionOptions);
        };
        /**
         * Connect without retries.
         */
        this.connectOnce = (connectionOptions, hubConnectionOptions = {}) => __awaiter(this, void 0, void 0, function* () {
            const { trace = this.trace } = hubConnectionOptions;
            trace.info('requested to connect once', connectionOptions, hubConnectionOptions);
            return yield this.connect(connectionOptions, Object.assign(Object.assign({}, constants_1.HUB_NO_RETRY_OPTIONS), hubConnectionOptions));
        });
        this.connections = {};
        this.retrySignals = {};
        /**
         * If connection is not complete after specified timeout, throw the ConnectionError.
         */
        this.createConnectionWithTimeout = (connectionOptions, hubConnectionOptions) => __awaiter(this, void 0, void 0, function* () {
            const { timeout } = hubConnectionOptions;
            if (!isFinite(timeout)) {
                this.trace.verbose(`creating connection without a timeout`);
                return yield this.createConnection(connectionOptions, hubConnectionOptions);
            }
            this.trace.verbose(`creating connection with timeout of ${timeout}ms`);
            const result = yield (0, vscs_utils_1.timeoutPromise)(this.createConnection(connectionOptions, hubConnectionOptions), timeout, new ConnectionTimeoutError_1.ConnectionTimeoutError(`Could not establish connection in ${timeout}ms.`));
            return result;
        });
        this.createConnection = (connectionOptions, hubConnectionOptions) => __awaiter(this, void 0, void 0, function* () {
            const { retries, retryDelay, performance = this.performance, trace = this.trace, } = hubConnectionOptions;
            const options = connectionOptions;
            const id = this.getConnectionId(options);
            try {
                this.trace.info('creating connection', hubConnectionOptions);
                // create new connection
                const connection = new this.connectionClass(trace.createChild(`connection:${id}`), performance.createGroup(`${trace.name}:${(0, vscs_utils_1.hashString)(id)}`), options, this.childConnectionHubs);
                const record = new ConnectionHubRecord_1.ConnectionHubRecord(this.trace.createChild('connection-record'), connection, connectionOptions, hubConnectionOptions, connection.onConnectionChanged(this.onConnectionChanged.bind(this, id)));
                this.connections[id] = record;
                const connectionResult = yield connection.connect();
                this.addToDisposables(record);
                // fire the event after the connection is complete
                (0, vscs_utils_1.defer)(() => {
                    this.onConnectionEmitter.fire(connectionResult);
                }, 0);
                return connectionResult;
            }
            catch (e) {
                this.trace.warning(`disposing connection "${id}" due to an error`, e);
                this.disposeConnection(id);
                /**
                 * If no retries left, re-throw the error.
                 */
                if (retries < 1) {
                    throw e;
                }
                this.trace.info(`connection failed, retrying ${retries}`);
                /**
                 * If a `disconnect` is requested when we wait on `retryDelay`,
                 * we must not create a new connection after the `retryDelay` is
                 * finished but rather bail out immediately.
                 */
                const signal = new vscs_utils_1.Signal();
                this.retrySignals[id] = signal;
                yield Promise.race([signal.promise, (0, vscs_utils_1.wait)(retryDelay)]);
                return yield this.createConnection(connectionOptions, Object.assign(Object.assign({}, hubConnectionOptions), { retries: retries - 1 }));
            }
        });
    }
    get childHubs() {
        return [...this.childConnectionHubs];
    }
    /**
     * Return a possible existing connection based on the connection options.
     * The returned connection if exists would have
     */
    getConnection(connectionOptions) {
        const id = this.getConnectionId(connectionOptions);
        const connectionRecord = this.connections[id];
        if (connectionRecord) {
            const { connection } = connectionRecord;
            return connection;
        }
    }
    /**
     * Will give you a LiveShare
     * connection back, either exisiting or will create a new one for you.
     */
    connect(connectionOptions, hubConnectionOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { trace = this.trace } = hubConnectionOptions;
            trace.info('requested to connect', connectionOptions, hubConnectionOptions);
            try {
                const id = this.getConnectionId(connectionOptions);
                const connectionRecord = this.connections[id];
                const connectionTrace = trace.createChild(`${id}`);
                connectionTrace.info(`connection record: ${!!connectionRecord}`);
                if (!connectionRecord) {
                    connectionTrace.info('creating new connection');
                    return yield this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));
                }
                const { connection } = connectionRecord;
                if (!connection) {
                    connectionTrace.info('no connection on connection record, creating');
                    return yield this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));
                }
                if (connection.status === 'disconnected') {
                    connectionTrace.info('disposed, creating');
                    this.disposeConnection(id);
                    return yield this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));
                }
                if (connection.status === 'connected') {
                    connectionTrace.info('return connected');
                    return connection;
                }
                const { timeout = Infinity } = hubConnectionOptions;
                connectionTrace.info(`connecting with timeout - ${timeout} ms`);
                const result = yield connection.connectWithTimeout(timeout);
                return result;
            }
            catch (e) {
                trace.warning('error during connection', e);
                throw (0, errorToConnectionError_1.errorToConnectionError)(e);
            }
        });
    }
    /**
     * Disconnect a connection.
     */
    disconnect(connectionOptions, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info('requested disconnect', connectionOptions);
            const id = this.getConnectionId(connectionOptions);
            const retryAwaitSignal = this.retrySignals[id];
            if (retryAwaitSignal) {
                retryAwaitSignal.cancel();
                this.retrySignals[id] = undefined;
            }
            const connectionRecord = this.connections[id];
            if (!connectionRecord) {
                return false;
            }
            yield connectionRecord.disconnect(reason);
            this.connections[id] = undefined;
            return true;
        });
    }
    /******************************************************
     * Implementation details.
     ******************************************************/
    /**
     * Individual connection state changed.
     */
    onConnectionChanged(id, connectionChange) {
        return __awaiter(this, void 0, void 0, function* () {
            const trace = this.trace.createChild(`onConnectionChanged:${id}`);
            const { status, previousStatus } = connectionChange;
            trace.info(`${previousStatus} -> ${status}`);
            if (status !== 'disconnected') {
                return;
            }
            // if disconnected, dispose the current connection
            const connectionRecord = this.connections[id];
            if (!connectionRecord) {
                trace.info('no connection record found');
                return;
            }
            trace.info('disposing the connection');
            this.disposeConnection(id);
            this.connections[id] = undefined;
            if (previousStatus !== 'connected') {
                return;
            }
            // if prev status was "connected" and we should also reconnect
            const { hubConnectionOptions, connectionOptions, connection } = connectionRecord;
            if (hubConnectionOptions.shouldReconnect && !connection.isDisposing) {
                trace.info('reconnecting..');
                return yield this.connect(connectionOptions, hubConnectionOptions);
            }
            trace.info('not reconnecting');
        });
    }
    disposeConnection(id) {
        try {
            this.trace.info(`disposing ${id} connection`);
            const connectionRecord = this.connections[id];
            if (!connectionRecord) {
                return;
            }
            connectionRecord.dispose('connection record disposed by ConnectionHub');
            this.connections[id] = undefined;
        }
        catch (err) {
            this.trace.warning(`error while disposing ${id} connection`, err);
        }
    }
}
exports.ConnectionHub = ConnectionHub;
//# sourceMappingURL=ConnectionHub.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connectionHub/ConnectionHubRecord.js":
/*!************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connectionHub/ConnectionHubRecord.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionHubRecord = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
/**
 * Record of a connection inside a ConnectionHub.
 */
class ConnectionHubRecord extends vscs_utils_1.DisposableClass {
    constructor(trace, connectionArg, connectionOptionsArg, hubConnectionOptionsArg, eventHandlerArg) {
        super(trace);
        this.connectionArg = connectionArg;
        this.connectionOptionsArg = connectionOptionsArg;
        this.hubConnectionOptionsArg = hubConnectionOptionsArg;
        this.eventHandlerArg = eventHandlerArg;
        this.addToDisposables(eventHandlerArg, connectionArg);
    }
    get connection() {
        return this.connectionArg;
    }
    get connectionOptions() {
        return this.connectionOptionsArg;
    }
    get hubConnectionOptions() {
        return this.hubConnectionOptionsArg;
    }
    get eventHandler() {
        return this.eventHandlerArg;
    }
    disconnect(reason) {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.disconnect(reason);
            return _super.dispose.call(this, reason);
        });
    }
}
exports.ConnectionHubRecord = ConnectionHubRecord;
//# sourceMappingURL=ConnectionHubRecord.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connectionHub/constants.js":
/*!**************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connectionHub/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HUB_NO_RETRY_OPTIONS = exports.HUB_CONNECTION_DEFAULT_OPTIONS = void 0;
exports.HUB_CONNECTION_DEFAULT_OPTIONS = {
    retries: 3,
    retryDelay: 0,
    timeout: Infinity,
    shouldReconnect: true,
};
exports.HUB_NO_RETRY_OPTIONS = Object.assign(Object.assign({}, exports.HUB_CONNECTION_DEFAULT_OPTIONS), { retries: 0, shouldReconnect: false });
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/CodespaceConnection.js":
/*!*********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/CodespaceConnection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodespaceConnection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const LiveShareConnection_1 = __webpack_require__(/*! ./LiveShareConnection */ "../../workspace/connection-hub/dist/src/connection/LiveShareConnection.js");
class CodespaceConnection extends LiveShareConnection_1.LiveShareConnection {
    setWorkspaceSessionInfo(workspaceSessionInfo) {
        this.trace.verbose(`setWorkspaceSessionInfo`, workspaceSessionInfo);
        const { ownerId, sessionNumber, sessions } = workspaceSessionInfo;
        (0, vscs_utils_1.assertDefined)(ownerId, 'No owner id defined.');
        this.trace.info(`ownerId: "${ownerId}"`);
        (0, vscs_utils_1.assert)(!ownerId.startsWith('vm_'), 'Session host is not updated to the user, retrying...');
        (0, vscs_utils_1.assertDefined)(sessions, 'Workspace sessions not defined.');
        const session = sessions[sessionNumber];
        (0, vscs_utils_1.assertDefined)(session, `Session #${sessionNumber} not defined.`);
        (0, vscs_utils_1.assert)(session.isOwner, 'Session does not have owner permissions');
        super.setWorkspaceSessionInfo(workspaceSessionInfo);
    }
}
exports.CodespaceConnection = CodespaceConnection;
//# sourceMappingURL=CodespaceConnection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/Connection.js":
/*!************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/Connection.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Connection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const ConnectionCancellationError_1 = __webpack_require__(/*! ../errors/ConnectionCancellationError */ "../../workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js");
const errorToConnectionError_1 = __webpack_require__(/*! ../utils/errorToConnectionError */ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js");
const ConnectionStateError_1 = __webpack_require__(/*! ../errors/ConnectionStateError */ "../../workspace/connection-hub/dist/src/errors/ConnectionStateError.js");
const ConnectionError_1 = __webpack_require__(/*! ../errors/ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
const ConnectionTimeoutError_1 = __webpack_require__(/*! ../errors/ConnectionTimeoutError */ "../../workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js");
class Connection extends vscs_utils_1.DisposableClass {
    constructor(traceName, performance, options = {}) {
        super(traceName);
        this.traceName = traceName;
        this.performance = performance;
        this.options = options;
        this.isDisconnectedFlag = false;
        this.isDisposingRef = false;
        /**
         * The `onConnectionChanged` callback is called every time the connection status changes.
         */
        this.onConnectionChangedEventEmitter = new vscode_jsonrpc_1.Emitter();
        this.connectionStatus = 'none';
        this.previousConnectionStatus = 'none';
        this.addToDisposables(this.onConnectionChangedEventEmitter);
    }
    /**
     * If the connection was explicitly disconnected (vs disposed).
     */
    get isDisconnected() {
        return this.isDisconnectedFlag;
    }
    /**
     * Get connection `id` from the connection `options`.
     */
    getId(options) {
        throw new ConnectionError_1.ConnectionError('Not implemented.');
    }
    get onConnectionChanged() {
        if (this.isDisposed) {
            throw new ConnectionStateError_1.ConnectionStateError('Cannot listen to `onConnectionChanged`, connection already disposed.');
        }
        return this.onConnectionChangedEventEmitter.event;
    }
    /**
     * If the connection is being disposed
     */
    get isDisposing() {
        return this.isDisposingRef;
    }
    /**
     * Connection status.
     */
    get status() {
        return this.connectionStatus;
    }
    /**
     * Previous connection status.
     */
    get previousStatus() {
        return this.previousConnectionStatus;
    }
    /**
     * Method to connect to LiveShare Session and create basic RPC services.
     * Will reuse connection currently in progress if one already exists.
     */
    connect() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.info('asked to connect');
                /**
                 * This will make sure we preserve the original rejection error versus
                 * always returning the ConnectionStateError.
                 */
                if (((_a = this.connectionSignal) === null || _a === void 0 ? void 0 : _a.isCancelled) || ((_b = this.connectionSignal) === null || _b === void 0 ? void 0 : _b.isRejected)) {
                    return yield this.connectionSignal.promise;
                }
                (0, vscs_utils_1.assert)(this.status !== 'disconnected', new ConnectionStateError_1.ConnectionStateError('Connection already disconnected, please create a new one.'));
                (0, vscs_utils_1.assert)(!this.isDisposed, new ConnectionStateError_1.ConnectionStateError('Connection is already disposed, please create a new one.'));
                if (this.connectionSignal) {
                    this.trace.info(`return promise, resolved: ${this.connectionSignal.isResolved}`);
                    return yield this.connectionSignal.promise;
                }
                this.trace.info('creating new connection');
                return yield this.createConnection();
            }
            catch (e) {
                this.handleConnectionError(e);
                throw (0, errorToConnectionError_1.errorToConnectionError)(e);
            }
        });
    }
    /**
     * Disconnect method is disposing the connection. Will cause the
     * `onConnectionChanged` and `onDispose` events to be fired.
     */
    disconnect(reason) {
        this.isDisconnectedFlag = true;
        this.dispose(reason);
    }
    /**
     * Dispose the connection, same as `disconnect`. Will cause the
     * `onConnectionChanged` and `onDispose` events to be fired.
     */
    dispose(reason) {
        this.isDisposingRef = true;
        if (this.isDisposed) {
            return;
        }
        this.onConnectionChangedHandler('disconnected', new ConnectionCancellationError_1.ConnectionCancellationError('Disposing the connection.'));
        super.dispose(reason);
        return;
    }
    /**
     * Same as connect but with timeout.
     */
    connectWithTimeout(timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.info(`asked to connect with timeout of ${timeout} ms`);
                if (!isFinite(timeout)) {
                    return yield this.connect();
                }
                return yield (0, vscs_utils_1.timeoutPromise)(this.connect(), timeout, new ConnectionTimeoutError_1.ConnectionTimeoutError(`Could not establish connection in ${timeout}ms.`));
            }
            catch (e) {
                this.handleConnectionError(e);
                throw (0, errorToConnectionError_1.errorToConnectionError)(e);
            }
        });
    }
    onConnectionChangedHandler(connectionStatus, error) {
        if (connectionStatus === this.connectionStatus) {
            return;
        }
        this.trace.info(`connection status changed: ${this.connectionStatus} -> ${connectionStatus}, error:`, error);
        this.previousConnectionStatus = this.connectionStatus;
        this.connectionStatus = connectionStatus;
        const event = {
            status: connectionStatus,
            previousStatus: this.previousConnectionStatus,
        };
        this.trace.info('firing change event: ', event);
        this.onConnectionChangedEventEmitter.fire(event);
        (0, vscs_utils_1.assertDefined)(this.connectionSignal, 'No `connectionSignal` found.');
        if (this.connectionSignal.isFulfilled) {
            return;
        }
        if (connectionStatus === 'connected') {
            this.trace.info('🔌 connected');
            this.connectionSignal.resolve(this);
        }
        if (connectionStatus === 'disconnected') {
            this.trace.info('disconnected');
            this.connectionSignal.reject((0, errorToConnectionError_1.errorToConnectionError)(error !== null && error !== void 0 ? error : new ConnectionError_1.ConnectionError('Connection failed.')));
        }
    }
    initializeConnection() {
        this.trace.info('creating connection');
        this.connectionSignal = new vscs_utils_1.Signal();
        this.connectionSignal.promise.catch((reason) => {
            this.trace.verbose(`signal rejected reason -> ${(0, vscs_utils_1.propertiesToString)(reason)}`);
        });
        this.addToDisposables(this.connectionSignal);
        this.onConnectionChangedHandler('connecting');
        return this;
    }
    createConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initializeConnection();
            (0, vscs_utils_1.assertDefined)(this.connectionSignal, new ConnectionError_1.ConnectionError('No `connectionSignal` found.'));
            yield this.connectionSignal.promise;
            throw new ConnectionError_1.ConnectionError('Not implemented.');
        });
    }
    handleConnectionError(e) {
        var _a;
        this.trace.error('connection failed: ', e);
        this.onConnectionChangedHandler('disconnected', e);
        (_a = this.connectionSignal) === null || _a === void 0 ? void 0 : _a.reject((0, errorToConnectionError_1.errorToConnectionError)(e));
        this.dispose();
    }
}
exports.Connection = Connection;
//# sourceMappingURL=Connection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/LiveShareConnection.js":
/*!*********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/LiveShareConnection.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LiveShareConnection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vsls_contracts_1 = __webpack_require__(/*! @vs/vsls-contracts */ "../../vsls-contracts/dist/src/index.js");
const vso_workspace_core_1 = __webpack_require__(/*! @vs/vso-workspace-core */ "../../workspace/core/dist/src/index.js");
const vso_workspace_client_1 = __webpack_require__(/*! @vs/vso-workspace-client */ "../../workspace/client/dist/src/index.js");
const TConnectionTypes_1 = __webpack_require__(/*! ../interfaces/TConnectionTypes */ "../../workspace/connection-hub/dist/src/interfaces/TConnectionTypes.js");
const ConnectionError_1 = __webpack_require__(/*! ../errors/ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
const Connection_1 = __webpack_require__(/*! ./Connection */ "../../workspace/connection-hub/dist/src/connection/Connection.js");
const PerformanceEventIds_1 = __webpack_require__(/*! ../performance/PerformanceEventIds */ "../../workspace/connection-hub/dist/src/performance/PerformanceEventIds.js");
const errorToConnectionError_1 = __webpack_require__(/*! ../utils/errorToConnectionError */ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js");
/**
 * Class to connect to LiveShare Session and create basic RPC services.
 */
class LiveShareConnection extends Connection_1.Connection {
    constructor(trace, performance, options) {
        super(trace.createChild('liveshare'), performance);
        this.performance = performance;
        this.options = options;
        if (!this.options.connectionInfo) {
            throw new ConnectionError_1.ConnectionError('Connection is missing required connection info', vsls_contracts_1.vsls.ErrorCodes.NoConnectionAddresses);
        }
    }
    /**
     * Get connection `id` from the connection `options`.
     */
    getId(options) {
        const { workspaceId } = options;
        return workspaceId;
    }
    get type() {
        return TConnectionTypes_1.TConnectionTypes.MainThread;
    }
    /**
     * LiveShare WorkspaceClient.
     */
    get workspaceClient() {
        (0, vscs_utils_1.assertDefined)(this.workspaceClientReference, 'No `WorkspaceClient` found.');
        return this.workspaceClientReference;
    }
    /**
     * Method to get RPC service proxy client.
     */
    getRpcService(rpcServiceContract) {
        return this.workspaceClient.getServiceProxy(rpcServiceContract);
    }
    dispose(reason) {
        super.dispose(reason);
        this.workspaceClientReference = undefined;
        this.workspaceSessionInfoReference = undefined;
        return;
    }
    get workspaceSessionInfo() {
        return this.workspaceSessionInfoReference;
    }
    createWorkspaceClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const workspaceClient = new vso_workspace_client_1.WorkspaceClient(this.trace.createChild('WorkspaceClient'), undefined, {
                enabled: true,
                retryTimeout: 0.25 * vscs_utils_1.TIME_SECOND_MS,
                maxTimeReconnect: 10 * vscs_utils_1.TIME_SECOND_MS,
            });
            return workspaceClient;
        });
    }
    setWorkspaceSessionInfo(workspaceSessionInfo) {
        this.workspaceSessionInfoReference = workspaceSessionInfo;
    }
    createConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.initializeConnection();
                this.trace.info('creating workspace client', this.options);
                const workspaceClient = yield this.createWorkspaceClient();
                workspaceClient.onProgressUpdated((e) => {
                    if (this.options.onProgressUpdated) {
                        this.options.onProgressUpdated(e);
                    }
                });
                this.addToDisposables({
                    dispose: () => {
                        workspaceClient.dispose('Disposed from LiveShareConnection');
                    },
                });
                const workspaceSessionInfo = yield this.performance.measure({
                    id: PerformanceEventIds_1.PerformanceEventIds.LiveshareJoinWorkspace,
                    name: 'join LiveShare session',
                }, () => __awaiter(this, void 0, void 0, function* () {
                    return yield workspaceClient.join(Object.assign(Object.assign({}, this.options), { performance: this.performance.createGroup(`${this.trace.name}:${this.options.workspaceId}`), checkConnectionOptions: {
                            enabled: true,
                        } }));
                }));
                this.workspaceClientReference = workspaceClient;
                this.setWorkspaceSessionInfo(workspaceSessionInfo);
                this.trace.info(`LS session joined and authenticated`);
                yield this.performance.measure({
                    name: 'create workspace service',
                }, () => __awaiter(this, void 0, void 0, function* () {
                    const workspaceService = workspaceClient.getServiceProxy(vsls_contracts_1.vsls.WorkspaceService);
                    (0, vscs_utils_1.assertDefined)(workspaceService, 'WorkspaceService not set.');
                    yield workspaceClient.rpcClient.onClose(() => {
                        this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError('RPC client closed.'));
                    });
                    this.addToDisposables(workspaceService.onConnectionStatusChanged((event) => {
                        if (event.connectionStatus ===
                            vsls_contracts_1.vsls.WorkspaceConnectionStatus.Disconnected) {
                            this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError(`Workspace service disconnected with status: "${event.disconnectedReason}".`));
                        }
                    }));
                }));
                this.onConnectionChangedHandler('connected');
                // hookup host connection events
                workspaceClient.onHostConnectionChanged((e) => {
                    this.trace.info(`host connection changed to "${vso_workspace_core_1.ConnectedState[e.state]}"`);
                    if (e.state === vso_workspace_core_1.ConnectedState.Reconnecting) {
                        this.initializeConnection();
                    }
                    else if (e.state === vso_workspace_core_1.ConnectedState.Reconnected) {
                        this.onConnectionChangedHandler('connected');
                    }
                    else if (e.state === vso_workspace_core_1.ConnectedState.Closed) {
                        this.onConnectionChangedHandler('disconnected');
                    }
                });
                return this;
            }
            catch (e) {
                this.handleConnectionError(e);
                throw (0, errorToConnectionError_1.errorToConnectionError)(e);
            }
        });
    }
}
exports.LiveShareConnection = LiveShareConnection;
//# sourceMappingURL=LiveShareConnection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/LiveShareJointConnection.js":
/*!**************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/LiveShareJointConnection.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LiveShareJointConnection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const LiveShareConnection_1 = __webpack_require__(/*! ./LiveShareConnection */ "../../workspace/connection-hub/dist/src/connection/LiveShareConnection.js");
/**
 * Class to connect to LiveShare Session through a main thread or service worker.
 */
class LiveShareJointConnection extends LiveShareConnection_1.LiveShareConnection {
    constructor(trace, performance, options, connectionHubs) {
        super(trace.createChild('liveshare-joint'), performance, options);
        this.performance = performance;
        this.options = options;
        this.connectionHubs = connectionHubs;
        /******************************************************
         * Implementation details.
         ******************************************************/
        this.connectionReference = null;
    }
    get type() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, '');
        return this.connectionReference.type;
    }
    get workspaceSessionInfo() {
        if (!this.connectionReference) {
            return;
        }
        return this.connectionReference.workspaceSessionInfo;
    }
    get connection() {
        return this.connectionReference;
    }
    createConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.info('creating connection');
                this.connectionSignal = new vscs_utils_1.Signal();
                this.addToDisposables(this.connectionSignal);
                this.onConnectionChangedHandler('connecting');
                const connectionPromises = this.connectionHubs.map((hub, i) => {
                    return hub.connectOnce(this.options, {
                        performance: this.performance.createGroup(`connection #${i}`),
                    });
                });
                const connection = yield (0, vscs_utils_1.raceAsync)(connectionPromises);
                connection.addToDisposables(this);
                (0, vscs_utils_1.assertDefined)(this.connectionSignal, 'No connection signal found.');
                this.connectionReference = connection;
                this.workspaceClientReference = connection.workspaceClient;
                this.addToDisposables(connection);
                this.addToDisposables(connection.onConnectionChanged(this.onConnectionChangedEventEmitter.fire.bind(connection)));
                this.onConnectionChangedHandler('connected');
                return this;
            }
            catch (e) {
                this.handleConnectionError(e);
                throw e;
            }
        });
    }
}
exports.LiveShareJointConnection = LiveShareJointConnection;
//# sourceMappingURL=LiveShareJointConnection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/PortSignal.js":
/*!************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/PortSignal.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PortSignal = void 0;
class PortSignal {
    constructor(port, changeKind, serverSharingService) {
        this.promise = new Promise(function (resolve, reject) {
            serverSharingService.onSharingSucceeded((e) => {
                if (e.port === port && e.changeKind === changeKind) {
                    resolve();
                }
            });
            serverSharingService.onSharingFailed((e) => {
                if (e.port === port && e.changeKind === changeKind) {
                    reject(e.errorDetail);
                }
            });
        });
    }
    /**
     * Block until we either receive a success or failure signal.
     */
    waitForSignal() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.promise;
            }
            catch (e) {
                throw Error(e);
            }
        });
    }
}
exports.PortSignal = PortSignal;
//# sourceMappingURL=PortSignal.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/VSCodeConnection.js":
/*!******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/VSCodeConnection.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VSCodeConnection = exports.DEFAULT_FORWARDING_HOST = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const vsls_contracts_1 = __webpack_require__(/*! @vs/vsls-contracts */ "../../vsls-contracts/dist/src/index.js");
const PerformanceEventIds_1 = __webpack_require__(/*! ../performance/PerformanceEventIds */ "../../workspace/connection-hub/dist/src/performance/PerformanceEventIds.js");
const PerformanceGroupIds_1 = __webpack_require__(/*! ../performance/PerformanceGroupIds */ "../../workspace/connection-hub/dist/src/performance/PerformanceGroupIds.js");
const errorToConnectionError_1 = __webpack_require__(/*! ../utils/errorToConnectionError */ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js");
const ConnectionError_1 = __webpack_require__(/*! ../errors/ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
const findSourcePort_1 = __webpack_require__(/*! ../utils/findSourcePort */ "../../workspace/connection-hub/dist/src/utils/findSourcePort.js");
const Connection_1 = __webpack_require__(/*! ./Connection */ "../../workspace/connection-hub/dist/src/connection/Connection.js");
const VSCodeServerHostRPCService_1 = __webpack_require__(/*! ../interfaces/VSCodeServerHostRPCService */ "../../workspace/connection-hub/dist/src/interfaces/VSCodeServerHostRPCService.js");
const vscs_utils_2 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const getVSCodeServerSessionName_1 = __webpack_require__(/*! ../utils/getVSCodeServerSessionName */ "../../workspace/connection-hub/dist/src/utils/getVSCodeServerSessionName.js");
const PortSignal_1 = __webpack_require__(/*! ./PortSignal */ "../../workspace/connection-hub/dist/src/connection/PortSignal.js");
const isVSCodeServerSession_1 = __webpack_require__(/*! ../utils/isVSCodeServerSession */ "../../workspace/connection-hub/dist/src/utils/isVSCodeServerSession.js");
/**
 * Render a `SharedServer` as a string, used in the tracing to make the related
 * logs compact.
 */
const compactSharedServer = (server) => {
    const { sessionName, sourcePort, privacy, isTCPServerConnectionEstablished, hasTLSHandshakePassed, } = server;
    return `${sessionName}:${sourcePort}:${privacy}:${isTCPServerConnectionEstablished}:${hasTLSHandshakePassed}`;
};
/**
 * Render a list of `SharedServer`s an array of strings, used in the tracing to make the related
 * logs compact.
 */
const compactSharedServers = (sharedPorts) => {
    return sharedPorts.map(compactSharedServer);
};
exports.DEFAULT_FORWARDING_HOST = '127.0.0.1';
/**
 * Class responsible for `vscode` connection - e.g. starting VSCode server and forwarding server
 * port. It consume the `LiveShareConnectionHub` that orchestrates the LiveShare connections.
 */
class VSCodeConnection extends Connection_1.Connection {
    constructor(trace, performance, options, connectionHubs) {
        super(trace.createChild('vscode'), performance);
        this.performance = performance;
        this.options = options;
        this.connectionHubs = connectionHubs;
        this.onVSCodeServerStartedEmitter = new vscode_jsonrpc_1.Emitter();
        this.onVSCodeServerStarted = this
            .onVSCodeServerStartedEmitter.event;
        this.forecastChannels = [];
        this.vscodeServerHostClientReference = null;
        /******************************************************
         * Implementation details.
         ******************************************************/
        this.sharedServerReference = null;
        this.liveshareConnectionReference = null;
        this.serverSharingServiceReference = null;
        this.remotePortReference = null;
        this.connectionTokenReference = null;
    }
    /**
     * Get connection `id` from the connection `options`.
     */
    getId(options) {
        const { workspaceId, environmentId, vsCodeQuality, vsCodeCommit } = options;
        return `${workspaceId}_${environmentId}_${vsCodeQuality}_${vsCodeCommit}`;
    }
    /**
     * Method to get LiveShare RPC service client proxy.
     */
    getRpcService(rpcServiceContract) {
        return this.workspaceClient.getServiceProxy(rpcServiceContract);
    }
    /**
     * WorkspaceClient reference.
     */
    get workspaceClient() {
        (0, vscs_utils_1.assertDefined)(this.liveshareConnection, 'No LiveShare connection found.');
        const { workspaceClient } = this.liveshareConnection;
        (0, vscs_utils_1.assertDefined)(workspaceClient, 'No WorkspaceClient found.');
        return workspaceClient;
    }
    /**
     * VSCodeServerHostService reference.
     */
    get vscodeServerHostClient() {
        (0, vscs_utils_1.assertDefined)(this.vscodeServerHostClientReference, 'No VSCodeServerHostClient defined.');
        return this.vscodeServerHostClientReference;
    }
    /**
     * ServerSharing service reference.
     */
    get serverSharingService() {
        (0, vscs_utils_1.assertDefined)(this.serverSharingServiceReference, 'No ServerSharing service found.');
        return this.serverSharingServiceReference;
    }
    /**
     * LiveShareConnection reference.
     */
    get liveshareConnection() {
        (0, vscs_utils_1.assertDefined)(this.liveshareConnectionReference, 'No LiveShare connection found.');
        return this.liveshareConnectionReference;
    }
    createConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const [liveshareConnectionHub] = this.connectionHubs;
            (0, vscs_utils_1.assertDefined)(liveshareConnectionHub, 'LiveShareConnectionHub not found.');
            try {
                this.initializeConnection();
                this.trace.info('get LS connection');
                this.liveshareConnectionReference = yield this.performance.measure({
                    name: 'liveshare connection',
                }, () => __awaiter(this, void 0, void 0, function* () {
                    return yield liveshareConnectionHub.connectOnce(this.options, {
                        performance: this.performance.createGroup('liveshare connection'),
                    });
                }));
                this.liveshareConnectionReference.addToDisposables(this);
                this.addToDisposables(this.liveshareConnectionReference.onConnectionChanged((e) => {
                    const { previousStatus, status } = e;
                    this.trace.info(`LiveShareConnection status changed: "${previousStatus}" -> "${status}"`);
                    this.dispose('LiveShareConnection disconnected');
                }), this.liveshareConnectionReference.onDispose((e) => {
                    this.trace.info(`LiveShareConnection disposed`);
                    this.dispose('LiveShareConnection disposed');
                }));
                const { workspaceClient } = this.liveshareConnectionReference;
                // TODO legomushroom - this is redundant in the "web" connction case?
                yield this.getVSCodeSharedServer(workspaceClient);
                // Start opening forecasted channels now, so they will be (almost) ready
                // by the time they are requested.
                for (let i = 0; i < VSCodeConnection.channelForecast; i++) {
                    this.forecastChannels.push(this.openChannel(this.performance, false));
                }
                this.onConnectionChangedHandler('connected');
                return this;
            }
            catch (e) {
                this.handleConnectionError(e);
                throw (0, errorToConnectionError_1.errorToConnectionError)(e);
            }
        });
    }
    get sharedServer() {
        (0, vscs_utils_1.assertDefined)(this.sharedServerReference, 'No SharedServer found.');
        return this.sharedServerReference;
    }
    getVSCodeSharedServer(workspaceClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharePerformance = this.performance.createGroup('share vscode server', PerformanceGroupIds_1.PerformanceGroupIds.VSCodeServerStartup);
            this.serverSharingServiceReference = workspaceClient.getServiceProxy(vsls_contracts_1.vsls.ServerSharingService);
            const port = yield sharePerformance.measure({
                name: 'start vscode server',
                id: PerformanceEventIds_1.PerformanceEventIds.VSCodeServerStartupServerStart,
            }, () => __awaiter(this, void 0, void 0, function* () {
                return yield this.startVSCodeServer(workspaceClient);
            }));
            (0, vscs_utils_1.assertDefined)(port, new ConnectionError_1.ConnectionError(`VSCode Server port is "${port}"`));
            this.trace.info(`forwarding the VSCode Server port "${port}".`);
            /**
             * If the sharing of the vscode server port have stopped,
             * dispose the current connection.
             */
            this.addToDisposables(this.serverSharingService.onSharingStopped((e) => {
                const { server } = e;
                this.trace.verbose('serverSharingService onSharingStopped:', server);
                if (server.sourcePort !== port) {
                    return;
                }
                this.trace.info('serverSharingService closed.', server);
                this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError('Port closed.'));
            }));
            // TODO legomushroom - not needed?
            // /**
            //  * If the sharing of the vscode server port have changed,
            //  * dispose the current connection.
            //  */
            // this.addToDisposables(
            //     this.serverSharingService.onSharingChanged((e: vsls.ServerSharingChangedEventArgs) => {
            //         const { server } = e;
            //         const { isTCPServerConnectionEstablished } = server;
            //         this.trace.verbose('serverSharingService onSharingChanged:', server);
            //         if (server.sourcePort !== port) {
            //             return;
            //         }
            //         if (isTCPServerConnectionEstablished === false) {
            //             this.onConnectionChangedHandler(
            //                 'disconnected',
            //                 new ConnectionError('Port closed.')
            //             );
            //         }
            //     })
            // );
            this.sharedServerReference = yield sharePerformance.measure({
                name: 'share vscode server TCP port',
                id: PerformanceEventIds_1.PerformanceEventIds.VSCodeServerStartupServerTcpPortForwarding,
            }, () => __awaiter(this, void 0, void 0, function* () {
                const { clientId } = this.options;
                return yield this.serverSharingService.startSharingAsync(port, (0, getVSCodeServerSessionName_1.getVSCodeServerSessionName)(clientId), '');
            }));
            this.trace.info(`VSCode Server port "${port}" forwarded.`);
            return this.sharedServerReference;
        });
    }
    getSharedServers(timeout = 3 * vscs_utils_1.TIME_SECOND_MS) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /**
                 * There is the current bug that makes RPC calls hang
                 * after connection lost/reconnection. Timeout the RPC
                 * call and dispose the LiveShare connection if that happens.
                 */
                const sharedServers = yield (0, vscs_utils_1.timeoutPromise)(this.serverSharingService.getSharedServersAsync(), timeout, new ConnectionError_1.ConnectionError('Getting shared servers timed out.'));
                this.trace.verbose('got shared servers list', compactSharedServers(sharedServers));
                return sharedServers;
            }
            catch (e) {
                this.trace.error('getting shared servers failed: ', e);
                this.liveshareConnection.dispose(`disposed by vscode connection: "${e.message}"`);
                throw e;
            }
        });
    }
    startVSCodeServer(workspaceClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldReuseExistingServers = false, clientId } = this.options;
            this.trace.info('starting vscode server..', this.options);
            this.vscodeServerHostClientReference = workspaceClient.getServiceProxy(VSCodeServerHostRPCService_1.vscodeServerHostRPCService);
            /**
             * If the `shouldReuseExistingServers` flag is set,
             * get the existing vscode server.
             */
            if (shouldReuseExistingServers) {
                this.trace.info('checking if existing vscode server can be reused');
                const sharedPorts = yield this.getSharedServers();
                this.trace.info('checking already running ports', compactSharedServers(sharedPorts));
                // take the last shared port
                const vscodeServerInfo = sharedPorts.reverse().find((port) => {
                    return port.sessionName === (0, getVSCodeServerSessionName_1.getVSCodeServerSessionName)(clientId);
                });
                if (vscodeServerInfo) {
                    this.remotePortReference = vscodeServerInfo.sourcePort;
                    this.trace.info(`reusing already shared port ${this.remotePortReference}`);
                    this.onVSCodeServerStartedEmitter.fire({
                        port: this.remotePort,
                        connectionToken: this.connectionToken,
                    });
                    return this.remotePortReference;
                }
            }
            this.trace.info('vscode started, forwarding the server port');
            const vscodeStartResult = yield this.vscodeServerHostClient.startRemoteServerResultAsync(Object.assign(Object.assign({}, this.options), { quality: this.options.vsCodeQuality }));
            this.remotePortReference = vscodeStartResult.port;
            this.connectionTokenReference = vscodeStartResult.connectionToken;
            this.trace.info(`the server port forwarded, port number is ${this.remotePortReference}`);
            this.trace.info('vscode server startup complete');
            this.onVSCodeServerStartedEmitter.fire({
                port: this.remotePort,
                connectionToken: this.connectionToken,
            });
            return this.remotePort;
        });
    }
    /**
     * The remote port that vscode server is running on.
     */
    get remotePort() {
        (0, vscs_utils_1.assertDefined)(this.remotePortReference, 'No remote port found.');
        return this.remotePortReference;
    }
    get connectionToken() {
        (0, vscs_utils_1.assertDefined)(this.connectionTokenReference, 'Connection token not found.');
        return this.connectionTokenReference;
    }
    startForwardingPort(port, revivedTunnels = new Set(), host = exports.DEFAULT_FORWARDING_HOST, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info(`start sharing the port "${port}"`);
            const servers = yield this.getSharedServers(timeout);
            return yield this.startForwardingPortCore(servers, port, host, revivedTunnels);
        });
    }
    updateForwardedPortProtocol(port, isHttps, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info(`updating protocol of "${port}" to "${isHttps}"`);
            const servers = yield this.getSharedServers(timeout);
            const currentPort = (0, findSourcePort_1.findSourcePort)(servers, port);
            (0, vscs_utils_1.assertDefined)(currentPort, `No port "${port}" found.`);
            return yield this.updateForwardedPortProtocolCore(currentPort, port, isHttps);
        });
    }
    updateForwardedPortPrivacy(port, privacy, revivedTunnels = new Set(), host = exports.DEFAULT_FORWARDING_HOST, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info(`updating privacy of "${port}" to "${privacy}"`);
            const servers = yield this.getSharedServers(timeout);
            const currentPort = (0, findSourcePort_1.findSourcePort)(servers, port);
            (0, vscs_utils_1.assertDefined)(currentPort, `No port "${port}" found.`);
            return yield this.updateForwardedPortPrivacyCore(currentPort, port, privacy, revivedTunnels, host);
        });
    }
    stopForwardingPort(port) {
        return __awaiter(this, void 0, void 0, function* () {
            const serverSharingClient = this.workspaceClient.getServiceProxy(vsls_contracts_1.vsls.ServerSharingService);
            yield serverSharingClient.stopSharingAsync(port);
            return this;
        });
    }
    openChannel(performance = this.performance, useForecast = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (useForecast) {
                const channelPromise = this.forecastChannels.shift();
                if (channelPromise) {
                    return yield channelPromise;
                }
            }
            const streamManager = this.getRpcService(vsls_contracts_1.vsls.StreamManagerService);
            const streamId = yield performance.measure({
                name: 'get stream Id',
                id: (0, vscs_utils_1.randomString)(),
            }, () => __awaiter(this, void 0, void 0, function* () {
                (0, vscs_utils_1.assertDefined)(this.sharedServer, 'No SharedServer found.');
                return yield streamManager.getStreamAsync(this.sharedServer.streamName, this.sharedServer.streamCondition);
            }));
            const channel = yield performance.measure({
                name: `open streaming channel "${streamId}"`,
            }, () => __awaiter(this, void 0, void 0, function* () {
                return yield this.workspaceClient.openStreamingChannel(streamId);
            }));
            return channel || null;
        });
    }
    // TODO legomushroom - move out of the common connection class
    // [ref:0fd69cbff577529b853378fd51839fb7]
    sendHandshakeRequest(requestStr) {
        return __awaiter(this, void 0, void 0, function* () {
            const openedChannel = new vscs_utils_1.Signal();
            try {
                this.trace.info('opening ssh channel');
                const channel = yield this.openChannel();
                (0, vscs_utils_1.assertDefined)(channel, 'Cannot open a channel.');
                const dataReceivedHandler = channel.onDataReceived((e) => {
                    // the first request on this channel is for the handshake,
                    // ignore all other data messages as the consumer will set up its own listeners.
                    dataReceivedHandler.dispose();
                    this.trace.info(`response: \n${e.toString()}\n`);
                    channel.adjustWindow(e.length);
                    openedChannel.resolve(channel);
                });
                this.addToDisposables(dataReceivedHandler);
                this.trace.info(`sending the request: \n${requestStr}\n`);
                yield channel.send(Buffer.from(requestStr));
                this.trace.info('🔌 connected');
            }
            catch (e) {
                this.trace.info('failed to send request');
                openedChannel.reject(e);
            }
            return yield openedChannel.promise;
        });
    }
    /**
     * Disconnect method is disposing the connection. Will cause the
     * `onConnectionChanged` and `onDispose` events to be fired.
     */
    disconnect(reason) {
        const _super = Object.create(null, {
            disconnect: { get: () => super.disconnect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.trace.info(`disconnecting with reason: "${reason}"`);
            if (this.isDisconnected) {
                this.trace.info('already disconnected');
                return;
            }
            try {
                // stop sharing the vscode server port
                if (this.remotePortReference && this.serverSharingServiceReference) {
                    this.trace.info(`stop sharing vscode server port "${this.remotePortReference}"`);
                    yield this.serverSharingService.stopSharingAsync(this.remotePortReference);
                }
                // shut down the vscode server
                yield this.vscodeServerHostClient.shutDownRemoteServerAsync();
            }
            catch (e) {
                this.trace.warning('error while disconnecting', e);
            }
            finally {
                this.remotePortReference = null;
                this.vscodeServerHostClientReference = null;
            }
            _super.disconnect.call(this, reason);
        });
    }
    startForwardingPortCore(servers, port, host = exports.DEFAULT_FORWARDING_HOST, revivedTunnels) {
        return __awaiter(this, void 0, void 0, function* () {
            const server = (0, findSourcePort_1.findSourcePort)(servers, port);
            if (server) {
                this.trace.info(`port ${port} is already forwarded.`);
                return server;
            }
            // Create signal for starting the port.
            const startPortSignal = new PortSignal_1.PortSignal(port, vsls_contracts_1.vsls.ChangeKind.Start, this.serverSharingService);
            const sharedServer = yield this.serverSharingService.startSharingAsync(port, host, '');
            // Wait for success signal from the agent only if this is a port forwarded by the user
            // and not a revived tunnel from a previous session.
            if (!(0, isVSCodeServerSession_1.isVSCodeServerSession)(host) && !revivedTunnels.has(port)) {
                yield startPortSignal.waitForSignal();
            }
            return sharedServer;
        });
    }
    updateForwardedPortProtocolCore(server, port, isHttps) {
        return __awaiter(this, void 0, void 0, function* () {
            if (server.hasTLSHandshakePassed === isHttps) {
                this.trace.info(`port ${port} protocol is already ${isHttps ? 'https' : 'http'}.`);
                return this;
            }
            yield this.serverSharingService.updateSharedServerProtocolAsync(port, isHttps);
            this.trace.info(`port ${port} protocol updated to ${isHttps ? 'https' : 'http'}.`);
            return this;
        });
    }
    updateForwardedPortPrivacyCore(server, port, privacy, revivedTunnels, host = exports.DEFAULT_FORWARDING_HOST) {
        return __awaiter(this, void 0, void 0, function* () {
            if (server.privacy === privacy) {
                this.trace.info(`port ${port} privacy is already ${privacy}.`);
                return this;
            }
            // Create signal for updating the port.
            const updatePortSignal = new PortSignal_1.PortSignal(port, vsls_contracts_1.vsls.ChangeKind.Update, this.serverSharingService);
            yield this.serverSharingService.updateSharedServerPrivacyAsync(port, privacy);
            this.trace.info(`port ${port} privacy updated to ${privacy}.`);
            // Wait for success signal from the agent only if this is a port forwarded by the user
            // and not a revived tunnel from a previous session.
            if (!(0, isVSCodeServerSession_1.isVSCodeServerSession)(host) && !revivedTunnels.has(port)) {
                yield updatePortSignal.waitForSignal();
            }
            return this;
        });
    }
    /*
     * Stop forwarding vscode server port.
     */
    dispose(reason) {
        if (this.remotePortReference == null) {
            return super.dispose(reason);
        }
        this.trace.info(`stopping remote port "${this.remotePortReference}"`);
        this.stopForwardingPort(this.remotePortReference).catch((e) => {
            this.trace.warning('failed to stop forwarding vscode server port');
        });
        return super.dispose(reason);
    }
}
/**
 * VS Code always requests 2 channels when connecting. The channels will be pre-allocated
 * so that those connections can be setup faster.
 */
VSCodeConnection.channelForecast = 2;
__decorate([
    (0, vscs_utils_2.withHelperDecorator)(vscs_utils_1.withMutexByArguments, {
        serializeArguments: (servers, port, host = exports.DEFAULT_FORWARDING_HOST) => {
            return `${port}_${host}`;
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Number, String, Set]),
    __metadata("design:returntype", Promise)
], VSCodeConnection.prototype, "startForwardingPortCore", null);
exports.VSCodeConnection = VSCodeConnection;
//# sourceMappingURL=VSCodeConnection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/connection/VSCodeJointConnection.js":
/*!***********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/connection/VSCodeJointConnection.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VSCodeJointConnection = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const Connection_1 = __webpack_require__(/*! ./Connection */ "../../workspace/connection-hub/dist/src/connection/Connection.js");
/**
 * Class to connect establish a VSCode connection through a main thread or service worker.
 * Currently the fastest to connect wins, but in the future, we can add different criteria on
 * what connection should be used - for instance connection with better throughput or latency
 * characteristics can win instead, and the connections might be upgraded/downgraded dynamically.
 */
class VSCodeJointConnection extends Connection_1.Connection {
    constructor(trace, performance, options, connectionHubs) {
        super(trace.createChild('vscode-joint'), performance);
        this.performance = performance;
        this.options = options;
        this.connectionHubs = connectionHubs;
        this.connectionReference = null;
    }
    getSharedServers() {
        throw new vscs_utils_1.NotImplementedError('Method not implemented.');
    }
    get vscodeServerHostClient() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'No connection found.');
        return this.connectionReference.vscodeServerHostClient;
    }
    get serverSharingService() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'No connection found.');
        return this.connectionReference.serverSharingService;
    }
    getRpcService(rpcServiceContract) {
        throw new Error('Method not implemented.');
    }
    get connection() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'No connection found.');
        return this.connectionReference;
    }
    get workspaceClient() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'No connection found.');
        const { liveshareConnection } = this.connectionReference;
        (0, vscs_utils_1.assertDefined)(liveshareConnection, 'No LiveShare connection found.');
        return liveshareConnection.workspaceClient;
    }
    get liveshareConnection() {
        var _a, _b;
        (0, vscs_utils_1.assertDefined)((_a = this.connectionReference) === null || _a === void 0 ? void 0 : _a.liveshareConnection, 'No LiveShare conneciton found.');
        return (_b = this.connectionReference) === null || _b === void 0 ? void 0 : _b.liveshareConnection;
    }
    get sharedServer() {
        return this.connection.sharedServer;
    }
    openChannel(performance) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield ((_a = this.connectionReference) === null || _a === void 0 ? void 0 : _a.openChannel(performance));
            return result !== null && result !== void 0 ? result : null;
        });
    }
    get onVSCodeServerStarted() {
        return this.connection.onVSCodeServerStarted;
    }
    get remotePort() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'No connection found.');
        return this.connectionReference.remotePort;
    }
    get connectionToken() {
        (0, vscs_utils_1.assertDefined)(this.connectionReference, 'Connection token not found.');
        return this.connectionReference.connectionToken;
    }
    startForwardingPort(port) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.connection.startForwardingPort(port);
        });
    }
    updateForwardedPortProtocol(port, isHttps) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.updateForwardedPortProtocol(port, isHttps);
            return this;
        });
    }
    updateForwardedPortPrivacy(port, privacy) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connection.updateForwardedPortPrivacy(port, privacy);
            return this;
        });
    }
    stopForwardingPort(port) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.stopForwardingPort(port));
            return this;
        });
    }
    sendHandshakeRequest(requestStr) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.connection.sendHandshakeRequest(requestStr);
        });
    }
    /******************************************************
     * Implementation details.
     ******************************************************/
    createConnectionMock() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.trace.info('creating connection');
                this.connectionSignal = new vscs_utils_1.Signal();
                this.addToDisposables(this.connectionSignal);
                const [connectionHub, remoteConnectionHub] = this.connectionHubs;
                (0, vscs_utils_1.assertDefined)(connectionHub, 'No VSCode ConnectionHub found.');
                (0, vscs_utils_1.assertDefined)(remoteConnectionHub, 'No Remote VSCode ConnectionHub found.');
                this.onConnectionChangedHandler('connecting');
                const connection = yield (0, vscs_utils_1.raceAsync)([
                    connectionHub.connectOnce(this.options, {
                        performance: this.performance.createGroup('main-thread'),
                    }),
                    remoteConnectionHub.connectOnce(this.options, {
                        performance: this.performance.createGroup('service-worker'),
                    }),
                ]);
                (0, vscs_utils_1.assertDefined)(this.connectionSignal, 'No connection signal found.');
                (0, vscs_utils_1.assertDefined)(connection.liveshareConnection, 'Connected but no LiveShare connection found.');
                this.connectionReference = connection;
                this.addToDisposables(connection);
                this.addToDisposables(connection.onConnectionChanged(this.onConnectionChangedEventEmitter.fire.bind(connection)));
                this.connectionSignal.resolve(this);
                // fire the event after the connection completed
                (0, vscs_utils_1.defer)(() => {
                    this.onConnectionChangedHandler('connected');
                });
                return this;
            }
            catch (e) {
                this.handleConnectionError(e);
                throw e;
            }
        });
    }
}
exports.VSCodeJointConnection = VSCodeJointConnection;
//# sourceMappingURL=VSCodeJointConnection.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/constants.js":
/*!************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CODESPACES_PORT_NAME = exports.VSCODE_SERVER_PORT_NAME = void 0;
exports.VSCODE_SERVER_PORT_NAME = 'VSCodeServerInternal';
exports.CODESPACES_PORT_NAME = 'CodespacesInternal';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js":
/*!*************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionCancellationError = void 0;
const ConnectionError_1 = __webpack_require__(/*! ./ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
class ConnectionCancellationError extends ConnectionError_1.ConnectionError {
    constructor() {
        super(...arguments);
        this.errorType = 'ConnectionCancellationError';
    }
}
exports.ConnectionCancellationError = ConnectionCancellationError;
//# sourceMappingURL=ConnectionCancellationError.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js":
/*!*************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/errors/ConnectionError.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionError = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
/**
 * The main error type for the connection hub package. All errors
 * thrown by this package or any of libraries used by the package
 * should derrive from this class.
 */
class ConnectionError extends vscs_utils_1.BaseError {
    constructor() {
        super(...arguments);
        this.errorType = 'ConnectionError';
    }
}
exports.ConnectionError = ConnectionError;
//# sourceMappingURL=ConnectionError.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/errors/ConnectionStateError.js":
/*!******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/errors/ConnectionStateError.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionStateError = void 0;
const ConnectionError_1 = __webpack_require__(/*! ./ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
class ConnectionStateError extends ConnectionError_1.ConnectionError {
    constructor() {
        super(...arguments);
        this.errorType = 'ConnectionStateError';
    }
}
exports.ConnectionStateError = ConnectionStateError;
//# sourceMappingURL=ConnectionStateError.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js":
/*!********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionTimeoutError = void 0;
const ConnectionError_1 = __webpack_require__(/*! ./ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
class ConnectionTimeoutError extends ConnectionError_1.ConnectionError {
    constructor() {
        super(...arguments);
        this.errorType = 'ConnectionTimeoutError';
    }
}
exports.ConnectionTimeoutError = ConnectionTimeoutError;
//# sourceMappingURL=ConnectionTimeoutError.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/errors/index.js":
/*!***************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/errors/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionCancellationError = exports.ConnectionStateError = exports.ConnectionTimeoutError = exports.ConnectionError = void 0;
/**
 * The main error type for the connection hub package. All errors
 * thrown by this package or any of libraries used by the package
 * should derrive from this class.
 */
var ConnectionError_1 = __webpack_require__(/*! ./ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return ConnectionError_1.ConnectionError; } }));
/**
 * `ConnectionTimeoutError` expected to be throw when a connection
 * attempt timeouts.
 */
var ConnectionTimeoutError_1 = __webpack_require__(/*! ./ConnectionTimeoutError */ "../../workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js");
Object.defineProperty(exports, "ConnectionTimeoutError", ({ enumerable: true, get: function () { return ConnectionTimeoutError_1.ConnectionTimeoutError; } }));
/**
 * `ConnectionStateError` when connection encounters unexpected state,
 * commonly from the public method call, for instance, if you try to
 * add a `onConnectionChange` event listener to a disposed connection.
 */
var ConnectionStateError_1 = __webpack_require__(/*! ./ConnectionStateError */ "../../workspace/connection-hub/dist/src/errors/ConnectionStateError.js");
Object.defineProperty(exports, "ConnectionStateError", ({ enumerable: true, get: function () { return ConnectionStateError_1.ConnectionStateError; } }));
/**
 * `ConnectionCancellationError` when the connection is cancelled or disposed
 * during on going connection (connection has the `connecting` status).
 */
var ConnectionCancellationError_1 = __webpack_require__(/*! ./ConnectionCancellationError */ "../../workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js");
Object.defineProperty(exports, "ConnectionCancellationError", ({ enumerable: true, get: function () { return ConnectionCancellationError_1.ConnectionCancellationError; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/index.js":
/*!********************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VSCODE_SERVER_PORT_NAME = exports.PerformanceGroupIds = exports.PerformanceEventIds = exports.mocks = exports.TConnectionTypes = exports.vscodeServerHostRPCService = exports.isCodespacesInternalSession = exports.isVSCodeServerSession = exports.getVSCodeServerSessionName = exports.errorToConnectionError = exports.ConnectionHub = exports.VSCodeJointConnection = exports.LiveShareJointConnection = exports.CodespaceConnection = exports.VSCodeConnection = exports.LiveShareConnection = exports.Connection = void 0;
// Connections
var Connection_1 = __webpack_require__(/*! ./connection/Connection */ "../../workspace/connection-hub/dist/src/connection/Connection.js");
Object.defineProperty(exports, "Connection", ({ enumerable: true, get: function () { return Connection_1.Connection; } }));
var LiveShareConnection_1 = __webpack_require__(/*! ./connection/LiveShareConnection */ "../../workspace/connection-hub/dist/src/connection/LiveShareConnection.js");
Object.defineProperty(exports, "LiveShareConnection", ({ enumerable: true, get: function () { return LiveShareConnection_1.LiveShareConnection; } }));
var VSCodeConnection_1 = __webpack_require__(/*! ./connection/VSCodeConnection */ "../../workspace/connection-hub/dist/src/connection/VSCodeConnection.js");
Object.defineProperty(exports, "VSCodeConnection", ({ enumerable: true, get: function () { return VSCodeConnection_1.VSCodeConnection; } }));
var CodespaceConnection_1 = __webpack_require__(/*! ./connection/CodespaceConnection */ "../../workspace/connection-hub/dist/src/connection/CodespaceConnection.js");
Object.defineProperty(exports, "CodespaceConnection", ({ enumerable: true, get: function () { return CodespaceConnection_1.CodespaceConnection; } }));
// - joint
var LiveShareJointConnection_1 = __webpack_require__(/*! ./connection/LiveShareJointConnection */ "../../workspace/connection-hub/dist/src/connection/LiveShareJointConnection.js");
Object.defineProperty(exports, "LiveShareJointConnection", ({ enumerable: true, get: function () { return LiveShareJointConnection_1.LiveShareJointConnection; } }));
var VSCodeJointConnection_1 = __webpack_require__(/*! ./connection/VSCodeJointConnection */ "../../workspace/connection-hub/dist/src/connection/VSCodeJointConnection.js");
Object.defineProperty(exports, "VSCodeJointConnection", ({ enumerable: true, get: function () { return VSCodeJointConnection_1.VSCodeJointConnection; } }));
// ConnectionHub
var ConnectionHub_1 = __webpack_require__(/*! ./connectionHub/ConnectionHub */ "../../workspace/connection-hub/dist/src/connectionHub/ConnectionHub.js");
Object.defineProperty(exports, "ConnectionHub", ({ enumerable: true, get: function () { return ConnectionHub_1.ConnectionHub; } }));
// utils
var errorToConnectionError_1 = __webpack_require__(/*! ./utils/errorToConnectionError */ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js");
Object.defineProperty(exports, "errorToConnectionError", ({ enumerable: true, get: function () { return errorToConnectionError_1.errorToConnectionError; } }));
var getVSCodeServerSessionName_1 = __webpack_require__(/*! ./utils/getVSCodeServerSessionName */ "../../workspace/connection-hub/dist/src/utils/getVSCodeServerSessionName.js");
Object.defineProperty(exports, "getVSCodeServerSessionName", ({ enumerable: true, get: function () { return getVSCodeServerSessionName_1.getVSCodeServerSessionName; } }));
var isVSCodeServerSession_1 = __webpack_require__(/*! ./utils/isVSCodeServerSession */ "../../workspace/connection-hub/dist/src/utils/isVSCodeServerSession.js");
Object.defineProperty(exports, "isVSCodeServerSession", ({ enumerable: true, get: function () { return isVSCodeServerSession_1.isVSCodeServerSession; } }));
var isCodespacesInternalSession_1 = __webpack_require__(/*! ./utils/isCodespacesInternalSession */ "../../workspace/connection-hub/dist/src/utils/isCodespacesInternalSession.js");
Object.defineProperty(exports, "isCodespacesInternalSession", ({ enumerable: true, get: function () { return isCodespacesInternalSession_1.isCodespacesInternalSession; } }));
// interfaces & contracts
var VSCodeServerHostRPCService_1 = __webpack_require__(/*! ./interfaces/VSCodeServerHostRPCService */ "../../workspace/connection-hub/dist/src/interfaces/VSCodeServerHostRPCService.js");
Object.defineProperty(exports, "vscodeServerHostRPCService", ({ enumerable: true, get: function () { return VSCodeServerHostRPCService_1.vscodeServerHostRPCService; } }));
var TConnectionTypes_1 = __webpack_require__(/*! ./interfaces/TConnectionTypes */ "../../workspace/connection-hub/dist/src/interfaces/TConnectionTypes.js");
Object.defineProperty(exports, "TConnectionTypes", ({ enumerable: true, get: function () { return TConnectionTypes_1.TConnectionTypes; } }));
// Errors
__exportStar(__webpack_require__(/*! ./errors */ "../../workspace/connection-hub/dist/src/errors/index.js"), exports);
// mocks
const mocks = __importStar(__webpack_require__(/*! ./mocks */ "../../workspace/connection-hub/dist/src/mocks/index.js"));
exports.mocks = mocks;
// performance
var PerformanceEventIds_1 = __webpack_require__(/*! ./performance/PerformanceEventIds */ "../../workspace/connection-hub/dist/src/performance/PerformanceEventIds.js");
Object.defineProperty(exports, "PerformanceEventIds", ({ enumerable: true, get: function () { return PerformanceEventIds_1.PerformanceEventIds; } }));
var PerformanceGroupIds_1 = __webpack_require__(/*! ./performance/PerformanceGroupIds */ "../../workspace/connection-hub/dist/src/performance/PerformanceGroupIds.js");
Object.defineProperty(exports, "PerformanceGroupIds", ({ enumerable: true, get: function () { return PerformanceGroupIds_1.PerformanceGroupIds; } }));
// constants
var constants_1 = __webpack_require__(/*! ./constants */ "../../workspace/connection-hub/dist/src/constants.js");
Object.defineProperty(exports, "VSCODE_SERVER_PORT_NAME", ({ enumerable: true, get: function () { return constants_1.VSCODE_SERVER_PORT_NAME; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/interfaces/TConnectionTypes.js":
/*!******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/interfaces/TConnectionTypes.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TConnectionTypes = void 0;
var TConnectionTypes;
(function (TConnectionTypes) {
    TConnectionTypes["MainThread"] = "MainThread";
    TConnectionTypes["ServiceWorker"] = "ServiceWorker";
    TConnectionTypes["WorkspaceHub"] = "WorkspaceHub";
})(TConnectionTypes = exports.TConnectionTypes || (exports.TConnectionTypes = {}));
//# sourceMappingURL=TConnectionTypes.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/interfaces/VSCodeServerHostRPCService.js":
/*!****************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/interfaces/VSCodeServerHostRPCService.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vscodeServerHostRPCService = void 0;
exports.vscodeServerHostRPCService = {
    name: 'IVSCodeServerHostService',
    methods: [
        'startRemoteServer',
        'startRemoteServerResult',
        'exportLogs',
        'shutDownRemoteServer',
        'getVMTerminalFilePath',
        'getContainerTerminalFilePath',
        'getStateFolderPath',
        'getSharedFolderPath',
        'getCodespaceStateFilePath',
        'getDevcontainerStateFilePath',
        'getSharedFile',
        'getContainerPersistedFolderPath',
        'isRecoveryContainer',
        'terminateOryxTask',
        'downloadVsCodeServerByCommitId',
        'getPerformanceData',
        'getCreationLogStatus',
    ],
    events: [
        'configurationFinished',
        'devContainerConfigChanged',
        'codespaceStopping',
        'codespaceAvailable',
        'creationLogUpdated',
    ],
};
//# sourceMappingURL=VSCodeServerHostRPCService.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/connectionHub/ConnectionHubMock.js":
/*!****************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/connectionHub/ConnectionHubMock.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionHubMock = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const ConnectionHub_1 = __webpack_require__(/*! ../../connectionHub/ConnectionHub */ "../../workspace/connection-hub/dist/src/connectionHub/ConnectionHub.js");
class ConnectionHubMock extends ConnectionHub_1.ConnectionHub {
    constructor() {
        super(...arguments);
        /**
         * Mock the failure for the `this.createConnection` method.
         */
        this.mockCreateConnectionFail = (error, delay = 1) => {
            this.createConnection = () => __awaiter(this, void 0, void 0, function* () {
                yield (0, vscs_utils_1.wait)(delay);
                throw error;
            });
        };
    }
    /**
     * Expose the method to calculate the connection id.
     */
    getConnectionIdMock(options) {
        return this.getConnectionId(options);
    }
    /**
     * Get `ConnectionMock` instantse by `ConnectionMockOptions`.
     */
    getConnectionMock(options) {
        const id = this.getConnectionId(options);
        const record = this.connections[id];
        return record ? record.connection : undefined;
    }
    /**
     * Get `ConnectionMock` record instantse by `ConnectionMockOptions`.
     */
    getConnectionRecordMock(options) {
        const id = this.getConnectionId(options);
        const record = this.connections[id];
        return record;
    }
}
exports.ConnectionHubMock = ConnectionHubMock;
//# sourceMappingURL=ConnectionHubMock.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js":
/*!**********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionMock = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vscs_utils_2 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const Connection_1 = __webpack_require__(/*! ../../connection/Connection */ "../../workspace/connection-hub/dist/src/connection/Connection.js");
const ConnectionError_1 = __webpack_require__(/*! ../../errors/ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
// import { IConnectionMockOptions } from '../interfaces/IConnectionMockOptions';
/**
 * `ConnectionMock` is a `Connection` class for the tests.
 * Exposes some `protected` properties and adds few mock methods.
 */
class ConnectionMock extends Connection_1.Connection {
    constructor() {
        super(...arguments);
        /**
         * Expose `onConnectionChangedEventEmitter` for tests.
         */
        this.onConnectionChangedEventEmitterMock = this.onConnectionChangedEventEmitter;
    }
    /**
     * Get connection `id` from the connection `options`.
     */
    getId(options) {
        const { id, someProp, numericProp } = options;
        return `${id}_${someProp}_${numericProp}`;
    }
    /**
     * Expose `onConnectionChangedHandler` for tests.
     */
    onConnectionChangedHandlerMock(connectionStatus, error) {
        return this.onConnectionChangedHandler(connectionStatus, error);
    }
    /**
     * Expose `connectionSignal` for tests.
     */
    get connectionSignalMock() {
        return this.connectionSignal;
    }
    /**
     * Finish the connection, error presence defines the connection result.
     */
    finish(error) {
        (0, vscs_utils_1.assertDefined)(this.connectionSignal, 'No `Connection Signal` found.');
        if (error) {
            this.connectionSignal.reject(error);
            return this;
        }
        this.connectionSignal.resolve(this);
        return this;
    }
    /**
     * Finish the connection with optional `delay`. Error presence defines
     * the connection result. If `delay` is not set, the connection is
     * finished immediatelly.
     */
    finishWithDelay(error, delay = 0) {
        if (!delay) {
            return this.finish(error);
        }
        (0, vscs_utils_2.defer)(() => {
            this.finish(error);
        }, delay);
        return this;
    }
    /**
     * Mock implementation of the `Connection` waits on the connection
     * signal and sets the `status` to connected, if no error thrown.
     */
    createConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initializeConnection();
            (0, vscs_utils_1.assertDefined)(this.connectionSignal, new ConnectionError_1.ConnectionError('No `connectionSignal` found.'));
            yield this.connectionSignal.promise;
            this.onConnectionChangedHandler('connected');
            return this;
        });
    }
    /**
     * Expose the `initializeConnection` for tests.
     */
    initializeConnectionMock() {
        return this.initializeConnection();
    }
    /**
     * Expose the `performance` for tests.
     */
    get performanceMock() {
        return this.performance;
    }
}
exports.ConnectionMock = ConnectionMock;
//# sourceMappingURL=ConnectionMock.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/connection/VSCodeConnectionMock.js":
/*!****************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/connection/VSCodeConnectionMock.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VSCodeConnectionMock = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
const ConnectionMock_1 = __webpack_require__(/*! ./ConnectionMock */ "../../workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js");
class VSCodeConnectionMock extends ConnectionMock_1.ConnectionMock {
    constructor() {
        super(...arguments);
        this.onVSCodeServerStarted = new vscode_jsonrpc_1.Emitter().event;
    }
    get workspaceClient() {
        return {};
    }
    get liveshareConnection() {
        return {};
    }
    get vscodeServerHostClient() {
        return {};
    }
    sendHandshakeRequest(requestStr) {
        return {};
    }
    openChannel(performance) {
        return Promise.resolve(null);
    }
    startForwardingPort(port) {
        return Promise.resolve({});
    }
    stopForwardingPort(port) {
        return Promise.resolve(this);
    }
    updateForwardedPortProtocol(port, isHttps) {
        return Promise.resolve(this);
    }
    updateForwardedPortPrivacy(port, privacy) {
        return Promise.resolve(this);
    }
    get serverSharingService() {
        return {};
    }
    get sharedServer() {
        return {};
    }
    get remotePort() {
        return 0;
    }
    get connectionToken() {
        return '';
    }
    getSharedServers() {
        throw new Error('Method not implemented.');
    }
    getRpcService(rpcServiceContract) {
        throw new Error('Method not implemented.');
    }
}
exports.VSCodeConnectionMock = VSCodeConnectionMock;
//# sourceMappingURL=VSCodeConnectionMock.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionHubMockOptions.js":
/*!********************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionHubMockOptions.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConnectionHubMockOptions = exports.performance = exports.testTrace = void 0;
const vscs_performance_1 = __webpack_require__(/*! @vs/vscs-performance */ "../../performance/dist/src/index.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const ConnectionMock_1 = __webpack_require__(/*! ../connection/ConnectionMock */ "../../workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js");
// import { IConnectionMock } from '../connectionHub/IConnectionMock';
// import { IConnectionMockOptions } from '../interfaces/IConnectionMockOptions';
exports.testTrace = new vso_logging_1.TraceSource('test-trace');
exports.performance = (0, vscs_performance_1.initializePerformanceInstance)('test:start');
/**
 * Mock helper to generate default `ConnectionHubMock` options.
 * Pass real trace if you want to see logs in the console.
 */
const getConnectionHubMockOptions = (options = {}) => {
    const { trace = exports.testTrace, childHubs } = options;
    return [
        trace,
        exports.performance,
        ConnectionMock_1.ConnectionMock,
        childHubs,
    ];
};
exports.getConnectionHubMockOptions = getConnectionHubMockOptions;
//# sourceMappingURL=getConnectionHubMockOptions.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionMockOptions.js":
/*!*****************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionMockOptions.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConnectionMockOptions = exports.testTrace = exports.getRandomConnectionMockOptions = exports.PerformanceMock = void 0;
const vscs_performance_1 = __webpack_require__(/*! @vs/vscs-performance */ "../../performance/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
// import { mocks } from '../../../src';
exports.PerformanceMock = vscs_performance_1.mocks.PerformanceMock;
/**
 * Mock helper to a random `IConnectionMockOptions`.
 */
const getRandomConnectionMockOptions = () => {
    return {
        id: (0, vscs_utils_1.randomString)(),
        someProp: (0, vscs_utils_1.randomString)(),
        numericProp: (0, vscs_utils_1.randomInt)(100),
    };
};
exports.getRandomConnectionMockOptions = getRandomConnectionMockOptions;
exports.testTrace = new vso_logging_1.TraceSource('test-trace');
const performance = new exports.PerformanceMock('test-performance', 'test-start');
/**
 * Mock helper to generate default `ConnectionMock` options.
 * Pass real trace if you want to see logs in the console.
 */
const getConnectionMockOptions = (options = {}) => {
    const { trace = exports.testTrace } = options;
    return [
        trace,
        performance,
        Object.assign({}, (0, exports.getRandomConnectionMockOptions)()),
    ];
};
exports.getConnectionMockOptions = getConnectionMockOptions;
//# sourceMappingURL=getConnectionMockOptions.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/helpers/getLiveShareConnectionMockOptionsTestHelper.js":
/*!************************************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/helpers/getLiveShareConnectionMockOptionsTestHelper.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLiveShareConnectionMockOptions = exports.getRandomLiveShareMockOptions = exports.testTrace = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const getConnectionMockOptions_1 = __webpack_require__(/*! ./getConnectionMockOptions */ "../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionMockOptions.js");
exports.testTrace = new vso_logging_1.TraceSource((0, vscs_utils_1.randomString)());
const getRandomLiveShareMockOptions = () => {
    const connectionInfo = {
        id: 'mock-connection-id',
        relayLink: 'sb://test-namespace.servicebus.windows.net/anyEndpointId',
        relaySas: 'mock-relay',
        hostPublicKeys: ['mock-host-public-key'],
        sessionToken: 'mock-session-token',
    };
    return {
        liveShareEndpoint: 'mock-liveshare-endpoint',
        workspaceId: 'mock-id',
        connectionInfo,
        token: 'mock-token',
        id: 'mock-id',
        someProp: 'mock-prop',
        numericProp: 12345,
    };
};
exports.getRandomLiveShareMockOptions = getRandomLiveShareMockOptions;
/**
 * Mock helper to generate default `LiveShareConnectionMock` options.
 * Pass real trace if you want to see logs in the console.
 */
const getLiveShareConnectionMockOptions = (options = {}) => {
    const { trace = exports.testTrace } = options;
    const performance = new getConnectionMockOptions_1.PerformanceMock('test-performance', 'test-start', 'test-path-string');
    return [trace, performance, Object.assign({}, (0, exports.getRandomLiveShareMockOptions)())];
};
exports.getLiveShareConnectionMockOptions = getLiveShareConnectionMockOptions;
//# sourceMappingURL=getLiveShareConnectionMockOptionsTestHelper.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/helpers/index.js":
/*!**********************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/helpers/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLiveShareConnectionMockOptions = exports.getConnectionMockOptions = exports.getConnectionHubMockOptions = void 0;
var getConnectionHubMockOptions_1 = __webpack_require__(/*! ./getConnectionHubMockOptions */ "../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionHubMockOptions.js");
Object.defineProperty(exports, "getConnectionHubMockOptions", ({ enumerable: true, get: function () { return getConnectionHubMockOptions_1.getConnectionHubMockOptions; } }));
var getConnectionMockOptions_1 = __webpack_require__(/*! ./getConnectionMockOptions */ "../../workspace/connection-hub/dist/src/mocks/helpers/getConnectionMockOptions.js");
Object.defineProperty(exports, "getConnectionMockOptions", ({ enumerable: true, get: function () { return getConnectionMockOptions_1.getConnectionMockOptions; } }));
var getLiveShareConnectionMockOptionsTestHelper_1 = __webpack_require__(/*! ./getLiveShareConnectionMockOptionsTestHelper */ "../../workspace/connection-hub/dist/src/mocks/helpers/getLiveShareConnectionMockOptionsTestHelper.js");
Object.defineProperty(exports, "getLiveShareConnectionMockOptions", ({ enumerable: true, get: function () { return getLiveShareConnectionMockOptionsTestHelper_1.getLiveShareConnectionMockOptions; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/index.js":
/*!**************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionMock = exports.ConnectionHubMock = exports.VSCodeConnectionMock = void 0;
// class mocks
var VSCodeConnectionMock_1 = __webpack_require__(/*! ./connection/VSCodeConnectionMock */ "../../workspace/connection-hub/dist/src/mocks/connection/VSCodeConnectionMock.js");
Object.defineProperty(exports, "VSCodeConnectionMock", ({ enumerable: true, get: function () { return VSCodeConnectionMock_1.VSCodeConnectionMock; } }));
var ConnectionHubMock_1 = __webpack_require__(/*! ./connectionHub/ConnectionHubMock */ "../../workspace/connection-hub/dist/src/mocks/connectionHub/ConnectionHubMock.js");
Object.defineProperty(exports, "ConnectionHubMock", ({ enumerable: true, get: function () { return ConnectionHubMock_1.ConnectionHubMock; } }));
var ConnectionMock_1 = __webpack_require__(/*! ./connection/ConnectionMock */ "../../workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js");
Object.defineProperty(exports, "ConnectionMock", ({ enumerable: true, get: function () { return ConnectionMock_1.ConnectionMock; } }));
// helpers
__exportStar(__webpack_require__(/*! ./helpers */ "../../workspace/connection-hub/dist/src/mocks/helpers/index.js"), exports);
// interfaces
__exportStar(__webpack_require__(/*! ./interfaces */ "../../workspace/connection-hub/dist/src/mocks/interfaces/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/mocks/interfaces/index.js":
/*!*************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/mocks/interfaces/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// export { IConnectionMockOptions } from './IConnectionMockOptions';
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/performance/PerformanceEventIds.js":
/*!**********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/performance/PerformanceEventIds.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceEventIds = void 0;
var PerformanceEventIds;
(function (PerformanceEventIds) {
    /**
     * Join a liveshare workspace
     */
    PerformanceEventIds["LiveshareJoinWorkspace"] = "LiveshareJoinWorkspace";
    /**
     * Start vscode server inside the codespace.
     */
    PerformanceEventIds["VSCodeServerStartupServerStart"] = "VSCodeServerStartupServerStart";
    /**
     * Forward vscode server TCP port inside the codespace.
     */
    PerformanceEventIds["VSCodeServerStartupServerTcpPortForwarding"] = "VSCodeServerStartupServerTCPPortForwarding";
})(PerformanceEventIds = exports.PerformanceEventIds || (exports.PerformanceEventIds = {}));
//# sourceMappingURL=PerformanceEventIds.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/performance/PerformanceGroupIds.js":
/*!**********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/performance/PerformanceGroupIds.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceGroupIds = void 0;
var PerformanceGroupIds;
(function (PerformanceGroupIds) {
    /**
     * The time to start vscode server on the remote side:
     *
     *  - including the RPC message travel time
     *  - including downloading vscode server, if needed
     *  - including installing extensions, if needed
     *  - including sharing vscode server port
     */
    PerformanceGroupIds["VSCodeServerStartup"] = "VSCodeServerStartup";
})(PerformanceGroupIds = exports.PerformanceGroupIds || (exports.PerformanceGroupIds = {}));
//# sourceMappingURL=PerformanceGroupIds.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js":
/*!*******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/utils/errorToConnectionError.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorToConnectionError = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const ConnectionCancellationError_1 = __webpack_require__(/*! ../errors/ConnectionCancellationError */ "../../workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js");
const ConnectionError_1 = __webpack_require__(/*! ../errors/ConnectionError */ "../../workspace/connection-hub/dist/src/errors/ConnectionError.js");
/**
 * Map an error to `ConnectionError` instance, all errors thrown by this
 * library or any of the child libraries should extend the `ConnectionError`.
 */
const errorToConnectionError = (e) => {
    /**
     * `ConnectionError` is not wrapped.
     */
    if (e instanceof ConnectionError_1.ConnectionError) {
        return e;
    }
    /**
     * `CancellationError` is wrapped with `ConnectionCancellationError`.
     */
    if (e instanceof vscs_utils_1.CancellationError) {
        return new ConnectionCancellationError_1.ConnectionCancellationError(e);
    }
    /**
     * `generic error` is wrapped with `ConnectionError` base class.
     */
    return new ConnectionError_1.ConnectionError(e);
};
exports.errorToConnectionError = errorToConnectionError;
//# sourceMappingURL=errorToConnectionError.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/utils/findSourcePort.js":
/*!***********************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/utils/findSourcePort.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findSourcePort = void 0;
/**
 * Function to find a specific source port in shared servers list.
 */
// TODO legomushroom - test this
const findSourcePort = (servers, port, targetSessionName) => {
    return servers.find((server) => {
        const { sourcePort, sessionName } = server;
        const isPortMatch = sourcePort === port;
        if (!targetSessionName) {
            return isPortMatch;
        }
        return isPortMatch && sessionName === targetSessionName;
    });
};
exports.findSourcePort = findSourcePort;
//# sourceMappingURL=findSourcePort.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/utils/getVSCodeServerSessionName.js":
/*!***********************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/utils/getVSCodeServerSessionName.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVSCodeServerSessionName = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "../../workspace/connection-hub/dist/src/constants.js");
/**
 * Function to construct vscode server session name.
 */
const getVSCodeServerSessionName = (clientId) => {
    if (!clientId) {
        return constants_1.VSCODE_SERVER_PORT_NAME;
    }
    return `${constants_1.VSCODE_SERVER_PORT_NAME}_${clientId}`;
};
exports.getVSCodeServerSessionName = getVSCodeServerSessionName;
//# sourceMappingURL=getVSCodeServerSessionName.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/utils/isCodespacesInternalSession.js":
/*!************************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/utils/isCodespacesInternalSession.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCodespacesInternalSession = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "../../workspace/connection-hub/dist/src/constants.js");
/**
 * Function to check of forwarded port session belongs to an internal Codespaces port.
 */
const isCodespacesInternalSession = (sessionName) => {
    return sessionName.startsWith(constants_1.CODESPACES_PORT_NAME);
};
exports.isCodespacesInternalSession = isCodespacesInternalSession;
//# sourceMappingURL=isCodespacesInternalSession.js.map

/***/ }),

/***/ "../../workspace/connection-hub/dist/src/utils/isVSCodeServerSession.js":
/*!******************************************************************************!*\
  !*** ../../workspace/connection-hub/dist/src/utils/isVSCodeServerSession.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVSCodeServerSession = void 0;
const constants_1 = __webpack_require__(/*! ../constants */ "../../workspace/connection-hub/dist/src/constants.js");
/**
 * Function to check of forwarded port session belongs to vscode server.
 */
const isVSCodeServerSession = (sessionName) => {
    return sessionName.startsWith(constants_1.VSCODE_SERVER_PORT_NAME);
};
exports.isVSCodeServerSession = isVSCodeServerSession;
//# sourceMappingURL=isVSCodeServerSession.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/ConnectedState.js":
/*!*******************************************************!*\
  !*** ../../workspace/core/dist/src/ConnectedState.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectedState = void 0;
var ConnectedState;
(function (ConnectedState) {
    ConnectedState[ConnectedState["Reconnecting"] = 1] = "Reconnecting";
    ConnectedState[ConnectedState["Reconnected"] = 2] = "Reconnected";
    ConnectedState[ConnectedState["Closed"] = 3] = "Closed";
})(ConnectedState = exports.ConnectedState || (exports.ConnectedState = {}));
//# sourceMappingURL=ConnectedState.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/Errors.js":
/*!***********************************************!*\
  !*** ../../workspace/core/dist/src/Errors.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayConnectionTimeoutError = exports.RelayConnectionError = exports.RelayErrorType = exports.NoHostConnectedError = void 0;
/**
 * Error when a workspace has no host connected, hence no join could happen.
 */
class NoHostConnectedError extends Error {
    constructor(workspaceId) {
        super(`Host not connected to workspace:${workspaceId}`);
        this.workspaceId = workspaceId;
    }
}
exports.NoHostConnectedError = NoHostConnectedError;
/**
 * Type of relay connection error types.
 */
var RelayErrorType;
(function (RelayErrorType) {
    RelayErrorType[RelayErrorType["ConnectionError"] = 1] = "ConnectionError";
    RelayErrorType[RelayErrorType["SasInvalid"] = 2] = "SasInvalid";
    RelayErrorType[RelayErrorType["EndpointNotFound"] = 3] = "EndpointNotFound";
    RelayErrorType[RelayErrorType["ListenerOffline"] = 4] = "ListenerOffline";
    RelayErrorType[RelayErrorType["ServerError"] = 5] = "ServerError";
})(RelayErrorType = exports.RelayErrorType || (exports.RelayErrorType = {}));
/**
 * Error used when a connection to an Azure relay failed.
 */
class RelayConnectionError extends Error {
    constructor(message, errorContext) {
        super(message);
        this.errorContext = errorContext;
    }
}
exports.RelayConnectionError = RelayConnectionError;
/**
 * Error used when a timeout connecting to Azure relay occurs
 */
class RelayConnectionTimeoutError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.RelayConnectionTimeoutError = RelayConnectionTimeoutError;
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/IWorkspaceClient.js":
/*!*********************************************************!*\
  !*** ../../workspace/core/dist/src/IWorkspaceClient.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IWorkspaceClient.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/IWorkspaceConnection.js":
/*!*************************************************************!*\
  !*** ../../workspace/core/dist/src/IWorkspaceConnection.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LatencyMetrics = void 0;
class LatencyMetrics {
    constructor(latencyCurrent, latencyAvg, latencyMin, latencyMax) {
        this.current = latencyCurrent;
        this.average = latencyAvg;
        this.min = latencyMin;
        this.max = latencyMax;
    }
}
exports.LatencyMetrics = LatencyMetrics;
//# sourceMappingURL=IWorkspaceConnection.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/IWorkspaceSessionInfo.js":
/*!**************************************************************!*\
  !*** ../../workspace/core/dist/src/IWorkspaceSessionInfo.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionMode = void 0;
/**
 * Workspace connection mode. Must match vsls.ConnectionMode
 */
var ConnectionMode;
(function (ConnectionMode) {
    ConnectionMode["Auto"] = "auto";
    ConnectionMode["Direct"] = "direct";
    ConnectionMode["Relay"] = "relay";
    ConnectionMode["Local"] = "local";
    ConnectionMode["SignalR"] = "signalR";
    ConnectionMode["DevTunnel"] = "devTunnel";
})(ConnectionMode = exports.ConnectionMode || (exports.ConnectionMode = {}));
//# sourceMappingURL=IWorkspaceSessionInfo.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/RpcErrorCodes.js":
/*!******************************************************!*\
  !*** ../../workspace/core/dist/src/RpcErrorCodes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPC_ERR_RELAY_CONNECTIONY_SSH = exports.RPC_ERR_NO_HOST_NOT_CONNECTED = void 0;
exports.RPC_ERR_NO_HOST_NOT_CONNECTED = 270;
exports.RPC_ERR_RELAY_CONNECTIONY_SSH = 271;
//# sourceMappingURL=RpcErrorCodes.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/WorkspaceApi.js":
/*!*****************************************************!*\
  !*** ../../workspace/core/dist/src/WorkspaceApi.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceApi = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vso_http_client_1 = __webpack_require__(/*! @vs/vso-http-client */ "../../http-client/lib/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const ssh = __importStar(__webpack_require__(/*! @microsoft/dev-tunnels-ssh */ "../../node_modules/@microsoft/dev-tunnels-ssh/index.js"));
const vsls_contracts_1 = __webpack_require__(/*! @vs/vsls-contracts */ "../../vsls-contracts/dist/src/index.js");
/**
 * Class to interact with our liveshare workspace API.
 */
class WorkspaceApi {
    constructor(serviceUri, tokenProvider, logger) {
        this.serviceUri = serviceUri;
        this.tokenProvider = tokenProvider;
        this.logger = logger;
        this.getRequestHeaders = () => __awaiter(this, void 0, void 0, function* () {
            return {
                Authorization: `Bearer ${yield this.tokenProvider()}`,
                'Cache-Control': 'no-cache',
                'Content-Type': 'application/json',
            };
        });
        (0, vscs_utils_1.assertDefined)(serviceUri, 'service uri needs to be defined');
        let baseUri = serviceUri;
        if (!baseUri.endsWith('/')) {
            baseUri = baseUri + '/';
        }
        if (!baseUri.includes('api/v1.2')) {
            baseUri = baseUri + 'api/v1.2';
        }
        // We need to remove the trailing slash in the case it was directly
        // taken from an environment record
        this.baseUri = this.removeTrailingSlash(baseUri);
        this.httpClient = new vso_http_client_1.HttpClient(logger);
    }
    static getWorkspaceSessionInfo(workspaceId, options, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`getWorkspaceSessionInfo -> workspaceId:${workspaceId}`);
            const workspaceApi = new WorkspaceApi(options.liveShareEndpoint, () => options.token, logger);
            const [workspaceAccess, workspaceInfo] = yield Promise.all([
                workspaceApi.getWorkspaceAccess(workspaceId),
                workspaceApi.getWorkspaceInfo(workspaceId),
            ]);
            const workspaceSessionInfo = Object.assign(Object.assign({}, workspaceAccess), workspaceInfo);
            (0, vscs_utils_1.assertDefined)(workspaceInfo, 'Cannot get LiveShare workspace info.');
            (0, vscs_utils_1.assertDefined)(workspaceAccess, 'Cannot get LiveShare workspace access.');
            (0, vscs_utils_1.assertDefined)(workspaceInfo.relaySas, 'No RelaySas token found.');
            return workspaceSessionInfo;
        });
    }
    deleteWorkspace(workspaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(workspaceId, 'Cannot get Live Share workspaceId');
            workspaceId = workspaceId.toUpperCase();
            const url = `${this.baseUri}/workspace/${workspaceId}`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `delete workspace -> ${url}`);
            const response = yield this.httpClient.delete(url, {
                headers: yield this.getRequestHeaders(),
            });
            return response.ok;
        });
    }
    getManagedWorkspaces() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.baseUri}/workspace/managed`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `get managed workspaces -> ${url}`);
            const workspaces = yield this.httpClient
                .get(url, {
                headers: yield this.getRequestHeaders(),
            })
                .value();
            return workspaces;
        });
    }
    deleteLink(workspaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(workspaceId, 'Cannot get Live Share workspaceId');
            workspaceId = workspaceId.toUpperCase();
            const url = `${this.baseUri}/workspace/link/${workspaceId}`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `delete link -> ${url}`);
            const response = yield this.httpClient.delete(url, {
                headers: yield this.getRequestHeaders(),
            });
            return response.ok;
        });
    }
    rename(workspaceId, label) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.baseUri}/workspace/${workspaceId.toUpperCase()}`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `rename workspace -> ${url}`);
            return yield this.httpClient
                .post(url, {
                headers: yield this.getRequestHeaders(),
                body: JSON.stringify(label),
            })
                .value();
        });
    }
    getWorkspaceInfo(workspaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(workspaceId, 'Cannot get Live Share workspaceId');
            workspaceId = workspaceId.toUpperCase();
            const url = `${this.baseUri}/workspace/${workspaceId}`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace info -> ${url}`);
            return yield this.httpClient
                .get(url, {
                headers: yield this.getRequestHeaders(),
            })
                .value();
        });
    }
    getWorkspaceAccess(workspaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(workspaceId, 'Cannot get Live Share workspaceId');
            workspaceId = workspaceId.toUpperCase();
            const url = `${this.baseUri}/workspace/${workspaceId}/user`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace access -> ${url}`);
            return yield this.httpClient
                .put(url, {
                headers: yield this.getRequestHeaders(),
            })
                .value();
        });
    }
    postWorkspaceInfo(workspaceInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.baseUri}/workspace`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `post workspace info -> ${url}`);
            return yield this.httpClient
                .post(url, {
                headers: yield this.getRequestHeaders(),
                body: JSON.stringify(workspaceInfo),
            })
                .value();
        });
    }
    createInvitationLink(invitationLinkInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.baseUri}/workspace/${invitationLinkInfo.workspaceId}/link`;
            const response = yield this.httpClient
                .put(url, {
                headers: yield this.getRequestHeaders(),
                body: JSON.stringify(invitationLinkInfo),
            })
                .value();
            return response;
        });
    }
    getWorkspaceUserProfile(workspaceId, userToken) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, vscs_utils_1.assertDefined)(workspaceId, 'Cannot get Live Share workspaceId');
            workspaceId = workspaceId.toUpperCase();
            const url = `${this.baseUri}/workspace/${workspaceId}/user`;
            this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace user profile -> ${url}`);
            const workspaceUserProfile = yield this.httpClient
                .get(url, {
                headers: Object.assign(Object.assign({}, (yield this.getRequestHeaders())), { 'User-Session-Token': userToken }),
            })
                .value();
            // The collaboration service's WorkspaceGetProfileResponse returns 'username'
            // vsls.WorkspaceUserProfile property has a different casing 'userName'
            if (workspaceUserProfile === null || workspaceUserProfile === void 0 ? void 0 : workspaceUserProfile.username) {
                workspaceUserProfile.userName = workspaceUserProfile.username;
            }
            return workspaceUserProfile;
        });
    }
    static createSshKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const rsa = ssh.SshAlgorithms.publicKey.rsaWithSha512;
            const hostPrivateKey = yield rsa.generateKeyPair();
            const hostPublicKey = (yield hostPrivateKey.getPublicKeyBytes(hostPrivateKey.keyAlgorithmName)).toString('base64');
            return [hostPrivateKey, hostPublicKey];
        });
    }
    createSharedWorkspace(workspaceShareInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const sshKeys = yield WorkspaceApi.createSshKeys();
            const workspacePayload = {
                name: workspaceShareInfo.name,
                connectionMode: (_a = workspaceShareInfo.connectionMode) !== null && _a !== void 0 ? _a : vsls_contracts_1.vsls.ConnectionMode.Relay,
                areAnonymousGuestsAllowed: workspaceShareInfo.areAnonymousGuestsAllowed,
                hostPublicKeys: [sshKeys[1]],
                connectLinks: workspaceShareInfo.connectLinks,
                tunnelProperties: workspaceShareInfo.tunnelProperties,
            };
            const workspaceInfo = yield this.postWorkspaceInfo(workspacePayload);
            return {
                workspaceInfo,
                hostPrivateKeys: [sshKeys[0]],
                getWorkspaceUserProfile: (userToken) => this.getWorkspaceUserProfile(workspaceInfo.id, userToken),
            };
        });
    }
    removeTrailingSlash(baseUri) {
        return baseUri.endsWith('/') ? baseUri.substr(0, baseUri.length - 1) : baseUri;
    }
}
exports.WorkspaceApi = WorkspaceApi;
//# sourceMappingURL=WorkspaceApi.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/WorkspaceClientBase.js":
/*!************************************************************!*\
  !*** ../../workspace/core/dist/src/WorkspaceClientBase.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceClientBase = void 0;
const rpc = __importStar(__webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js"));
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const checkWorkspaceClient_1 = __webpack_require__(/*! ./checkWorkspaceClient */ "../../workspace/core/dist/src/checkWorkspaceClient.js");
const vso_rpc_1 = __webpack_require__(/*! @vs/vso-rpc */ "../../rpc/core/dist/src/index.js");
/**
 * A base class to implement the IWorkspaceClient interface contract.
 */
class WorkspaceClientBase extends vscs_utils_1.DisposableClass {
    constructor(rcpClientInstance, logger) {
        super(logger);
        this.rcpClientInstance = rcpClientInstance;
        this.onHostConnectionChangedEmitter = new rpc.Emitter();
        this.onHostConnectionChanged = this.onHostConnectionChangedEmitter.event;
        this.onWorkspaceMetricsUpdatedEmitter = new rpc.Emitter();
        this.onWorkspaceMetricsUpdated = this.onWorkspaceMetricsUpdatedEmitter.event;
        this.onProgressUpdatedEmitter = new rpc.Emitter();
        this.onProgressUpdated = this.onProgressUpdatedEmitter.event;
        this.rpcProxyCache = new vso_rpc_1.RpcProxyCache(this.rcpClientInstance, logger);
        this.addToDisposables((0, vscs_utils_1.createDisposable)(() => {
            this.stopCheckConnection('disposed');
        }));
    }
    get rpcClient() {
        return this.rcpClientInstance;
    }
    getServiceProxy(serviceInfo, traceName) {
        return this.rpcProxyCache.getOrCreate(serviceInfo, traceName);
    }
    setCheckConnectionOptions(options) {
        if (options.enabled && this.checkConnectionDisposable === undefined && !this.isDisposed) {
            this.ensureIsJoined();
            this.checkConnectionDisposable = (0, checkWorkspaceClient_1.checkWorkspaceClient)(this, this.trace, options.metricsTimeout, options.checkConnectionTimeout, () => this.canCheckConnection());
        }
        else if (!options.enabled) {
            this.stopCheckConnection('connection options');
        }
        return Promise.resolve();
    }
    ensureIsJoined() { }
    canCheckConnection() {
        return true;
    }
    stopCheckConnection(reason) {
        this.trace.info(`stopCheckConnection reason:'${reason}'`);
        if (this.checkConnectionDisposable !== undefined) {
            this.checkConnectionDisposable.dispose();
            this.checkConnectionDisposable = undefined;
        }
    }
}
exports.WorkspaceClientBase = WorkspaceClientBase;
//# sourceMappingURL=WorkspaceClientBase.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/WorkspaceServiceClient.js":
/*!***************************************************************!*\
  !*** ../../workspace/core/dist/src/WorkspaceServiceClient.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.workspaceServiceClient = void 0;
exports.workspaceServiceClient = {
    name: 'workspaceServiceClient',
    methods: [
        'getSessionInfo',
        'join',
        'disconnect',
        'openStreamingChannel',
        'keepAlive',
        'checkConnection',
        'setCheckConnectionOptions',
    ],
    events: ['hostConnectionChanged', 'workspaceMetricsUpdated', 'progressUpdated'],
};
//# sourceMappingURL=WorkspaceServiceClient.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/checkConnectionWithTimeout.js":
/*!*******************************************************************!*\
  !*** ../../workspace/core/dist/src/checkConnectionWithTimeout.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkConnectionWithTimeout = exports.failedtoCheckConnectionMessage = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
// timeout to wait to check to check the health of a connection
const defaultCheckConnectionTimeout = 10 * vscs_utils_1.TIME_SECOND_MS;
// message to log and throw if timeout is reached
exports.failedtoCheckConnectionMessage = 'failed to check connection';
const checkConnectionWithTimeoutMessage = 'checkConnectionWithTimeout';
/**
 * Check a workspace client by invoking the checkConnection method with a timeout
 * @returns false if the connection check failed or timeout.
 */
const checkConnectionWithTimeout = (workspaceClient, logger, checkConnectionTimeout, cancellationTokenSource) => __awaiter(void 0, void 0, void 0, function* () {
    const start = Date.now();
    const totalTime = () => {
        return (Date.now() - start).toFixed(1);
    };
    try {
        logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'started'`);
        yield (0, vscs_utils_1.timeoutPromise)(workspaceClient.checkConnection(), checkConnectionTimeout !== null && checkConnectionTimeout !== void 0 ? checkConnectionTimeout : defaultCheckConnectionTimeout, undefined, cancellationTokenSource);
        logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'succeeded' t:${totalTime()}`);
        return true;
    }
    catch (err) {
        if (err instanceof vscs_utils_1.CancellationError) {
            logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'cancelled' t:${totalTime()}`);
            return true;
        }
        logger === null || logger === void 0 ? void 0 : logger.error(`${checkConnectionWithTimeoutMessage} -> 'failed' t:${totalTime()}`, err);
        return false;
    }
});
exports.checkConnectionWithTimeout = checkConnectionWithTimeout;
//# sourceMappingURL=checkConnectionWithTimeout.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/checkWorkspaceClient.js":
/*!*************************************************************!*\
  !*** ../../workspace/core/dist/src/checkWorkspaceClient.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkWorkspaceClient = void 0;
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const checkConnectionWithTimeout_1 = __webpack_require__(/*! ./checkConnectionWithTimeout */ "../../workspace/core/dist/src/checkConnectionWithTimeout.js");
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../../node_modules/vscode-jsonrpc/lib/main.js");
// timeout to wait on workspace metrics
const defaultTimeout = 5 * vscs_utils_1.TIME_SECOND_MS;
let session = 0;
/**
 * Check if a liveshare connection is healthy by checking the connection when
 * the metrics event is not received in a period of time.
 * @returns A disposable instance if we want to stop the health check.
 */
function checkWorkspaceClient(workspaceClient, logger, metricsTimeout, checkConnectionTimeout, isCheckConnectionEnabled) {
    metricsTimeout = metricsTimeout !== null && metricsTimeout !== void 0 ? metricsTimeout : defaultTimeout;
    logger = logger.createChild(`${++session}`);
    logger.info(`Start checking connection timeout:${metricsTimeout}`);
    let timeoutReference;
    const setTimeoutMetrics = () => {
        timeoutReference = setTimeout(onWorkspaceMetricsTimeout, metricsTimeout);
    };
    const clearTimeoutMetrics = () => {
        clearTimeout(timeoutReference);
    };
    let isChecking = false;
    const cts = new vscode_jsonrpc_1.CancellationTokenSource();
    const isDisposed = () => {
        return cts.token.isCancellationRequested;
    };
    const onWorkspaceMetricsTimeout = () => __awaiter(this, void 0, void 0, function* () {
        if (isDisposed()) {
            return;
        }
        isChecking = true;
        if ((!isCheckConnectionEnabled || isCheckConnectionEnabled()) &&
            !(yield (0, checkConnectionWithTimeout_1.checkConnectionWithTimeout)(workspaceClient, logger, checkConnectionTimeout, cts))) {
            logger.info(`Failed check -> isDisposed:${isDisposed()}`);
            onMetricsDisposable === null || onMetricsDisposable === void 0 ? void 0 : onMetricsDisposable.dispose();
            if (!isDisposed()) {
                workspaceClient.dispose(checkConnectionWithTimeout_1.failedtoCheckConnectionMessage);
            }
        }
        else {
            setTimeoutMetrics();
        }
        isChecking = false;
    });
    workspaceClient.rpcClient.onDispose(() => {
        clearTimeoutMetrics();
    });
    const onMetricsDisposable = workspaceClient.onWorkspaceMetricsUpdated((e) => {
        clearTimeoutMetrics();
        if (!isChecking) {
            setTimeoutMetrics();
        }
    });
    // kick first metrics timeout
    setTimeoutMetrics();
    return {
        dispose: () => {
            logger.info(`Stop checking connection`);
            cts.cancel();
            onMetricsDisposable === null || onMetricsDisposable === void 0 ? void 0 : onMetricsDisposable.dispose();
        },
    };
}
exports.checkWorkspaceClient = checkWorkspaceClient;
//# sourceMappingURL=checkWorkspaceClient.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/index.js":
/*!**********************************************!*\
  !*** ../../workspace/core/dist/src/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceClientBase = exports.ConnectedState = void 0;
var ConnectedState_1 = __webpack_require__(/*! ./ConnectedState */ "../../workspace/core/dist/src/ConnectedState.js");
Object.defineProperty(exports, "ConnectedState", ({ enumerable: true, get: function () { return ConnectedState_1.ConnectedState; } }));
__exportStar(__webpack_require__(/*! ./IWorkspaceSessionInfo */ "../../workspace/core/dist/src/IWorkspaceSessionInfo.js"), exports);
__exportStar(__webpack_require__(/*! ./IWorkspaceConnection */ "../../workspace/core/dist/src/IWorkspaceConnection.js"), exports);
__exportStar(__webpack_require__(/*! ./IWorkspaceClient */ "../../workspace/core/dist/src/IWorkspaceClient.js"), exports);
__exportStar(__webpack_require__(/*! ./WorkspaceApi */ "../../workspace/core/dist/src/WorkspaceApi.js"), exports);
__exportStar(__webpack_require__(/*! ./WorkspaceServiceClient */ "../../workspace/core/dist/src/WorkspaceServiceClient.js"), exports);
__exportStar(__webpack_require__(/*! ./Errors */ "../../workspace/core/dist/src/Errors.js"), exports);
__exportStar(__webpack_require__(/*! ./RpcErrorCodes */ "../../workspace/core/dist/src/RpcErrorCodes.js"), exports);
__exportStar(__webpack_require__(/*! ./telemetryStrings */ "../../workspace/core/dist/src/telemetryStrings.js"), exports);
__exportStar(__webpack_require__(/*! ./checkConnectionWithTimeout */ "../../workspace/core/dist/src/checkConnectionWithTimeout.js"), exports);
__exportStar(__webpack_require__(/*! ./checkWorkspaceClient */ "../../workspace/core/dist/src/checkWorkspaceClient.js"), exports);
var WorkspaceClientBase_1 = __webpack_require__(/*! ./WorkspaceClientBase */ "../../workspace/core/dist/src/WorkspaceClientBase.js");
Object.defineProperty(exports, "WorkspaceClientBase", ({ enumerable: true, get: function () { return WorkspaceClientBase_1.WorkspaceClientBase; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/core/dist/src/telemetryStrings.js":
/*!*********************************************************!*\
  !*** ../../workspace/core/dist/src/telemetryStrings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelemetryPropertyNames = exports.TelemetryEventNames = void 0;
class TelemetryEventNames {
}
exports.TelemetryEventNames = TelemetryEventNames;
TelemetryEventNames.WORKSPACE_RECONNECT = 'workspace-reconnect';
TelemetryEventNames.WORKSPACE_JOIN = 'workspace-join';
TelemetryEventNames.WORKSPACE_JOIN_CONNECTION = 'workspace-join-connection';
TelemetryEventNames.WORKSPACE_CREATE_SESSION = 'workspace-create-session';
TelemetryEventNames.WORKSPACE_GET_SESSION_INFO = 'workspace-get-session-info';
class TelemetryPropertyNames {
}
exports.TelemetryPropertyNames = TelemetryPropertyNames;
TelemetryPropertyNames.RECONNECT_SUCCEEDED = 'reconnect-succeeded';
TelemetryPropertyNames.RECONNECT_ELAPSED = 'reconnect-elapsed';
TelemetryPropertyNames.RECONNECT_RETRY_COUNT = 'reconnect-retry-count';
TelemetryPropertyNames.RECONNECT_ERROR_MESSAGE = 'reconnect-error-message';
TelemetryPropertyNames.RECONNECT_ERROR_REASON = 'reconnect-error-reason';
//# sourceMappingURL=telemetryStrings.js.map

/***/ }),

/***/ "../../workspace/hub-util/dist/src/hubUtils.js":
/*!*****************************************************!*\
  !*** ../../workspace/hub-util/dist/src/hubUtils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startServer = exports.getServerArgOptions = void 0;
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vso_telemetry_1 = __webpack_require__(/*! @vs/vso-telemetry */ "../../telemetry/core/dist/src/index.js");
const vso_node_telemetry_reporter_1 = __webpack_require__(/*! @vs/vso-node-telemetry-reporter */ "../../telemetry/node-telemetry-reporter/dist/src/index.js");
const vso_node_server_1 = __webpack_require__(/*! @vs/vso-node-server */ "../../node/server/dist/src/index.js");
const vscs_utils_1 = __webpack_require__(/*! @vs/vscs-utils */ "../../utils/dist/src/index.js");
const logUtils_1 = __webpack_require__(/*! ./logUtils */ "../../workspace/hub-util/dist/src/logUtils.js");
function getServerArgOptions() {
    return (0, logUtils_1.getLoggingArgOptions)()
        .option('telemetryOptions', {
        description: 'telemetry options',
        type: 'string',
    })
        .option('port', {
        description: 'port number',
        type: 'number',
    })
        .option('pipe', {
        description: 'pipe name',
        type: 'string',
    })
        .option('autoExit', {
        description: 'If auto exit is enabled',
        type: 'boolean',
    })
        .option('disableObfuscation', {
        description: 'If disable obfuscation is enabled',
        type: 'boolean',
    })
        .option('keepAliveTime', {
        description: 'keep alive timeout',
        type: 'number',
    })
        .option('noVerbose', {
        description: 'If verbose is disabled',
        type: 'boolean',
    })
        .option('noLogConsole', {
        description: 'If log file is disabled',
        type: 'boolean',
    })
        .option('noLogFile', {
        description: 'If log file is disabled',
        type: 'boolean',
    })
        .option('logFile', {
        description: 'the log file name',
        type: 'string',
    })
        .option('maxRetries', {
        description: 'number of attempt on listening to a port',
        type: 'number',
    })
        .option('maxLogSize', {
        description: 'max number of logs to keep in memory',
        type: 'number',
    })
        .option('isRawPipe', {
        description: 'If the pipe name should be processed',
        type: 'boolean',
    })
        .help()
        .alias('help', 'h');
}
exports.getServerArgOptions = getServerArgOptions;
function startServer(options, socketServerFactory) {
    return __awaiter(this, void 0, void 0, function* () {
        const keepAliveTime = options.keepAliveTime || 10000;
        if (!(options.port || options.pipe)) {
            console.log('You need to specify a port or a pipe name');
            process.exit(1);
        }
        const listeners = [];
        const traceSource = yield (0, logUtils_1.initLogging)(options, listeners);
        traceSource.info(`logging options name:${options.name} noVerbose:${options.noVerbose} traceFilters:${options.traceFilters}`);
        // init telemetry
        let telemetryOptions;
        if (typeof options.telemetryOptions === 'string' || options.telemetryOptions instanceof String) {
            telemetryOptions = JSON.parse(Buffer.from(String(options.telemetryOptions), 'base64').toString('utf-8'));
        }
        else if (options.telemetryOptions) {
            telemetryOptions = options.telemetryOptions;
        }
        if (telemetryOptions) {
            traceSource.info(`initialize telemetry with options: ${JSON.stringify(telemetryOptions)}`);
            vso_telemetry_1.Telemetry.init(new vso_node_telemetry_reporter_1.TelemetryReporter(telemetryOptions.key, telemetryOptions.reporterConfiguration, undefined, traceSource.withName('telemetryReporter')), telemetryOptions.featureName, telemetryOptions.canSendSensistiveInformation);
        }
        else {
            vso_telemetry_1.Telemetry.init({
                sendTelemetryEvent: (eventName, properties, measurements) => void {},
                sendTelemetryErrorEvent: (eventName, properties, measurements, errorProps) => void {},
                dispose: () => {
                    return Promise.resolve();
                },
            }, `${options.name}.`);
        }
        const serverStopped = (reason) => process.exit((reason === null || reason === void 0 ? void 0 : reason.code) === 'EADDRINUSE' ? 10 :
            typeof reason === 'number' ? reason :
                0);
        const serverHost = {
            keepAliveTriggered: () => traceSource.info(`keep alive triggered...`),
            serverStopped,
        };
        const memoryTraceListener = listeners.find(l => l instanceof vso_logging_1.MemoryTraceListener);
        const getLogs = (logLevel) => memoryTraceListener.getLogs(logLevel);
        var server;
        try {
            server = yield (0, vso_node_server_1.startSocketServer)(Object.assign(Object.assign({}, options), { traceSource,
                keepAliveTime,
                getLogs,
                socketServerFactory,
                serverHost }));
        }
        catch (e) {
            traceSource.writeLine(`Exception err:${e} stack:${e === null || e === void 0 ? void 0 : e.stack}`);
            serverStopped(e);
        }
        traceSource.info(`starting server -> platform:${process.platform} exe:${process.execPath} version:${process.version} pid:${process.pid} auto exit:${options.autoExit ? 1 : 0} keepAliveTime:${keepAliveTime}`);
        process.on('exit', (code) => {
            traceSource.writeLine(`Server process exit event with code: ${code}`);
        });
        // warning message from node engine
        process.on('warning', (warning) => {
            traceSource.writeLine(`Node warning:${warning}`);
        });
        // catch undhandled rejections. 
        process.on('unhandledRejection', (reason, promise) => {
            traceSource.writeLine(`Unhandled Rejection reason -> ${(0, vscs_utils_1.propertiesToString)(reason)}`);
        });
        // catch undhandled exceptions. 
        process.on('uncaughtException', function (err) {
            traceSource.writeLine(`Uncaught exception err:${err} stack:${err === null || err === void 0 ? void 0 : err.stack}`);
            server.stop(99);
        });
        // catch NodeJS.Signals events and exit normally
        const signalCodes = {
            'SIGINT': 100,
            'SIGUSR1': 101,
            'SIGUSR2': 102,
            'SIGTERM': 103,
        };
        Object.keys(signalCodes).forEach((eventType) => {
            process.on(eventType, function () {
                traceSource.writeLine(`Signal received eventType:${eventType}`);
                server.stop(signalCodes[eventType]);
            });
        });
        return traceSource;
    });
}
exports.startServer = startServer;
//# sourceMappingURL=hubUtils.js.map

/***/ }),

/***/ "../../workspace/hub-util/dist/src/index.js":
/*!**************************************************!*\
  !*** ../../workspace/hub-util/dist/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./hubUtils */ "../../workspace/hub-util/dist/src/hubUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./logUtils */ "../../workspace/hub-util/dist/src/logUtils.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../workspace/hub-util/dist/src/logUtils.js":
/*!*****************************************************!*\
  !*** ../../workspace/hub-util/dist/src/logUtils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initLogging = exports.getLoggingArgOptions = void 0;
const os = __importStar(__webpack_require__(/*! os */ "os"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const util = __importStar(__webpack_require__(/*! util */ "util"));
const yargs = __importStar(__webpack_require__(/*! yargs */ "../../node_modules/yargs/index.js"));
const vso_logging_1 = __webpack_require__(/*! @vs/vso-logging */ "../../logging/core/dist/src/index.js");
const vso_logging_node_1 = __webpack_require__(/*! @vs/vso-logging-node */ "../../logging/desktop/dist/src/index.js");
const openAsync = util.promisify(fs.open);
function getLoggingArgOptions() {
    return yargs
        .option('disableObfuscation', {
        description: 'If disable obfuscation is enabled',
        type: 'boolean',
    })
        .option('noVerbose', {
        description: 'If verbose is disabled',
        type: 'boolean',
    })
        .option('noLogConsole', {
        description: 'If log file is disabled',
        type: 'boolean',
    })
        .option('noLogFile', {
        description: 'If log file is disabled',
        type: 'boolean',
    })
        .options('traceFilters', {
        description: 'Define trafe filter options',
        type: 'array',
    })
        .option('logFile', {
        description: 'the log file name',
        type: 'string',
    })
        .option('maxLogSize', {
        description: 'max number of logs to keep in memory',
        type: 'number',
    });
}
exports.getLoggingArgOptions = getLoggingArgOptions;
function initLogging(options, listeners) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options.disableObfuscation) {
            vso_logging_1.LoggerSettings.disableObfuscation = true;
        }
        const traceFilters = new vso_logging_1.TraceFilters();
        const noVerboseTraceFilter = {
            shouldTrace: (source, logLevel, id) => {
                return logLevel >= vso_logging_1.LogLevel.Info;
            }
        };
        if (options.noVerbose) {
            traceFilters.filters.push(noVerboseTraceFilter);
        }
        if (options.traceFilters) {
            const filters = {};
            options.traceFilters.map(i => String(i)).forEach(tf => {
                const pos = tf.indexOf('=');
                if (pos === -1) {
                    throw new Error(`Invalid trace filter:'${tf}' passed`);
                }
                filters[tf.substr(0, pos)] = tf.substr(pos + 1);
            });
            traceFilters.filters.push(new vso_logging_1.GlobPatternTraceFilter(filters));
        }
        // init logging
        const traceSource = new vso_logging_1.TraceSource(options.name);
        const addTraceListener = (listener) => {
            if (traceFilters.filters.length > 0) {
                listener.filter = traceFilters;
            }
            traceSource.addTraceListener(listener);
            listeners === null || listeners === void 0 ? void 0 : listeners.push(listener);
        };
        // memory trace listener
        const maxLogSize = options.maxLogSize || 512;
        const memoryTraceListener = new vso_logging_1.MemoryTraceListener(maxLogSize);
        addTraceListener(memoryTraceListener);
        if (!options.noLogConsole) {
            addTraceListener(new vso_logging_1.ConsoleTraceListener());
        }
        if (!options.noLogFile) {
            const logDirectory = path.join(os.tmpdir(), options.logTmpDirectory);
            const fd = options.logFile ? yield openAsync(options.logFile, 'a') : undefined;
            const logFileTraceListener = new vso_logging_node_1.LogFileTraceListener(options.processName, logDirectory, fd);
            if (fd) {
                traceSource.info('Trace log: ' + options.logFile);
                addTraceListener(logFileTraceListener);
            }
            else {
                const loggingFilePath = yield logFileTraceListener.openAsync();
                if (loggingFilePath) {
                    traceSource.info('Trace log: ' + logFileTraceListener.logFileName);
                    addTraceListener(logFileTraceListener);
                }
            }
        }
        return traceSource;
    });
}
exports.initLogging = initLogging;
//# sourceMappingURL=logUtils.js.map

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("console");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../node_modules/node-fetch/lib/index.mjs":
/*!***************************************************!*\
  !*** ../../node_modules/node-fetch/lib/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FetchError": () => (/* binding */ FetchError),
/* harmony export */   "Headers": () => (/* binding */ Headers),
/* harmony export */   "Request": () => (/* binding */ Request),
/* harmony export */   "Response": () => (/* binding */ Response),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var whatwg_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-url */ "../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ "zlib");







// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');
const URL = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;
const format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;

/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */
function parseURL(urlStr) {
	/*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */
	if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
		urlStr = new URL(urlStr).toString();
	}

	// Fallback to old implementation for arbitrary URLs
	return parse_url(urlStr);
}

const streamDestructionSupported = "destroy" in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parseURL(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parseURL(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parseURL(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

const URL$1 = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;

const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
	const orig = new URL$1(original).hostname;
	const dest = new URL$1(destination).hostname;

	return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_4__ : http__WEBPACK_IMPORTED_MODULE_1__).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL$1(location, request.url).toString();
				} catch (err) {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						if (!isDomainOrSubdomain(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOpts.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH,
				finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflate());
					} else {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress === 'function') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetch);



/***/ }),

/***/ "../../node_modules/@microsoft/dev-tunnels-ssh/package.json":
/*!******************************************************************!*\
  !*** ../../node_modules/@microsoft/dev-tunnels-ssh/package.json ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@microsoft/dev-tunnels-ssh","version":"3.11.36","description":"SSH library for Dev Tunnels","repository":"https://github.com/microsoft/dev-tunnels-ssh.git","keywords":["SSH"],"author":"Microsoft","license":"MIT","dependencies":{"buffer":"^5.2.1","debug":"^4.1.1","diffie-hellman":"^5.0.3","vscode-jsonrpc":"^4.0.0"},"main":"./index.js"}');

/***/ }),

/***/ "../../node_modules/async-hook-jl/package.json":
/*!*****************************************************!*\
  !*** ../../node_modules/async-hook-jl/package.json ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"async-hook-jl","description":"Inspect the life of handle objects in node","version":"1.7.6","author":"Andreas Madsen <amwebdk@gmail.com>","main":"./index.js","scripts":{"test":"node ./test/runner.js && eslint ."},"repository":{"type":"git","url":"git://github.com/jeff-lewis/async-hook-jl.git"},"keywords":["async","async hooks","inspect","async wrap"],"license":"MIT","dependencies":{"stack-chain":"^1.3.7"},"devDependencies":{"async":"1.5.x","cli-color":"1.1.x","eslint":"^3.4.0","endpoint":"0.4.x"},"engines":{"node":"^4.7 || >=6.9 || >=7.3"}}');

/***/ }),

/***/ "../../node_modules/diagnostic-channel/package.json":
/*!**********************************************************!*\
  !*** ../../node_modules/diagnostic-channel/package.json ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"diagnostic-channel","version":"0.3.1","main":"./dist/src/channel.js","types":"./dist/src/channel.d.ts","scripts":{"build":"tsc","lint":"tslint -c tslint.json -p tsconfig.json","clean":"rimraf ./dist","test":"mocha ./dist/tests/**/*.js"},"homepage":"https://github.com/Microsoft/node-diagnostic-channel","bugs":{"url":"https://github.com/Microsoft/node-diagnostic-channel/issues"},"repository":{"type":"git","url":"https://github.com/Microsoft/node-diagnostic-channel.git"},"description":"Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers","dependencies":{"semver":"^5.3.0"},"devDependencies":{"@types/mocha":"^2.2.40","@types/node":"^7.0.12","mocha":"^3.2.0","rimraf":"^2.6.1","tslint":"^5.0.0","typescript":"^2.2.1"},"files":["dist/src/**/*.d.ts","dist/src/**/*.js","LICENSE","README.md","package.json"],"license":"MIT"}');

/***/ }),

/***/ "../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json":
/*!*****************************************************************************!*\
  !*** ../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');

/***/ }),

/***/ "../../node_modules/stack-chain/package.json":
/*!***************************************************!*\
  !*** ../../node_modules/stack-chain/package.json ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"stack-chain","description":"API for combining call site modifiers","version":"1.3.7","author":"Andreas Madsen <amwebdk@gmail.com>","scripts":{"test":"tap ./test/simple"},"repository":{"type":"git","url":"git://github.com/AndreasMadsen/stack-chain.git"},"keywords":["stack","chain","trace","call site","concat","format"],"devDependencies":{"tap":"2.x.x","uglify-js":"2.5.x"},"license":"MIT"}');

/***/ }),

/***/ "../../node_modules/websocket/package.json":
/*!*************************************************!*\
  !*** ../../node_modules/websocket/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ }),

/***/ "../../workspace/client/dist/src/strings.nls.json":
/*!********************************************************!*\
  !*** ../../workspace/client/dist/src/strings.nls.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"error.relayConnectionError":"Failed to connect to the codespace.","error.relayEndpointNotFound":"The relay endpoint for the codespace is invalid or no longer exists.","error.relayListenerOffline":"The codespace is currently offline.","error.relaySasInvalid":"Failed to connect to the codespace through the relay: invalid relay SAS.","error.relayServerError":"Failed to connect to the codespace due to an unknown relay error."}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./app.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=port-forwarder-hub.js.map