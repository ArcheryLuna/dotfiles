(()=>{"use strict";var e={969:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.AsmParser=t.AsmParserResult=t.BinaryAsmLine=t.AsmLine=t.AsmLabel=t.AsmLabelRange=t.AsmSource=t.AsmFilter=void 0;const i=s(593);t.AsmFilter=class{constructor(){this.trim=!0,this.binary=!1,this.commentOnly=!1,this.directives=!0,this.labels=!0}};class o{constructor(e,t){this.file=e,this.line=t,this.column=0}}t.AsmSource=o;class n{constructor(e,t){this.startCol=e,this.endCol=t}}t.AsmLabelRange=n;class r{constructor(e,t){this.name=e,this.range=t}}t.AsmLabel=r;class a{constructor(e,t,s){this.text=e,this.source=t,this.labels=s}get value(){return this.text+"\n"}}t.AsmLine=a;class c extends a{constructor(e,t,s,i,o){super(e,t,s),this.address=i,this.opcodes=o}get value(){return`<${("0000000"+this.address.toString(16)).substr(-8)}> ${this.text}\n`}}t.BinaryAsmLine=c;class l{constructor(e,t){this.asm=e,this.labelDefinitions=t}}t.AsmParserResult=l,t.AsmParser=class{constructor(){this.labelDef=/^(?:.proc\s+)?([.a-z_$@][a-z0-9$_@.]*):/i,this.labelFindNonMips=/[.A-Z_a-z][\w$.]*/g,this.labelFindMips=/[$.A-Z_a-z][\w$.]*/g,this.mipsLabelDefinition=/^\$[\w$.]+:/,this.dataDefn=/^\s*\.(string|asciz|ascii|[1248]?byte|short|x?word|long|quad|value|zero)/,this.fileFind=/^\s*\.file\s+(\d+)\s+"([^"]+)"(\s+"([^"]+)")?.*/,this.hasOpcodeRe=/^\s*(%[$.A-Z_a-z][\w$.]*\s*=\s*)?[A-Za-z]/,this.instructionRe=/^\s*[A-Za-z]+/,this.identifierFindRe=/[$.@A-Z_a-z][\dA-z]*/g,this.hasNvccOpcodeRe=/^\s*[@A-Za-z|]/,this.definesFunction=/^\s*\.(type.*,\s*[#%@]function|proc\s+[.A-Z_a-z][\w$.]*:.*)$/,this.definesGlobal=/^\s*\.(?:globa?l|GLB|export)\s*([.A-Z_a-z][\w$.]*)/,this.definesWeak=/^\s*\.(?:weakext|weak)\s*([.A-Z_a-z][\w$.]*)/,this.indentedLabelDef=/^\s*([$.A-Z_a-z][\w$.]*):/,this.assignmentDef=/^\s*([$.A-Z_a-z][\w$.]*)\s*=/,this.directive=/^\s*\..*$/,this.startAppBlock=/\s*#APP.*/,this.endAppBlock=/\s*#NO_APP.*/,this.startAsmNesting=/\s*# Begin ASM.*/,this.endAsmNesting=/\s*# End ASM.*/,this.cudaBeginDef=/\.(entry|func)\s+(?:\([^)]*\)\s*)?([$.A-Z_a-z][\w$.]*)\($/,this.cudaEndDef=/^\s*\)\s*$/,this.asmOpcodeRe=/^\s*(?<address>[\da-f]+):(?:[|\\\/>X+-]|\s)*(?<opcodes>([\da-f]{2} ?)+)\s*(?<disasm>.*)/,this.lineRe=/^(\/[^:]+):(?<line>\d+).*/,this.labelRe=/^([\da-f]+)\s+<(.+)>:$/,this.destRe=/\s([\da-f]+)\s+<([^+>]+)(\+0x[\da-f]+)?>$/,this.commentRe=/[#;]/,this.instOpcodeRe=/(\.inst\.?\w?)\s*(.*)/}hasOpcode(e,t){const s=e.match(this.labelDef);return s&&(e=e.substr(s[0].length)),e=e.split(this.commentRe,1)[0],!!this.instOpcodeRe.test(e)||!this.assignmentDef.test(e)&&(t?!!this.hasNvccOpcodeRe.test(e):!!this.hasOpcodeRe.test(e))}filterAsmLine(e,t){return t.trim?(0,i.squashHorizontalWhitespace)(e,!0):e}labelFindFor(e){return e.some((e=>!!this.mipsLabelDefinition.test(e)))?this.labelFindMips:this.labelFindNonMips}findUsedLabels(e,t){const s=new Set,i=new Map,o=this.labelFindFor(e);let n=new Array,r=!1,a=0;const c=/\.cfi_startproc/,l=/\.cfi_endproc/;let d=!1;for(let h of e){this.startAppBlock.test(h)||this.startAsmNesting.test(h)?a++:this.endAppBlock.test(h)||this.endAsmNesting.test(h)?a--:c.test(h)?d=!0:l.test(h)&&(d=!1),a>0&&(h=this.fixLabelIndentation(h));let e=h.match(this.labelDef);e?(r?n.push(e[1]):n=[e[1]],r=!0):r=!1,e=h.match(this.definesGlobal),e||(e=h.match(this.definesWeak)),e||(e=h.match(this.cudaBeginDef)),e&&s.add(e[1]);const p=h.match(this.definesFunction);if((p||h&&"."!==h[0])&&(e=h.match(o),e))if(!t||this.hasOpcode(h,!1)||p)for(const t of e)s.add(t);else{const t=!!this.dataDefn.test(h),o=this.hasOpcode(h,!1);if(t||o)for(const o of n)if(d&&t)for(const t of e)s.add(t);else{void 0===i.get(o)&&i.set(o,[]);for(const t of e)i.get(o).push(t)}}}for(let e=0;e<10;++e){const e=[];if(s.forEach((t=>{const o=i.get(t);void 0!==o&&o.forEach((t=>{s.has(t)||e.push(t)}))})),!e)break;e.forEach((e=>{s.add(e)}))}return s}parseFiles(e){const t=new Map;for(const s of e){const e=s.match(this.fileFind);if(e){const s=parseInt(e[1]);e[4]?t.set(s,e[2]+"/"+e[4]):t.set(s,e[2])}}return t}removeLabelsWithoutDefinition(e,t){e.forEach((e=>{e.labels=e.labels.filter((e=>t.get(e.name)))}))}getUsedLabelsInLine(e){const t=[],s=e.split(this.commentRe,1)[0],i=s.replace(this.instructionRe,""),o=s.length-i.length+1;return i.replace(this.identifierFindRe,((e,s)=>{const i=o+s;return t.push(new r(e,new n(i,i+e.length))),""})),t}processAsm(e,t){if(t.commentOnly){const t=/^[\t ]*\/\*(\*(?!\/)|[^*])*\*\/\s*/gm;e=e.replace(t,"")}const s=[],n=new Map,r=(0,i.splitLines)(e),c=this.findUsedLabels(r,t.directives),d=this.parseFiles(r);let h="";const p=/^\s*(((#|@|\/\/).*)|(\/\*.*\*\/)|(;\s*)|(;[^;].*)|(;;\s*[^\s#].*))$/,m=/^\s*(((#|;|\/\/).*)|(\/\*.*\*\/))$/,u=/^\s*\.loc\s+(\d+)\s+(\d+)\s+(.*)/,f=/^\s*\.d2line\s+(\d+),?\s*(\d*).*/,w=/^\s*\.dbg\s+line,\s*"([^"]+)",\s*(\d+)/,g=/^\s*\.dbg\s+line[^,]/,v=/^\s*\.stabn\s+(\d+),0,(\d+),.*/,b=/.*<stdin>|^-$|example\.[^/]+$|<source>/,D=/\.(cfi_endproc|data|text|section)/;let C;function y(e){let t=e.match(u);if(t){const e=d.get(parseInt(t[1])),s=parseInt(t[2]);if(e){C=new o(b.test(e)?void 0:e,s);const i=parseInt(t[3]);isNaN(i)||0===i||(C.column=i)}else C=void 0}else if(t=e.match(f),t){const e=parseInt(t[1]);C=new o(void 0,e)}}function A(e){const t=e.match(v);if(t)switch(parseInt(t[1])){case 68:C=new o(void 0,parseInt(t[2]));break;case 132:case 100:C=void 0,h=void 0}}function E(e){const t=e.match(w);if(t){const e=t[1],s=parseInt(t[2]);C=new o(b.test(e)?void 0:e,s)}else g.test(e)&&(C=void 0)}let x=!1,L=!1,_=0;for(let e of r){if(""===e.trim()){0===s.length||""===s[s.length-1].text||s.push(new a("",void 0,[]));continue}if(this.startAppBlock.test(e)||this.startAsmNesting.test(e)?_++:(this.endAppBlock.test(e)||this.endAsmNesting.test(e))&&_--,y(e),A(e),E(e),(D.test(e)||L&&/}/.test(e))&&(C=void 0,h=void 0),t.commentOnly&&(p.test(e)&&!L||m.test(e)&&L))continue;_>0&&(e=this.fixLabelIndentation(e));let o=e.match(this.labelDef);if(o||(o=e.match(this.assignmentDef)),o||(o=e.match(this.cudaBeginDef),o&&(x=!0,L=!0)),o)if(c.has(o[1]))h=o[0],n.set(o[1],s.length+1);else if(t.labels)continue;if(x)this.cudaEndDef.test(e)&&(x=!1);else if(!o&&t.directives)if(this.dataDefn.test(e)&&h);else if(this.directive.test(e)&&!this.instOpcodeRe.test(e))continue;e=(0,i.expandTabs)(e);const r=this.filterAsmLine(e,t),l=o?[]:this.getUsedLabelsInLine(r);s.push(new a(r,this.hasOpcode(e,L)?C:void 0,l))}return this.removeLabelsWithoutDefinition(s,n),new l(s,n)}fixLabelIndentation(e){return e.match(this.indentedLabelDef)?e.replace(/^\s+/,""):e}isUserFunction(e){return void 0===this.binaryHideFuncRe||!this.binaryHideFuncRe.test(e)}processBinaryAsm(e,t){const s=[],i=new Map,n=e.split("\n");let r,d;if(1===n.length&&"<"===n[0][0])return new l([new a(n[0],void 0,[])],i);for(const e of n){const n=[];let l=e.match(this.lineRe);if(l)r=new o(l[1],parseInt(l.groups.line));else if(l=e.match(this.labelRe),l)d=l[2],this.isUserFunction(d)&&(s.push(new a(d+":",void 0,n)),i.set(d,s.length));else if((!d||e!==`${d}():`)&&d&&this.isUserFunction(d)&&(l=e.match(this.asmOpcodeRe),l)){const e=parseInt(l.groups.address,16),i=l.groups.opcodes.split(" ").filter((e=>!!e)).join(" "),o=" "+this.filterAsmLine(l.groups.disasm,t);s.push(new c(o,r,n,e,i))}}return this.removeLabelsWithoutDefinition(s,i),new l(s,i)}process(e,t){return t.binary?this.processBinaryAsm(e,t):this.processAsm(e,t)}}},32:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getOutputChannel=t.getAsmUri=t.constructCompileCommand=t.CompilationDatabase=void 0;const i=s(496),o=s(17),n=s(599),r=s(81),a=s(837),c=s(147),l=s(593),d="c++filt";class h{constructor(e,t){this.compileCancellationTokenSource=void 0,this.cxxFiltExeCache=new Map,this.compileCommandsFile=e,this.commands=t,this.watcher=i.workspace.createFileSystemWatcher(this.compileCommandsFile.path);const s=async()=>{this.commands=await h.load(this.compileCommandsFile)};this.watcher.onDidChange((async()=>await s())),this.watcher.onDidDelete((()=>{h.compdbs.get(this.compileCommandsFile)?.dispose(),h.compdbs.delete(this.compileCommandsFile)}))}static async for(e){const t=function(e,t){const s=i.workspace.getWorkspaceFolder(t)?.uri.fsPath,n={workspaceFolder:s,workspaceFolderBasename:o.parse(s).name,file:e,fileWorkspaceFolder:i.workspace.getWorkspaceFolder(i.Uri.file(e))?.uri.fsPath||"",relativeFile:o.relative(s,e),pathSeparator:o.sep},r=e.replace(/\$\{(.*?)\}/g,((e,t)=>{const s=n[t];return void 0!==s?s:e}));return o.normalize(r)}(i.workspace.getConfiguration("compilerexplorer").get("compilationDirectory","${workspaceFolder}"),e),s=i.Uri.joinPath(i.Uri.parse(t),"compile_commands.json");let n=h.compdbs.get(s);if(n)return n;const r=await h.load(s);return n=new h(s,r),this.compdbs.set(s,n),n}get(e){return this.commands.get(e.fsPath)}async compile(e,t){const s=this.get(e);if(!s)throw new Error("cannot find compilation command");this.compileCancellationTokenSource?.cancel();const o=new i.CancellationTokenSource;this.compileCancellationTokenSource=o;try{const e=(new Date).getTime(),n={location:i.ProgressLocation.Notification,title:"C++ Compiler Explorer",cancellable:!0},r=await i.window.withProgress(n,(async(e,i)=>(e.report({message:"Compilation in progress"}),i.onCancellationRequested((()=>o.cancel())),await this.runCompiler(o.token,s,t)))),a=((new Date).getTime()-e)/1e3;return u().appendLine(`Compilation succeeded: ${r.length} bytes, ${a} s`),r}finally{this.compileCancellationTokenSource=void 0}}static disposable(){return new i.Disposable((()=>{for(let e of this.compdbs)e[1].dispose()}))}static async load(e){u().appendLine(`Loading Compilation Database from: ${e.toString()}`);const t=(new a.TextDecoder).decode(await i.workspace.fs.readFile(e)),s=JSON.parse(t);h.preprocess(s);let n=new Map;for(let e of s){let t=e.file;o.isAbsolute(t)||(t=await c.promises.realpath(o.join(e.directory,e.file))),n.set(t,e)}return n}static preprocess(e){for(let t of e)t.arguments=p(t.command,t.arguments),t.arguments=t.arguments.filter((e=>e!=t.file)),t.command=""}async runCompiler(e,t,s){const i=0!=s.length?s:t.arguments,o=await this.getCxxFiltExe(i[0]),n=i[0],a=[...i.slice(1),t.file,"-g","-S","-o","-"];u().appendLine(`Compiling using: ${n} ${a.join(" ")}`);let d={stdio:["ignore","pipe","pipe"],shell:!0};(0,c.existsSync)(t.directory)&&(d.cwd=t.directory);const h=(0,r.spawn)(n,a,d),p=(0,r.spawn)(o,[],{stdio:["pipe","pipe","pipe"]});try{p.stdin.cork();for await(let t of h.stdout){if(e.isCancellationRequested)throw new Error("operation cancelled");p.stdin.write(t)}if(p.stdin.uncork(),p.stdin.end(),!await this.checkStdErr(h))throw new Error("compilation failed");let t="";for await(let s of p.stdout){if(e.isCancellationRequested)throw new Error("operation cancelled");t+=s}if(!await this.checkStdErr(p))throw new Error("compilation failed");return(0,l.splitLines)(t).filter((e=>!(e=e.trimStart()).startsWith("#")&&!e.startsWith(";"))).join("\n")}catch(e){throw h.kill(),p.kill(),e}}async getCxxFiltExe(e){let t=this.cxxFiltExeCache.get(e);return void 0!==t||(t=await this.findCxxFiltExe(e),this.cxxFiltExeCache.set(e,t)),t}async findCxxFiltExe(e){let t=o.parse(e),s=async e=>{if(void 0!==e){const s=d+t.ext;for(let t of await c.promises.readdir(e))if(t.endsWith(s))return o.resolve(e,t)}};if(0==t.dir.length){const t=await this.findExecutablePath(e),i=await s(t);if(void 0!==i)return i}else{const e=t.dir,i=await s(e);if(void 0!==i)return i}t.name=t.name.replace("clang++",d).replace("clang",d).replace("g++",d).replace("gcc",d).replace("c++",d).replace("cc",d);const i=o.join(t.dir,t.name,t.ext);return(0,c.existsSync)(i)?i:d}async findExecutablePath(e){const t=(0,r.spawn)("which",[e],{stdio:["ignore","pipe","ignore"]});try{let e="";for await(let s of t.stdout)e+=s.toString();if(!await this.checkStdErr(t))return o.parse(e).dir}catch(e){t.kill()}}async checkStdErr(e){let t="";for await(let s of e.stderr)t+=s;t.length>0&&(u().appendLine(t),u().show());try{if(await async function(e){return new Promise(((t,s)=>{e.once("exit",((e,s)=>{t(e)})),e.once("error",(e=>{s(e)}))}))}(e))return!1}catch(e){return!1}return!0}dispose(){this.compileCancellationTokenSource?.cancel(),this.compileCancellationTokenSource?.dispose(),this.commands.clear(),this.watcher.dispose()}}function p(e,t){e&&e.length>0&&(t=function(e){let t,s=!1,i=[],o=0,n=0;for(let r of e){if("\\"===r)s=!s;else{switch(r){case"'":case'"':s||(t=t===r?void 0:r);break;case" ":if(!t){const t=e.slice(n,o);t.length>0&&i.push(t),n=o+1}}s&&(s=!s)}o++}const r=e.slice(n,o);return r.length>0&&i.push(r),i}(e));let s=!1;return t.filter((e=>s?(s=!1,!1):(s="-o"===e,!s&&"-c"!==e&&"-g"!==e)))}let m;function u(){return void 0===m&&(m=i.window.createOutputChannel("C/C++ Compiler Explorer","shellscript")),m}t.CompilationDatabase=h,h.compdbs=new Map,t.constructCompileCommand=p,t.getAsmUri=function(e){var t;return e.with({scheme:n.AsmProvider.scheme,path:(t=e.path,(t.slice(0,t.lastIndexOf("."))||t)+".S")})},t.getOutputChannel=u},153:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.AsmDecorator=void 0;const i=s(496),o=s(17);t.AsmDecorator=class{constructor(e,t,s){this.visible=!1,this.mappings=new Map,this.srcEditor=e,this.asmEditor=t,this.provider=s,this.visible=i.window.visibleTextEditors.includes(e)&&i.window.visibleTextEditors.includes(t),this.selectedLineDecorationType=i.window.createTextEditorDecorationType({isWholeLine:!0,backgroundColor:new i.ThemeColor("editor.findMatchHighlightBackground"),overviewRulerColor:new i.ThemeColor("editorOverviewRuler.findMatchForeground")}),this.unusedLineDecorationType=i.window.createTextEditorDecorationType({opacity:"0.5"});const o=t.document.uri,n=s.onDidChange((e=>{e.toString()===o.toString()&&this.load(o)}));this.load(o),this.registrations=i.Disposable.from(this.selectedLineDecorationType,this.unusedLineDecorationType,n,i.window.onDidChangeTextEditorSelection((e=>{this.updateSelection(e.textEditor)})),i.window.onDidChangeVisibleTextEditors((e=>{const t=e.find((e=>e.document===this.srcEditor.document)),s=e.find((e=>e.document===this.asmEditor.document));this.srcEditor=t||this.srcEditor,this.asmEditor=s||this.asmEditor;const i=void 0!==t&&void 0!==s;this.updateVisibility(o,i)})))}dispose(){this.registrations.dispose()}load(e){this.document=this.provider.provideAsmDocument(e),this.loadMappings(),i.workspace.getConfiguration("",this.srcEditor.document.uri).get("compilerexplorer.dimUnusedSourceLines",!0)&&this.visible&&this.dimUnusedSourceLines()}asmLineHasSource(e){const t=this.srcEditor.document.uri.path,s=e.source?.file;if(void 0===s)return!1;const i=o.basename(s);return!!t.endsWith(i)}loadMappings(){this.mappings.clear(),this.document.lines.forEach(((e,t)=>{if(!this.asmLineHasSource(e))return;const s=e.source.line-1;void 0===this.mappings.get(s)&&this.mappings.set(s,[]),this.mappings.get(s).push(t)}))}updateSelection(e){e===this.srcEditor?this.srcLineSelected(this.srcEditor.selection.start.line):e===this.asmEditor&&this.asmLineSelected(this.asmEditor.selection.start.line)}updateVisibility(e,t){t!==this.visible&&(this.visible=t,t?this.load(e):(this.asmEditor.setDecorations(this.selectedLineDecorationType,[]),this.srcEditor.setDecorations(this.selectedLineDecorationType,[]),this.srcEditor.setDecorations(this.unusedLineDecorationType,[])))}dimUnusedSourceLines(){const e=[];for(let t=0;t<this.srcEditor.document.lineCount;t++)void 0===this.mappings.get(t)&&e.push(this.srcEditor.document.lineAt(t).range);this.srcEditor.setDecorations(this.unusedLineDecorationType,e)}srcLineSelected(e){const t=this.srcEditor.document.lineAt(e).range;this.srcEditor.setDecorations(this.selectedLineDecorationType,[t]);const s=[],o=this.mappings.get(e);void 0!==o&&o.forEach((e=>{e>=this.asmEditor.document.lineCount||s.push(this.asmEditor.document.lineAt(e).range)})),this.asmEditor.setDecorations(this.selectedLineDecorationType,s),s.length>0&&this.asmEditor.revealRange(s[0],i.TextEditorRevealType.InCenterIfOutsideViewport)}asmLineSelected(e){const t=this.document.lines[e],s=this.asmEditor.document.lineAt(e).range;if(this.asmEditor.setDecorations(this.selectedLineDecorationType,[s]),this.asmLineHasSource(t)){const e=this.srcEditor.document.lineAt(t.source.line-1).range;this.srcEditor.setDecorations(this.selectedLineDecorationType,[e]),this.srcEditor.revealRange(e,i.TextEditorRevealType.InCenterIfOutsideViewport)}else this.srcEditor.setDecorations(this.selectedLineDecorationType,[])}}},928:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.AsmDocument=void 0;const i=s(496),o=s(969);t.AsmDocument=class{constructor(e,t,s){this.lines=[],this.sourceToAsmMapping=new Map,this._uri=e,this._compinfo=t,this._emitter=s,this._watcher=i.workspace.createFileSystemWatcher(t.srcUri.path),this._watcher.onDidChange((()=>this.updateLater())),this._watcher.onDidCreate((()=>this.updateLater())),this._watcher.onDidDelete((()=>this.updateLater(!0))),this.update(!1)}updateCompilationInfo(e){this._compinfo=e,this.update(!1)}updateLater(e=!1){setTimeout((async()=>await this.update(e)),100)}async update(e){if(e)this.lines=[new o.AsmLine(`Failed to load file '${this._uri.path}'`,void 0,[])];else{const e=new o.AsmFilter;e.binary=!1;try{const t=await this._compinfo.compdb.compile(this._compinfo.srcUri,this._compinfo.customCommand);this.lines=(new o.AsmParser).process(t,e).asm}catch(e){e instanceof Error?i.window.showErrorMessage(`Failed to show assembly: ${e.message}`):i.window.showErrorMessage(`Failed to show assembly: ${JSON.stringify(e)}`)}}this._emitter.fire(this._uri)}get value(){return this.lines.reduce(((e,t)=>e+t.value),"")}dispose(){this._watcher.dispose()}}},599:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.AsmProvider=void 0;const i=s(496),o=s(928),n=s(32);class r{constructor(){this._compinfo=new Map,this._documents=new Map,this._onDidChange=new i.EventEmitter}provideTextDocumentContent(e){return this.provideAsmDocument(e).value}provideAsmDocument(e){let t=this._documents.get(e.path);if(!t){const s=this._compinfo.get(e.path);t=new o.AsmDocument(e,s,this._onDidChange),this._documents.set(e.path,t)}return t}async loadCompilationInfo(e,t,s){const i={srcUri:e,compdb:await n.CompilationDatabase.for(e),customCommand:s};this._compinfo.set(t.path,i),this._documents.get(t.path)?.updateCompilationInfo(i)}unload(e){const t=(0,n.getAsmUri)(e);this._documents.get(t.path)?.dispose(),this._documents.delete(t.path),this._compinfo.delete(t.path)}get onDidChange(){return this._onDidChange.event}dispose(){this._documents.forEach((e=>e.dispose())),this._documents.clear(),this._onDidChange.dispose()}}t.AsmProvider=r,r.scheme="disassembly"},593:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.squashHorizontalWhitespace=t.expandTabs=t.splitLines=void 0;const s=/\t/g,i=/\r?\n/,o=/(.*?)("(?:[^"\\]|\\.)*")(.*)/;t.splitLines=function(e){const t=e.split(i);return t.length>0&&""===t[t.length-1]?t.slice(0,t.length-1):t},t.expandTabs=function(e){let t=0;return e.replace(s,(function(e,s){const i=s+t+8&7;return t+=i-1,"        ".substr(i)}))},t.squashHorizontalWhitespace=function e(t,s){const i=t.match(o);if(i)return e(i[1],s)+i[2]+e(i[3],!1);const n=t.split(/\s+/);return""===n[0]&&s?"  "+n.slice(1).join(" "):n.join(" ")}},496:e=>{e.exports=require("vscode")},81:e=>{e.exports=require("child_process")},147:e=>{e.exports=require("fs")},17:e=>{e.exports=require("path")},837:e=>{e.exports=require("util")}},t={};function s(i){var o=t[i];if(void 0!==o)return o.exports;var n=t[i]={exports:{}};return e[i](n,n.exports,s),n.exports}var i={};(()=>{var e=i;Object.defineProperty(e,"__esModule",{value:!0}),e.activate=void 0;const t=s(496),o=s(599),n=s(153),r=s(32);e.activate=function(e){const s=new o.AsmProvider,i=t.workspace.registerTextDocumentContentProvider(o.AsmProvider.scheme,s),a=async(i,o=[])=>{try{const a=(0,r.getAsmUri)(i.document.uri);await s.loadCompilationInfo(i.document.uri,a,o);const c={viewColumn:i.viewColumn+1,preserveFocus:!0},l=await t.window.showTextDocument(a,c),d=new n.AsmDecorator(i,l,s);setTimeout((()=>d.updateSelection(i)),500);const h=i.document,p=l.document,m=t.workspace.onDidCloseTextDocument((e=>{e!==h&&e!==p||(d.dispose(),m.dispose(),s.unload(e.uri))}));e.subscriptions.push(d,m)}catch(e){e instanceof Error?t.window.showErrorMessage(`Failed to show assembly: ${e.message}`):t.window.showErrorMessage(`Failed to show assembly: ${JSON.stringify(e)}`)}},c=t.commands.registerTextEditorCommand("compilerexplorer.disassOutput",(async e=>{await a(e)})),l=t.commands.registerTextEditorCommand("compilerexplorer.disassOutputWithCustomCommand",(async e=>{const s=(await r.CompilationDatabase.for(e.document.uri)).get(e.document.uri),i=await t.window.showInputBox({prompt:"Provide arguments to pass to compiler",value:s?.arguments.join(" ")});await a(e,(0,r.constructCompileCommand)(i||"",[]))}));e.subscriptions.push(s,c,l,i,(0,r.getOutputChannel)(),r.CompilationDatabase.disposable())}})(),module.exports=i})();