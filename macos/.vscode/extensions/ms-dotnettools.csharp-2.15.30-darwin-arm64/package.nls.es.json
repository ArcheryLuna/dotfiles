{
  "command.csharp.attachToProcess": "Adjuntar a un proceso de .NET 5 (o posterior) o .NET Core",
  "command.csharp.downloadDebugger": "Descargar depurador de .NET Core",
  "command.csharp.listProcess": "Enumerar proceso que se va a adjuntar",
  "command.csharp.listRemoteDockerProcess": "Enumerar procesos en conexión de Docker",
  "command.csharp.listRemoteProcess": "Enumerar procesos en conexión remota para adjuntar",
  "command.csharp.reportIssue": "Informar de un problema",
  "command.csharp.showDecompilationTerms": "Mostrar el contrato de términos del descompilador",
  "command.dotnet.generateAssets.currentProject": "Generar recursos para compilar y depurar",
  "command.dotnet.openSolution": "Abrir solución",
  "command.dotnet.restartServer": "Reiniciar servidor de lenguaje",
  "command.dotnet.restore.all": "Restaurar todos los proyectos",
  "command.dotnet.restore.project": "Restaurar proyecto",
  "command.dotnet.test.debugTestsInContext": "Depurar pruebas en contexto",
  "command.dotnet.test.runTestsInContext": "Ejecutar pruebas en contexto",
  "command.extension.showRazorCSharpWindow": "Mostrar CSharp de Razor",
  "command.extension.showRazorHtmlWindow": "Mostrar HTML de Razor",
  "command.o.fixAll.document": "Corregir todas las repeticiones de un problema de código en el documento",
  "command.o.fixAll.project": "Corregir todas las repeticiones de un problema de código en el proyecto",
  "command.o.fixAll.solution": "Corregir todas las repeticiones de un problema de código en la solución",
  "command.o.pickProjectAndStart": "Seleccionar proyecto",
  "command.o.reanalyze.allProjects": "Analizar todos los proyectos",
  "command.o.reanalyze.currentProject": "Analizar proyecto actual",
  "command.o.restart": "Reiniciar OmniSharp",
  "command.razor.reportIssue": "Notificar un problema de Razor",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitObjectCreation": "Mostrar sugerencias para la creación implícita de objetos",
  "configuration.csharp.inlayHints.enableInlayHintsForImplicitVariableTypes": "Mostrar sugerencias para las variables con tipos inferidos",
  "configuration.csharp.inlayHints.enableInlayHintsForIndexerParameters": "Mostrar sugerencias para indizadores",
  "configuration.csharp.inlayHints.enableInlayHintsForLambdaParameterTypes": "Mostrar sugerencias para los tipos de parámetros lambda",
  "configuration.csharp.inlayHints.enableInlayHintsForTypes": "Mostrar sugerencias de tipo insertado",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope": "Ejecutar análisis de código en segundo plano para: (anteriormente \"omnisharp.enableRoslynAnalyzers\")",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.fullSolution": "Toda la solución",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.none": "Ninguno",
  "configuration.dotnet.backgroundAnalysis.analyzerDiagnosticsScope.openFiles": "Documentos abiertos",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope": "Mostrar errores y advertencias del compilador para:",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.fullSolution": "Toda la solución",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.none": "Ninguno",
  "configuration.dotnet.backgroundAnalysis.compilerDiagnosticsScope.openFiles": "Documentos abiertos",
  "configuration.dotnet.codeLens.enableReferencesCodeLens": "Especifica si se deben mostrar las referencias CodeLens. (Anteriormente \"csharp.referencesCodeLens.enabled\")",
  "configuration.dotnet.codeLens.enableTestsCodeLens": "Especifica si se debe mostrar CodeLens de prueba de ejecución y depuración. (Anteriormente \"csharp.testsCodeLens.enabled\")",
  "configuration.dotnet.completion.provideRegexCompletions": "Mostrar expresiones regulares en la lista de finalización.",
  "configuration.dotnet.completion.showCompletionItemsFromUnimportedNamespaces": "Habilita la compatibilidad para mostrar tipos no importados y métodos de extensión no importados en listas de finalización. Cuando se confirme, se agregará la directiva de uso adecuada en la parte superior del archivo actual. (Anteriormente \"omnisharp.enableImportCompletion\")",
  "configuration.dotnet.completion.showNameCompletionSuggestions": "Realice la finalización automática del nombre de objeto para los miembros que ha seleccionado recientemente.",
  "configuration.dotnet.defaultSolution.description": "Ruta de acceso de la solución predeterminada que se va a abrir en el área de trabajo o se establece en \"deshabilitar\" para omitirla. (Anteriormente \"omnisharp.defaultLaunchSolution\")",
  "configuration.dotnet.dotnetPath": "Especifica la ruta de acceso a un directorio de instalación de dotnet que se va a usar en lugar del predeterminado del sistema. Esto solo influye en la instalación de dotnet que se va a usar para hospedar el propio servidor de idioma. Ejemplo: \"/home/username/mycustomdotnetdirectory\".",
  "configuration.dotnet.highlighting.highlightRelatedJsonComponents": "Resaltar los componentes JSON relacionados bajo el cursor.",
  "configuration.dotnet.highlighting.highlightRelatedRegexComponents": "Resaltar los componentes de expresiones regulares relacionados bajo el cursor.",
  "configuration.dotnet.implementType.insertionBehavior": "Ubicación de inserción de propiedades, eventos y métodos cuando se implementa una interfaz o una clase abstracta.",
  "configuration.dotnet.implementType.insertionBehavior.atTheEnd": "Colóquelos al final.",
  "configuration.dotnet.implementType.insertionBehavior.withOtherMembersOfTheSameKind": "Colóquelos con otros miembros del mismo tipo.",
  "configuration.dotnet.implementType.propertyGenerationBehavior": "Comportamiento de generación de propiedades al implementar una interfaz o una clase abstracta.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferAutoProperties": "Preferir propiedades automáticas.",
  "configuration.dotnet.implementType.propertyGenerationBehavior.preferThrowingProperties": "Preferir propiedades de lanzamiento.",
  "configuration.dotnet.inlayHints.enableInlayHintsForLiteralParameters": "Mostrar sugerencias para los literales",
  "configuration.dotnet.inlayHints.enableInlayHintsForObjectCreationParameters": "Mostrar sugerencias para las expresiones \"new\"",
  "configuration.dotnet.inlayHints.enableInlayHintsForOtherParameters": "Mostrar sugerencias para todo lo demás",
  "configuration.dotnet.inlayHints.enableInlayHintsForParameters": "Mostrar sugerencias de nombre de parámetro insertado",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatDifferOnlyBySuffix": "Suprimir las sugerencias cuando los nombres de parámetro solo se diferencien por el sufijo",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchArgumentName": "Suprimir las sugerencias cuando el argumento coincide con el nombre del parámetro",
  "configuration.dotnet.inlayHints.suppressInlayHintsForParametersThatMatchMethodIntent": "Suprimir las sugerencias cuando el nombre del parámetro coincida con la intención del método",
  "configuration.dotnet.navigation.navigateToDecompiledSources": "Habilitar la navegación a fuentes descompiladas.",
  "configuration.dotnet.preferCSharpExtension": "Fuerza la carga de proyectos solo con la extensión de C#.  Esto puede ser útil cuando se usan tipos de proyecto heredados que no son compatibles con el kit de desarrollo de C#. (Requiere volver a cargar la ventana)",
  "configuration.dotnet.projects.enableAutomaticRestore": "Habilita la restauración automática de NuGet si la extensión detecta que faltan activos.",
  "configuration.dotnet.quickInfo.showRemarksInQuickInfo": "Mostrar información de comentarios cuando se muestra el símbolo.",
  "configuration.dotnet.server.crashDumpPath": "Establece una ruta de acceso de carpeta en la que se escriben los volcados de memoria si el servidor de lenguaje se bloquea.  El usuario debe poder escribir en él.",
  "configuration.dotnet.server.extensionPaths": "Invalidación de la ruta de acceso a los argumentos --extension del servidor de lenguaje",
  "configuration.dotnet.server.path": "Especifica la ruta absoluta al ejecutable del servidor (LSP u O#). Cuando se deja vacío, se utiliza la versión anclada a la extensión C#. (Anteriormente \"omnisharp.path\")",
  "configuration.dotnet.server.startTimeout": "Especifica un tiempo de espera (en ms) para que el cliente se inicie correctamente y se conecte al servidor de lenguaje.",
  "configuration.dotnet.server.trace": "Establece el nivel de registro para el servidor de lenguaje",
  "configuration.dotnet.server.waitForDebugger": "Pasa la marca --debug al iniciar el servidor para permitir que se adjunte un depurador. (Anteriormente \"omnisharp.waitForDebugger\")",
  "configuration.dotnet.symbolSearch.searchReferenceAssemblies": "Buscar símbolos en ensamblados de referencia. Afecta a las características y requiere la búsqueda de símbolos, como agregar importaciones.",
  "configuration.dotnet.unitTestDebuggingOptions": "Opciones que se van a usar con el depurador al iniciar para la depuración de pruebas unitarias. (Anteriormente \"csharp.unitTestDebuggingOptions\")",
  "configuration.razor.languageServer.debug": "Especifica si se debe esperar a que se adjunte la depuración al iniciar el servidor de lenguaje.",
  "configuration.razor.languageServer.directory": "Invalida la ruta de acceso al directorio del servidor de lenguaje Razor.",
  "configuration.razor.trace": "Especifica si se deben generar todos los mensajes [Verbose], algunos mensajes [Messages] o no [Off].",
  "configuration.razor.trace.messages": "Registra solo algunos mensajes de la extensión Razor.",
  "configuration.razor.trace.off": "No registra mensajes de la extensión Razor",
  "configuration.razor.trace.verbose": "Registra todos los mensajes de la extensión Razor.",
  "debuggers.coreclr.configurationSnippets.description.attach": "Adjunte el depurador de .NET (coreclr) a un proceso en ejecución. Esto también se puede hacer mediante el comando \"Asociar a un proceso de .NET 5+ o .NET Core\".",
  "debuggers.coreclr.configurationSnippets.description.blazor-hosted": "Este fragmento de código se usa para iniciar un nuevo proceso en el depurador Blazor WebAssembly (blazorwasm), especificando la ruta de acceso al ejecutable que se va a iniciar. En la mayoría de los casos, \".NET: Launch C# project\" (Iniciar proyecto de C#) es una mejor opción, pero este fragmento de código se puede usar para tener control total sobre todas las opciones de inicio. Este fragmento de código es para proyectos de Blazor hospedados, que es un proyecto que tiene un back-end ASP.NET aplicación Core para atender sus archivos.",
  "debuggers.coreclr.configurationSnippets.description.blazor-standalone": "Este fragmento de código se usa para iniciar un nuevo proceso en el depurador WebAssembly de Blazor (blazorwasm). En la mayoría de los casos, \".NET: Launch C# project\" (Iniciar proyecto de C#) es una mejor opción, pero este fragmento de código se puede usar para tener control total sobre todas las opciones de inicio. Este fragmento de código es para proyectos independientes de Blazor, que es un proyecto que no tiene un back-end ASP.NET aplicación core para atender sus archivos.",
  "debuggers.coreclr.configurationSnippets.description.console-local": "Este fragmento de código se usa para iniciar un nuevo proceso en el depurador de .NET (coreclr), especificando la ruta de acceso al ejecutable que se va a iniciar. En la mayoría de los casos, \".NET: El fragmento de código \"Launch C# project\" (Iniciar proyecto de C#) es una mejor opción. Este fragmento de código es útil cuando el proyecto se compiló fuera de esta instancia de VS Code o si desea hospedar el código .NET en un archivo ejecutable personalizado, como una versión específica de \"dotnet.exe\"/\"dotnet\" o el código .NET se hospeda en una aplicación nativa. Este fragmento de código es para aplicaciones de consola.",
  "debuggers.coreclr.configurationSnippets.description.remote": "Este fragmento de código muestra cómo depurar de forma remota .NET Code **sin** mediante VS Code comunicación remota. Debe usarse en los casos en los que desea compilar el proyecto localmente, pero ejecutarlo en otro equipo.",
  "debuggers.coreclr.configurationSnippets.description.web-local": "Este fragmento de código se usa para iniciar un nuevo proceso en el depurador de .NET (coreclr), especificando la ruta de acceso al ejecutable que se va a iniciar. En la mayoría de los casos, \".NET: El fragmento de código \"Launch C# project\" (Iniciar proyecto de C#) es una mejor opción. Este fragmento de código es útil cuando el proyecto se compiló fuera de esta instancia de VS Code o si desea hospedar el código .NET en un archivo ejecutable personalizado, como una versión específica de \"dotnet.exe\"/\"dotnet\" o el código .NET se hospeda en una aplicación nativa. Este fragmento de código es para aplicaciones web (ASP.NET Core).",
  "debuggers.coreclr.configurationSnippets.label.attach-local": ".NET: Asociación a un proceso de .NET",
  "debuggers.coreclr.configurationSnippets.label.attach-remote": ".NET: Depuración remota: Asociación a un proceso de .NET",
  "debuggers.coreclr.configurationSnippets.label.blazor-hosted": ".NET: Ensamblado web: Inicio del proyecto de Blazor hospedado",
  "debuggers.coreclr.configurationSnippets.label.blazor-standalone": ".NET: Ensamblado web: Inicio de un proyecto de Blazor independiente",
  "debuggers.coreclr.configurationSnippets.label.console-local": ".NET: Iniciar archivo ejecutable (consola)",
  "debuggers.coreclr.configurationSnippets.label.console-remote": ".NET: Depuración remota: Iniciar archivo ejecutable (consola)",
  "debuggers.coreclr.configurationSnippets.label.web-local": ".NET: Iniciar archivo ejecutable (Web)",
  "debuggers.dotnet.configurationSnippets.description": "Este fragmento de código configura VS Code para depurar un proyecto de C#. Las opciones de depuración (ejemplo: argumentos para el ejecutable) se pueden configurar a través del archivo \"<project-directory>/Properties/launchSettings.json\".",
  "debuggers.dotnet.configurationSnippets.label": ".NET: Iniciar proyecto de C#",
  "debuggers.dotnet.launch.launchConfigurationId.description": "Identificador de configuración de inicio que se va a usar. La cadena vacía usará la configuración activa actual.",
  "debuggers.dotnet.launch.projectPath.description": "Ruta de acceso al archivo .csproj.",
  "generateOptionsSchema.allowFastEvaluate.description": "Cuando es true (el estado predeterminado), el depurador intentará una evaluación más rápida simulando la ejecución de propiedades y métodos simples.",
  "generateOptionsSchema.args.0.description": "Argumentos de la línea de comandos que se pasan al programa.",
  "generateOptionsSchema.args.1.description": "Versión en cadena de los argumentos de la línea de comandos pasados al programa.",
  "generateOptionsSchema.checkForDevCert.description": "Si va a iniciar un proyecto web en Windows o macOS y está habilitado, el depurador comprobará si el equipo tiene un certificado HTTPS autofirmado que se usa para desarrollar servidores web que se ejecutan en puntos de conexión HTTPS. Si no se especifica, el valor predeterminado es true cuando se establece “serverReadyAction”. Esta opción no hace nada en escenarios de Linux, VS Code remoto e interfaz de usuario web de VS Code. Si no se encuentra el certificado HTTPS o no es de confianza, se pedirá al usuario que lo instale o confíe en él.",
  "generateOptionsSchema.console.externalTerminal.enumDescription": "El proceso de destino se ejecutará dentro de su propia terminal externa. Al utilizar este modo, deberá cambiar el foco entre Visual Studio Code y la ventana del terminal externo.",
  "generateOptionsSchema.console.integratedTerminal.enumDescription": "El proceso de destino se ejecutará dentro de la terminal integrada de VS Code.",
  "generateOptionsSchema.console.internalConsole.enumDescription": "La entrada (stdin) y la salida (stdout/stderr) de la consola del proceso de destino se enrutan a través de la Consola de depuración de VS Code.",
  "generateOptionsSchema.console.markdownDescription": "Indica en qué consola se debe iniciar el programa de destino. Consulte https://aka.ms/VSCode-CS-LaunchJson-Console para obtener más información.",
  "generateOptionsSchema.console.settingsDescription": "**Nota:** _Esta opción solo se usa para proyectos de consola iniciados con el tipo de configuración de depuración `dotnet`_.\r\n\r\nIndica en qué consola se debe iniciar el programa de destino. Consulte https://aka.ms/VSCode-CS-LaunchJson-Console para obtener más información.",
  "generateOptionsSchema.cwd.description": "Ruta de acceso al directorio de trabajo del programa que se está depurando. El valor predeterminado es el área de trabajo actual.",
  "generateOptionsSchema.enableStepFiltering.markdownDescription": "Marca para habilitar la ejecución paso a paso de las propiedades y los operadores. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.env.description": "Variables de entorno pasadas al programa.",
  "generateOptionsSchema.envFile.markdownDescription": "Variables de entorno pasadas al programa por un archivo. Por ejemplo, \"${workspaceFolder}/.env\"",
  "generateOptionsSchema.externalConsole.markdownDescription": "El atributo \"externalConsole\" está en desuso; use \"console\" en su lugar. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.justMyCode.markdownDescription": "Cuando está habilitado (valor predeterminado), el depurador solo muestra y avanza en el código de usuario (\"Mi código\"), omitiendo el código del sistema y otro código que está optimizado o que no tiene símbolos de depuración. [Obtener más información](https://aka.ms/VSCode-CS-LaunchJson-JustMyCode)",
  "generateOptionsSchema.launchBrowser.args.description": "Argumentos que se van a pasar al comando para abrir el explorador. Solo se usa si el elemento específico de la plataforma (“osx”, “linux” o “windows”) no especifica un valor para “args”. Use ${auto-detect-url} para usar automáticamente la dirección a la que escucha el servidor.",
  "generateOptionsSchema.launchBrowser.description": "Describe las opciones para iniciar un explorador web como parte del inicio",
  "generateOptionsSchema.launchBrowser.enabled.description": "Indica si el inicio del explorador web está habilitado. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.launchBrowser.linux.args.description": "Argumentos que se van a pasar al comando para abrir el explorador. Use ${auto-detect-url} para usar automáticamente la dirección a la que escucha el servidor.",
  "generateOptionsSchema.launchBrowser.linux.command.description": "Archivo ejecutable que iniciará el explorador web.",
  "generateOptionsSchema.launchBrowser.linux.description": "Opciones de configuración de inicio web específicas de Linux. De manera predeterminada, se iniciará el explorador con \"xdg-open\".",
  "generateOptionsSchema.launchBrowser.osx.args.description": "Argumentos que se van a pasar al comando para abrir el explorador. Use ${auto-detect-url} para usar automáticamente la dirección a la que escucha el servidor.",
  "generateOptionsSchema.launchBrowser.osx.command.description": "Archivo ejecutable que iniciará el explorador web.",
  "generateOptionsSchema.launchBrowser.osx.description": "Opciones de configuración de inicio web específicas de OSX. De manera predeterminada, se iniciará el explorador mediante “open”.",
  "generateOptionsSchema.launchBrowser.windows.args.description": "Argumentos que se van a pasar al comando para abrir el explorador. Use ${auto-detect-url} para usar automáticamente la dirección a la que escucha el servidor.",
  "generateOptionsSchema.launchBrowser.windows.command.description": "Archivo ejecutable que iniciará el explorador web.",
  "generateOptionsSchema.launchBrowser.windows.description": "Opciones de configuración de inicio web específicas de Windows. De manera predeterminada, se iniciará el explorador mediante \"cmd /c start\".",
  "generateOptionsSchema.launchSettingsFilePath.markdownDescription": "Ruta de acceso a un archivo launchSettings.json. Si no se establece, el depurador buscará en “{cwd}/Properties/launchSettings.json”.",
  "generateOptionsSchema.launchSettingsProfile.description": "Si se especifica, indica el nombre del perfil en launchSettings.json que se va a usar. Esto se omite si no se encuentra launchSettings.json. launchSettings.json se leerá desde la ruta de acceso especificada si se establece la propiedad \"launchSettingsFilePath\" o {cwd}/Properties/launchSettings.json si no está establecida. Si se establece en null o en una cadena vacía, se omite launchSettings.json. Si no se especifica este valor, se usará el primer perfil “Project”.",
  "generateOptionsSchema.logging.browserStdOut.markdownDescription": "Marca para determinar si el texto stdout del inicio del explorador web debe registrarse en la ventana de salida. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.logging.consoleUsageMessage.description": "Controla si se registra un mensaje cuando el proceso de destino llama a una API \"Console.Read*\" y stdin se redirige a la consola.",
  "generateOptionsSchema.logging.description": "Marcas para determinar qué tipos de mensajes se deben registrar en la ventana de salida.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.all.enumDescription": "Imprima todas las llamadas API del depurador. Esto es muy detallado.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.error.enumDescription": "Errores de impresión de llamadas API del depurador.",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.markdownDescription": "Controla si las llamadas API a Microsoft.VisualStudio.Debugger.Engine/vsdebugeng.h se deben imprimir en la ventana de salida. El valor predeterminado de esta opción es \"none\".",
  "generateOptionsSchema.logging.diagnosticsLog.debugEngineAPITracing.none.enumDescription": "Deshabilitar llamadas API de seguimiento",
  "generateOptionsSchema.logging.diagnosticsLog.debugRuntimeEventTracing.markdownDescription": "Marca para determinar si debe habilitarse el seguimiento detallado de eventos generados por el tiempo de ejecución subyacente. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.logging.diagnosticsLog.description": "Configuración para controlar los mensajes que se imprimen en la ventana de salida desde el registro de diagnóstico del depurador. Este registro está diseñado para ayudar a solucionar problemas con el depurador.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.error.enumDescription": "Imprima mensajes de diagnóstico de nivel de error.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.important.enumDescription": "Imprima mensajes de diagnóstico importantes.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.markdownDescription": "Controla los mensajes que se imprimen en la ventana de salida desde el Dispatcher del depurador. Si no se especifica, el valor predeterminado será \"none\" a menos que se habilite una de las opciones de registro detalladas (\"debugEngineAPITracing\", \"debugRuntimeEventTracing\", \"expressionEvaluationTracing\" o \"startDebuggingTracing\"), en cuyo caso el valor predeterminado cambia a \"normal\".",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.none.enumDescription": "No imprimir mensajes de diagnóstico adicionales.",
  "generateOptionsSchema.logging.diagnosticsLog.dispatcherMessages.normal.enumDescription": "Imprima todos los mensajes de diagnóstico no detallados.",
  "generateOptionsSchema.logging.diagnosticsLog.expressionEvaluationTracing.markdownDescription": "Marca para determinar si debe habilitarse el seguimiento detallado para la evaluación de expresiones. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.logging.diagnosticsLog.protocolMessages.markdownDescription": "Marca para determinar si los mensajes de protocolo DAP intercambiados entre el depurador de C# y la interfaz de usuario deben registrarse en la ventana de salida. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.logging.diagnosticsLog.startDebuggingTracing.markdownDescription": "Marca para determinar si debe habilitarse el seguimiento detallado para iniciar la depuración. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.logging.elapsedTiming.markdownDescription": "Si es true, el registro del mensaje de protocolo incluirá las propiedades \"adapterElapsedTime\" y \"engineElapsedTime\" para indicar la cantidad de tiempo, en microsegundos, que tardó una solicitud. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.logging.engineLogging.deprecationMessage": "La configuración \"logging.engineLogging\" ha quedado en desuso en favor de \"logging.diagnosticsLog.protocolMessages\".",
  "generateOptionsSchema.logging.exceptions.markdownDescription": "Marca para determinar si los mensajes de excepción se deben registrar en la ventana de salida. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.logging.moduleLoad.markdownDescription": "Marca para determinar si los eventos de carga del módulo se deben registrar en la ventana de salida. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.logging.processExit.markdownDescription": "Controla si se registra un mensaje cuando se cierra el proceso de destino o se detiene la depuración. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.logging.programOutput.markdownDescription": "Marca para determinar si la salida del programa debe registrarse en la ventana de salida cuando no se usa una consola externa. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.logging.threadExit.markdownDescription": "Controla si se registra un mensaje cuando se cierra un subproceso en el proceso de destino. El valor predeterminado de esta opción es “false”.",
  "generateOptionsSchema.pipeTransport.debuggerPath.description": "Ruta de acceso completa al depurador en la máquina de destino.",
  "generateOptionsSchema.pipeTransport.description": "Cuando se especifica, indica al depurador que se conecte a un equipo remoto usando otro archivo ejecutable como canalización que retransmitirá la entrada o la salida estándar entre VS Code y el archivo ejecutable del back-end del depurador de .Net Core (vsdbg).",
  "generateOptionsSchema.pipeTransport.linux.description": "Opciones de configuración de inicio de canalización específicas de Linux",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.0.description": "Argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.linux.pipeArgs.1.description": "Versión en cadena de los argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.linux.pipeCwd.description": "Ruta de acceso completa al directorio de trabajo del programa de canalización.",
  "generateOptionsSchema.pipeTransport.linux.pipeEnv.description": "Variables de entorno que se pasan al programa de canalización.",
  "generateOptionsSchema.pipeTransport.linux.pipeProgram.description": "Comando de canalización completo para ejecutar.",
  "generateOptionsSchema.pipeTransport.linux.quoteArgs.description": "¿Deben incluirse entre comillas los argumentos que contienen caracteres (por ejemplo, espacios) que deben incluirse entre comillas? El valor predeterminado es \"true\". Si se establece en false, el comando del depurador ya no se incluirá entre comillas automáticamente.",
  "generateOptionsSchema.pipeTransport.osx.description": "Opciones de configuración de inicio de canalización específicas de OSX",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.0.description": "Argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.osx.pipeArgs.1.description": "Versión en cadena de los argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.osx.pipeCwd.description": "Ruta de acceso completa al directorio de trabajo del programa de canalización.",
  "generateOptionsSchema.pipeTransport.osx.pipeEnv.description": "Variables de entorno que se pasan al programa de canalización.",
  "generateOptionsSchema.pipeTransport.osx.pipeProgram.description": "Comando de canalización completo para ejecutar.",
  "generateOptionsSchema.pipeTransport.osx.quoteArgs.description": "¿Deben incluirse entre comillas los argumentos que contienen caracteres (por ejemplo, espacios) que deben incluirse entre comillas? El valor predeterminado es \"true\". Si se establece en false, el comando del depurador ya no se incluirá entre comillas automáticamente.",
  "generateOptionsSchema.pipeTransport.pipeArgs.0.description": "Argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.pipeArgs.1.description": "Versión en cadena de los argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.pipeCwd.description": "Ruta de acceso completa al directorio de trabajo del programa de canalización.",
  "generateOptionsSchema.pipeTransport.pipeEnv.description": "Variables de entorno que se pasan al programa de canalización.",
  "generateOptionsSchema.pipeTransport.pipeProgram.description": "Comando de canalización completo para ejecutar.",
  "generateOptionsSchema.pipeTransport.quoteArgs.description": "¿Deben incluirse entre comillas los argumentos que contienen caracteres (por ejemplo, espacios) que deben incluirse entre comillas? El valor predeterminado es \"true\". Si se establece en false, el comando del depurador ya no se incluirá entre comillas automáticamente.",
  "generateOptionsSchema.pipeTransport.windows.description": "Opciones de configuración de inicio de canalización específicas de Windows",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.0.description": "Argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.windows.pipeArgs.1.description": "Versión en cadena de los argumentos de línea de comandos pasados al programa de canalización. El token ${debuggerCommand} de pipeArgs se reemplazará por el comando completo del depurador; este token se puede especificar en línea con otros argumentos. Si ${debuggerCommand} no se usa en ningún argumento, el comando completo del depurador se agregará al final de la lista de argumentos.",
  "generateOptionsSchema.pipeTransport.windows.pipeCwd.description": "Ruta de acceso completa al directorio de trabajo del programa de canalización.",
  "generateOptionsSchema.pipeTransport.windows.pipeEnv.description": "Variables de entorno que se pasan al programa de canalización.",
  "generateOptionsSchema.pipeTransport.windows.pipeProgram.description": "Comando de canalización completo para ejecutar.",
  "generateOptionsSchema.pipeTransport.windows.quoteArgs.description": "¿Deben incluirse entre comillas los argumentos que contienen caracteres (por ejemplo, espacios) que deben incluirse entre comillas? El valor predeterminado es \"true\". Si se establece en false, el comando del depurador ya no se incluirá entre comillas automáticamente.",
  "generateOptionsSchema.processId.0.markdownDescription": "Identificador de proceso al que se va a asociar. Use \"\" para obtener una lista de los procesos en ejecución a los que asociar. Si se usa \"processId\", no se debe usar \"processName\".",
  "generateOptionsSchema.processId.1.markdownDescription": "Identificador de proceso al que se va a asociar. Use \"\" para obtener una lista de los procesos en ejecución a los que asociar. Si se usa \"processId\", no se debe usar \"processName\".",
  "generateOptionsSchema.processName.markdownDescription": "Nombre del proceso al que se va a asociar. Si se usa, no se debe usar \"processId\".",
  "generateOptionsSchema.program.markdownDescription": "Ruta de acceso al la DLL de la aplicación o al archivo ejecutable del host de .NET Core que se va a iniciar.\r\nNormalmente, esta propiedad adopta el formato: \"${workspaceFolder}/bin/Debug/(target-framework)/(project-name.dll)\"\r\n\r\nEjemplo: \"${workspaceFolder}/bin/Debug/netcoreapp1.1/MyProject.dll\"\r\n\r\nDónde:\r\n“(target-framework)” es el marco para el que se está compilando el proyecto depurado. Normalmente, esto se encuentra en el archivo de proyecto como la propiedad \"TargetFramework\".\r\n\r\n“(project-name.dll)” es el nombre de la DLL de salida de compilación del proyecto depurado. Normalmente es lo mismo que el nombre de archivo del proyecto, pero con una extensión “.dll”.",
  "generateOptionsSchema.requireExactSource.markdownDescription": "Marca para requerir que el código fuente actual coincida con el pdb. Esta opción tiene como valor predeterminado \"true\".",
  "generateOptionsSchema.sourceFileMap.markdownDescription": "Asigna rutas de acceso en tiempo de compilación a ubicaciones de origen locales. Todas las instancias de la ruta de acceso en tiempo de compilación se reemplazarán por la ruta de acceso de origen local.\r\n\r\nEjemplo:\r\n\r\n\"{\"<build-path>\":\"<local-source-path>\"}\"",
  "generateOptionsSchema.sourceLinkOptions.additionalItems.enabled.markdownDescription": "¿Está habilitado Source Link para esta dirección URL? Si no se especifica, el valor predeterminado de esta opción es \"true\".",
  "generateOptionsSchema.sourceLinkOptions.markdownDescription": "Opciones para controlar cómo se conecta Source Link a los servidores web. [Obtener más información](https://aka.ms/VSCode-DotNet-SourceLink)",
  "generateOptionsSchema.stopAtEntry.markdownDescription": "Si es true, el depurador debe detenerse en el punto de entrada del destino. El valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.suppressJITOptimizations.markdownDescription": "Si es true, cuando un módulo optimizado (.dll compilado en la configuración de la versión) se carga en el proceso de destino, el depurador pedirá al compilador Just-In-Time que genere código con las optimizaciones deshabilitadas. [Obtener más información](https://aka.ms/VSCode-CS-LaunchJson-SuppressJITOptimizations)",
  "generateOptionsSchema.symbolOptions.cachePath.description": "Directorio donde se deben almacenar en caché los símbolos descargados de los servidores de símbolos. Si no se especifica, en Windows, el depurador tendrá como valor predeterminado %TEMP%\\SymbolCache y, en Linux y macOS, el depurador tendrá como valor predeterminado ~/.dotnet/symbolcache.",
  "generateOptionsSchema.symbolOptions.description": "Opciones para controlar cómo se encuentran y se cargan los símbolos (archivos .pdb).",
  "generateOptionsSchema.symbolOptions.moduleFilter.description": "Proporciona opciones para controlar los módulos (archivos .dll) para los que el depurador intenta cargar los símbolos (archivos .pdb).",
  "generateOptionsSchema.symbolOptions.moduleFilter.excludedModules.description": "Matriz de módulos para los que el depurador NO debería cargar símbolos. Se admiten los caracteres comodín (ejemplo: MiEmpresa.*.dll).\r\n\r\nEsta propiedad se ignora a menos que «modo» se establezca como «loadAllButExcluded».",
  "generateOptionsSchema.symbolOptions.moduleFilter.includeSymbolsNextToModules.description": "Si es verdadero, para cualquier módulo que NO esté en la matriz «includedModules», el depurador seguirá comprobando junto al propio módulo y el ejecutable de inicio, pero no comprobará las rutas en la lista de búsqueda de símbolos. Esta opción tiene el valor predeterminado «verdadero».\r\n\r\nEsta propiedad se omite a menos que «modo» esté establecido como «loadOnlyIncluded».",
  "generateOptionsSchema.symbolOptions.moduleFilter.includedModules.description": "Matriz de módulos para los que el depurador debería cargar símbolos. Se admiten los caracteres comodín (ejemplo: MiEmpresa.*.dll).\r\n\r\nEsta propiedad se ignora a menos que «modo» se establezca como «loadOnlyIncluded».",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.description": "Controla en cuál de los dos modos operativos básicos opera el filtro de módulo.",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadAllButExcluded.enumDescription": "Cargar símbolos para todos los módulos a menos que el módulo esté en la matriz «excludedModules».",
  "generateOptionsSchema.symbolOptions.moduleFilter.mode.loadOnlyIncluded.enumDescription": "No intente cargar los símbolos de NINGÚN módulo a menos que esté en la matriz «includedModules» o se incluya a través de la configuración «includeSymbolsNextToModules».",
  "generateOptionsSchema.symbolOptions.searchMicrosoftSymbolServer.description": "Si es «verdadero», se agrega el servidor de símbolos de Microsoft (https​://msdl.microsoft.com​/download/symbols) a la ruta de búsqueda de símbolos. Si no se especifica, esta opción tendrá el valor predeterminado de «falso».",
  "generateOptionsSchema.symbolOptions.searchNuGetOrgSymbolServer.description": "Si es \"true\", el servidor de símbolos de NuGet.org (https​://symbols.nuget.org​/download/symbols) se agrega a la ruta de acceso de búsqueda de símbolos. Si no se especifica, el valor predeterminado de esta opción es \"false\".",
  "generateOptionsSchema.symbolOptions.searchPaths.description": "Matriz de direcciones URL del servidor de símbolos (ejemplo: http​://MyExampleSymbolServer) o directorios (ejemplo: /build/symbols) para buscar archivos .pdb. Se buscarán estos directorios además de las ubicaciones predeterminadas, junto al módulo y la ruta de acceso en la que se anuló originalmente el archivo pdb.",
  "generateOptionsSchema.targetArchitecture.markdownDescription": "[Solo se admite en la depuración local de macOS]\r\n\r\nArquitectura del depurado. Esto se detectará automáticamente a menos que se establezca este parámetro. Los valores permitidos son \"x86_64\" o \"arm64\".",
  "generateOptionsSchema.targetOutputLogPath.description": "Cuando se establece, el texto que la aplicación de destino escribe en stdout y stderr (por ejemplo, Console.WriteLine) se guardará en el archivo especificado. Esta opción se omite si la consola se establece en un valor distinto de internalConsole. Por ejemplo, \"${workspaceFolder}/out.txt\"",
  "viewsWelcome.debug.contents": "[Generar recursos de C# para compilación y depuración](command:dotnet.generateAssets)\r\n\r\nPara obtener más información sobre launch.json, consulte [Configuración de launch.json para la depuración de C#](https://aka.ms/VSCode-CS-LaunchJson)."
}