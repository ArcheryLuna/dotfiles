/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = require("vscode");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const Is = require("./utils/is");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressPart {
    constructor(client, params) {
        let location = params.cancellable ? vscode_1.ProgressLocation.Notification : vscode_1.ProgressLocation.Window;
        this._reported = 0;
        vscode_1.window.withProgress({ location, cancellable: params.cancellable, title: params.title }, (progress, token) => __awaiter(this, void 0, void 0, function* () {
            this._progress = progress;
            this._infinite = params.percentage === undefined;
            this._token = token;
            this._token.onCancellationRequested(() => {
                client.sendNotification(vscode_languageserver_protocol_1.Proposed.ProgressCancelNotification.type, { id: params.id });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        }));
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            let percentage = Math.max(0, Math.min(params.percentage, 100));
            let delta = Math.max(0, percentage - this._reported);
            this._progress.report({ message: params.message, increment: delta });
            this._reported += delta;
        }
    }
    cancel() {
        this._reject();
    }
    done() {
        this._resolve();
    }
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this._progresses = new Map();
    }
    fillClientCapabilities(cap) {
        let capabilities = cap;
        ensure(capabilities, 'window').progress = true;
    }
    initialize() {
        let client = this._client;
        let progresses = this._progresses;
        let startHandler = (params) => {
            if (Is.string(params.id)) {
                let progress = new ProgressPart(this._client, params);
                this._progresses.set(params.id, progress);
            }
        };
        client.onNotification(vscode_languageserver_protocol_1.Proposed.ProgressStartNotification.type, startHandler);
        let reportHandler = (params) => {
            let progress = this._progresses.get(params.id);
            if (progress !== undefined) {
                progress.report(params);
            }
        };
        client.onNotification(vscode_languageserver_protocol_1.Proposed.ProgressReportNotification.type, reportHandler);
        let doneHandler = (params) => {
            let progress = progresses.get(params.id);
            if (progress !== undefined) {
                progress.done();
                progresses.delete(params.id);
            }
        };
        client.onNotification(vscode_languageserver_protocol_1.Proposed.ProgressDoneNotification.type, doneHandler);
    }
}
exports.ProgressFeature = ProgressFeature;
